{
	_events: {
	},
	_eventsCount: 0,
	_maxListeners: undefined,
	debugger: function () { },
	appPath: "/Users/ruochuan/git-source/github/taro",
	optsPresets: [
	  "/Users/ruochuan/git-source/github/taro/packages/taro-cli/dist/presets/index.js",
	],
	optsPlugins: [
	  "/Users/ruochuan/git-source/github/taro/packages/taro-cli/dist/presets/commands/init.js",
	],
	config: {
	  appPath: "/Users/ruochuan/git-source/github/taro",
	  disableGlobalConfig: false,
	  initialConfig: {
		env: {
		},
	  },
	  initialGlobalConfig: {
		plugins: [
		],
		presets: [
		],
	  },
	  isInitSuccess: false,
	  configPath: "/Users/ruochuan/git-source/github/taro/config/index",
	},
	hooks: {
	},
	methods: {
	},
	commands: {
	},
	platforms: {
	},
	helper: {
	  swc: {
		version: "1.3.96",
		plugins: function plugins(ps) {
		  return mod => {
			  let m = mod;
			  for (const p of ps) {
				  m = p(m);
			  }
			  return m;
		  };
		},
		Compiler: class Compiler {
		  constructor() {
			  this.fallbackBindingsPluginWarningDisplayed = false;
		  }
		  minify(src, opts) {
			  return __awaiter(this, void 0, void 0, function* () {
				  if (bindings) {
					  return bindings.minify(toBuffer(src), toBuffer(opts !== null && opts !== void 0 ? opts : {}));
				  }
				  else if (fallbackBindings) {
					  return fallbackBindings.minify(src, opts);
				  }
				  throw new Error('Bindings not found.');
			  });
		  }
		  minifySync(src, opts) {
			  if (bindings) {
				  return bindings.minifySync(toBuffer(src), toBuffer(opts !== null && opts !== void 0 ? opts : {}));
			  }
			  else if (fallbackBindings) {
				  return fallbackBindings.minifySync(src, opts);
			  }
			  throw new Error('Bindings not found.');
		  }
		  parse(src, options, filename) {
			  return __awaiter(this, void 0, void 0, function* () {
				  options = options || { syntax: "ecmascript" };
				  options.syntax = options.syntax || "ecmascript";
				  if (!bindings && !!fallbackBindings) {
					  throw new Error('Fallback bindings does not support this interface yet.');
				  }
				  else if (!bindings) {
					  throw new Error('Bindings not found.');
				  }
				  if (bindings) {
					  const res = yield bindings.parse(src, toBuffer(options), filename);
					  return JSON.parse(res);
				  }
				  else if (fallbackBindings) {
					  return fallbackBindings.parse(src, options);
				  }
				  throw new Error('Bindings not found.');
			  });
		  }
		  parseSync(src, options, filename) {
			  options = options || { syntax: "ecmascript" };
			  options.syntax = options.syntax || "ecmascript";
			  if (bindings) {
				  return JSON.parse(bindings.parseSync(src, toBuffer(options), filename));
			  }
			  else if (fallbackBindings) {
				  return fallbackBindings.parseSync(src, options);
			  }
			  throw new Error('Bindings not found.');
		  }
		  parseFile(path, options) {
			  return __awaiter(this, void 0, void 0, function* () {
				  options = options || { syntax: "ecmascript" };
				  options.syntax = options.syntax || "ecmascript";
				  if (!bindings && !!fallbackBindings) {
					  throw new Error('Fallback bindings does not support filesystem access.');
				  }
				  else if (!bindings) {
					  throw new Error('Bindings not found.');
				  }
				  const res = yield bindings.parseFile(path, toBuffer(options));
				  return JSON.parse(res);
			  });
		  }
		  parseFileSync(path, options) {
			  options = options || { syntax: "ecmascript" };
			  options.syntax = options.syntax || "ecmascript";
			  if (!bindings && !!fallbackBindings) {
				  throw new Error('Fallback bindings does not support filesystem access');
			  }
			  else if (!bindings) {
				  throw new Error('Bindings not found.');
			  }
			  return JSON.parse(bindings.parseFileSync(path, toBuffer(options)));
		  }
		  /**
		   * Note: this method should be invoked on the compiler instance used
		   *  for `parse()` / `parseSync()`.
		   */
		  print(m, options) {
			  return __awaiter(this, void 0, void 0, function* () {
				  options = options || {};
				  if (bindings) {
					  return bindings.print(JSON.stringify(m), toBuffer(options));
				  }
				  else if (fallbackBindings) {
					  return fallbackBindings.print(m, options);
				  }
				  throw new Error('Bindings not found.');
			  });
		  }
		  /**
		   * Note: this method should be invoked on the compiler instance used
		   *  for `parse()` / `parseSync()`.
		   */
		  printSync(m, options) {
			  options = options || {};
			  if (bindings) {
				  return bindings.printSync(JSON.stringify(m), toBuffer(options));
			  }
			  else if (fallbackBindings) {
				  return fallbackBindings.printSync(m, options);
			  }
			  throw new Error('Bindings not found.');
		  }
		  transform(src, options) {
			  var _a, _b, _c;
			  return __awaiter(this, void 0, void 0, function* () {
				  const isModule = typeof src !== "string";
				  options = options || {};
				  if ((_a = options === null || options === void 0 ? void 0 : options.jsc) === null || _a === void 0 ? void 0 : _a.parser) {
					  options.jsc.parser.syntax = (_b = options.jsc.parser.syntax) !== null && _b !== void 0 ? _b : 'ecmascript';
				  }
				  const { plugin } = options, newOptions = __rest(options, ["plugin"]);
				  if (bindings) {
					  if (plugin) {
						  const m = typeof src === "string"
							  ? yield this.parse(src, (_c = options === null || options === void 0 ? void 0 : options.jsc) === null || _c === void 0 ? void 0 : _c.parser, options.filename)
							  : src;
						  return this.transform(plugin(m), newOptions);
					  }
					  return bindings.transform(isModule ? JSON.stringify(src) : src, isModule, toBuffer(newOptions));
				  }
				  else if (fallbackBindings) {
					  if (plugin && !this.fallbackBindingsPluginWarningDisplayed) {
						  console.warn(`Fallback bindings does not support legacy plugins, it'll be ignored.`);
						  this.fallbackBindingsPluginWarningDisplayed = true;
					  }
					  return fallbackBindings.transform(src, options);
				  }
				  throw new Error('Bindings not found.');
			  });
		  }
		  transformSync(src, options) {
			  var _a, _b, _c;
			  const isModule = typeof src !== "string";
			  options = options || {};
			  if ((_a = options === null || options === void 0 ? void 0 : options.jsc) === null || _a === void 0 ? void 0 : _a.parser) {
				  options.jsc.parser.syntax = (_b = options.jsc.parser.syntax) !== null && _b !== void 0 ? _b : 'ecmascript';
			  }
			  const { plugin } = options, newOptions = __rest(options, ["plugin"]);
			  if (bindings) {
				  if (plugin) {
					  const m = typeof src === "string" ? this.parseSync(src, (_c = options === null || options === void 0 ? void 0 : options.jsc) === null || _c === void 0 ? void 0 : _c.parser, options.filename) : src;
					  return this.transformSync(plugin(m), newOptions);
				  }
				  return bindings.transformSync(isModule ? JSON.stringify(src) : src, isModule, toBuffer(newOptions));
			  }
			  else if (fallbackBindings) {
				  if (plugin && !this.fallbackBindingsPluginWarningDisplayed) {
					  console.warn(`Fallback bindings does not support legacy plugins, it'll be ignored.`);
					  this.fallbackBindingsPluginWarningDisplayed = true;
				  }
				  return fallbackBindings.transformSync(isModule ? JSON.stringify(src) : src, options);
			  }
			  throw new Error("Bindings not found");
		  }
		  transformFile(path, options) {
			  var _a, _b, _c;
			  return __awaiter(this, void 0, void 0, function* () {
				  if (!bindings && !!fallbackBindings) {
					  throw new Error('Fallback bindings does not support filesystem access.');
				  }
				  else if (!bindings) {
					  throw new Error('Bindings not found.');
				  }
				  options = options || {};
				  if ((_a = options === null || options === void 0 ? void 0 : options.jsc) === null || _a === void 0 ? void 0 : _a.parser) {
					  options.jsc.parser.syntax = (_b = options.jsc.parser.syntax) !== null && _b !== void 0 ? _b : 'ecmascript';
				  }
				  const { plugin } = options, newOptions = __rest(options, ["plugin"]);
				  newOptions.filename = path;
				  if (plugin) {
					  const m = yield this.parseFile(path, (_c = options === null || options === void 0 ? void 0 : options.jsc) === null || _c === void 0 ? void 0 : _c.parser);
					  return this.transform(plugin(m), newOptions);
				  }
				  return bindings.transformFile(path, false, toBuffer(newOptions));
			  });
		  }
		  transformFileSync(path, options) {
			  var _a, _b, _c;
			  if (!bindings && !!fallbackBindings) {
				  throw new Error('Fallback bindings does not support filesystem access.');
			  }
			  else if (!bindings) {
				  throw new Error('Bindings not found.');
			  }
			  options = options || {};
			  if ((_a = options === null || options === void 0 ? void 0 : options.jsc) === null || _a === void 0 ? void 0 : _a.parser) {
				  options.jsc.parser.syntax = (_b = options.jsc.parser.syntax) !== null && _b !== void 0 ? _b : 'ecmascript';
			  }
			  const { plugin } = options, newOptions = __rest(options, ["plugin"]);
			  newOptions.filename = path;
			  if (plugin) {
				  const m = this.parseFileSync(path, (_c = options === null || options === void 0 ? void 0 : options.jsc) === null || _c === void 0 ? void 0 : _c.parser);
				  return this.transformSync(plugin(m), newOptions);
			  }
			  return bindings.transformFileSync(path, /* isModule */ false, toBuffer(newOptions));
		  }
		  bundle(options) {
			  return __awaiter(this, void 0, void 0, function* () {
				  if (!bindings && !!fallbackBindings) {
					  throw new Error('Fallback bindings does not support this interface yet.');
				  }
				  else if (!bindings) {
					  throw new Error('Bindings not found.');
				  }
				  const opts = yield (0, spack_1.compileBundleOptions)(options);
				  if (Array.isArray(opts)) {
					  const all = yield Promise.all(opts.map((opt) => __awaiter(this, void 0, void 0, function* () {
						  return this.bundle(opt);
					  })));
					  let obj = {};
					  for (const o of all) {
						  obj = Object.assign(Object.assign({}, obj), o);
					  }
					  return obj;
				  }
				  return bindings.bundle(toBuffer(Object.assign({}, opts)));
			  });
		  }
		},
		parse: function parse(src, options) {
		  return compiler.parse(src, options);
		},
		parseSync: function parseSync(src, options) {
		  return compiler.parseSync(src, options);
		},
		parseFile: function parseFile(path, options) {
		  return compiler.parseFile(path, options);
		},
		parseFileSync: function parseFileSync(path, options) {
		  return compiler.parseFileSync(path, options);
		},
		print: function print(m, options) {
		  return compiler.print(m, options);
		},
		printSync: function printSync(m, options) {
		  return compiler.printSync(m, options);
		},
		transform: function transform(src, options) {
		  return compiler.transform(src, options);
		},
		transformSync: function transformSync(src, options) {
		  return compiler.transformSync(src, options);
		},
		transformFile: function transformFile(path, options) {
		  return compiler.transformFile(path, options);
		},
		transformFileSync: function transformFileSync(path, options) {
		  return compiler.transformFileSync(path, options);
		},
		bundle: function bundle(options) {
		  return compiler.bundle(options);
		},
		minify: function minify(src, opts) {
		  return __awaiter(this, void 0, void 0, function* () {
			  return compiler.minify(src, opts);
		  });
		},
		minifySync: function minifySync(src, opts) {
		  return compiler.minifySync(src, opts);
		},
		__experimental_registerGlobalTraceConfig: function __experimental_registerGlobalTraceConfig(traceConfig) {
		  // Do not raise error if binding doesn't exists - fallback binding will not support
		  // this ever.
		  if (bindings) {
			  if (traceConfig.type === 'traceEvent') {
				  bindings.initCustomTraceSubscriber(traceConfig.fileName);
			  }
		  }
		},
		getBinaryMetadata: function getBinaryMetadata() {
		  return {
			  target: bindings ? bindings === null || bindings === void 0 ? void 0 : bindings.getTargetTriple() : undefined
		  };
		},
		DEFAULT_EXTENSIONS: [
		  ".js",
		  ".jsx",
		  ".es6",
		  ".es",
		  ".mjs",
		  ".ts",
		  ".tsx",
		  ".cts",
		  ".mts",
		],
	  },
	  chokidar: {
		FSWatcher: class FSWatcher extends EventEmitter {
		  // Not indenting methods for history sake; for now.
		  constructor(_opts) {
		  super();

		  const opts = {};
		  if (_opts) Object.assign(opts, _opts); // for frozen objects

		  /** @type {Map<String, DirEntry>} */
		  this._watched = new Map();
		  /** @type {Map<String, Array>} */
		  this._closers = new Map();
		  /** @type {Set<String>} */
		  this._ignoredPaths = new Set();

		  /** @type {Map<ThrottleType, Map>} */
		  this._throttled = new Map();

		  /** @type {Map<Path, String|Boolean>} */
		  this._symlinkPaths = new Map();

		  this._streams = new Set();
		  this.closed = false;

		  // Set up default options.
		  if (undef(opts, 'persistent')) opts.persistent = true;
		  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
		  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
		  if (undef(opts, 'interval')) opts.interval = 100;
		  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
		  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
		  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;

		  // Enable fsevents on OS X when polling isn't explicitly enabled.
		  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;

		  // If we can't use fsevents, ensure the options reflect it's disabled.
		  const canUseFsEvents = FsEventsHandler.canUse();
		  if (!canUseFsEvents) opts.useFsEvents = false;

		  // Use polling on Mac if not using fsevents.
		  // Other platforms use non-polling fs_watch.
		  if (undef(opts, 'usePolling') && !opts.useFsEvents) {
			opts.usePolling = isMacos;
		  }

		  // Always default to polling on IBM i because fs.watch() is not available on IBM i.
		  if(isIBMi) {
			opts.usePolling = true;
		  }

		  // Global override (useful for end-developers that need to force polling for all
		  // instances of chokidar, regardless of usage/dependency depth)
		  const envPoll = process.env.CHOKIDAR_USEPOLLING;
		  if (envPoll !== undefined) {
			const envLower = envPoll.toLowerCase();

			if (envLower === 'false' || envLower === '0') {
			  opts.usePolling = false;
			} else if (envLower === 'true' || envLower === '1') {
			  opts.usePolling = true;
			} else {
			  opts.usePolling = !!envLower;
			}
		  }
		  const envInterval = process.env.CHOKIDAR_INTERVAL;
		  if (envInterval) {
			opts.interval = Number.parseInt(envInterval, 10);
		  }

		  // Editor atomic write normalization enabled by default with fs.watch
		  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
		  if (opts.atomic) this._pendingUnlinks = new Map();

		  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;

		  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
		  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
		  const awf = opts.awaitWriteFinish;
		  if (awf) {
			if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
			if (!awf.pollInterval) awf.pollInterval = 100;
			this._pendingWrites = new Map();
		  }
		  if (opts.ignored) opts.ignored = arrify(opts.ignored);

		  let readyCalls = 0;
		  this._emitReady = () => {
			readyCalls++;
			if (readyCalls >= this._readyCount) {
			  this._emitReady = EMPTY_FN;
			  this._readyEmitted = true;
			  // use process.nextTick to allow time for listener to be bound
			  process.nextTick(() => this.emit(EV_READY));
			}
		  };
		  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
		  this._readyEmitted = false;
		  this.options = opts;

		  // Initialize with proper watcher.
		  if (opts.useFsEvents) {
			this._fsEventsHandler = new FsEventsHandler(this);
		  } else {
			this._nodeFsHandler = new NodeFsHandler(this);
		  }

		  // You’re frozen when your heart’s not open.
		  Object.freeze(opts);
		  }

		  // Public methods

		  /**
		  * Adds paths to be watched on an existing FSWatcher instance
		  * @param {Path|Array<Path>} paths_
		  * @param {String=} _origAdd private; for handling non-existent paths to be watched
		  * @param {Boolean=} _internal private; indicates a non-user add
		  * @returns {FSWatcher} for chaining
		  */
		  add(paths_, _origAdd, _internal) {
		  const {cwd, disableGlobbing} = this.options;
		  this.closed = false;
		  let paths = unifyPaths(paths_);
		  if (cwd) {
			paths = paths.map((path) => {
			  const absPath = getAbsolutePath(path, cwd);

			  // Check `path` instead of `absPath` because the cwd portion can't be a glob
			  if (disableGlobbing || !isGlob(path)) {
				return absPath;
			  }
			  return normalizePath(absPath);
			});
		  }

		  // set aside negated glob strings
		  paths = paths.filter((path) => {
			if (path.startsWith(BANG)) {
			  this._ignoredPaths.add(path.slice(1));
			  return false;
			}

			// if a path is being added that was previously ignored, stop ignoring it
			this._ignoredPaths.delete(path);
			this._ignoredPaths.delete(path + SLASH_GLOBSTAR);

			// reset the cached userIgnored anymatch fn
			// to make ignoredPaths changes effective
			this._userIgnored = undefined;

			return true;
		  });

		  if (this.options.useFsEvents && this._fsEventsHandler) {
			if (!this._readyCount) this._readyCount = paths.length;
			if (this.options.persistent) this._readyCount *= 2;
			paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));
		  } else {
			if (!this._readyCount) this._readyCount = 0;
			this._readyCount += paths.length;
			Promise.all(
			  paths.map(async path => {
				const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);
				if (res) this._emitReady();
				return res;
			  })
			).then(results => {
			  if (this.closed) return;
			  results.filter(item => item).forEach(item => {
				this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
			  });
			});
		  }

		  return this;
		  }

		  /**
		  * Close watchers or start ignoring events from specified paths.
		  * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
		  * @returns {FSWatcher} for chaining
		  */
		  unwatch(paths_) {
		  if (this.closed) return this;
		  const paths = unifyPaths(paths_);
		  const {cwd} = this.options;

		  paths.forEach((path) => {
			// convert to absolute path unless relative path already matches
			if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {
			  if (cwd) path = sysPath.join(cwd, path);
			  path = sysPath.resolve(path);
			}

			this._closePath(path);

			this._ignoredPaths.add(path);
			if (this._watched.has(path)) {
			  this._ignoredPaths.add(path + SLASH_GLOBSTAR);
			}

			// reset the cached userIgnored anymatch fn
			// to make ignoredPaths changes effective
			this._userIgnored = undefined;
		  });

		  return this;
		  }

		  /**
		  * Close watchers and remove all listeners from watched paths.
		  * @returns {Promise<void>}.
		  */
		  close() {
		  if (this.closed) return this._closePromise;
		  this.closed = true;

		  // Memory management.
		  this.removeAllListeners();
		  const closers = [];
		  this._closers.forEach(closerList => closerList.forEach(closer => {
			const promise = closer();
			if (promise instanceof Promise) closers.push(promise);
		  }));
		  this._streams.forEach(stream => stream.destroy());
		  this._userIgnored = undefined;
		  this._readyCount = 0;
		  this._readyEmitted = false;
		  this._watched.forEach(dirent => dirent.dispose());
		  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {
			this[`_${key}`].clear();
		  });

		  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();
		  return this._closePromise;
		  }

		  /**
		  * Expose list of watched paths
		  * @returns {Object} for chaining
		  */
		  getWatched() {
		  const watchList = {};
		  this._watched.forEach((entry, dir) => {
			const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
			watchList[key || ONE_DOT] = entry.getChildren().sort();
		  });
		  return watchList;
		  }

		  emitWithAll(event, args) {
		  this.emit(...args);
		  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);
		  }

		  // Common helpers
		  // --------------

		  /**
		  * Normalize and emit events.
		  * Calling _emit DOES NOT MEAN emit() would be called!
		  * @param {EventName} event Type of event
		  * @param {Path} path File or directory path
		  * @param {*=} val1 arguments to be passed with event
		  * @param {*=} val2
		  * @param {*=} val3
		  * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
		  */
		  async _emit(event, path, val1, val2, val3) {
		  if (this.closed) return;

		  const opts = this.options;
		  if (isWindows) path = sysPath.normalize(path);
		  if (opts.cwd) path = sysPath.relative(opts.cwd, path);
		  /** @type Array<any> */
		  const args = [event, path];
		  if (val3 !== undefined) args.push(val1, val2, val3);
		  else if (val2 !== undefined) args.push(val1, val2);
		  else if (val1 !== undefined) args.push(val1);

		  const awf = opts.awaitWriteFinish;
		  let pw;
		  if (awf && (pw = this._pendingWrites.get(path))) {
			pw.lastChange = new Date();
			return this;
		  }

		  if (opts.atomic) {
			if (event === EV_UNLINK) {
			  this._pendingUnlinks.set(path, args);
			  setTimeout(() => {
				this._pendingUnlinks.forEach((entry, path) => {
				  this.emit(...entry);
				  this.emit(EV_ALL, ...entry);
				  this._pendingUnlinks.delete(path);
				});
			  }, typeof opts.atomic === 'number' ? opts.atomic : 100);
			  return this;
			}
			if (event === EV_ADD && this._pendingUnlinks.has(path)) {
			  event = args[0] = EV_CHANGE;
			  this._pendingUnlinks.delete(path);
			}
		  }

		  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
			const awfEmit = (err, stats) => {
			  if (err) {
				event = args[0] = EV_ERROR;
				args[1] = err;
				this.emitWithAll(event, args);
			  } else if (stats) {
				// if stats doesn't exist the file must have been deleted
				if (args.length > 2) {
				  args[2] = stats;
				} else {
				  args.push(stats);
				}
				this.emitWithAll(event, args);
			  }
			};

			this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
			return this;
		  }

		  if (event === EV_CHANGE) {
			const isThrottled = !this._throttle(EV_CHANGE, path, 50);
			if (isThrottled) return this;
		  }

		  if (opts.alwaysStat && val1 === undefined &&
			(event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)
		  ) {
			const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
			let stats;
			try {
			  stats = await stat(fullPath);
			} catch (err) {}
			// Suppress event when fs_stat fails, to avoid sending undefined 'stat'
			if (!stats || this.closed) return;
			args.push(stats);
		  }
		  this.emitWithAll(event, args);

		  return this;
		  }

		  /**
		  * Common handler for errors
		  * @param {Error} error
		  * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
		  */
		  _handleError(error) {
		  const code = error && error.code;
		  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&
			(!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))
		  ) {
			this.emit(EV_ERROR, error);
		  }
		  return error || this.closed;
		  }

		  /**
		  * Helper utility for throttling
		  * @param {ThrottleType} actionType type being throttled
		  * @param {Path} path being acted upon
		  * @param {Number} timeout duration of time to suppress duplicate actions
		  * @returns {Object|false} tracking object or false if action should be suppressed
		  */
		  _throttle(actionType, path, timeout) {
		  if (!this._throttled.has(actionType)) {
			this._throttled.set(actionType, new Map());
		  }

		  /** @type {Map<Path, Object>} */
		  const action = this._throttled.get(actionType);
		  /** @type {Object} */
		  const actionPath = action.get(path);

		  if (actionPath) {
			actionPath.count++;
			return false;
		  }

		  let timeoutObject;
		  const clear = () => {
			const item = action.get(path);
			const count = item ? item.count : 0;
			action.delete(path);
			clearTimeout(timeoutObject);
			if (item) clearTimeout(item.timeoutObject);
			return count;
		  };
		  timeoutObject = setTimeout(clear, timeout);
		  const thr = {timeoutObject, clear, count: 0};
		  action.set(path, thr);
		  return thr;
		  }

		  _incrReadyCount() {
		  return this._readyCount++;
		  }

		  /**
		  * Awaits write operation to finish.
		  * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
		  * @param {Path} path being acted upon
		  * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
		  * @param {EventName} event
		  * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
		  */
		  _awaitWriteFinish(path, threshold, event, awfEmit) {
		  let timeoutHandler;

		  let fullPath = path;
		  if (this.options.cwd && !sysPath.isAbsolute(path)) {
			fullPath = sysPath.join(this.options.cwd, path);
		  }

		  const now = new Date();

		  const awaitWriteFinish = (prevStat) => {
			fs.stat(fullPath, (err, curStat) => {
			  if (err || !this._pendingWrites.has(path)) {
				if (err && err.code !== 'ENOENT') awfEmit(err);
				return;
			  }

			  const now = Number(new Date());

			  if (prevStat && curStat.size !== prevStat.size) {
				this._pendingWrites.get(path).lastChange = now;
			  }
			  const pw = this._pendingWrites.get(path);
			  const df = now - pw.lastChange;

			  if (df >= threshold) {
				this._pendingWrites.delete(path);
				awfEmit(undefined, curStat);
			  } else {
				timeoutHandler = setTimeout(
				  awaitWriteFinish,
				  this.options.awaitWriteFinish.pollInterval,
				  curStat
				);
			  }
			});
		  };

		  if (!this._pendingWrites.has(path)) {
			this._pendingWrites.set(path, {
			  lastChange: now,
			  cancelWait: () => {
				this._pendingWrites.delete(path);
				clearTimeout(timeoutHandler);
				return event;
			  }
			});
			timeoutHandler = setTimeout(
			  awaitWriteFinish,
			  this.options.awaitWriteFinish.pollInterval
			);
		  }
		  }

		  _getGlobIgnored() {
		  return [...this._ignoredPaths.values()];
		  }

		  /**
		  * Determines whether user has asked to ignore this path.
		  * @param {Path} path filepath or dir
		  * @param {fs.Stats=} stats result of fs.stat
		  * @returns {Boolean}
		  */
		  _isIgnored(path, stats) {
		  if (this.options.atomic && DOT_RE.test(path)) return true;
		  if (!this._userIgnored) {
			const {cwd} = this.options;
			const ign = this.options.ignored;

			const ignored = ign && ign.map(normalizeIgnored(cwd));
			const paths = arrify(ignored)
			  .filter((path) => typeof path === STRING_TYPE && !isGlob(path))
			  .map((path) => path + SLASH_GLOBSTAR);
			const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
			this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);
		  }

		  return this._userIgnored([path, stats]);
		  }

		  _isntIgnored(path, stat) {
		  return !this._isIgnored(path, stat);
		  }

		  /**
		  * Provides a set of common helpers and properties relating to symlink and glob handling.
		  * @param {Path} path file, directory, or glob pattern being watched
		  * @param {Number=} depth at any depth > 0, this isn't a glob
		  * @returns {WatchHelper} object containing helpers for this path
		  */
		  _getWatchHelpers(path, depth) {
		  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
		  const follow = this.options.followSymlinks;

		  return new WatchHelper(path, watchPath, follow, this);
		  }

		  // Directory helpers
		  // -----------------

		  /**
		  * Provides directory tracking objects
		  * @param {String} directory path of the directory
		  * @returns {DirEntry} the directory's tracking object
		  */
		  _getWatchedDir(directory) {
		  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
		  const dir = sysPath.resolve(directory);
		  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
		  return this._watched.get(dir);
		  }

		  // File helpers
		  // ------------

		  /**
		  * Check for read permissions.
		  * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
		  * @param {fs.Stats} stats - object, result of fs_stat
		  * @returns {Boolean} indicates whether the file can be read
		  */
		  _hasReadPermissions(stats) {
		  if (this.options.ignorePermissionErrors) return true;

		  // stats.mode may be bigint
		  const md = stats && Number.parseInt(stats.mode, 10);
		  const st = md & 0o777;
		  const it = Number.parseInt(st.toString(8)[0], 10);
		  return Boolean(4 & it);
		  }

		  /**
		  * Handles emitting unlink events for
		  * files and directories, and via recursion, for
		  * files and directories within directories that are unlinked
		  * @param {String} directory within which the following item is located
		  * @param {String} item      base path of item/directory
		  * @returns {void}
		  */
		  _remove(directory, item, isDirectory) {
		  // if what is being deleted is a directory, get that directory's paths
		  // for recursive deleting and cleaning of watched object
		  // if it is not a directory, nestedDirectoryChildren will be empty array
		  const path = sysPath.join(directory, item);
		  const fullPath = sysPath.resolve(path);
		  isDirectory = isDirectory != null
			? isDirectory
			: this._watched.has(path) || this._watched.has(fullPath);

		  // prevent duplicate handling in case of arriving here nearly simultaneously
		  // via multiple paths (such as _handleFile and _handleDir)
		  if (!this._throttle('remove', path, 100)) return;

		  // if the only watched file is removed, watch for its return
		  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
			this.add(directory, item, true);
		  }

		  // This will create a new entry in the watched object in either case
		  // so we got to do the directory check beforehand
		  const wp = this._getWatchedDir(path);
		  const nestedDirectoryChildren = wp.getChildren();

		  // Recursively remove children directories / files.
		  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));

		  // Check if item was on the watched list and remove it
		  const parent = this._getWatchedDir(directory);
		  const wasTracked = parent.has(item);
		  parent.remove(item);

		  // Fixes issue #1042 -> Relative paths were detected and added as symlinks
		  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
		  // but never removed from the map in case the path was deleted.
		  // This leads to an incorrect state if the path was recreated:
		  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553
		  if (this._symlinkPaths.has(fullPath)) {
			this._symlinkPaths.delete(fullPath);
		  }

		  // If we wait for this file to be fully written, cancel the wait.
		  let relPath = path;
		  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
		  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
			const event = this._pendingWrites.get(relPath).cancelWait();
			if (event === EV_ADD) return;
		  }

		  // The Entry will either be a directory that just got removed
		  // or a bogus entry to a file, in either case we have to remove it
		  this._watched.delete(path);
		  this._watched.delete(fullPath);
		  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
		  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);

		  // Avoid conflicts if we later create another file with the same name
		  if (!this.options.useFsEvents) {
			this._closePath(path);
		  }
		  }

		  /**
		  * Closes all watchers for a path
		  * @param {Path} path
		  */
		  _closePath(path) {
		  this._closeFile(path)
		  const dir = sysPath.dirname(path);
		  this._getWatchedDir(dir).remove(sysPath.basename(path));
		  }

		  /**
		  * Closes only file-specific watchers
		  * @param {Path} path
		  */
		  _closeFile(path) {
		  const closers = this._closers.get(path);
		  if (!closers) return;
		  closers.forEach(closer => closer());
		  this._closers.delete(path);
		  }

		  /**
		  *
		  * @param {Path} path
		  * @param {Function} closer
		  */
		  _addPathCloser(path, closer) {
		  if (!closer) return;
		  let list = this._closers.get(path);
		  if (!list) {
			list = [];
			this._closers.set(path, list);
		  }
		  list.push(closer);
		  }

		  _readdirp(root, opts) {
		  if (this.closed) return;
		  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};
		  let stream = readdirp(root, options);
		  this._streams.add(stream);
		  stream.once(STR_CLOSE, () => {
			stream = undefined;
		  });
		  stream.once(STR_END, () => {
			if (stream) {
			  this._streams.delete(stream);
			  stream = undefined;
			}
		  });
		  return stream;
		  }

		},
		watch: (paths, options) => {
		  const watcher = new FSWatcher(options);
		  watcher.add(paths);
		  return watcher;
		},
		default: {
		  FSWatcher: class FSWatcher extends EventEmitter {
			// Not indenting methods for history sake; for now.
			constructor(_opts) {
			super();

			const opts = {};
			if (_opts) Object.assign(opts, _opts); // for frozen objects

			/** @type {Map<String, DirEntry>} */
			this._watched = new Map();
			/** @type {Map<String, Array>} */
			this._closers = new Map();
			/** @type {Set<String>} */
			this._ignoredPaths = new Set();

			/** @type {Map<ThrottleType, Map>} */
			this._throttled = new Map();

			/** @type {Map<Path, String|Boolean>} */
			this._symlinkPaths = new Map();

			this._streams = new Set();
			this.closed = false;

			// Set up default options.
			if (undef(opts, 'persistent')) opts.persistent = true;
			if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
			if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
			if (undef(opts, 'interval')) opts.interval = 100;
			if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
			if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
			opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;

			// Enable fsevents on OS X when polling isn't explicitly enabled.
			if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;

			// If we can't use fsevents, ensure the options reflect it's disabled.
			const canUseFsEvents = FsEventsHandler.canUse();
			if (!canUseFsEvents) opts.useFsEvents = false;

			// Use polling on Mac if not using fsevents.
			// Other platforms use non-polling fs_watch.
			if (undef(opts, 'usePolling') && !opts.useFsEvents) {
			  opts.usePolling = isMacos;
			}

			// Always default to polling on IBM i because fs.watch() is not available on IBM i.
			if(isIBMi) {
			  opts.usePolling = true;
			}

			// Global override (useful for end-developers that need to force polling for all
			// instances of chokidar, regardless of usage/dependency depth)
			const envPoll = process.env.CHOKIDAR_USEPOLLING;
			if (envPoll !== undefined) {
			  const envLower = envPoll.toLowerCase();

			  if (envLower === 'false' || envLower === '0') {
				opts.usePolling = false;
			  } else if (envLower === 'true' || envLower === '1') {
				opts.usePolling = true;
			  } else {
				opts.usePolling = !!envLower;
			  }
			}
			const envInterval = process.env.CHOKIDAR_INTERVAL;
			if (envInterval) {
			  opts.interval = Number.parseInt(envInterval, 10);
			}

			// Editor atomic write normalization enabled by default with fs.watch
			if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
			if (opts.atomic) this._pendingUnlinks = new Map();

			if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;

			if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
			if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
			const awf = opts.awaitWriteFinish;
			if (awf) {
			  if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
			  if (!awf.pollInterval) awf.pollInterval = 100;
			  this._pendingWrites = new Map();
			}
			if (opts.ignored) opts.ignored = arrify(opts.ignored);

			let readyCalls = 0;
			this._emitReady = () => {
			  readyCalls++;
			  if (readyCalls >= this._readyCount) {
				this._emitReady = EMPTY_FN;
				this._readyEmitted = true;
				// use process.nextTick to allow time for listener to be bound
				process.nextTick(() => this.emit(EV_READY));
			  }
			};
			this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
			this._readyEmitted = false;
			this.options = opts;

			// Initialize with proper watcher.
			if (opts.useFsEvents) {
			  this._fsEventsHandler = new FsEventsHandler(this);
			} else {
			  this._nodeFsHandler = new NodeFsHandler(this);
			}

			// You’re frozen when your heart’s not open.
			Object.freeze(opts);
			}

			// Public methods

			/**
			* Adds paths to be watched on an existing FSWatcher instance
			* @param {Path|Array<Path>} paths_
			* @param {String=} _origAdd private; for handling non-existent paths to be watched
			* @param {Boolean=} _internal private; indicates a non-user add
			* @returns {FSWatcher} for chaining
			*/
			add(paths_, _origAdd, _internal) {
			const {cwd, disableGlobbing} = this.options;
			this.closed = false;
			let paths = unifyPaths(paths_);
			if (cwd) {
			  paths = paths.map((path) => {
				const absPath = getAbsolutePath(path, cwd);

				// Check `path` instead of `absPath` because the cwd portion can't be a glob
				if (disableGlobbing || !isGlob(path)) {
				  return absPath;
				}
				return normalizePath(absPath);
			  });
			}

			// set aside negated glob strings
			paths = paths.filter((path) => {
			  if (path.startsWith(BANG)) {
				this._ignoredPaths.add(path.slice(1));
				return false;
			  }

			  // if a path is being added that was previously ignored, stop ignoring it
			  this._ignoredPaths.delete(path);
			  this._ignoredPaths.delete(path + SLASH_GLOBSTAR);

			  // reset the cached userIgnored anymatch fn
			  // to make ignoredPaths changes effective
			  this._userIgnored = undefined;

			  return true;
			});

			if (this.options.useFsEvents && this._fsEventsHandler) {
			  if (!this._readyCount) this._readyCount = paths.length;
			  if (this.options.persistent) this._readyCount *= 2;
			  paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));
			} else {
			  if (!this._readyCount) this._readyCount = 0;
			  this._readyCount += paths.length;
			  Promise.all(
				paths.map(async path => {
				  const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);
				  if (res) this._emitReady();
				  return res;
				})
			  ).then(results => {
				if (this.closed) return;
				results.filter(item => item).forEach(item => {
				  this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
				});
			  });
			}

			return this;
			}

			/**
			* Close watchers or start ignoring events from specified paths.
			* @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
			* @returns {FSWatcher} for chaining
			*/
			unwatch(paths_) {
			if (this.closed) return this;
			const paths = unifyPaths(paths_);
			const {cwd} = this.options;

			paths.forEach((path) => {
			  // convert to absolute path unless relative path already matches
			  if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {
				if (cwd) path = sysPath.join(cwd, path);
				path = sysPath.resolve(path);
			  }

			  this._closePath(path);

			  this._ignoredPaths.add(path);
			  if (this._watched.has(path)) {
				this._ignoredPaths.add(path + SLASH_GLOBSTAR);
			  }

			  // reset the cached userIgnored anymatch fn
			  // to make ignoredPaths changes effective
			  this._userIgnored = undefined;
			});

			return this;
			}

			/**
			* Close watchers and remove all listeners from watched paths.
			* @returns {Promise<void>}.
			*/
			close() {
			if (this.closed) return this._closePromise;
			this.closed = true;

			// Memory management.
			this.removeAllListeners();
			const closers = [];
			this._closers.forEach(closerList => closerList.forEach(closer => {
			  const promise = closer();
			  if (promise instanceof Promise) closers.push(promise);
			}));
			this._streams.forEach(stream => stream.destroy());
			this._userIgnored = undefined;
			this._readyCount = 0;
			this._readyEmitted = false;
			this._watched.forEach(dirent => dirent.dispose());
			['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {
			  this[`_${key}`].clear();
			});

			this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();
			return this._closePromise;
			}

			/**
			* Expose list of watched paths
			* @returns {Object} for chaining
			*/
			getWatched() {
			const watchList = {};
			this._watched.forEach((entry, dir) => {
			  const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
			  watchList[key || ONE_DOT] = entry.getChildren().sort();
			});
			return watchList;
			}

			emitWithAll(event, args) {
			this.emit(...args);
			if (event !== EV_ERROR) this.emit(EV_ALL, ...args);
			}

			// Common helpers
			// --------------

			/**
			* Normalize and emit events.
			* Calling _emit DOES NOT MEAN emit() would be called!
			* @param {EventName} event Type of event
			* @param {Path} path File or directory path
			* @param {*=} val1 arguments to be passed with event
			* @param {*=} val2
			* @param {*=} val3
			* @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
			*/
			async _emit(event, path, val1, val2, val3) {
			if (this.closed) return;

			const opts = this.options;
			if (isWindows) path = sysPath.normalize(path);
			if (opts.cwd) path = sysPath.relative(opts.cwd, path);
			/** @type Array<any> */
			const args = [event, path];
			if (val3 !== undefined) args.push(val1, val2, val3);
			else if (val2 !== undefined) args.push(val1, val2);
			else if (val1 !== undefined) args.push(val1);

			const awf = opts.awaitWriteFinish;
			let pw;
			if (awf && (pw = this._pendingWrites.get(path))) {
			  pw.lastChange = new Date();
			  return this;
			}

			if (opts.atomic) {
			  if (event === EV_UNLINK) {
				this._pendingUnlinks.set(path, args);
				setTimeout(() => {
				  this._pendingUnlinks.forEach((entry, path) => {
					this.emit(...entry);
					this.emit(EV_ALL, ...entry);
					this._pendingUnlinks.delete(path);
				  });
				}, typeof opts.atomic === 'number' ? opts.atomic : 100);
				return this;
			  }
			  if (event === EV_ADD && this._pendingUnlinks.has(path)) {
				event = args[0] = EV_CHANGE;
				this._pendingUnlinks.delete(path);
			  }
			}

			if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
			  const awfEmit = (err, stats) => {
				if (err) {
				  event = args[0] = EV_ERROR;
				  args[1] = err;
				  this.emitWithAll(event, args);
				} else if (stats) {
				  // if stats doesn't exist the file must have been deleted
				  if (args.length > 2) {
					args[2] = stats;
				  } else {
					args.push(stats);
				  }
				  this.emitWithAll(event, args);
				}
			  };

			  this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
			  return this;
			}

			if (event === EV_CHANGE) {
			  const isThrottled = !this._throttle(EV_CHANGE, path, 50);
			  if (isThrottled) return this;
			}

			if (opts.alwaysStat && val1 === undefined &&
			  (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)
			) {
			  const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
			  let stats;
			  try {
				stats = await stat(fullPath);
			  } catch (err) {}
			  // Suppress event when fs_stat fails, to avoid sending undefined 'stat'
			  if (!stats || this.closed) return;
			  args.push(stats);
			}
			this.emitWithAll(event, args);

			return this;
			}

			/**
			* Common handler for errors
			* @param {Error} error
			* @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
			*/
			_handleError(error) {
			const code = error && error.code;
			if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&
			  (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))
			) {
			  this.emit(EV_ERROR, error);
			}
			return error || this.closed;
			}

			/**
			* Helper utility for throttling
			* @param {ThrottleType} actionType type being throttled
			* @param {Path} path being acted upon
			* @param {Number} timeout duration of time to suppress duplicate actions
			* @returns {Object|false} tracking object or false if action should be suppressed
			*/
			_throttle(actionType, path, timeout) {
			if (!this._throttled.has(actionType)) {
			  this._throttled.set(actionType, new Map());
			}

			/** @type {Map<Path, Object>} */
			const action = this._throttled.get(actionType);
			/** @type {Object} */
			const actionPath = action.get(path);

			if (actionPath) {
			  actionPath.count++;
			  return false;
			}

			let timeoutObject;
			const clear = () => {
			  const item = action.get(path);
			  const count = item ? item.count : 0;
			  action.delete(path);
			  clearTimeout(timeoutObject);
			  if (item) clearTimeout(item.timeoutObject);
			  return count;
			};
			timeoutObject = setTimeout(clear, timeout);
			const thr = {timeoutObject, clear, count: 0};
			action.set(path, thr);
			return thr;
			}

			_incrReadyCount() {
			return this._readyCount++;
			}

			/**
			* Awaits write operation to finish.
			* Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
			* @param {Path} path being acted upon
			* @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
			* @param {EventName} event
			* @param {Function} awfEmit Callback to be called when ready for event to be emitted.
			*/
			_awaitWriteFinish(path, threshold, event, awfEmit) {
			let timeoutHandler;

			let fullPath = path;
			if (this.options.cwd && !sysPath.isAbsolute(path)) {
			  fullPath = sysPath.join(this.options.cwd, path);
			}

			const now = new Date();

			const awaitWriteFinish = (prevStat) => {
			  fs.stat(fullPath, (err, curStat) => {
				if (err || !this._pendingWrites.has(path)) {
				  if (err && err.code !== 'ENOENT') awfEmit(err);
				  return;
				}

				const now = Number(new Date());

				if (prevStat && curStat.size !== prevStat.size) {
				  this._pendingWrites.get(path).lastChange = now;
				}
				const pw = this._pendingWrites.get(path);
				const df = now - pw.lastChange;

				if (df >= threshold) {
				  this._pendingWrites.delete(path);
				  awfEmit(undefined, curStat);
				} else {
				  timeoutHandler = setTimeout(
					awaitWriteFinish,
					this.options.awaitWriteFinish.pollInterval,
					curStat
				  );
				}
			  });
			};

			if (!this._pendingWrites.has(path)) {
			  this._pendingWrites.set(path, {
				lastChange: now,
				cancelWait: () => {
				  this._pendingWrites.delete(path);
				  clearTimeout(timeoutHandler);
				  return event;
				}
			  });
			  timeoutHandler = setTimeout(
				awaitWriteFinish,
				this.options.awaitWriteFinish.pollInterval
			  );
			}
			}

			_getGlobIgnored() {
			return [...this._ignoredPaths.values()];
			}

			/**
			* Determines whether user has asked to ignore this path.
			* @param {Path} path filepath or dir
			* @param {fs.Stats=} stats result of fs.stat
			* @returns {Boolean}
			*/
			_isIgnored(path, stats) {
			if (this.options.atomic && DOT_RE.test(path)) return true;
			if (!this._userIgnored) {
			  const {cwd} = this.options;
			  const ign = this.options.ignored;

			  const ignored = ign && ign.map(normalizeIgnored(cwd));
			  const paths = arrify(ignored)
				.filter((path) => typeof path === STRING_TYPE && !isGlob(path))
				.map((path) => path + SLASH_GLOBSTAR);
			  const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
			  this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);
			}

			return this._userIgnored([path, stats]);
			}

			_isntIgnored(path, stat) {
			return !this._isIgnored(path, stat);
			}

			/**
			* Provides a set of common helpers and properties relating to symlink and glob handling.
			* @param {Path} path file, directory, or glob pattern being watched
			* @param {Number=} depth at any depth > 0, this isn't a glob
			* @returns {WatchHelper} object containing helpers for this path
			*/
			_getWatchHelpers(path, depth) {
			const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
			const follow = this.options.followSymlinks;

			return new WatchHelper(path, watchPath, follow, this);
			}

			// Directory helpers
			// -----------------

			/**
			* Provides directory tracking objects
			* @param {String} directory path of the directory
			* @returns {DirEntry} the directory's tracking object
			*/
			_getWatchedDir(directory) {
			if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
			const dir = sysPath.resolve(directory);
			if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
			return this._watched.get(dir);
			}

			// File helpers
			// ------------

			/**
			* Check for read permissions.
			* Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
			* @param {fs.Stats} stats - object, result of fs_stat
			* @returns {Boolean} indicates whether the file can be read
			*/
			_hasReadPermissions(stats) {
			if (this.options.ignorePermissionErrors) return true;

			// stats.mode may be bigint
			const md = stats && Number.parseInt(stats.mode, 10);
			const st = md & 0o777;
			const it = Number.parseInt(st.toString(8)[0], 10);
			return Boolean(4 & it);
			}

			/**
			* Handles emitting unlink events for
			* files and directories, and via recursion, for
			* files and directories within directories that are unlinked
			* @param {String} directory within which the following item is located
			* @param {String} item      base path of item/directory
			* @returns {void}
			*/
			_remove(directory, item, isDirectory) {
			// if what is being deleted is a directory, get that directory's paths
			// for recursive deleting and cleaning of watched object
			// if it is not a directory, nestedDirectoryChildren will be empty array
			const path = sysPath.join(directory, item);
			const fullPath = sysPath.resolve(path);
			isDirectory = isDirectory != null
			  ? isDirectory
			  : this._watched.has(path) || this._watched.has(fullPath);

			// prevent duplicate handling in case of arriving here nearly simultaneously
			// via multiple paths (such as _handleFile and _handleDir)
			if (!this._throttle('remove', path, 100)) return;

			// if the only watched file is removed, watch for its return
			if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
			  this.add(directory, item, true);
			}

			// This will create a new entry in the watched object in either case
			// so we got to do the directory check beforehand
			const wp = this._getWatchedDir(path);
			const nestedDirectoryChildren = wp.getChildren();

			// Recursively remove children directories / files.
			nestedDirectoryChildren.forEach(nested => this._remove(path, nested));

			// Check if item was on the watched list and remove it
			const parent = this._getWatchedDir(directory);
			const wasTracked = parent.has(item);
			parent.remove(item);

			// Fixes issue #1042 -> Relative paths were detected and added as symlinks
			// (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
			// but never removed from the map in case the path was deleted.
			// This leads to an incorrect state if the path was recreated:
			// https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553
			if (this._symlinkPaths.has(fullPath)) {
			  this._symlinkPaths.delete(fullPath);
			}

			// If we wait for this file to be fully written, cancel the wait.
			let relPath = path;
			if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
			if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
			  const event = this._pendingWrites.get(relPath).cancelWait();
			  if (event === EV_ADD) return;
			}

			// The Entry will either be a directory that just got removed
			// or a bogus entry to a file, in either case we have to remove it
			this._watched.delete(path);
			this._watched.delete(fullPath);
			const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
			if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);

			// Avoid conflicts if we later create another file with the same name
			if (!this.options.useFsEvents) {
			  this._closePath(path);
			}
			}

			/**
			* Closes all watchers for a path
			* @param {Path} path
			*/
			_closePath(path) {
			this._closeFile(path)
			const dir = sysPath.dirname(path);
			this._getWatchedDir(dir).remove(sysPath.basename(path));
			}

			/**
			* Closes only file-specific watchers
			* @param {Path} path
			*/
			_closeFile(path) {
			const closers = this._closers.get(path);
			if (!closers) return;
			closers.forEach(closer => closer());
			this._closers.delete(path);
			}

			/**
			*
			* @param {Path} path
			* @param {Function} closer
			*/
			_addPathCloser(path, closer) {
			if (!closer) return;
			let list = this._closers.get(path);
			if (!list) {
			  list = [];
			  this._closers.set(path, list);
			}
			list.push(closer);
			}

			_readdirp(root, opts) {
			if (this.closed) return;
			const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};
			let stream = readdirp(root, options);
			this._streams.add(stream);
			stream.once(STR_CLOSE, () => {
			  stream = undefined;
			});
			stream.once(STR_END, () => {
			  if (stream) {
				this._streams.delete(stream);
				stream = undefined;
			  }
			});
			return stream;
			}

		  },
		  watch: (paths, options) => {
			const watcher = new FSWatcher(options);
			watcher.add(paths);
			return watcher;
		  },
		},
	  },
	  createDebug: (id) => require('debug')(id),
	  createBabelRegister: function createBabelRegister({ only }) {
		require('@babel/register')({
			only: Array.from(new Set([...only])),
			presets: [
				require.resolve('@babel/preset-env'),
				require.resolve('@babel/preset-typescript')
			],
			plugins: [
				injectDefineConfigHeader,
				[require.resolve('@babel/plugin-proposal-decorators'), {
						legacy: true
					}],
				require.resolve('@babel/plugin-proposal-object-rest-spread'),
				[require.resolve('@babel/plugin-transform-runtime'), {
						corejs: false,
						helpers: true,
						regenerator: true,
						useESModules: false,
						version: '^7.7.7',
						absoluteRuntime: path.resolve(__dirname, '..', 'node_modules/@babel/runtime')
					}]
			],
			extensions: ['.jsx', '.js', '.ts', '.tsx'],
			babelrc: false,
			configFile: false,
			cache: false
		});
	  },
	  injectDefineConfigHeader: function injectDefineConfigHeader(babel) {
		const appConfig = 'function defineAppConfig(config) { return config }';
		const pageConfig = 'function definePageConfig(config) { return config }';
		const prependHeader = (nodePath, header) => {
			const parsedHeader = babel.parse(header, { filename: '' }).program.body[0];
			nodePath.node.body.unshift(parsedHeader);
		};
		const enterHandler = (nodePath) => {
			const { scope, node } = nodePath;
			scope.traverse(node, {
				CallExpression(p) {
					const callee = p.node.callee;
					// @ts-ignore
					switch (callee.name) {
						case 'defineAppConfig':
							return prependHeader(nodePath, appConfig);
						case 'definePageConfig':
							return prependHeader(nodePath, pageConfig);
					}
				}
			});
		};
		return {
			visitor: {
				Program: { enter: enterHandler }
			}
		};
	  },
	  npm: {
		taroPluginPrefix: "@tarojs/plugin-",
		resolveNpm: function resolveNpm(pluginName, root) {
		  const resolvePath = require('resolve');
		  if (!npmCached[pluginName]) {
			  return new Promise((resolve, reject) => {
				  resolvePath(`${pluginName}`, { basedir: root }, (err, res) => {
					  if (err) {
						  return reject(err);
					  }
					  npmCached[pluginName] = res;
					  resolve(res || '');
				  });
			  });
		  }
		  return Promise.resolve(npmCached[pluginName]);
		},
		resolveNpmSync: function resolveNpmSync(pluginName, root) {
		  const resolvePath = require('resolve');
		  try {
			  if (!npmCached[pluginName]) {
				  const res = resolvePath.sync(pluginName, { basedir: root });
				  return res;
			  }
			  return npmCached[pluginName];
		  }
		  catch (err) {
			  if (err.code === 'MODULE_NOT_FOUND') {
				  console.log(terminal_1.chalk.cyan(`缺少npm包${pluginName}，开始安装...`));
				  const installOptions = {
					  dev: false,
				  };
				  if (pluginName.indexOf(exports.taroPluginPrefix) >= 0) {
					  installOptions.dev = true;
				  }
				  installNpmPkg(pluginName, installOptions);
				  return resolveNpmSync(pluginName, root);
			  }
			  return '';
		  }
		},
		installNpmPkg: function installNpmPkg(pkgList, options) {
		  if (!pkgList) {
			  return;
		  }
		  if (!Array.isArray(pkgList)) {
			  pkgList = [pkgList];
		  }
		  pkgList = pkgList.filter((dep) => {
			  return erroneous.indexOf(dep) === -1;
		  });
		  if (!pkgList.length) {
			  return;
		  }
		  options = Object.assign({}, defaultInstallOptions, options);
		  let installer = '';
		  let args = [];
		  if (Util.shouldUseYarn()) {
			  installer = 'yarn';
		  }
		  else if (Util.shouldUseCnpm()) {
			  installer = 'cnpm';
		  }
		  else {
			  installer = 'npm';
		  }
		  if (Util.shouldUseYarn()) {
			  args = ['add'].concat(pkgList).filter(Boolean);
			  args.push('--silent', '--no-progress');
			  if (options.dev) {
				  args.push('-D');
			  }
		  }
		  else {
			  args = ['install'].concat(pkgList).filter(Boolean);
			  args.push('--silent', '--no-progress');
			  if (options.dev) {
				  args.push('--save-dev');
			  }
			  else {
				  args.push('--save');
			  }
		  }
		  const spawn = require('cross-spawn');
		  const output = spawn.sync(installer, args, {
			  stdio: ['ignore', 'pipe', 'inherit'],
		  });
		  if (output.status) {
			  pkgList.forEach((dep) => {
				  erroneous.push(dep);
			  });
		  }
		  let matches = null;
		  const peers = [];
		  while ((matches = PEERS.exec(output.stdout))) {
			  const pkg = matches[1];
			  const version = matches[2];
			  if (version.match(' ')) {
				  peers.push(pkg);
			  }
			  else {
				  peers.push(`${pkg}@${version}`);
			  }
		  }
		  if (options.peerDependencies && peers.length) {
			  console.info('正在安装 peerDependencies...');
			  installNpmPkg(peers, options);
		  }
		  return output;
		},
		callPlugin: (pluginName, content, file, config, root) => __awaiter(void 0, void 0, void 0, function* () {
		  const pluginFn = yield getNpmPkg(`${exports.taroPluginPrefix}${pluginName}`, root);
		  return pluginFn(content, file, config);
		}),
		callPluginSync: (pluginName, content, file, config, root) => {
		  const pluginFn = getNpmPkgSync(`${exports.taroPluginPrefix}${pluginName}`, root);
		  return pluginFn(content, file, config);
		},
		getNpmPkgSync: function getNpmPkgSync(npmName, root) {
		  const npmPath = resolveNpmSync(npmName, root);
		  const npmFn = require(npmPath);
		  return npmFn;
		},
		getNpmPkg: function getNpmPkg(npmName, root) {
		  return __awaiter(this, void 0, void 0, function* () {
			  let npmPath;
			  try {
				  npmPath = resolveNpmSync(npmName, root);
			  }
			  catch (err) {
				  if (err.code === 'MODULE_NOT_FOUND') {
					  console.log(terminal_1.chalk.cyan(`缺少npm包${npmName}，开始安装...`));
					  const installOptions = {
						  dev: false,
					  };
					  if (npmName.indexOf(exports.taroPluginPrefix) >= 0) {
						  installOptions.dev = true;
					  }
					  installNpmPkg(npmName, installOptions);
					  npmPath = yield resolveNpm(npmName, root);
				  }
			  }
			  const npmFn = require(npmPath);
			  return npmFn;
		  });
		},
	  },
	  createSwcRegister: function createSwcRegister({ only, plugins }) {
		const config = {
			only: Array.from(new Set([...only])),
			jsc: {
				parser: {
					syntax: 'typescript',
					decorators: true
				},
				transform: {
					legacyDecorator: true
				}
			},
			module: {
				type: 'commonjs'
			}
		};
		if (plugins) {
			config.jsc.experimental = {
				plugins
			};
		}
		require('@swc/register')(config);
	  },
	  PLATFORMS: {
	  },
	  processTypeEnum: {
		START: "start",
		CREATE: "create",
		COMPILE: "compile",
		CONVERT: "convert",
		COPY: "copy",
		GENERATE: "generate",
		MODIFY: "modify",
		ERROR: "error",
		WARNING: "warning",
		UNLINK: "unlink",
		REFERENCE: "reference",
		REMIND: "remind",
	  },
	  processTypeMap: {
		create: {
		  name: "创建",
		  color: "cyan",
		},
		compile: {
		  name: "编译",
		  color: "green",
		},
		convert: {
		  name: "转换",
		  color: (...arguments_) => {
			// Single argument is hot path, implicit coercion is faster than anything
			// eslint-disable-next-line no-implicit-coercion
			return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
		  },
		},
		copy: {
		  name: "拷贝",
		  color: "magenta",
		},
		generate: {
		  name: "生成",
		  color: "blue",
		},
		modify: {
		  name: "修改",
		  color: "yellow",
		},
		error: {
		  name: "错误",
		  color: "red",
		},
		warning: {
		  name: "警告",
		  color: "yellowBright",
		},
		unlink: {
		  name: "删除",
		  color: "magenta",
		},
		start: {
		  name: "启动",
		  color: "green",
		},
		reference: {
		  name: "引用",
		  color: "blue",
		},
		remind: {
		  name: "提示",
		  color: "green",
		},
	  },
	  CSS_EXT: [
		".css",
		".scss",
		".sass",
		".less",
		".styl",
		".stylus",
		".wxss",
		".acss",
	  ],
	  SCSS_EXT: [
		".scss",
	  ],
	  JS_EXT: [
		".js",
		".jsx",
	  ],
	  TS_EXT: [
		".ts",
		".tsx",
	  ],
	  UX_EXT: [
		".ux",
	  ],
	  SCRIPT_EXT: [
		".js",
		".jsx",
		".ts",
		".tsx",
	  ],
	  VUE_EXT: [
		".vue",
	  ],
	  REG_JS: {
	  },
	  REG_SCRIPT: {
	  },
	  REG_TYPESCRIPT: {
	  },
	  REG_SCRIPTS: {
	  },
	  REG_VUE: {
	  },
	  REG_SASS: {
	  },
	  REG_SASS_SASS: {
	  },
	  REG_SASS_SCSS: {
	  },
	  REG_LESS: {
	  },
	  REG_STYLUS: {
	  },
	  REG_STYLE: {
	  },
	  REG_CSS: {
	  },
	  REG_MEDIA: {
	  },
	  REG_IMAGE: {
	  },
	  REG_FONT: {
	  },
	  REG_JSON: {
	  },
	  REG_UX: {
	  },
	  REG_TEMPLATE: {
	  },
	  REG_WXML_IMPORT: {
	  },
	  REG_URL: {
	  },
	  REG_TARO_H5: {
	  },
	  REG_TARO_H5_RUNTIME_API: {
	  },
	  CSS_IMPORT_REG: {
	  },
	  NODE_MODULES: "node_modules",
	  NODE_MODULES_REG: {
	  },
	  PROJECT_CONFIG: "config/index",
	  DEVICE_RATIO: {
		"640": 1.17,
		"750": 1,
		"828": 0.905,
	  },
	  FILE_PROCESSOR_MAP: {
		".js": "babel",
		".scss": "sass",
		".sass": "sass",
		".less": "less",
		".styl": "stylus",
	  },
	  UPDATE_PACKAGE_LIST: [
		"babel-plugin-transform-react-jsx-to-rn-stylesheet",
		"taro-css-to-react-native",
		"stylelint-config-taro-rn",
		"stylelint-taro-rn",
		"babel-plugin-transform-taroapi",
		"babel-preset-taro",
		"eslint-config-taro",
		"postcss-html-transform",
		"postcss-plugin-constparse",
		"postcss-pxtransform",
		"@tarojs/shared",
		"@tarojs/taro",
		"@tarojs/cli",
		"@tarojs/api",
		"@tarojs/components",
		"@tarojs/components-react",
		"@tarojs/components-rn",
		"@tarojs/extend",
		"@tarojs/taro-h5",
		"@tarojs/taro-rn",
		"@tarojs/rn-runner",
		"@tarojs/rn-style-transformer",
		"@tarojs/rn-supporter",
		"@tarojs/rn-transformer",
		"@tarojs/helper",
		"@tarojs/taro-loader",
		"@tarojs/mini-runner",
		"@tarojs/react",
		"@tarojs/plugin-framework-react",
		"@tarojs/plugin-framework-vue2",
		"@tarojs/plugin-framework-vue3",
		"@tarojs/plugin-react-devtools",
		"@tarojs/plugin-vue-devtools",
		"@tarojs/router",
		"@tarojs/router-rn",
		"@tarojs/runner-utils",
		"@tarojs/runtime",
		"@tarojs/runtime-rn",
		"@tarojs/service",
		"@tarojs/webpack-runner",
		"@tarojs/with-weapp",
		"@tarojs/taroize",
		"@tarojs/plugin-platform-weapp",
		"@tarojs/plugin-platform-alipay",
		"@tarojs/plugin-platform-swan",
		"@tarojs/plugin-platform-tt",
		"@tarojs/plugin-platform-qq",
		"@tarojs/plugin-platform-jd",
		"@tarojs/plugin-platform-h5",
		"@tarojs/plugin-html",
		"@tarojs/plugin-mini-ci",
		"@tarojs/webpack5-runner",
		"@tarojs/webpack5-prebundle",
	  ],
	  META_TYPE: {
		ENTRY: "ENTRY",
		PAGE: "PAGE",
		COMPONENT: "COMPONENT",
		NORMAL: "NORMAL",
		STATIC: "STATIC",
		CONFIG: "CONFIG",
		EXPORTS: "EXPORTS",
	  },
	  taroJsComponents: "@tarojs/components",
	  taroJsQuickAppComponents: "@tarojs/components-qa",
	  taroJsFramework: "@tarojs/taro",
	  taroJsRedux: "@tarojs/redux",
	  taroJsMobx: "@tarojs/mobx",
	  taroJsMobxCommon: "@tarojs/mobx-common",
	  DEVICE_RATIO_NAME: "deviceRatio",
	  isWindows: false,
	  DEFAULT_TEMPLATE_SRC: "github:NervJS/taro-project-templates#v4.0",
	  DEFAULT_TEMPLATE_SRC_GITEE: "direct:https://gitee.com/o2team/taro-project-templates.git#v4.0",
	  TARO_CONFIG_FOLDER: ".taro3.7",
	  TARO_BASE_CONFIG: "index.json",
	  TARO_GLOBAL_CONFIG_DIR: ".taro-global-config",
	  TARO_GLOBAL_CONFIG_FILE: "index.json",
	  OUTPUT_DIR: "dist",
	  SOURCE_DIR: "src",
	  TEMP_DIR: ".temp",
	  NPM_DIR: "npm",
	  ENTRY: "app",
	  FRAMEWORK_MAP: {
		VUE: "vue",
		VUE3: "vue3",
		REACT: "react",
		NERV: "nerv",
	  },
	  defaultMainFields: [
		"browser",
		"module",
		"jsnext:main",
		"main",
	  ],
	  formatPrefix: (prefixs = ['TARO_APP_']) => {
		const prefixsArr = (Array.isArray(prefixs) ? prefixs : prefixs.split(',')).map(prefix => prefix.trim()).filter(prefix => !!prefix);
		return prefixsArr;
	  },
	  dotenvParse: (root, prefixs = ['TARO_APP_'], mode) => {
		const prefixsArr = (0, exports.formatPrefix)(prefixs);
		const envFiles = new Set([
			/** default file */ `.env`,
			/** local file */ `.env.local`,
		]);
		if (mode) {
			envFiles.add(/** mode file */ `.env.${mode}`);
			envFiles.add(/** mode local file */ `.env.${mode}.local`);
		}
		let parseTemp = {};
		const load = envPath => {
			// file doesn'et exist
			if (!fs.existsSync(envPath))
				return;
			const env = (0, dotenv_1.parse)(fs.readFileSync(envPath));
			parseTemp = Object.assign(Object.assign({}, parseTemp), env);
		};
		envFiles.forEach(envPath => {
			load(path.resolve(root, envPath));
		});
		const parsed = {};
		Object.entries(parseTemp).forEach(([key, value]) => {
			if (prefixsArr.some(prefix => key.startsWith(prefix)) || ['TARO_APP_ID'].includes(key)) {
				parsed[key] = value;
			}
		});
		(0, dotenv_expand_1.expand)({ parsed });
		return parsed;
	  },
	  patchEnv: (config, expandEnv) => {
		const expandEnvStringify = {};
		for (const key in expandEnv) {
			expandEnvStringify[key] = JSON.stringify(expandEnv[key]);
		}
		return Object.assign(Object.assign({}, config.env), expandEnvStringify);
	  },
	  defaultEsbuildLoader: {
		".js": "tsx",
		".jsx": "tsx",
		".ts": "tsx",
	  },
	  requireWithEsbuild: function requireWithEsbuild(id, { customConfig = {}, customSwcConfig = {}, cwd = process.cwd() } = {}) {
		const { outputFiles = [] } = esbuild_1.default.buildSync((0, lodash_1.defaults)((0, lodash_1.omit)(customConfig, ['alias', 'define', 'loader', 'plugins']), {
			platform: 'node',
			absWorkingDir: cwd,
			bundle: true,
			define: (0, lodash_1.defaults)(customConfig.define, {
				// AMD 被 esbuild 转 ESM 后，是套着 ESM 外皮的 AMD 语法模块。
				// Webpack HarmonyDetectionParserPlugin 会阻止 AMDDefineDependencyParserPlugin 对这些模块的处理。
				// 导致这些模块报错（如 lodash）。目前的办法是把 define 置为 false，不支持 AMD 导出。
				define: 'false',
			}),
			alias: Object.fromEntries(Object.entries(customConfig.alias || {}).filter(([key]) => !key.startsWith('/'))),
			entryPoints: [id],
			format: 'esm',
			loader: (0, lodash_1.defaults)(customConfig.loader, exports.defaultEsbuildLoader),
			mainFields: [...constants_1.defaultMainFields],
			write: false,
		}));
		// Note: esbuild.buildSync 模式下不支持引入插件，所以这里需要手动转换
		const { code = '' } = (0, core_1.transformSync)(outputFiles[0].text, (0, lodash_1.defaults)(customSwcConfig, {
			jsc: { target: 'es2015' },
		}));
		return (0, require_from_string_1.default)(code, id);
	  },
	  esbuild: {
		analyzeMetafile: (messages, options) => ensureServiceIsRunning().analyzeMetafile(messages, options),
		analyzeMetafileSync: (metafile, options) => {
		  if (worker_threads && !isInternalWorkerThread) {
			if (!workerThreadService)
			  workerThreadService = startWorkerThreadService(worker_threads);
			return workerThreadService.analyzeMetafileSync(metafile, options);
		  }
		  let result;
		  runServiceSync((service) => service.analyzeMetafile({
			callName: "analyzeMetafileSync",
			refs: null,
			metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
			options,
			callback: (err, res) => {
			  if (err)
				throw err;
			  result = res;
			}
		  }));
		  return result;
		},
		build: (options) => ensureServiceIsRunning().build(options),
		buildSync: (options) => {
		  if (worker_threads && !isInternalWorkerThread) {
			if (!workerThreadService)
			  workerThreadService = startWorkerThreadService(worker_threads);
			return workerThreadService.buildSync(options);
		  }
		  let result;
		  runServiceSync((service) => service.buildOrContext({
			callName: "buildSync",
			refs: null,
			options,
			isTTY: isTTY(),
			defaultWD,
			callback: (err, res) => {
			  if (err)
				throw err;
			  result = res;
			}
		  }));
		  return result;
		},
		context: (buildOptions) => ensureServiceIsRunning().context(buildOptions),
		default: [Circular],
		formatMessages: (messages, options) => ensureServiceIsRunning().formatMessages(messages, options),
		formatMessagesSync: (messages, options) => {
		  if (worker_threads && !isInternalWorkerThread) {
			if (!workerThreadService)
			  workerThreadService = startWorkerThreadService(worker_threads);
			return workerThreadService.formatMessagesSync(messages, options);
		  }
		  let result;
		  runServiceSync((service) => service.formatMessages({
			callName: "formatMessagesSync",
			refs: null,
			messages,
			options,
			callback: (err, res) => {
			  if (err)
				throw err;
			  result = res;
			}
		  }));
		  return result;
		},
		initialize: (options) => {
		  options = validateInitializeOptions(options || {});
		  if (options.wasmURL)
			throw new Error(`The "wasmURL" option only works in the browser`);
		  if (options.wasmModule)
			throw new Error(`The "wasmModule" option only works in the browser`);
		  if (options.worker)
			throw new Error(`The "worker" option only works in the browser`);
		  if (initializeWasCalled)
			throw new Error('Cannot call "initialize" more than once');
		  ensureServiceIsRunning();
		  initializeWasCalled = true;
		  return Promise.resolve();
		},
		transform: (input, options) => ensureServiceIsRunning().transform(input, options),
		transformSync: (input, options) => {
		  if (worker_threads && !isInternalWorkerThread) {
			if (!workerThreadService)
			  workerThreadService = startWorkerThreadService(worker_threads);
			return workerThreadService.transformSync(input, options);
		  }
		  let result;
		  runServiceSync((service) => service.transform({
			callName: "transformSync",
			refs: null,
			input,
			options: options || {},
			isTTY: isTTY(),
			fs: fsSync,
			callback: (err, res) => {
			  if (err)
				throw err;
			  result = res;
			}
		  }));
		  return result;
		},
		version: "0.19.7",
	  },
	  externalEsbuildModule: function externalEsbuildModule({ path, namespace, importer, pluginData }) {
		if (namespace === 'file' && importer && path) {
			path = (0, path_1.resolve)(importer, path);
		}
		return {
			path,
			namespace,
			pluginData,
			external: true
		};
	  },
	  chalk: [object Function],
	  terminalLink: function terminalLink(text, url, { target = 'stdout', fallback } = {}) {
		if (!supports_hyperlinks_1.default[target]) {
			if (fallback === false)
				return text;
			return typeof fallback === 'function' ? fallback(text, url) : `${text} (\u200B${url}\u200B)`;
		}
		return ansi_escapes_1.default.link(text, url);
	  },
	  normalizePath: function normalizePath(path) {
		return path.replace(/\\/g, '/').replace(/\/{2,}/g, '/');
	  },
	  isNodeModule: (filename) => constants_1.NODE_MODULES_REG.test(filename),
	  isNpmPkg: function isNpmPkg(name) {
		if (/^(\.|\/)/.test(name)) {
			return false;
		}
		return true;
	  },
	  isQuickAppPkg: function isQuickAppPkg(name) {
		return /^@(system|service)\.[a-zA-Z]{1,}/.test(name);
	  },
	  isAliasPath: function isAliasPath(name, pathAlias = {}) {
		const prefixes = Object.keys(pathAlias);
		if (prefixes.length === 0) {
			return false;
		}
		return prefixes.includes(name) || new RegExp(`^(${prefixes.join('|')})/`).test(name);
	  },
	  replaceAliasPath: function replaceAliasPath(filePath, name, pathAlias = {}) {
		// 后续的 path.join 在遇到符号链接时将会解析为真实路径，如果
		// 这里的 filePath 没有做同样的处理，可能会导致 import 指向
		// 源代码文件，导致文件被意外修改
		filePath = fs.realpathSync(filePath);
		const prefixes = Object.keys(pathAlias);
		if (prefixes.includes(name)) {
			return promoteRelativePath(path.relative(filePath, fs.realpathSync(resolveScriptPath(pathAlias[name]))));
		}
		const reg = new RegExp(`^(${prefixes.join('|')})/(.*)`);
		name = name.replace(reg, function (_m, $1, $2) {
			return promoteRelativePath(path.relative(filePath, path.join(pathAlias[$1], $2)));
		});
		return name;
	  },
	  promoteRelativePath: function promoteRelativePath(fPath) {
		const fPathArr = fPath.split(path.sep);
		let dotCount = 0;
		fPathArr.forEach((item) => {
			if (item.indexOf('..') >= 0) {
				dotCount++;
			}
		});
		if (dotCount === 1) {
			fPathArr.splice(0, 1, '.');
			return fPathArr.join('/');
		}
		if (dotCount > 1) {
			fPathArr.splice(0, 1);
			return fPathArr.join('/');
		}
		return normalizePath(fPath);
	  },
	  resolveStylePath: function resolveStylePath(p) {
		const realPath = p;
		const removeExtPath = p.replace(path.extname(p), '');
		const taroEnv = process.env.TARO_ENV;
		for (let i = 0; i < constants_1.CSS_EXT.length; i++) {
			const item = constants_1.CSS_EXT[i];
			if (taroEnv) {
				if (fs.existsSync(`${removeExtPath}.${taroEnv}${item}`)) {
					return `${removeExtPath}.${taroEnv}${item}`;
				}
			}
			if (fs.existsSync(`${p}${item}`)) {
				return `${p}${item}`;
			}
		}
		return realPath;
	  },
	  printLog: function printLog(type, tag, filePath) {
		const typeShow = constants_1.processTypeMap[type];
		const tagLen = tag.replace(/[\u0391-\uFFE5]/g, 'aa').length;
		const tagFormatLen = 8;
		if (tagLen < tagFormatLen) {
			const rightPadding = new Array(tagFormatLen - tagLen + 1).join(' ');
			tag += rightPadding;
		}
		const padding = '';
		filePath = filePath || '';
		if (typeof typeShow.color === 'string') {
			console.log(terminal_1.chalk[typeShow.color](typeShow.name), padding, tag, padding, filePath);
		}
		else {
			console.log(typeShow.color(typeShow.name), padding, tag, padding, filePath);
		}
	  },
	  recursiveFindNodeModules: function recursiveFindNodeModules(filePath, lastFindPath) {
		const findWorkspaceRoot = require('find-yarn-workspace-root');
		if (lastFindPath && normalizePath(filePath) === normalizePath(lastFindPath)) {
			return filePath;
		}
		const dirname = path.dirname(filePath);
		const workspaceRoot = findWorkspaceRoot(dirname);
		const nodeModules = path.join(workspaceRoot || dirname, 'node_modules');
		if (fs.existsSync(nodeModules)) {
			return nodeModules;
		}
		if (dirname.split(path.sep).length <= 1) {
			printLog("error" /* processTypeEnum.ERROR */, `在${dirname}目录下`, '未找到node_modules文件夹，请先安装相关依赖库！');
			return nodeModules;
		}
		return recursiveFindNodeModules(dirname, filePath);
	  },
	  getUserHomeDir: function getUserHomeDir() {
		function homedir() {
			var _a;
			const env = process.env;
			const home = env.HOME;
			const user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;
			if (process.platform === 'win32') {
				return env.USERPROFILE || '' + env.HOMEDRIVE + env.HOMEPATH || home || '';
			}
			if (process.platform === 'darwin') {
				return home || (user ? '/Users/' + user : '');
			}
			if (process.platform === 'linux') {
				return home || (((_a = process.getuid) === null || _a === void 0 ? void 0 : _a.call(process)) === 0 ? '/root' : user ? '/home/' + user : '');
			}
			return home || '';
		}
		return typeof os.homedir === 'function' ? os.homedir() : homedir();
	  },
	  getTaroPath: function getTaroPath() {
		const taroPath = path.join(getUserHomeDir(), constants_1.TARO_CONFIG_FOLDER);
		if (!fs.existsSync(taroPath)) {
			fs.ensureDirSync(taroPath);
		}
		return taroPath;
	  },
	  getConfig: function getConfig() {
		const configPath = path.join(getTaroPath(), 'config.json');
		if (fs.existsSync(configPath)) {
			return require(configPath);
		}
		return {};
	  },
	  getHash: function getHash(text) {
		return (0, crypto_1.createHash)('sha256').update(text).digest('hex').substring(0, 8);
	  },
	  getSystemUsername: function getSystemUsername() {
		const userHome = getUserHomeDir();
		const systemUsername = process.env.USER || path.basename(userHome);
		return systemUsername;
	  },
	  shouldUseYarn: function shouldUseYarn() {
		try {
			execSync('yarn --version', { stdio: 'ignore' });
			return true;
		}
		catch (e) {
			return false;
		}
	  },
	  shouldUseCnpm: function shouldUseCnpm() {
		try {
			execSync('cnpm --version', { stdio: 'ignore' });
			return true;
		}
		catch (e) {
			return false;
		}
	  },
	  isEmptyObject: function isEmptyObject(obj) {
		if (obj == null) {
			return true;
		}
		for (const key in obj) {
			if (obj.hasOwnProperty(key)) {
				return false;
			}
		}
		return true;
	  },
	  resolveSync: function resolveSync(id, opts = {}) {
		try {
			const resolve = require('resolve').sync;
			return resolve(id, Object.assign(Object.assign({}, opts), { packageFilter(pkg, pkgfile, dir) {
					var _a;
					if (opts.packageFilter) {
						pkg = opts.packageFilter(pkg, pkgfile, dir);
					}
					else if ((_a = opts.mainFields) === null || _a === void 0 ? void 0 : _a.length) {
						pkg.main = pkg[opts.mainFields.find((field) => pkg[field] && typeof pkg[field] === 'string') || 'main'];
					}
					return pkg;
				} }));
		}
		catch (error) {
			return null;
		}
	  },
	  resolveMainFilePath: function resolveMainFilePath(p, extArrs = constants_1.SCRIPT_EXT) {
		if (p.startsWith('pages/') || p === 'app.config') {
			return p;
		}
		const realPath = p;
		const taroEnv = process.env.TARO_ENV;
		for (let i = 0; i < extArrs.length; i++) {
			const item = extArrs[i];
			if (taroEnv) {
				if (fs.existsSync(`${p}.${taroEnv}${item}`)) {
					return `${p}.${taroEnv}${item}`;
				}
				if (fs.existsSync(`${p}${path.sep}index.${taroEnv}${item}`)) {
					return `${p}${path.sep}index.${taroEnv}${item}`;
				}
				if (fs.existsSync(`${p.replace(/\/index$/, `.${taroEnv}/index`)}${item}`)) {
					return `${p.replace(/\/index$/, `.${taroEnv}/index`)}${item}`;
				}
			}
			if (fs.existsSync(`${p}${item}`)) {
				return `${p}${item}`;
			}
			if (fs.existsSync(`${p}${path.sep}index${item}`)) {
				return `${p}${path.sep}index${item}`;
			}
		}
		// 存在多端页面但是对应的多端页面配置不存在时，使用该页面默认配置
		if (taroEnv && path.parse(p).base.endsWith(`.${taroEnv}.config`)) {
			const idx = p.lastIndexOf(`.${taroEnv}.config`);
			return resolveMainFilePath(p.slice(0, idx) + '.config');
		}
		return realPath;
	  },
	  resolveScriptPath: function resolveScriptPath(p) {
		return resolveMainFilePath(p);
	  },
	  generateEnvList: function generateEnvList(env) {
		const res = {};
		if (env && !isEmptyObject(env)) {
			for (const key in env) {
				try {
					res[`process.env.${key}`] = JSON.parse(env[key]);
				}
				catch (err) {
					res[`process.env.${key}`] = env[key];
				}
			}
		}
		return res;
	  },
	  getNpmPackageAbsolutePath: function getNpmPackageAbsolutePath(npmPath, defaultFile = 'index') {
		try {
			let packageName = '';
			let componentRelativePath = '';
			const packageParts = npmPath.split(path.sep);
			// 获取 npm 包名和指定的包文件路径
			// taro-loader/path/index => packageName = taro-loader, componentRelativePath = path/index
			// @tarojs/runtime/path/index => packageName = @tarojs/runtime, componentRelativePath = path/index
			if (npmPath.startsWith('@')) {
				packageName = packageParts.slice(0, 2).join(path.sep);
				componentRelativePath = packageParts.slice(2).join(path.sep);
			}
			else {
				packageName = packageParts[0];
				componentRelativePath = packageParts.slice(1).join(path.sep);
			}
			// 没有指定的包文件路径统一使用 defaultFile
			componentRelativePath || (componentRelativePath = defaultFile);
			// require.resolve 解析的路径会包含入口文件路径，通过正则过滤一下
			const match = require.resolve(packageName).match(new RegExp('.*' + packageName));
			if (!(match === null || match === void 0 ? void 0 : match.length))
				return null;
			const packagePath = match[0];
			return path.join(packagePath, `./${componentRelativePath}`);
		}
		catch (error) {
			return null;
		}
	  },
	  generateConstantsList: function generateConstantsList(constants) {
		const res = {};
		if (constants && !isEmptyObject(constants)) {
			for (const key in constants) {
				if ((0, lodash_1.isPlainObject)(constants[key])) {
					res[key] = generateConstantsList(constants[key]);
				}
				else {
					try {
						res[key] = JSON.parse(constants[key]);
					}
					catch (err) {
						res[key] = constants[key];
					}
				}
			}
		}
		return res;
	  },
	  cssImports: function cssImports(content) {
		let match;
		const results = [];
		content = String(content).replace(/\/\*.+?\*\/|\/\/.*(?=[\n\r])/g, '');
		while ((match = constants_1.CSS_IMPORT_REG.exec(content))) {
			results.push(match[2]);
		}
		return results;
	  },
	  emptyDirectory: function emptyDirectory(dirPath, opts = { excludes: [] }) {
		if (fs.existsSync(dirPath)) {
			fs.readdirSync(dirPath).forEach((file) => {
				const curPath = path.join(dirPath, file);
				if (fs.lstatSync(curPath).isDirectory()) {
					let removed = false;
					let i = 0; // retry counter
					do {
						try {
							const excludes = Array.isArray(opts.excludes) ? opts.excludes : [opts.excludes];
							const canRemove = !excludes.length ||
								!excludes.some((item) => typeof item === 'string' ? curPath.indexOf(item) >= 0 : item.test(curPath));
							if (canRemove) {
								emptyDirectory(curPath);
								fs.rmdirSync(curPath);
							}
							removed = true;
						}
						catch (e) {
						}
						finally {
							if (++i < retries) {
								continue;
							}
						}
					} while (!removed);
				}
				else {
					fs.unlinkSync(curPath);
				}
			});
		}
	  },
	  pascalCase: (str) => str.charAt(0).toUpperCase() + (0, lodash_1.camelCase)(str.substr(1)),
	  getInstalledNpmPkgPath: function getInstalledNpmPkgPath(pkgName, basedir) {
		try {
			const resolve = require('resolve').sync;
			return resolve(`${pkgName}/package.json`, { basedir });
		}
		catch (err) {
			return null;
		}
	  },
	  getInstalledNpmPkgVersion: function getInstalledNpmPkgVersion(pkgName, basedir) {
		const pkgPath = getInstalledNpmPkgPath(pkgName, basedir);
		if (!pkgPath) {
			return null;
		}
		return fs.readJSONSync(pkgPath).version;
	  },
	  recursiveMerge: (src, ...args) => {
		return (0, lodash_1.mergeWith)(src, ...args, (value, srcValue) => {
			const typeValue = typeof value;
			const typeSrcValue = typeof srcValue;
			if (typeValue !== typeSrcValue)
				return;
			if (Array.isArray(value) && Array.isArray(srcValue)) {
				return value.concat(srcValue);
			}
			if (typeValue === 'object') {
				return (0, exports.recursiveMerge)(value, srcValue);
			}
		});
	  },
	  mergeVisitors: (src, ...args) => {
		const validFuncs = ['exit', 'enter'];
		return (0, lodash_1.mergeWith)(src, ...args, (value, srcValue, key, object, srcObject) => {
			if (!object.hasOwnProperty(key) || !srcObject.hasOwnProperty(key)) {
				return undefined;
			}
			const shouldMergeToArray = validFuncs.indexOf(key) > -1;
			if (shouldMergeToArray) {
				return (0, lodash_1.flatMap)([value, srcValue]);
			}
			const [newValue, newSrcValue] = [value, srcValue].map((v) => {
				if (typeof v === 'function') {
					return {
						enter: v,
					};
				}
				else {
					return v;
				}
			});
			return (0, exports.mergeVisitors)(newValue, newSrcValue);
		});
	  },
	  applyArrayedVisitors: (obj) => {
		let key;
		for (key in obj) {
			const funcs = obj[key];
			if (Array.isArray(funcs)) {
				obj[key] = (astPath, ...args) => {
					funcs.forEach((func) => {
						func(astPath, ...args);
					});
				};
			}
			else if (typeof funcs === 'object') {
				(0, exports.applyArrayedVisitors)(funcs);
			}
		}
		return obj;
	  },
	  unzip: function unzip(zipPath) {
		const Transform = require('stream').Transform;
		const yauzl = require('yauzl');
		return new Promise((resolve, reject) => {
			yauzl.open(zipPath, { lazyEntries: true }, (err, zipfile) => {
				if (err || !zipfile)
					throw err;
				zipfile.on('close', () => {
					fs.removeSync(zipPath);
					resolve();
				});
				zipfile.readEntry();
				zipfile.on('error', (err) => {
					reject(err);
				});
				zipfile.on('entry', (entry) => {
					if (/\/$/.test(entry.fileName)) {
						const fileNameArr = entry.fileName.replace(/\\/g, '/').split('/');
						fileNameArr.shift();
						const fileName = fileNameArr.join('/');
						fs.ensureDirSync(path.join(path.dirname(zipPath), fileName));
						zipfile.readEntry();
					}
					else {
						zipfile.openReadStream(entry, (err, readStream) => {
							if (err || !readStream)
								throw err;
							const filter = new Transform();
							filter._transform = function (chunk, _encoding, cb) {
								cb(undefined, chunk);
							};
							filter._flush = function (cb) {
								cb();
								zipfile.readEntry();
							};
							const fileNameArr = normalizePath(entry.fileName).split('/');
							fileNameArr.shift();
							const fileName = fileNameArr.join('/');
							const writeStream = fs.createWriteStream(path.join(path.dirname(zipPath), fileName));
							writeStream.on('close', () => { });
							readStream.pipe(filter).pipe(writeStream);
						});
					}
				});
			});
		});
	  },
	  getAllFilesInFolder: (folder, filter = []) => __awaiter(void 0, void 0, void 0, function* () {
		let files = [];
		const list = readDirWithFileTypes(folder);
		yield Promise.all(list.map((item) => __awaiter(void 0, void 0, void 0, function* () {
			const itemPath = path.join(folder, item.name);
			if (item.isDirectory) {
				const _files = yield (0, exports.getAllFilesInFolder)(itemPath, filter);
				files = [...files, ..._files];
			}
			else if (item.isFile) {
				if (!filter.find((rule) => rule === item.name))
					files.push(itemPath);
			}
		})));
		return files;
	  }),
	  readDirWithFileTypes: function readDirWithFileTypes(folder) {
		const list = fs.readdirSync(folder);
		const res = list.map((name) => {
			const stat = fs.statSync(path.join(folder, name));
			return {
				name,
				isDirectory: stat.isDirectory(),
				isFile: stat.isFile(),
			};
		});
		return res;
	  },
	  extnameExpRegOf: function extnameExpRegOf(filePath) {
		return new RegExp(`${path.extname(filePath)}$`);
	  },
	  addPlatforms: function addPlatforms(platform) {
		const upperPlatform = platform.toLocaleUpperCase();
		if (constants_1.PLATFORMS[upperPlatform])
			return;
		constants_1.PLATFORMS[upperPlatform] = platform;
	  },
	  getModuleDefaultExport: (exports) => (exports.__esModule ? exports.default : exports),
	  removeHeadSlash: function removeHeadSlash(str) {
		return str.replace(/^(\/|\\)/, '');
	  },
	  readPageConfig: function readPageConfig(configPath) {
		let result = {};
		const extNames = ['.js', '.jsx', '.ts', '.tsx', '.vue'];
		// check source file extension
		extNames.some((ext) => {
			const tempPath = configPath.replace('.config', ext);
			if (fs.existsSync(tempPath)) {
				try {
					result = readSFCPageConfig(tempPath);
				}
				catch (error) {
					result = {};
				}
				return true;
			}
		});
		return result;
	  },
	  readConfig: function readConfig(configPath, options = {}) {
		let result = {};
		if (fs.existsSync(configPath)) {
			if (constants_1.REG_JSON.test(configPath)) {
				result = fs.readJSONSync(configPath);
			}
			else {
				result = (0, esbuild_1.requireWithEsbuild)(configPath, {
					customConfig: {
						define: options.defineConstants || {},
						alias: options.alias || {},
					},
					customSwcConfig: {
						jsc: {
							parser: {
								syntax: 'typescript',
								decorators: true,
							},
							transform: {
								legacyDecorator: true,
							},
							experimental: {
								plugins: [
									[path.resolve(__dirname, '../swc/swc_plugin_define_config.wasm'), {}]
								]
							}
						},
						module: {
							type: 'commonjs',
						},
					},
				});
			}
			result = (0, exports.getModuleDefaultExport)(result);
		}
		else {
			result = readPageConfig(configPath);
		}
		return result;
	  },
	  removePathPrefix: function removePathPrefix(filePath = '') {
		const normalizedPath = path.normalize(filePath);
		const parsedPath = path.parse(normalizedPath);
		const { root, dir, base } = parsedPath;
		let result = path.join(dir, base);
		if (result.startsWith(root)) {
			result = result.slice(root.length);
		}
		return result;
	  },
	  fs: {
		appendFile: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		appendFileSync: function appendFileSync(path, data, options) {
		  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });

		  // Don't make changes directly on options object
		  options = copyObject(options);

		  // Force append behavior when using a supplied file descriptor
		  if (!options.flag || isFd(path))
			options.flag = 'a';

		  fs.writeFileSync(path, data, options);
		},
		access: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		accessSync: function accessSync(path, mode) {
		  path = getValidatedPath(path);
		  mode = getValidMode(mode, 'access');

		  const ctx = { path };
		  binding.access(pathModule.toNamespacedPath(path), mode, undefined, ctx);
		  handleErrorFromBinding(ctx);
		},
		chown: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		chownSync: function (target, uid, gid) {
		  try {
			return orig.call(fs, target, uid, gid)
		  } catch (er) {
			if (!chownErOk(er)) throw er
		  }
		},
		chmod: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		chmodSync: function (target, mode) {
		  try {
			return orig.call(fs, target, mode)
		  } catch (er) {
			if (!chownErOk(er)) throw er
		  }
		},
		close: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		closeSync: function closeSync (fd) {
		  // This function uses the graceful-fs shared queue
		  fs$closeSync.apply(fs, arguments)
		  resetQueue()
		},
		copyFile: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		copyFileSync: function copyFileSync(src, dest, mode) {
		  src = getValidatedPath(src, 'src');
		  dest = getValidatedPath(dest, 'dest');

		  const ctx = { path: src, dest };  // non-prefixed

		  src = pathModule._makeLong(src);
		  dest = pathModule._makeLong(dest);
		  mode = getValidMode(mode, 'copyFile');
		  binding.copyFile(src, dest, mode, undefined, ctx);
		  handleErrorFromBinding(ctx);
		},
		cp: function cp(src, dest, options, callback) {
		  if (typeof options === 'function') {
			callback = options;
			options = undefined;
		  }
		  callback = makeCallback(callback);
		  options = validateCpOptions(options);
		  src = pathModule.toNamespacedPath(getValidatedPath(src, 'src'));
		  dest = pathModule.toNamespacedPath(getValidatedPath(dest, 'dest'));
		  lazyLoadCp();
		  cpFn(src, dest, options, callback);
		},
		cpSync: function cpSync(src, dest, options) {
		  options = validateCpOptions(options);
		  src = pathModule.toNamespacedPath(getValidatedPath(src, 'src'));
		  dest = pathModule.toNamespacedPath(getValidatedPath(dest, 'dest'));
		  lazyLoadCp();
		  cpSyncFn(src, dest, options);
		},
		createReadStream: function createReadStream (path, options) {
		  return new fs.ReadStream(path, options)
		},
		createWriteStream: function createWriteStream (path, options) {
		  return new fs.WriteStream(path, options)
		},
		exists: function (filename, callback) {
		  if (typeof callback === 'function') {
			return fs.exists(filename, callback)
		  }
		  return new Promise(resolve => {
			return fs.exists(filename, resolve)
		  })
		},
		existsSync: function existsSync(path) {
		  try {
			path = getValidatedPath(path);
		  } catch {
			return false;
		  }
		  const ctx = { path };
		  const nPath = pathModule.toNamespacedPath(path);
		  binding.access(nPath, F_OK, undefined, ctx);

		  // In case of an invalid symlink, `binding.access()` on win32
		  // will **not** return an error and is therefore not enough.
		  // Double check with `binding.stat()`.
		  if (isWindows && ctx.errno === undefined) {
			binding.stat(nPath, false, undefined, ctx);
		  }

		  return ctx.errno === undefined;
		},
		fchown: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		fchownSync: function (target, uid, gid) {
		  try {
			return orig.call(fs, target, uid, gid)
		  } catch (er) {
			if (!chownErOk(er)) throw er
		  }
		},
		fchmod: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		fchmodSync: function (target, mode) {
		  try {
			return orig.call(fs, target, mode)
		  } catch (er) {
			if (!chownErOk(er)) throw er
		  }
		},
		fdatasync: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		fdatasyncSync: function fdatasyncSync(fd) {
		  fd = getValidatedFd(fd);
		  const ctx = {};
		  binding.fdatasync(fd, undefined, ctx);
		  handleErrorFromBinding(ctx);
		},
		fstat: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		fstatSync: function (target, options) {
		  var stats = options ? orig.call(fs, target, options)
			: orig.call(fs, target)
		  if (stats) {
			if (stats.uid < 0) stats.uid += 0x100000000
			if (stats.gid < 0) stats.gid += 0x100000000
		  }
		  return stats;
		},
		fsync: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		fsyncSync: function fsyncSync(fd) {
		  fd = getValidatedFd(fd);
		  const ctx = {};
		  binding.fsync(fd, undefined, ctx);
		  handleErrorFromBinding(ctx);
		},
		ftruncate: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		ftruncateSync: function ftruncateSync(fd, len = 0) {
		  fd = getValidatedFd(fd);
		  validateInteger(len, 'len');
		  len = MathMax(0, len);
		  const ctx = {};
		  binding.ftruncate(fd, len, undefined, ctx);
		  handleErrorFromBinding(ctx);
		},
		futimes: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		futimesSync: function futimesSync(fd, atime, mtime) {
		  fd = getValidatedFd(fd);
		  atime = toUnixTimestamp(atime, 'atime');
		  mtime = toUnixTimestamp(mtime, 'mtime');
		  const ctx = {};
		  binding.futimes(fd, atime, mtime, undefined, ctx);
		  handleErrorFromBinding(ctx);
		},
		lchown: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		lchownSync: function (target, uid, gid) {
		  try {
			return orig.call(fs, target, uid, gid)
		  } catch (er) {
			if (!chownErOk(er)) throw er
		  }
		},
		lchmod: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		lchmodSync: function (target, mode) {
		  try {
			return orig.call(fs, target, mode)
		  } catch (er) {
			if (!chownErOk(er)) throw er
		  }
		},
		link: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		linkSync: function linkSync(existingPath, newPath) {
		  existingPath = getValidatedPath(existingPath, 'existingPath');
		  newPath = getValidatedPath(newPath, 'newPath');

		  const ctx = { path: existingPath, dest: newPath };
		  const result = binding.link(pathModule.toNamespacedPath(existingPath),
									  pathModule.toNamespacedPath(newPath),
									  undefined, ctx);
		  handleErrorFromBinding(ctx);
		  return result;
		},
		lstat: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		lstatSync: function (target, options) {
		  var stats = options ? orig.call(fs, target, options)
			: orig.call(fs, target)
		  if (stats) {
			if (stats.uid < 0) stats.uid += 0x100000000
			if (stats.gid < 0) stats.gid += 0x100000000
		  }
		  return stats;
		},
		lutimes: function lutimes(path, atime, mtime, callback) {
		  callback = makeCallback(callback);
		  path = getValidatedPath(path);

		  const req = new FSReqCallback();
		  req.oncomplete = callback;
		  binding.lutimes(pathModule.toNamespacedPath(path),
						  toUnixTimestamp(atime),
						  toUnixTimestamp(mtime),
						  req);
		},
		lutimesSync: function lutimesSync(path, atime, mtime) {
		  path = getValidatedPath(path);
		  const ctx = { path };
		  binding.lutimes(pathModule.toNamespacedPath(path),
						  toUnixTimestamp(atime),
						  toUnixTimestamp(mtime),
						  undefined, ctx);
		  handleErrorFromBinding(ctx);
		},
		mkdir: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		mkdirSync: function mkdirSync(path, options) {
		  let mode = 0o777;
		  let recursive = false;
		  if (typeof options === 'number' || typeof options === 'string') {
			mode = options;
		  } else if (options) {
			if (options.recursive !== undefined)
			  recursive = options.recursive;
			if (options.mode !== undefined)
			  mode = options.mode;
		  }
		  path = getValidatedPath(path);
		  validateBoolean(recursive, 'options.recursive');

		  const ctx = { path };
		  const result = binding.mkdir(pathModule.toNamespacedPath(path),
									   parseFileMode(mode, 'mode'), recursive,
									   undefined, ctx);
		  handleErrorFromBinding(ctx);
		  if (recursive) {
			return result;
		  }
		},
		mkdtemp: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		mkdtempSync: function mkdtempSync(prefix, options) {
		  options = getOptions(options);

		  prefix = getValidatedPath(prefix, 'prefix');
		  warnOnNonPortableTemplate(prefix);

		  let path;
		  if (typeof prefix === 'string') {
			path = `${prefix}XXXXXX`;
		  } else {
			path = Buffer.concat([prefix, Buffer.from('XXXXXX')]);
		  }

		  const ctx = { path };
		  const result = binding.mkdtemp(path, options.encoding,
										 undefined, ctx);
		  handleErrorFromBinding(ctx);
		  return result;
		},
		open: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		openSync: function openSync(path, flags, mode) {
		  path = getValidatedPath(path);
		  const flagsNumber = stringToFlags(flags);
		  mode = parseFileMode(mode, 'mode', 0o666);

		  const ctx = { path };
		  const result = binding.open(pathModule.toNamespacedPath(path),
									  flagsNumber, mode,
									  undefined, ctx);
		  handleErrorFromBinding(ctx);
		  return result;
		},
		readdir: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		readdirSync: function readdirSync(path, options) {
		  options = getOptions(options);
		  path = getValidatedPath(path);
		  if (options.recursive != null) {
			validateBoolean(options.recursive, 'options.recursive');
		  }

		  if (options.recursive) {
			return readdirSyncRecursive(path, options);
		  }

		  const ctx = { path };
		  const result = binding.readdir(pathModule.toNamespacedPath(path),
										 options.encoding, !!options.withFileTypes,
										 undefined, ctx);
		  handleErrorFromBinding(ctx);
		  return options.withFileTypes ? getDirents(path, result) : result;
		},
		read: function (fd, buffer, offset, length, position, callback) {
		  if (typeof callback === 'function') {
			return fs.read(fd, buffer, offset, length, position, callback)
		  }
		  return new Promise((resolve, reject) => {
			fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
			  if (err) return reject(err)
			  resolve({ bytesRead, buffer })
			})
		  })
		},
		readSync: function (fd, buffer, offset, length, position) {
		  var eagCounter = 0
		  while (true) {
			try {
			  return fs$readSync.call(fs, fd, buffer, offset, length, position)
			} catch (er) {
			  if (er.code === 'EAGAIN' && eagCounter < 10) {
				eagCounter ++
				continue
			  }
			  throw er
			}
		  }
		},
		readv: function readv(fd, buffers, position, callback) {
		  function wrapper(err, read) {
			callback(err, read || 0, buffers);
		  }

		  fd = getValidatedFd(fd);
		  validateBufferArray(buffers);
		  callback = maybeCallback(callback || position);

		  const req = new FSReqCallback();
		  req.oncomplete = wrapper;

		  if (typeof position !== 'number')
			position = null;

		  return binding.readBuffers(fd, buffers, position, req);
		},
		readvSync: function readvSync(fd, buffers, position) {
		  fd = getValidatedFd(fd);
		  validateBufferArray(buffers);

		  const ctx = {};

		  if (typeof position !== 'number')
			position = null;

		  const result = binding.readBuffers(fd, buffers, position, undefined, ctx);
		  handleErrorFromBinding(ctx);
		  return result;
		},
		readFile: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		readFileSync: function readFileSync(path, options) {
		  options = getOptions(options, { flag: 'r' });
		  const isUserFd = isFd(path); // File descriptor ownership
		  const fd = isUserFd ? path : fs.openSync(path, options.flag, 0o666);

		  const stats = tryStatSync(fd, isUserFd);
		  const size = isFileType(stats, S_IFREG) ? stats[8] : 0;
		  let pos = 0;
		  let buffer; // Single buffer with file data
		  let buffers; // List for when size is unknown

		  if (size === 0) {
			buffers = [];
		  } else {
			buffer = tryCreateBuffer(size, fd, isUserFd);
		  }

		  let bytesRead;

		  if (size !== 0) {
			do {
			  bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);
			  pos += bytesRead;
			} while (bytesRead !== 0 && pos < size);
		  } else {
			do {
			  // The kernel lies about many files.
			  // Go ahead and try to read some bytes.
			  buffer = Buffer.allocUnsafe(8192);
			  bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);
			  if (bytesRead !== 0) {
				ArrayPrototypePush(buffers, buffer.slice(0, bytesRead));
			  }
			  pos += bytesRead;
			} while (bytesRead !== 0);
		  }

		  if (!isUserFd)
			fs.closeSync(fd);

		  if (size === 0) {
			// Data was collected into the buffers list.
			buffer = Buffer.concat(buffers, pos);
		  } else if (pos < size) {
			buffer = buffer.slice(0, pos);
		  }

		  if (options.encoding) buffer = buffer.toString(options.encoding);
		  return buffer;
		},
		readlink: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		readlinkSync: function readlinkSync(path, options) {
		  options = getOptions(options);
		  path = getValidatedPath(path, 'oldPath');
		  const ctx = { path };
		  const result = binding.readlink(pathModule.toNamespacedPath(path),
										  options.encoding, undefined, ctx);
		  handleErrorFromBinding(ctx);
		  return result;
		},
		realpath: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		realpathSync: function realpathSync(p, options) {
		  options = getOptions(options);
		  p = toPathIfFileURL(p);
		  if (typeof p !== 'string') {
			p += '';
		  }
		  validatePath(p);
		  p = pathModule.resolve(p);

		  const cache = options[realpathCacheKey];
		  const maybeCachedResult = cache?.get(p);
		  if (maybeCachedResult) {
			return maybeCachedResult;
		  }

		  const seenLinks = new SafeMap();
		  const knownHard = new SafeSet();
		  const original = p;

		  // Current character position in p
		  let pos;
		  // The partial path so far, including a trailing slash if any
		  let current;
		  // The partial path without a trailing slash (except when pointing at a root)
		  let base;
		  // The partial path scanned in the previous round, with slash
		  let previous;

		  // Skip over roots
		  current = base = splitRoot(p);
		  pos = current.length;

		  // On windows, check that the root exists. On unix there is no need.
		  if (isWindows) {
			const ctx = { path: base };
			binding.lstat(pathModule.toNamespacedPath(base), false, undefined, ctx);
			handleErrorFromBinding(ctx);
			knownHard.add(base);
		  }

		  // Walk down the path, swapping out linked path parts for their real
		  // values
		  // NB: p.length changes.
		  while (pos < p.length) {
			// find the next part
			const result = nextPart(p, pos);
			previous = current;
			if (result === -1) {
			  const last = StringPrototypeSlice(p, pos);
			  current += last;
			  base = previous + last;
			  pos = p.length;
			} else {
			  current += StringPrototypeSlice(p, pos, result + 1);
			  base = previous + StringPrototypeSlice(p, pos, result);
			  pos = result + 1;
			}

			// Continue if not a symlink, break if a pipe/socket
			if (knownHard.has(base) || cache?.get(base) === base) {
			  if (isFileType(binding.statValues, S_IFIFO) ||
				  isFileType(binding.statValues, S_IFSOCK)) {
				break;
			  }
			  continue;
			}

			let resolvedLink;
			const maybeCachedResolved = cache?.get(base);
			if (maybeCachedResolved) {
			  resolvedLink = maybeCachedResolved;
			} else {
			  // Use stats array directly to avoid creating an fs.Stats instance just
			  // for our internal use.

			  const baseLong = pathModule.toNamespacedPath(base);
			  const ctx = { path: base };
			  const stats = binding.lstat(baseLong, true, undefined, ctx);
			  handleErrorFromBinding(ctx);

			  if (!isFileType(stats, S_IFLNK)) {
				knownHard.add(base);
				cache?.set(base, base);
				continue;
			  }

			  // Read the link if it wasn't read before
			  // dev/ino always return 0 on windows, so skip the check.
			  let linkTarget = null;
			  let id;
			  if (!isWindows) {
				const dev = BigIntPrototypeToString(stats[0], 32);
				const ino = BigIntPrototypeToString(stats[7], 32);
				id = `${dev}:${ino}`;
				if (seenLinks.has(id)) {
				  linkTarget = seenLinks.get(id);
				}
			  }
			  if (linkTarget === null) {
				const ctx = { path: base };
				binding.stat(baseLong, false, undefined, ctx);
				handleErrorFromBinding(ctx);
				linkTarget = binding.readlink(baseLong, undefined, undefined, ctx);
				handleErrorFromBinding(ctx);
			  }
			  resolvedLink = pathModule.resolve(previous, linkTarget);

			  cache?.set(base, resolvedLink);
			  if (!isWindows) seenLinks.set(id, linkTarget);
			}

			// Resolve the link, then start over
			p = pathModule.resolve(resolvedLink, StringPrototypeSlice(p, pos));

			// Skip over roots
			current = base = splitRoot(p);
			pos = current.length;

			// On windows, check that the root exists. On unix there is no need.
			if (isWindows && !knownHard.has(base)) {
			  const ctx = { path: base };
			  binding.lstat(pathModule.toNamespacedPath(base), false, undefined, ctx);
			  handleErrorFromBinding(ctx);
			  knownHard.add(base);
			}
		  }

		  cache?.set(original, p);
		  return encodeRealpathResult(p, options);
		},
		rename: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		renameSync: function renameSync(oldPath, newPath) {
		  oldPath = getValidatedPath(oldPath, 'oldPath');
		  newPath = getValidatedPath(newPath, 'newPath');
		  const ctx = { path: oldPath, dest: newPath };
		  binding.rename(pathModule.toNamespacedPath(oldPath),
						 pathModule.toNamespacedPath(newPath), undefined, ctx);
		  handleErrorFromBinding(ctx);
		},
		rm: function rm(path, options, callback) {
		  if (typeof options === 'function') {
			callback = options;
			options = undefined;
		  }
		  path = getValidatedPath(path);

		  validateRmOptions(path, options, false, (err, options) => {
			if (err) {
			  return callback(err);
			}
			lazyLoadRimraf();
			return rimraf(pathModule.toNamespacedPath(path), options, callback);
		  });
		},
		rmSync: function rmSync(path, options) {
		  path = getValidatedPath(path);
		  options = validateRmOptionsSync(path, options, false);

		  lazyLoadRimraf();
		  return rimrafSync(pathModule.toNamespacedPath(path), options);
		},
		rmdir: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		rmdirSync: function rmdirSync(path, options) {
		  path = getValidatedPath(path);

		  if (options?.recursive) {
			emitRecursiveRmdirWarning();
			options = validateRmOptionsSync(path, { ...options, force: false }, true);
			if (options !== false) {
			  lazyLoadRimraf();
			  return rimrafSync(pathModule.toNamespacedPath(path), options);
			}
		  } else {
			validateRmdirOptions(options);
		  }

		  const ctx = { path };
		  binding.rmdir(pathModule.toNamespacedPath(path), undefined, ctx);
		  return handleErrorFromBinding(ctx);
		},
		stat: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		statfs: function statfs(path, options = { bigint: false }, callback) {
		  if (typeof options === 'function') {
			callback = options;
			options = kEmptyObject;
		  }
		  callback = maybeCallback(callback);
		  path = getValidatedPath(path);
		  const req = new FSReqCallback(options.bigint);
		  req.oncomplete = (err, stats) => {
			if (err) {
			  return callback(err);
			}

			callback(err, getStatFsFromBinding(stats));
		  };
		  binding.statfs(pathModule.toNamespacedPath(path), options.bigint, req);
		},
		statSync: function (target, options) {
		  var stats = options ? orig.call(fs, target, options)
			: orig.call(fs, target)
		  if (stats) {
			if (stats.uid < 0) stats.uid += 0x100000000
			if (stats.gid < 0) stats.gid += 0x100000000
		  }
		  return stats;
		},
		statfsSync: function statfsSync(path, options = { bigint: false }) {
		  path = getValidatedPath(path);
		  const ctx = { path };
		  const stats = binding.statfs(pathModule.toNamespacedPath(path),
									   options.bigint, undefined, ctx);
		  handleErrorFromBinding(ctx);
		  return getStatFsFromBinding(stats);
		},
		symlink: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		symlinkSync: function symlinkSync(target, path, type) {
		  type = (typeof type === 'string' ? type : null);
		  if (isWindows && type === null) {
			const absoluteTarget = pathModule.resolve(`${path}`, '..', `${target}`);
			if (statSync(absoluteTarget, { throwIfNoEntry: false })?.isDirectory()) {
			  type = 'dir';
			}
		  }
		  target = getValidatedPath(target, 'target');
		  path = getValidatedPath(path);
		  const flags = stringToSymlinkType(type);

		  const ctx = { path: target, dest: path };
		  binding.symlink(preprocessSymlinkDestination(target, type, path),
						  pathModule.toNamespacedPath(path), flags, undefined, ctx);

		  handleErrorFromBinding(ctx);
		},
		truncate: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		truncateSync: function truncateSync(path, len) {
		  if (typeof path === 'number') {
			// legacy
			showTruncateDeprecation();
			return fs.ftruncateSync(path, len);
		  }
		  if (len === undefined) {
			len = 0;
		  }
		  // Allow error to be thrown, but still close fd.
		  const fd = fs.openSync(path, 'r+');
		  let ret;

		  try {
			ret = fs.ftruncateSync(fd, len);
		  } finally {
			fs.closeSync(fd);
		  }
		  return ret;
		},
		unwatchFile: function unwatchFile(filename, listener) {
		  filename = getValidatedPath(filename);
		  filename = pathModule.resolve(filename);
		  const stat = statWatchers.get(filename);

		  if (stat === undefined) return;
		  const watchers = require('internal/fs/watchers');
		  if (typeof listener === 'function') {
			const beforeListenerCount = stat.listenerCount('change');
			stat.removeListener('change', listener);
			if (stat.listenerCount('change') < beforeListenerCount)
			  stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');
		  } else {
			stat.removeAllListeners('change');
			stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');
		  }

		  if (stat.listenerCount('change') === 0) {
			stat.stop();
			statWatchers.delete(filename);
		  }
		},
		unlink: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		unlinkSync: function unlinkSync(path) {
		  path = getValidatedPath(path);
		  const ctx = { path };
		  binding.unlink(pathModule.toNamespacedPath(path), undefined, ctx);
		  handleErrorFromBinding(ctx);
		},
		utimes: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		utimesSync: function utimesSync(path, atime, mtime) {
		  path = getValidatedPath(path);
		  const ctx = { path };
		  binding.utimes(pathModule.toNamespacedPath(path),
						 toUnixTimestamp(atime), toUnixTimestamp(mtime),
						 undefined, ctx);
		  handleErrorFromBinding(ctx);
		},
		watch: function watch(filename, options, listener) {
		  if (typeof options === 'function') {
			listener = options;
		  }
		  options = getOptions(options);

		  // Don't make changes directly on options object
		  options = copyObject(options);

		  if (options.persistent === undefined) options.persistent = true;
		  if (options.recursive === undefined) options.recursive = false;
		  if (options.recursive && !(isOSX || isWindows))
			throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');

		  const watchers = require('internal/fs/watchers');
		  const watcher = new watchers.FSWatcher();
		  watcher[watchers.kFSWatchStart](filename,
										  options.persistent,
										  options.recursive,
										  options.encoding);
		  if (listener) {
			watcher.addListener('change', listener);
		  }
		  if (options.signal) {
			if (options.signal.aborted) {
			  process.nextTick(() => watcher.close());
			} else {
			  const listener = () => watcher.close();
			  kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;
			  options.signal.addEventListener('abort', listener, { __proto__: null, [kResistStopPropagation]: true });
			  watcher.once('close', () => {
				options.signal.removeEventListener('abort', listener);
			  });
			}
		  }

		  return watcher;
		},
		watchFile: function watchFile(filename, options, listener) {
		  filename = getValidatedPath(filename);
		  filename = pathModule.resolve(filename);
		  let stat;

		  if (options === null || typeof options !== 'object') {
			listener = options;
			options = null;
		  }

		  options = {
			// Poll interval in milliseconds. 5007 is what libev used to use. It's
			// a little on the slow side but let's stick with it for now to keep
			// behavioral changes to a minimum.
			interval: 5007,
			persistent: true,
			...options,
		  };

		  validateFunction(listener, 'listener');

		  stat = statWatchers.get(filename);
		  const watchers = require('internal/fs/watchers');
		  if (stat === undefined) {
			stat = new watchers.StatWatcher(options.bigint);
			stat[watchers.kFSStatWatcherStart](filename,
											   options.persistent, options.interval);
			statWatchers.set(filename, stat);
		  } else {
			stat[watchers.kFSStatWatcherAddOrCleanRef]('add');
		  }

		  stat.addListener('change', listener);
		  return stat;
		},
		writeFile: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		writeFileSync: function writeFileSync(path, data, options) {
		  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });

		  if (!isArrayBufferView(data)) {
			validateStringAfterArrayBufferView(data, 'data');
			if (typeof data !== 'string') {
			  showStringCoercionDeprecation();
			}
			data = Buffer.from(String(data), options.encoding || 'utf8');
		  }

		  const flag = options.flag || 'w';

		  const isUserFd = isFd(path); // File descriptor ownership
		  const fd = isUserFd ? path : fs.openSync(path, flag, options.mode);

		  let offset = 0;
		  let length = data.byteLength;
		  try {
			while (length > 0) {
			  const written = fs.writeSync(fd, data, offset, length);
			  offset += written;
			  length -= written;
			}
		  } finally {
			if (!isUserFd) fs.closeSync(fd);
		  }
		},
		write: function (fd, buffer, ...args) {
		  if (typeof args[args.length - 1] === 'function') {
			return fs.write(fd, buffer, ...args)
		  }

		  return new Promise((resolve, reject) => {
			fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
			  if (err) return reject(err)
			  resolve({ bytesWritten, buffer })
			})
		  })
		},
		writeSync: function writeSync(fd, buffer, offsetOrOptions, length, position) {
		  fd = getValidatedFd(fd);
		  const ctx = {};
		  let result;

		  let offset = offsetOrOptions;
		  if (isArrayBufferView(buffer)) {
			if (typeof offset === 'object') {
			  ({
				offset = 0,
				length = buffer.byteLength - offset,
				position = null,
			  } = offsetOrOptions ?? kEmptyObject);
			}
			if (position === undefined)
			  position = null;
			if (offset == null) {
			  offset = 0;
			} else {
			  validateInteger(offset, 'offset', 0);
			}
			if (typeof length !== 'number')
			  length = buffer.byteLength - offset;
			validateOffsetLengthWrite(offset, length, buffer.byteLength);
			result = binding.writeBuffer(fd, buffer, offset, length, position,
										 undefined, ctx);
		  } else {
			validatePrimitiveStringAfterArrayBufferView(buffer, 'buffer');
			validateEncoding(buffer, length);

			if (offset === undefined)
			  offset = null;
			result = binding.writeString(fd, buffer, offset, length,
										 undefined, ctx);
		  }
		  handleErrorFromBinding(ctx);
		  return result;
		},
		writev: function writev(fd, buffers, position, callback) {
		  function wrapper(err, written) {
			callback(err, written || 0, buffers);
		  }

		  fd = getValidatedFd(fd);
		  validateBufferArray(buffers);
		  callback = maybeCallback(callback || position);

		  if (buffers.length === 0) {
			process.nextTick(callback, null, 0, buffers);
			return;
		  }

		  const req = new FSReqCallback();
		  req.oncomplete = wrapper;

		  if (typeof position !== 'number')
			position = null;

		  return binding.writeBuffers(fd, buffers, position, req);
		},
		writevSync: function writevSync(fd, buffers, position) {
		  fd = getValidatedFd(fd);
		  validateBufferArray(buffers);

		  if (buffers.length === 0) {
			return 0;
		  }

		  const ctx = {};

		  if (typeof position !== 'number')
			position = null;

		  const result = binding.writeBuffers(fd, buffers, position, undefined, ctx);

		  handleErrorFromBinding(ctx);
		  return result;
		},
		Dirent: class Dirent {
		  constructor(name, type, path, filepath = path && join(path, name)) {
			this.name = name;
			this.parentPath = path;
			this.path = filepath;
			this[kType] = type;
		  }

		  isDirectory() {
			return this[kType] === UV_DIRENT_DIR;
		  }

		  isFile() {
			return this[kType] === UV_DIRENT_FILE;
		  }

		  isBlockDevice() {
			return this[kType] === UV_DIRENT_BLOCK;
		  }

		  isCharacterDevice() {
			return this[kType] === UV_DIRENT_CHAR;
		  }

		  isSymbolicLink() {
			return this[kType] === UV_DIRENT_LINK;
		  }

		  isFIFO() {
			return this[kType] === UV_DIRENT_FIFO;
		  }

		  isSocket() {
			return this[kType] === UV_DIRENT_SOCKET;
		  }
		},
		Stats: function Stats(dev, mode, nlink, uid, gid, rdev, blksize,
		  ino, size, blocks,
		  atimeMs, mtimeMs, ctimeMs, birthtimeMs) {
		  FunctionPrototypeCall(StatsBase, this, dev, mode, nlink, uid, gid, rdev,
				   blksize, ino, size, blocks);
		  this.atimeMs = atimeMs;
		  this.mtimeMs = mtimeMs;
		  this.ctimeMs = ctimeMs;
		  this.birthtimeMs = birthtimeMs;
		  this.atime = dateFromMs(atimeMs);
		  this.mtime = dateFromMs(mtimeMs);
		  this.ctime = dateFromMs(ctimeMs);
		  this.birthtime = dateFromMs(birthtimeMs);
		},
		ReadStream: function ReadStream (path, options) {
		  if (this instanceof ReadStream)
			return fs$ReadStream.apply(this, arguments), this
		  else
			return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
		},
		WriteStream: function WriteStream (path, options) {
		  if (this instanceof WriteStream)
			return fs$WriteStream.apply(this, arguments), this
		  else
			return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
		},
		FileReadStream: function ReadStream (path, options) {
		  if (this instanceof ReadStream)
			return fs$ReadStream.apply(this, arguments), this
		  else
			return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
		},
		FileWriteStream: function WriteStream (path, options) {
		  if (this instanceof WriteStream)
			return fs$WriteStream.apply(this, arguments), this
		  else
			return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
		},
		_toUnixTimestamp: function toUnixTimestamp(time, name = 'time') {
		  // eslint-disable-next-line eqeqeq
		  if (typeof time === 'string' && +time == time) {
			return +time;
		  }
		  if (NumberIsFinite(time)) {
			if (time < 0) {
			  return DateNow() / 1000;
			}
			return time;
		  }
		  if (isDate(time)) {
			// Convert to 123.456 UNIX timestamp
			return DatePrototypeGetTime(time) / 1000;
		  }
		  throw new ERR_INVALID_ARG_TYPE(name, ['Date', 'Time in seconds'], time);
		},
		Dir: class Dir {
		  constructor(handle, path, options) {
			if (handle == null) throw new ERR_MISSING_ARGS('handle');
			this[kDirHandle] = handle;
			this[kDirBufferedEntries] = [];
			this[kDirPath] = path;
			this[kDirClosed] = false;

			// Either `null` or an Array of pending operations (= functions to be called
			// once the current operation is done).
			this[kDirOperationQueue] = null;

			this[kDirOptions] = {
			  bufferSize: 32,
			  ...getOptions(options, {
				encoding: 'utf8',
			  }),
			};

			validateUint32(this[kDirOptions].bufferSize, 'options.bufferSize', true);

			this[kDirReadPromisified] = FunctionPrototypeBind(
			  internalUtil.promisify(this[kDirReadImpl]), this, false);
			this[kDirClosePromisified] = FunctionPrototypeBind(
			  internalUtil.promisify(this.close), this);
		  }

		  get path() {
			return this[kDirPath];
		  }

		  read(callback) {
			return this[kDirReadImpl](true, callback);
		  }

		  [kDirReadImpl](maybeSync, callback) {
			if (this[kDirClosed] === true) {
			  throw new ERR_DIR_CLOSED();
			}

			if (callback === undefined) {
			  return this[kDirReadPromisified]();
			}

			validateFunction(callback, 'callback');

			if (this[kDirOperationQueue] !== null) {
			  ArrayPrototypePush(this[kDirOperationQueue], () => {
				this[kDirReadImpl](maybeSync, callback);
			  });
			  return;
			}

			if (this[kDirBufferedEntries].length > 0) {
			  try {
				const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);

				if (this[kDirOptions].recursive && dirent.isDirectory()) {
				  this.readSyncRecursive(dirent);
				}

				if (maybeSync)
				  process.nextTick(callback, null, dirent);
				else
				  callback(null, dirent);
				return;
			  } catch (error) {
				return callback(error);
			  }
			}

			const req = new FSReqCallback();
			req.oncomplete = (err, result) => {
			  process.nextTick(() => {
				const queue = this[kDirOperationQueue];
				this[kDirOperationQueue] = null;
				for (const op of queue) op();
			  });

			  if (err || result === null) {
				return callback(err, result);
			  }

			  try {
				this.processReadResult(this[kDirPath], result);
				const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);
				if (this[kDirOptions].recursive && dirent.isDirectory()) {
				  this.readSyncRecursive(dirent);
				}
				callback(null, dirent);
			  } catch (error) {
				callback(error);
			  }
			};

			this[kDirOperationQueue] = [];
			this[kDirHandle].read(
			  this[kDirOptions].encoding,
			  this[kDirOptions].bufferSize,
			  req,
			);
		  }

		  processReadResult(path, result) {
			for (let i = 0; i < result.length; i += 2) {
			  ArrayPrototypePush(
				this[kDirBufferedEntries],
				getDirent(
				  path,
				  result[i],
				  result[i + 1],
				  true, // Quirk to not introduce a breaking change.
				),
			  );
			}
		  }

		  readSyncRecursive(dirent) {
			const ctx = { path: dirent.path };
			const handle = dirBinding.opendir(
			  pathModule.toNamespacedPath(dirent.path),
			  this[kDirOptions].encoding,
			  undefined,
			  ctx,
			);
			handleErrorFromBinding(ctx);
			const result = handle.read(
			  this[kDirOptions].encoding,
			  this[kDirOptions].bufferSize,
			  undefined,
			  ctx,
			);

			if (result) {
			  this.processReadResult(dirent.path, result);
			}

			handle.close(undefined, ctx);
			handleErrorFromBinding(ctx);
		  }

		  readSync() {
			if (this[kDirClosed] === true) {
			  throw new ERR_DIR_CLOSED();
			}

			if (this[kDirOperationQueue] !== null) {
			  throw new ERR_DIR_CONCURRENT_OPERATION();
			}

			if (this[kDirBufferedEntries].length > 0) {
			  const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);
			  if (this[kDirOptions].recursive && dirent.isDirectory()) {
				this.readSyncRecursive(dirent);
			  }
			  return dirent;
			}

			const ctx = { path: this[kDirPath] };
			const result = this[kDirHandle].read(
			  this[kDirOptions].encoding,
			  this[kDirOptions].bufferSize,
			  undefined,
			  ctx,
			);
			handleErrorFromBinding(ctx);

			if (result === null) {
			  return result;
			}

			this.processReadResult(this[kDirPath], result);

			const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);
			if (this[kDirOptions].recursive && dirent.isDirectory()) {
			  this.readSyncRecursive(dirent);
			}
			return dirent;
		  }

		  close(callback) {
			// Promise
			if (callback === undefined) {
			  if (this[kDirClosed] === true) {
				return PromiseReject(new ERR_DIR_CLOSED());
			  }
			  return this[kDirClosePromisified]();
			}

			// callback
			validateFunction(callback, 'callback');

			if (this[kDirClosed] === true) {
			  process.nextTick(callback, new ERR_DIR_CLOSED());
			  return;
			}

			if (this[kDirOperationQueue] !== null) {
			  ArrayPrototypePush(this[kDirOperationQueue], () => {
				this.close(callback);
			  });
			  return;
			}

			this[kDirClosed] = true;
			const req = new FSReqCallback();
			req.oncomplete = callback;
			this[kDirHandle].close(req);
		  }

		  closeSync() {
			if (this[kDirClosed] === true) {
			  throw new ERR_DIR_CLOSED();
			}

			if (this[kDirOperationQueue] !== null) {
			  throw new ERR_DIR_CONCURRENT_OPERATION();
			}

			this[kDirClosed] = true;
			const ctx = { path: this[kDirPath] };
			const result = this[kDirHandle].close(undefined, ctx);
			handleErrorFromBinding(ctx);
			return result;
		  }

		  async* entries() {
			try {
			  while (true) {
				const result = await this[kDirReadPromisified]();
				if (result === null) {
				  break;
				}
				yield result;
			  }
			} finally {
			  await this[kDirClosePromisified]();
			}
		  }
		},
		opendir: function opendir(path, options, callback) {
		  callback = typeof options === 'function' ? options : callback;
		  validateFunction(callback, 'callback');

		  path = getValidatedPath(path);
		  options = getOptions(options, {
			encoding: 'utf8',
		  });

		  function opendirCallback(error, handle) {
			if (error) {
			  callback(error);
			} else {
			  callback(null, new Dir(handle, path, options));
			}
		  }

		  const req = new FSReqCallback();
		  req.oncomplete = opendirCallback;

		  dirBinding.opendir(
			pathModule.toNamespacedPath(path),
			options.encoding,
			req,
		  );
		},
		opendirSync: function opendirSync(path, options) {
		  path = getValidatedPath(path);
		  options = getOptions(options, {
			encoding: 'utf8',
		  });

		  const ctx = { path };
		  const handle = dirBinding.opendir(
			pathModule.toNamespacedPath(path),
			options.encoding,
			undefined,
			ctx,
		  );
		  handleErrorFromBinding(ctx);

		  return new Dir(handle, path, options);
		},
		F_OK: 0,
		R_OK: 4,
		W_OK: 2,
		X_OK: 1,
		constants: {
		  UV_FS_SYMLINK_DIR: 1,
		  UV_FS_SYMLINK_JUNCTION: 2,
		  O_RDONLY: 0,
		  O_WRONLY: 1,
		  O_RDWR: 2,
		  UV_DIRENT_UNKNOWN: 0,
		  UV_DIRENT_FILE: 1,
		  UV_DIRENT_DIR: 2,
		  UV_DIRENT_LINK: 3,
		  UV_DIRENT_FIFO: 4,
		  UV_DIRENT_SOCKET: 5,
		  UV_DIRENT_CHAR: 6,
		  UV_DIRENT_BLOCK: 7,
		  S_IFMT: 61440,
		  S_IFREG: 32768,
		  S_IFDIR: 16384,
		  S_IFCHR: 8192,
		  S_IFBLK: 24576,
		  S_IFIFO: 4096,
		  S_IFLNK: 40960,
		  S_IFSOCK: 49152,
		  O_CREAT: 512,
		  O_EXCL: 2048,
		  UV_FS_O_FILEMAP: 0,
		  O_NOCTTY: 131072,
		  O_TRUNC: 1024,
		  O_APPEND: 8,
		  O_DIRECTORY: 1048576,
		  O_NOFOLLOW: 256,
		  O_SYNC: 128,
		  O_DSYNC: 4194304,
		  O_SYMLINK: 2097152,
		  O_NONBLOCK: 4,
		  S_IRWXU: 448,
		  S_IRUSR: 256,
		  S_IWUSR: 128,
		  S_IXUSR: 64,
		  S_IRWXG: 56,
		  S_IRGRP: 32,
		  S_IWGRP: 16,
		  S_IXGRP: 8,
		  S_IRWXO: 7,
		  S_IROTH: 4,
		  S_IWOTH: 2,
		  S_IXOTH: 1,
		  F_OK: 0,
		  R_OK: 4,
		  W_OK: 2,
		  X_OK: 1,
		  UV_FS_COPYFILE_EXCL: 1,
		  COPYFILE_EXCL: 1,
		  UV_FS_COPYFILE_FICLONE: 2,
		  COPYFILE_FICLONE: 2,
		  UV_FS_COPYFILE_FICLONE_FORCE: 4,
		  COPYFILE_FICLONE_FORCE: 4,
		},
		gracefulify: function patch (fs) {
		  // Everything that references the open() function needs to be in here
		  polyfills(fs)
		  fs.gracefulify = patch

		  fs.createReadStream = createReadStream
		  fs.createWriteStream = createWriteStream
		  var fs$readFile = fs.readFile
		  fs.readFile = readFile
		  function readFile (path, options, cb) {
			if (typeof options === 'function')
			  cb = options, options = null

			return go$readFile(path, options, cb)

			function go$readFile (path, options, cb, startTime) {
			  return fs$readFile(path, options, function (err) {
				if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
				  enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])
				else {
				  if (typeof cb === 'function')
					cb.apply(this, arguments)
				}
			  })
			}
		  }

		  var fs$writeFile = fs.writeFile
		  fs.writeFile = writeFile
		  function writeFile (path, data, options, cb) {
			if (typeof options === 'function')
			  cb = options, options = null

			return go$writeFile(path, data, options, cb)

			function go$writeFile (path, data, options, cb, startTime) {
			  return fs$writeFile(path, data, options, function (err) {
				if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
				  enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
				else {
				  if (typeof cb === 'function')
					cb.apply(this, arguments)
				}
			  })
			}
		  }

		  var fs$appendFile = fs.appendFile
		  if (fs$appendFile)
			fs.appendFile = appendFile
		  function appendFile (path, data, options, cb) {
			if (typeof options === 'function')
			  cb = options, options = null

			return go$appendFile(path, data, options, cb)

			function go$appendFile (path, data, options, cb, startTime) {
			  return fs$appendFile(path, data, options, function (err) {
				if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
				  enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
				else {
				  if (typeof cb === 'function')
					cb.apply(this, arguments)
				}
			  })
			}
		  }

		  var fs$copyFile = fs.copyFile
		  if (fs$copyFile)
			fs.copyFile = copyFile
		  function copyFile (src, dest, flags, cb) {
			if (typeof flags === 'function') {
			  cb = flags
			  flags = 0
			}
			return go$copyFile(src, dest, flags, cb)

			function go$copyFile (src, dest, flags, cb, startTime) {
			  return fs$copyFile(src, dest, flags, function (err) {
				if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
				  enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])
				else {
				  if (typeof cb === 'function')
					cb.apply(this, arguments)
				}
			  })
			}
		  }

		  var fs$readdir = fs.readdir
		  fs.readdir = readdir
		  var noReaddirOptionVersions = /^v[0-5]\./
		  function readdir (path, options, cb) {
			if (typeof options === 'function')
			  cb = options, options = null

			var go$readdir = noReaddirOptionVersions.test(process.version)
			  ? function go$readdir (path, options, cb, startTime) {
				return fs$readdir(path, fs$readdirCallback(
				  path, options, cb, startTime
				))
			  }
			  : function go$readdir (path, options, cb, startTime) {
				return fs$readdir(path, options, fs$readdirCallback(
				  path, options, cb, startTime
				))
			  }

			return go$readdir(path, options, cb)

			function fs$readdirCallback (path, options, cb, startTime) {
			  return function (err, files) {
				if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
				  enqueue([
					go$readdir,
					[path, options, cb],
					err,
					startTime || Date.now(),
					Date.now()
				  ])
				else {
				  if (files && files.sort)
					files.sort()

				  if (typeof cb === 'function')
					cb.call(this, err, files)
				}
			  }
			}
		  }

		  if (process.version.substr(0, 4) === 'v0.8') {
			var legStreams = legacy(fs)
			ReadStream = legStreams.ReadStream
			WriteStream = legStreams.WriteStream
		  }

		  var fs$ReadStream = fs.ReadStream
		  if (fs$ReadStream) {
			ReadStream.prototype = Object.create(fs$ReadStream.prototype)
			ReadStream.prototype.open = ReadStream$open
		  }

		  var fs$WriteStream = fs.WriteStream
		  if (fs$WriteStream) {
			WriteStream.prototype = Object.create(fs$WriteStream.prototype)
			WriteStream.prototype.open = WriteStream$open
		  }

		  Object.defineProperty(fs, 'ReadStream', {
			get: function () {
			  return ReadStream
			},
			set: function (val) {
			  ReadStream = val
			},
			enumerable: true,
			configurable: true
		  })
		  Object.defineProperty(fs, 'WriteStream', {
			get: function () {
			  return WriteStream
			},
			set: function (val) {
			  WriteStream = val
			},
			enumerable: true,
			configurable: true
		  })

		  // legacy names
		  var FileReadStream = ReadStream
		  Object.defineProperty(fs, 'FileReadStream', {
			get: function () {
			  return FileReadStream
			},
			set: function (val) {
			  FileReadStream = val
			},
			enumerable: true,
			configurable: true
		  })
		  var FileWriteStream = WriteStream
		  Object.defineProperty(fs, 'FileWriteStream', {
			get: function () {
			  return FileWriteStream
			},
			set: function (val) {
			  FileWriteStream = val
			},
			enumerable: true,
			configurable: true
		  })

		  function ReadStream (path, options) {
			if (this instanceof ReadStream)
			  return fs$ReadStream.apply(this, arguments), this
			else
			  return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
		  }

		  function ReadStream$open () {
			var that = this
			open(that.path, that.flags, that.mode, function (err, fd) {
			  if (err) {
				if (that.autoClose)
				  that.destroy()

				that.emit('error', err)
			  } else {
				that.fd = fd
				that.emit('open', fd)
				that.read()
			  }
			})
		  }

		  function WriteStream (path, options) {
			if (this instanceof WriteStream)
			  return fs$WriteStream.apply(this, arguments), this
			else
			  return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
		  }

		  function WriteStream$open () {
			var that = this
			open(that.path, that.flags, that.mode, function (err, fd) {
			  if (err) {
				that.destroy()
				that.emit('error', err)
			  } else {
				that.fd = fd
				that.emit('open', fd)
			  }
			})
		  }

		  function createReadStream (path, options) {
			return new fs.ReadStream(path, options)
		  }

		  function createWriteStream (path, options) {
			return new fs.WriteStream(path, options)
		  }

		  var fs$open = fs.open
		  fs.open = open
		  function open (path, flags, mode, cb) {
			if (typeof mode === 'function')
			  cb = mode, mode = null

			return go$open(path, flags, mode, cb)

			function go$open (path, flags, mode, cb, startTime) {
			  return fs$open(path, flags, mode, function (err, fd) {
				if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
				  enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])
				else {
				  if (typeof cb === 'function')
					cb.apply(this, arguments)
				}
			  })
			}
		  }

		  return fs
		},
		copySync: function copySync (src, dest, opts) {
		  if (typeof opts === 'function') {
			opts = { filter: opts }
		  }

		  opts = opts || {}
		  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
		  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

		  // Warn about using preserveTimestamps on 32-bit node
		  if (opts.preserveTimestamps && process.arch === 'ia32') {
			console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
			see https://github.com/jprichardson/node-fs-extra/issues/269`)
		  }

		  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')
		  stat.checkParentPathsSync(src, srcStat, dest, 'copy')
		  return handleFilterAndCopy(destStat, src, dest, opts)
		},
		copy: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		emptyDirSync: function emptyDirSync (dir) {
		  let items
		  try {
			items = fs.readdirSync(dir)
		  } catch (err) {
			return mkdir.mkdirsSync(dir)
		  }

		  items.forEach(item => {
			item = path.join(dir, item)
			remove.removeSync(item)
		  })
		},
		emptydirSync: function emptyDirSync (dir) {
		  let items
		  try {
			items = fs.readdirSync(dir)
		  } catch (err) {
			return mkdir.mkdirsSync(dir)
		  }

		  items.forEach(item => {
			item = path.join(dir, item)
			remove.removeSync(item)
		  })
		},
		emptyDir: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		emptydir: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		createFile: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		createFileSync: function createFileSync (file) {
		  let stats
		  try {
			stats = fs.statSync(file)
		  } catch (e) {}
		  if (stats && stats.isFile()) return

		  const dir = path.dirname(file)
		  if (!fs.existsSync(dir)) {
			mkdir.mkdirsSync(dir)
		  }

		  fs.writeFileSync(file, '')
		},
		ensureFile: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		ensureFileSync: function createFileSync (file) {
		  let stats
		  try {
			stats = fs.statSync(file)
		  } catch (e) {}
		  if (stats && stats.isFile()) return

		  const dir = path.dirname(file)
		  if (!fs.existsSync(dir)) {
			mkdir.mkdirsSync(dir)
		  }

		  fs.writeFileSync(file, '')
		},
		createLink: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		createLinkSync: function createLinkSync (srcpath, dstpath) {
		  const destinationExists = fs.existsSync(dstpath)
		  if (destinationExists) return undefined

		  try {
			fs.lstatSync(srcpath)
		  } catch (err) {
			err.message = err.message.replace('lstat', 'ensureLink')
			throw err
		  }

		  const dir = path.dirname(dstpath)
		  const dirExists = fs.existsSync(dir)
		  if (dirExists) return fs.linkSync(srcpath, dstpath)
		  mkdir.mkdirsSync(dir)

		  return fs.linkSync(srcpath, dstpath)
		},
		ensureLink: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		ensureLinkSync: function createLinkSync (srcpath, dstpath) {
		  const destinationExists = fs.existsSync(dstpath)
		  if (destinationExists) return undefined

		  try {
			fs.lstatSync(srcpath)
		  } catch (err) {
			err.message = err.message.replace('lstat', 'ensureLink')
			throw err
		  }

		  const dir = path.dirname(dstpath)
		  const dirExists = fs.existsSync(dir)
		  if (dirExists) return fs.linkSync(srcpath, dstpath)
		  mkdir.mkdirsSync(dir)

		  return fs.linkSync(srcpath, dstpath)
		},
		createSymlink: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		createSymlinkSync: function createSymlinkSync (srcpath, dstpath, type) {
		  const destinationExists = fs.existsSync(dstpath)
		  if (destinationExists) return undefined

		  const relative = symlinkPathsSync(srcpath, dstpath)
		  srcpath = relative.toDst
		  type = symlinkTypeSync(relative.toCwd, type)
		  const dir = path.dirname(dstpath)
		  const exists = fs.existsSync(dir)
		  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
		  mkdirsSync(dir)
		  return fs.symlinkSync(srcpath, dstpath, type)
		},
		ensureSymlink: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		ensureSymlinkSync: function createSymlinkSync (srcpath, dstpath, type) {
		  const destinationExists = fs.existsSync(dstpath)
		  if (destinationExists) return undefined

		  const relative = symlinkPathsSync(srcpath, dstpath)
		  srcpath = relative.toDst
		  type = symlinkTypeSync(relative.toCwd, type)
		  const dir = path.dirname(dstpath)
		  const exists = fs.existsSync(dir)
		  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
		  mkdirsSync(dir)
		  return fs.symlinkSync(srcpath, dstpath, type)
		},
		readJson: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		readJsonSync: function readFileSync (file, options) {
		  options = options || {}
		  if (typeof options === 'string') {
			options = {encoding: options}
		  }

		  var fs = options.fs || _fs

		  var shouldThrow = true
		  if ('throws' in options) {
			shouldThrow = options.throws
		  }

		  try {
			var content = fs.readFileSync(file, options)
			content = stripBom(content)
			return JSON.parse(content, options.reviver)
		  } catch (err) {
			if (shouldThrow) {
			  err.message = file + ': ' + err.message
			  throw err
			} else {
			  return null
			}
		  }
		},
		writeJson: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		writeJsonSync: function writeFileSync (file, obj, options) {
		  options = options || {}
		  var fs = options.fs || _fs

		  var str = stringify(obj, options)
		  // not sure if fs.writeFileSync returns anything, but just in case
		  return fs.writeFileSync(file, str, options)
		},
		outputJson: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		outputJsonSync: function outputJsonSync (file, data, options) {
		  const dir = path.dirname(file)

		  if (!fs.existsSync(dir)) {
			mkdir.mkdirsSync(dir)
		  }

		  jsonFile.writeJsonSync(file, data, options)
		},
		outputJSON: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		outputJSONSync: function outputJsonSync (file, data, options) {
		  const dir = path.dirname(file)

		  if (!fs.existsSync(dir)) {
			mkdir.mkdirsSync(dir)
		  }

		  jsonFile.writeJsonSync(file, data, options)
		},
		writeJSON: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		writeJSONSync: function writeFileSync (file, obj, options) {
		  options = options || {}
		  var fs = options.fs || _fs

		  var str = stringify(obj, options)
		  // not sure if fs.writeFileSync returns anything, but just in case
		  return fs.writeFileSync(file, str, options)
		},
		readJSON: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		readJSONSync: function readFileSync (file, options) {
		  options = options || {}
		  if (typeof options === 'string') {
			options = {encoding: options}
		  }

		  var fs = options.fs || _fs

		  var shouldThrow = true
		  if ('throws' in options) {
			shouldThrow = options.throws
		  }

		  try {
			var content = fs.readFileSync(file, options)
			content = stripBom(content)
			return JSON.parse(content, options.reviver)
		  } catch (err) {
			if (shouldThrow) {
			  err.message = file + ': ' + err.message
			  throw err
			} else {
			  return null
			}
		  }
		},
		mkdirs: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		mkdirsSync: function mkdirsSync (p, opts, made) {
		  if (!opts || typeof opts !== 'object') {
			opts = { mode: opts }
		  }

		  let mode = opts.mode
		  const xfs = opts.fs || fs

		  if (process.platform === 'win32' && invalidWin32Path(p)) {
			const errInval = new Error(p + ' contains invalid WIN32 path characters.')
			errInval.code = 'EINVAL'
			throw errInval
		  }

		  if (mode === undefined) {
			mode = o777 & (~process.umask())
		  }
		  if (!made) made = null

		  p = path.resolve(p)

		  try {
			xfs.mkdirSync(p, mode)
			made = made || p
		  } catch (err0) {
			if (err0.code === 'ENOENT') {
			  if (path.dirname(p) === p) throw err0
			  made = mkdirsSync(path.dirname(p), opts, made)
			  mkdirsSync(p, opts, made)
			} else {
			  // In the case of any other error, just see if there's a dir there
			  // already. If so, then hooray!  If not, then something is borked.
			  let stat
			  try {
				stat = xfs.statSync(p)
			  } catch (err1) {
				throw err0
			  }
			  if (!stat.isDirectory()) throw err0
			}
		  }

		  return made
		},
		mkdirp: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		mkdirpSync: function mkdirsSync (p, opts, made) {
		  if (!opts || typeof opts !== 'object') {
			opts = { mode: opts }
		  }

		  let mode = opts.mode
		  const xfs = opts.fs || fs

		  if (process.platform === 'win32' && invalidWin32Path(p)) {
			const errInval = new Error(p + ' contains invalid WIN32 path characters.')
			errInval.code = 'EINVAL'
			throw errInval
		  }

		  if (mode === undefined) {
			mode = o777 & (~process.umask())
		  }
		  if (!made) made = null

		  p = path.resolve(p)

		  try {
			xfs.mkdirSync(p, mode)
			made = made || p
		  } catch (err0) {
			if (err0.code === 'ENOENT') {
			  if (path.dirname(p) === p) throw err0
			  made = mkdirsSync(path.dirname(p), opts, made)
			  mkdirsSync(p, opts, made)
			} else {
			  // In the case of any other error, just see if there's a dir there
			  // already. If so, then hooray!  If not, then something is borked.
			  let stat
			  try {
				stat = xfs.statSync(p)
			  } catch (err1) {
				throw err0
			  }
			  if (!stat.isDirectory()) throw err0
			}
		  }

		  return made
		},
		ensureDir: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		ensureDirSync: function mkdirsSync (p, opts, made) {
		  if (!opts || typeof opts !== 'object') {
			opts = { mode: opts }
		  }

		  let mode = opts.mode
		  const xfs = opts.fs || fs

		  if (process.platform === 'win32' && invalidWin32Path(p)) {
			const errInval = new Error(p + ' contains invalid WIN32 path characters.')
			errInval.code = 'EINVAL'
			throw errInval
		  }

		  if (mode === undefined) {
			mode = o777 & (~process.umask())
		  }
		  if (!made) made = null

		  p = path.resolve(p)

		  try {
			xfs.mkdirSync(p, mode)
			made = made || p
		  } catch (err0) {
			if (err0.code === 'ENOENT') {
			  if (path.dirname(p) === p) throw err0
			  made = mkdirsSync(path.dirname(p), opts, made)
			  mkdirsSync(p, opts, made)
			} else {
			  // In the case of any other error, just see if there's a dir there
			  // already. If so, then hooray!  If not, then something is borked.
			  let stat
			  try {
				stat = xfs.statSync(p)
			  } catch (err1) {
				throw err0
			  }
			  if (!stat.isDirectory()) throw err0
			}
		  }

		  return made
		},
		moveSync: function moveSync (src, dest, opts) {
		  opts = opts || {}
		  const overwrite = opts.overwrite || opts.clobber || false

		  const { srcStat } = stat.checkPathsSync(src, dest, 'move')
		  stat.checkParentPathsSync(src, srcStat, dest, 'move')
		  mkdirpSync(path.dirname(dest))
		  return doRename(src, dest, overwrite)
		},
		move: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		outputFile: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		outputFileSync: function outputFileSync (file, ...args) {
		  const dir = path.dirname(file)
		  if (fs.existsSync(dir)) {
			return fs.writeFileSync(file, ...args)
		  }
		  mkdir.mkdirsSync(dir)
		  fs.writeFileSync(file, ...args)
		},
		pathExists: function () {
		  const cb = arguments[arguments.length - 1]
		  if (typeof cb !== 'function') return fn.apply(this, arguments)
		  else fn.apply(this, arguments).then(r => cb(null, r), cb)
		},
		pathExistsSync: function existsSync(path) {
		  try {
			path = getValidatedPath(path);
		  } catch {
			return false;
		  }
		  const ctx = { path };
		  const nPath = pathModule.toNamespacedPath(path);
		  binding.access(nPath, F_OK, undefined, ctx);

		  // In case of an invalid symlink, `binding.access()` on win32
		  // will **not** return an error and is therefore not enough.
		  // Double check with `binding.stat()`.
		  if (isWindows && ctx.errno === undefined) {
			binding.stat(nPath, false, undefined, ctx);
		  }

		  return ctx.errno === undefined;
		},
		remove: function () {
		  if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
		  else {
			return new Promise((resolve, reject) => {
			  arguments[arguments.length] = (err, res) => {
				if (err) return reject(err)
				resolve(res)
			  }
			  arguments.length++
			  fn.apply(this, arguments)
			})
		  }
		},
		removeSync: function rimrafSync (p, options) {
		  let st

		  options = options || {}
		  defaults(options)

		  assert(p, 'rimraf: missing path')
		  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
		  assert(options, 'rimraf: missing options')
		  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

		  try {
			st = options.lstatSync(p)
		  } catch (er) {
			if (er.code === 'ENOENT') {
			  return
			}

			// Windows can EPERM on stat.  Life is suffering.
			if (er.code === 'EPERM' && isWindows) {
			  fixWinEPERMSync(p, options, er)
			}
		  }

		  try {
			// sunos lets the root user unlink directories, which is... weird.
			if (st && st.isDirectory()) {
			  rmdirSync(p, options, null)
			} else {
			  options.unlinkSync(p)
			}
		  } catch (er) {
			if (er.code === 'ENOENT') {
			  return
			} else if (er.code === 'EPERM') {
			  return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
			} else if (er.code !== 'EISDIR') {
			  throw er
			}
			rmdirSync(p, options, er)
		  }
		},
		default: {
		  appendFile: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  appendFileSync: function appendFileSync(path, data, options) {
			options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });

			// Don't make changes directly on options object
			options = copyObject(options);

			// Force append behavior when using a supplied file descriptor
			if (!options.flag || isFd(path))
			  options.flag = 'a';

			fs.writeFileSync(path, data, options);
		  },
		  access: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  accessSync: function accessSync(path, mode) {
			path = getValidatedPath(path);
			mode = getValidMode(mode, 'access');

			const ctx = { path };
			binding.access(pathModule.toNamespacedPath(path), mode, undefined, ctx);
			handleErrorFromBinding(ctx);
		  },
		  chown: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  chownSync: function (target, uid, gid) {
			try {
			  return orig.call(fs, target, uid, gid)
			} catch (er) {
			  if (!chownErOk(er)) throw er
			}
		  },
		  chmod: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  chmodSync: function (target, mode) {
			try {
			  return orig.call(fs, target, mode)
			} catch (er) {
			  if (!chownErOk(er)) throw er
			}
		  },
		  close: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  closeSync: function closeSync (fd) {
			// This function uses the graceful-fs shared queue
			fs$closeSync.apply(fs, arguments)
			resetQueue()
		  },
		  copyFile: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  copyFileSync: function copyFileSync(src, dest, mode) {
			src = getValidatedPath(src, 'src');
			dest = getValidatedPath(dest, 'dest');

			const ctx = { path: src, dest };  // non-prefixed

			src = pathModule._makeLong(src);
			dest = pathModule._makeLong(dest);
			mode = getValidMode(mode, 'copyFile');
			binding.copyFile(src, dest, mode, undefined, ctx);
			handleErrorFromBinding(ctx);
		  },
		  cp: function cp(src, dest, options, callback) {
			if (typeof options === 'function') {
			  callback = options;
			  options = undefined;
			}
			callback = makeCallback(callback);
			options = validateCpOptions(options);
			src = pathModule.toNamespacedPath(getValidatedPath(src, 'src'));
			dest = pathModule.toNamespacedPath(getValidatedPath(dest, 'dest'));
			lazyLoadCp();
			cpFn(src, dest, options, callback);
		  },
		  cpSync: function cpSync(src, dest, options) {
			options = validateCpOptions(options);
			src = pathModule.toNamespacedPath(getValidatedPath(src, 'src'));
			dest = pathModule.toNamespacedPath(getValidatedPath(dest, 'dest'));
			lazyLoadCp();
			cpSyncFn(src, dest, options);
		  },
		  createReadStream: function createReadStream (path, options) {
			return new fs.ReadStream(path, options)
		  },
		  createWriteStream: function createWriteStream (path, options) {
			return new fs.WriteStream(path, options)
		  },
		  exists: function (filename, callback) {
			if (typeof callback === 'function') {
			  return fs.exists(filename, callback)
			}
			return new Promise(resolve => {
			  return fs.exists(filename, resolve)
			})
		  },
		  existsSync: function existsSync(path) {
			try {
			  path = getValidatedPath(path);
			} catch {
			  return false;
			}
			const ctx = { path };
			const nPath = pathModule.toNamespacedPath(path);
			binding.access(nPath, F_OK, undefined, ctx);

			// In case of an invalid symlink, `binding.access()` on win32
			// will **not** return an error and is therefore not enough.
			// Double check with `binding.stat()`.
			if (isWindows && ctx.errno === undefined) {
			  binding.stat(nPath, false, undefined, ctx);
			}

			return ctx.errno === undefined;
		  },
		  fchown: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  fchownSync: function (target, uid, gid) {
			try {
			  return orig.call(fs, target, uid, gid)
			} catch (er) {
			  if (!chownErOk(er)) throw er
			}
		  },
		  fchmod: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  fchmodSync: function (target, mode) {
			try {
			  return orig.call(fs, target, mode)
			} catch (er) {
			  if (!chownErOk(er)) throw er
			}
		  },
		  fdatasync: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  fdatasyncSync: function fdatasyncSync(fd) {
			fd = getValidatedFd(fd);
			const ctx = {};
			binding.fdatasync(fd, undefined, ctx);
			handleErrorFromBinding(ctx);
		  },
		  fstat: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  fstatSync: function (target, options) {
			var stats = options ? orig.call(fs, target, options)
			  : orig.call(fs, target)
			if (stats) {
			  if (stats.uid < 0) stats.uid += 0x100000000
			  if (stats.gid < 0) stats.gid += 0x100000000
			}
			return stats;
		  },
		  fsync: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  fsyncSync: function fsyncSync(fd) {
			fd = getValidatedFd(fd);
			const ctx = {};
			binding.fsync(fd, undefined, ctx);
			handleErrorFromBinding(ctx);
		  },
		  ftruncate: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  ftruncateSync: function ftruncateSync(fd, len = 0) {
			fd = getValidatedFd(fd);
			validateInteger(len, 'len');
			len = MathMax(0, len);
			const ctx = {};
			binding.ftruncate(fd, len, undefined, ctx);
			handleErrorFromBinding(ctx);
		  },
		  futimes: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  futimesSync: function futimesSync(fd, atime, mtime) {
			fd = getValidatedFd(fd);
			atime = toUnixTimestamp(atime, 'atime');
			mtime = toUnixTimestamp(mtime, 'mtime');
			const ctx = {};
			binding.futimes(fd, atime, mtime, undefined, ctx);
			handleErrorFromBinding(ctx);
		  },
		  lchown: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  lchownSync: function (target, uid, gid) {
			try {
			  return orig.call(fs, target, uid, gid)
			} catch (er) {
			  if (!chownErOk(er)) throw er
			}
		  },
		  lchmod: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  lchmodSync: function (target, mode) {
			try {
			  return orig.call(fs, target, mode)
			} catch (er) {
			  if (!chownErOk(er)) throw er
			}
		  },
		  link: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  linkSync: function linkSync(existingPath, newPath) {
			existingPath = getValidatedPath(existingPath, 'existingPath');
			newPath = getValidatedPath(newPath, 'newPath');

			const ctx = { path: existingPath, dest: newPath };
			const result = binding.link(pathModule.toNamespacedPath(existingPath),
										pathModule.toNamespacedPath(newPath),
										undefined, ctx);
			handleErrorFromBinding(ctx);
			return result;
		  },
		  lstat: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  lstatSync: function (target, options) {
			var stats = options ? orig.call(fs, target, options)
			  : orig.call(fs, target)
			if (stats) {
			  if (stats.uid < 0) stats.uid += 0x100000000
			  if (stats.gid < 0) stats.gid += 0x100000000
			}
			return stats;
		  },
		  lutimes: function lutimes(path, atime, mtime, callback) {
			callback = makeCallback(callback);
			path = getValidatedPath(path);

			const req = new FSReqCallback();
			req.oncomplete = callback;
			binding.lutimes(pathModule.toNamespacedPath(path),
							toUnixTimestamp(atime),
							toUnixTimestamp(mtime),
							req);
		  },
		  lutimesSync: function lutimesSync(path, atime, mtime) {
			path = getValidatedPath(path);
			const ctx = { path };
			binding.lutimes(pathModule.toNamespacedPath(path),
							toUnixTimestamp(atime),
							toUnixTimestamp(mtime),
							undefined, ctx);
			handleErrorFromBinding(ctx);
		  },
		  mkdir: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  mkdirSync: function mkdirSync(path, options) {
			let mode = 0o777;
			let recursive = false;
			if (typeof options === 'number' || typeof options === 'string') {
			  mode = options;
			} else if (options) {
			  if (options.recursive !== undefined)
				recursive = options.recursive;
			  if (options.mode !== undefined)
				mode = options.mode;
			}
			path = getValidatedPath(path);
			validateBoolean(recursive, 'options.recursive');

			const ctx = { path };
			const result = binding.mkdir(pathModule.toNamespacedPath(path),
										 parseFileMode(mode, 'mode'), recursive,
										 undefined, ctx);
			handleErrorFromBinding(ctx);
			if (recursive) {
			  return result;
			}
		  },
		  mkdtemp: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  mkdtempSync: function mkdtempSync(prefix, options) {
			options = getOptions(options);

			prefix = getValidatedPath(prefix, 'prefix');
			warnOnNonPortableTemplate(prefix);

			let path;
			if (typeof prefix === 'string') {
			  path = `${prefix}XXXXXX`;
			} else {
			  path = Buffer.concat([prefix, Buffer.from('XXXXXX')]);
			}

			const ctx = { path };
			const result = binding.mkdtemp(path, options.encoding,
										   undefined, ctx);
			handleErrorFromBinding(ctx);
			return result;
		  },
		  open: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  openSync: function openSync(path, flags, mode) {
			path = getValidatedPath(path);
			const flagsNumber = stringToFlags(flags);
			mode = parseFileMode(mode, 'mode', 0o666);

			const ctx = { path };
			const result = binding.open(pathModule.toNamespacedPath(path),
										flagsNumber, mode,
										undefined, ctx);
			handleErrorFromBinding(ctx);
			return result;
		  },
		  readdir: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  readdirSync: function readdirSync(path, options) {
			options = getOptions(options);
			path = getValidatedPath(path);
			if (options.recursive != null) {
			  validateBoolean(options.recursive, 'options.recursive');
			}

			if (options.recursive) {
			  return readdirSyncRecursive(path, options);
			}

			const ctx = { path };
			const result = binding.readdir(pathModule.toNamespacedPath(path),
										   options.encoding, !!options.withFileTypes,
										   undefined, ctx);
			handleErrorFromBinding(ctx);
			return options.withFileTypes ? getDirents(path, result) : result;
		  },
		  read: function (fd, buffer, offset, length, position, callback) {
			if (typeof callback === 'function') {
			  return fs.read(fd, buffer, offset, length, position, callback)
			}
			return new Promise((resolve, reject) => {
			  fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
				if (err) return reject(err)
				resolve({ bytesRead, buffer })
			  })
			})
		  },
		  readSync: function (fd, buffer, offset, length, position) {
			var eagCounter = 0
			while (true) {
			  try {
				return fs$readSync.call(fs, fd, buffer, offset, length, position)
			  } catch (er) {
				if (er.code === 'EAGAIN' && eagCounter < 10) {
				  eagCounter ++
				  continue
				}
				throw er
			  }
			}
		  },
		  readv: function readv(fd, buffers, position, callback) {
			function wrapper(err, read) {
			  callback(err, read || 0, buffers);
			}

			fd = getValidatedFd(fd);
			validateBufferArray(buffers);
			callback = maybeCallback(callback || position);

			const req = new FSReqCallback();
			req.oncomplete = wrapper;

			if (typeof position !== 'number')
			  position = null;

			return binding.readBuffers(fd, buffers, position, req);
		  },
		  readvSync: function readvSync(fd, buffers, position) {
			fd = getValidatedFd(fd);
			validateBufferArray(buffers);

			const ctx = {};

			if (typeof position !== 'number')
			  position = null;

			const result = binding.readBuffers(fd, buffers, position, undefined, ctx);
			handleErrorFromBinding(ctx);
			return result;
		  },
		  readFile: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  readFileSync: function readFileSync(path, options) {
			options = getOptions(options, { flag: 'r' });
			const isUserFd = isFd(path); // File descriptor ownership
			const fd = isUserFd ? path : fs.openSync(path, options.flag, 0o666);

			const stats = tryStatSync(fd, isUserFd);
			const size = isFileType(stats, S_IFREG) ? stats[8] : 0;
			let pos = 0;
			let buffer; // Single buffer with file data
			let buffers; // List for when size is unknown

			if (size === 0) {
			  buffers = [];
			} else {
			  buffer = tryCreateBuffer(size, fd, isUserFd);
			}

			let bytesRead;

			if (size !== 0) {
			  do {
				bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);
				pos += bytesRead;
			  } while (bytesRead !== 0 && pos < size);
			} else {
			  do {
				// The kernel lies about many files.
				// Go ahead and try to read some bytes.
				buffer = Buffer.allocUnsafe(8192);
				bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);
				if (bytesRead !== 0) {
				  ArrayPrototypePush(buffers, buffer.slice(0, bytesRead));
				}
				pos += bytesRead;
			  } while (bytesRead !== 0);
			}

			if (!isUserFd)
			  fs.closeSync(fd);

			if (size === 0) {
			  // Data was collected into the buffers list.
			  buffer = Buffer.concat(buffers, pos);
			} else if (pos < size) {
			  buffer = buffer.slice(0, pos);
			}

			if (options.encoding) buffer = buffer.toString(options.encoding);
			return buffer;
		  },
		  readlink: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  readlinkSync: function readlinkSync(path, options) {
			options = getOptions(options);
			path = getValidatedPath(path, 'oldPath');
			const ctx = { path };
			const result = binding.readlink(pathModule.toNamespacedPath(path),
											options.encoding, undefined, ctx);
			handleErrorFromBinding(ctx);
			return result;
		  },
		  realpath: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  realpathSync: function realpathSync(p, options) {
			options = getOptions(options);
			p = toPathIfFileURL(p);
			if (typeof p !== 'string') {
			  p += '';
			}
			validatePath(p);
			p = pathModule.resolve(p);

			const cache = options[realpathCacheKey];
			const maybeCachedResult = cache?.get(p);
			if (maybeCachedResult) {
			  return maybeCachedResult;
			}

			const seenLinks = new SafeMap();
			const knownHard = new SafeSet();
			const original = p;

			// Current character position in p
			let pos;
			// The partial path so far, including a trailing slash if any
			let current;
			// The partial path without a trailing slash (except when pointing at a root)
			let base;
			// The partial path scanned in the previous round, with slash
			let previous;

			// Skip over roots
			current = base = splitRoot(p);
			pos = current.length;

			// On windows, check that the root exists. On unix there is no need.
			if (isWindows) {
			  const ctx = { path: base };
			  binding.lstat(pathModule.toNamespacedPath(base), false, undefined, ctx);
			  handleErrorFromBinding(ctx);
			  knownHard.add(base);
			}

			// Walk down the path, swapping out linked path parts for their real
			// values
			// NB: p.length changes.
			while (pos < p.length) {
			  // find the next part
			  const result = nextPart(p, pos);
			  previous = current;
			  if (result === -1) {
				const last = StringPrototypeSlice(p, pos);
				current += last;
				base = previous + last;
				pos = p.length;
			  } else {
				current += StringPrototypeSlice(p, pos, result + 1);
				base = previous + StringPrototypeSlice(p, pos, result);
				pos = result + 1;
			  }

			  // Continue if not a symlink, break if a pipe/socket
			  if (knownHard.has(base) || cache?.get(base) === base) {
				if (isFileType(binding.statValues, S_IFIFO) ||
					isFileType(binding.statValues, S_IFSOCK)) {
				  break;
				}
				continue;
			  }

			  let resolvedLink;
			  const maybeCachedResolved = cache?.get(base);
			  if (maybeCachedResolved) {
				resolvedLink = maybeCachedResolved;
			  } else {
				// Use stats array directly to avoid creating an fs.Stats instance just
				// for our internal use.

				const baseLong = pathModule.toNamespacedPath(base);
				const ctx = { path: base };
				const stats = binding.lstat(baseLong, true, undefined, ctx);
				handleErrorFromBinding(ctx);

				if (!isFileType(stats, S_IFLNK)) {
				  knownHard.add(base);
				  cache?.set(base, base);
				  continue;
				}

				// Read the link if it wasn't read before
				// dev/ino always return 0 on windows, so skip the check.
				let linkTarget = null;
				let id;
				if (!isWindows) {
				  const dev = BigIntPrototypeToString(stats[0], 32);
				  const ino = BigIntPrototypeToString(stats[7], 32);
				  id = `${dev}:${ino}`;
				  if (seenLinks.has(id)) {
					linkTarget = seenLinks.get(id);
				  }
				}
				if (linkTarget === null) {
				  const ctx = { path: base };
				  binding.stat(baseLong, false, undefined, ctx);
				  handleErrorFromBinding(ctx);
				  linkTarget = binding.readlink(baseLong, undefined, undefined, ctx);
				  handleErrorFromBinding(ctx);
				}
				resolvedLink = pathModule.resolve(previous, linkTarget);

				cache?.set(base, resolvedLink);
				if (!isWindows) seenLinks.set(id, linkTarget);
			  }

			  // Resolve the link, then start over
			  p = pathModule.resolve(resolvedLink, StringPrototypeSlice(p, pos));

			  // Skip over roots
			  current = base = splitRoot(p);
			  pos = current.length;

			  // On windows, check that the root exists. On unix there is no need.
			  if (isWindows && !knownHard.has(base)) {
				const ctx = { path: base };
				binding.lstat(pathModule.toNamespacedPath(base), false, undefined, ctx);
				handleErrorFromBinding(ctx);
				knownHard.add(base);
			  }
			}

			cache?.set(original, p);
			return encodeRealpathResult(p, options);
		  },
		  rename: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  renameSync: function renameSync(oldPath, newPath) {
			oldPath = getValidatedPath(oldPath, 'oldPath');
			newPath = getValidatedPath(newPath, 'newPath');
			const ctx = { path: oldPath, dest: newPath };
			binding.rename(pathModule.toNamespacedPath(oldPath),
						   pathModule.toNamespacedPath(newPath), undefined, ctx);
			handleErrorFromBinding(ctx);
		  },
		  rm: function rm(path, options, callback) {
			if (typeof options === 'function') {
			  callback = options;
			  options = undefined;
			}
			path = getValidatedPath(path);

			validateRmOptions(path, options, false, (err, options) => {
			  if (err) {
				return callback(err);
			  }
			  lazyLoadRimraf();
			  return rimraf(pathModule.toNamespacedPath(path), options, callback);
			});
		  },
		  rmSync: function rmSync(path, options) {
			path = getValidatedPath(path);
			options = validateRmOptionsSync(path, options, false);

			lazyLoadRimraf();
			return rimrafSync(pathModule.toNamespacedPath(path), options);
		  },
		  rmdir: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  rmdirSync: function rmdirSync(path, options) {
			path = getValidatedPath(path);

			if (options?.recursive) {
			  emitRecursiveRmdirWarning();
			  options = validateRmOptionsSync(path, { ...options, force: false }, true);
			  if (options !== false) {
				lazyLoadRimraf();
				return rimrafSync(pathModule.toNamespacedPath(path), options);
			  }
			} else {
			  validateRmdirOptions(options);
			}

			const ctx = { path };
			binding.rmdir(pathModule.toNamespacedPath(path), undefined, ctx);
			return handleErrorFromBinding(ctx);
		  },
		  stat: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  statfs: function statfs(path, options = { bigint: false }, callback) {
			if (typeof options === 'function') {
			  callback = options;
			  options = kEmptyObject;
			}
			callback = maybeCallback(callback);
			path = getValidatedPath(path);
			const req = new FSReqCallback(options.bigint);
			req.oncomplete = (err, stats) => {
			  if (err) {
				return callback(err);
			  }

			  callback(err, getStatFsFromBinding(stats));
			};
			binding.statfs(pathModule.toNamespacedPath(path), options.bigint, req);
		  },
		  statSync: function (target, options) {
			var stats = options ? orig.call(fs, target, options)
			  : orig.call(fs, target)
			if (stats) {
			  if (stats.uid < 0) stats.uid += 0x100000000
			  if (stats.gid < 0) stats.gid += 0x100000000
			}
			return stats;
		  },
		  statfsSync: function statfsSync(path, options = { bigint: false }) {
			path = getValidatedPath(path);
			const ctx = { path };
			const stats = binding.statfs(pathModule.toNamespacedPath(path),
										 options.bigint, undefined, ctx);
			handleErrorFromBinding(ctx);
			return getStatFsFromBinding(stats);
		  },
		  symlink: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  symlinkSync: function symlinkSync(target, path, type) {
			type = (typeof type === 'string' ? type : null);
			if (isWindows && type === null) {
			  const absoluteTarget = pathModule.resolve(`${path}`, '..', `${target}`);
			  if (statSync(absoluteTarget, { throwIfNoEntry: false })?.isDirectory()) {
				type = 'dir';
			  }
			}
			target = getValidatedPath(target, 'target');
			path = getValidatedPath(path);
			const flags = stringToSymlinkType(type);

			const ctx = { path: target, dest: path };
			binding.symlink(preprocessSymlinkDestination(target, type, path),
							pathModule.toNamespacedPath(path), flags, undefined, ctx);

			handleErrorFromBinding(ctx);
		  },
		  truncate: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  truncateSync: function truncateSync(path, len) {
			if (typeof path === 'number') {
			  // legacy
			  showTruncateDeprecation();
			  return fs.ftruncateSync(path, len);
			}
			if (len === undefined) {
			  len = 0;
			}
			// Allow error to be thrown, but still close fd.
			const fd = fs.openSync(path, 'r+');
			let ret;

			try {
			  ret = fs.ftruncateSync(fd, len);
			} finally {
			  fs.closeSync(fd);
			}
			return ret;
		  },
		  unwatchFile: function unwatchFile(filename, listener) {
			filename = getValidatedPath(filename);
			filename = pathModule.resolve(filename);
			const stat = statWatchers.get(filename);

			if (stat === undefined) return;
			const watchers = require('internal/fs/watchers');
			if (typeof listener === 'function') {
			  const beforeListenerCount = stat.listenerCount('change');
			  stat.removeListener('change', listener);
			  if (stat.listenerCount('change') < beforeListenerCount)
				stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');
			} else {
			  stat.removeAllListeners('change');
			  stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');
			}

			if (stat.listenerCount('change') === 0) {
			  stat.stop();
			  statWatchers.delete(filename);
			}
		  },
		  unlink: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  unlinkSync: function unlinkSync(path) {
			path = getValidatedPath(path);
			const ctx = { path };
			binding.unlink(pathModule.toNamespacedPath(path), undefined, ctx);
			handleErrorFromBinding(ctx);
		  },
		  utimes: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  utimesSync: function utimesSync(path, atime, mtime) {
			path = getValidatedPath(path);
			const ctx = { path };
			binding.utimes(pathModule.toNamespacedPath(path),
						   toUnixTimestamp(atime), toUnixTimestamp(mtime),
						   undefined, ctx);
			handleErrorFromBinding(ctx);
		  },
		  watch: function watch(filename, options, listener) {
			if (typeof options === 'function') {
			  listener = options;
			}
			options = getOptions(options);

			// Don't make changes directly on options object
			options = copyObject(options);

			if (options.persistent === undefined) options.persistent = true;
			if (options.recursive === undefined) options.recursive = false;
			if (options.recursive && !(isOSX || isWindows))
			  throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');

			const watchers = require('internal/fs/watchers');
			const watcher = new watchers.FSWatcher();
			watcher[watchers.kFSWatchStart](filename,
											options.persistent,
											options.recursive,
											options.encoding);
			if (listener) {
			  watcher.addListener('change', listener);
			}
			if (options.signal) {
			  if (options.signal.aborted) {
				process.nextTick(() => watcher.close());
			  } else {
				const listener = () => watcher.close();
				kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;
				options.signal.addEventListener('abort', listener, { __proto__: null, [kResistStopPropagation]: true });
				watcher.once('close', () => {
				  options.signal.removeEventListener('abort', listener);
				});
			  }
			}

			return watcher;
		  },
		  watchFile: function watchFile(filename, options, listener) {
			filename = getValidatedPath(filename);
			filename = pathModule.resolve(filename);
			let stat;

			if (options === null || typeof options !== 'object') {
			  listener = options;
			  options = null;
			}

			options = {
			  // Poll interval in milliseconds. 5007 is what libev used to use. It's
			  // a little on the slow side but let's stick with it for now to keep
			  // behavioral changes to a minimum.
			  interval: 5007,
			  persistent: true,
			  ...options,
			};

			validateFunction(listener, 'listener');

			stat = statWatchers.get(filename);
			const watchers = require('internal/fs/watchers');
			if (stat === undefined) {
			  stat = new watchers.StatWatcher(options.bigint);
			  stat[watchers.kFSStatWatcherStart](filename,
												 options.persistent, options.interval);
			  statWatchers.set(filename, stat);
			} else {
			  stat[watchers.kFSStatWatcherAddOrCleanRef]('add');
			}

			stat.addListener('change', listener);
			return stat;
		  },
		  writeFile: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  writeFileSync: function writeFileSync(path, data, options) {
			options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });

			if (!isArrayBufferView(data)) {
			  validateStringAfterArrayBufferView(data, 'data');
			  if (typeof data !== 'string') {
				showStringCoercionDeprecation();
			  }
			  data = Buffer.from(String(data), options.encoding || 'utf8');
			}

			const flag = options.flag || 'w';

			const isUserFd = isFd(path); // File descriptor ownership
			const fd = isUserFd ? path : fs.openSync(path, flag, options.mode);

			let offset = 0;
			let length = data.byteLength;
			try {
			  while (length > 0) {
				const written = fs.writeSync(fd, data, offset, length);
				offset += written;
				length -= written;
			  }
			} finally {
			  if (!isUserFd) fs.closeSync(fd);
			}
		  },
		  write: function (fd, buffer, ...args) {
			if (typeof args[args.length - 1] === 'function') {
			  return fs.write(fd, buffer, ...args)
			}

			return new Promise((resolve, reject) => {
			  fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
				if (err) return reject(err)
				resolve({ bytesWritten, buffer })
			  })
			})
		  },
		  writeSync: function writeSync(fd, buffer, offsetOrOptions, length, position) {
			fd = getValidatedFd(fd);
			const ctx = {};
			let result;

			let offset = offsetOrOptions;
			if (isArrayBufferView(buffer)) {
			  if (typeof offset === 'object') {
				({
				  offset = 0,
				  length = buffer.byteLength - offset,
				  position = null,
				} = offsetOrOptions ?? kEmptyObject);
			  }
			  if (position === undefined)
				position = null;
			  if (offset == null) {
				offset = 0;
			  } else {
				validateInteger(offset, 'offset', 0);
			  }
			  if (typeof length !== 'number')
				length = buffer.byteLength - offset;
			  validateOffsetLengthWrite(offset, length, buffer.byteLength);
			  result = binding.writeBuffer(fd, buffer, offset, length, position,
										   undefined, ctx);
			} else {
			  validatePrimitiveStringAfterArrayBufferView(buffer, 'buffer');
			  validateEncoding(buffer, length);

			  if (offset === undefined)
				offset = null;
			  result = binding.writeString(fd, buffer, offset, length,
										   undefined, ctx);
			}
			handleErrorFromBinding(ctx);
			return result;
		  },
		  writev: function writev(fd, buffers, position, callback) {
			function wrapper(err, written) {
			  callback(err, written || 0, buffers);
			}

			fd = getValidatedFd(fd);
			validateBufferArray(buffers);
			callback = maybeCallback(callback || position);

			if (buffers.length === 0) {
			  process.nextTick(callback, null, 0, buffers);
			  return;
			}

			const req = new FSReqCallback();
			req.oncomplete = wrapper;

			if (typeof position !== 'number')
			  position = null;

			return binding.writeBuffers(fd, buffers, position, req);
		  },
		  writevSync: function writevSync(fd, buffers, position) {
			fd = getValidatedFd(fd);
			validateBufferArray(buffers);

			if (buffers.length === 0) {
			  return 0;
			}

			const ctx = {};

			if (typeof position !== 'number')
			  position = null;

			const result = binding.writeBuffers(fd, buffers, position, undefined, ctx);

			handleErrorFromBinding(ctx);
			return result;
		  },
		  Dirent: class Dirent {
			constructor(name, type, path, filepath = path && join(path, name)) {
			  this.name = name;
			  this.parentPath = path;
			  this.path = filepath;
			  this[kType] = type;
			}

			isDirectory() {
			  return this[kType] === UV_DIRENT_DIR;
			}

			isFile() {
			  return this[kType] === UV_DIRENT_FILE;
			}

			isBlockDevice() {
			  return this[kType] === UV_DIRENT_BLOCK;
			}

			isCharacterDevice() {
			  return this[kType] === UV_DIRENT_CHAR;
			}

			isSymbolicLink() {
			  return this[kType] === UV_DIRENT_LINK;
			}

			isFIFO() {
			  return this[kType] === UV_DIRENT_FIFO;
			}

			isSocket() {
			  return this[kType] === UV_DIRENT_SOCKET;
			}
		  },
		  Stats: function Stats(dev, mode, nlink, uid, gid, rdev, blksize,
			ino, size, blocks,
			atimeMs, mtimeMs, ctimeMs, birthtimeMs) {
			FunctionPrototypeCall(StatsBase, this, dev, mode, nlink, uid, gid, rdev,
					 blksize, ino, size, blocks);
			this.atimeMs = atimeMs;
			this.mtimeMs = mtimeMs;
			this.ctimeMs = ctimeMs;
			this.birthtimeMs = birthtimeMs;
			this.atime = dateFromMs(atimeMs);
			this.mtime = dateFromMs(mtimeMs);
			this.ctime = dateFromMs(ctimeMs);
			this.birthtime = dateFromMs(birthtimeMs);
		  },
		  ReadStream: function ReadStream (path, options) {
			if (this instanceof ReadStream)
			  return fs$ReadStream.apply(this, arguments), this
			else
			  return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
		  },
		  WriteStream: function WriteStream (path, options) {
			if (this instanceof WriteStream)
			  return fs$WriteStream.apply(this, arguments), this
			else
			  return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
		  },
		  FileReadStream: function ReadStream (path, options) {
			if (this instanceof ReadStream)
			  return fs$ReadStream.apply(this, arguments), this
			else
			  return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
		  },
		  FileWriteStream: function WriteStream (path, options) {
			if (this instanceof WriteStream)
			  return fs$WriteStream.apply(this, arguments), this
			else
			  return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
		  },
		  _toUnixTimestamp: function toUnixTimestamp(time, name = 'time') {
			// eslint-disable-next-line eqeqeq
			if (typeof time === 'string' && +time == time) {
			  return +time;
			}
			if (NumberIsFinite(time)) {
			  if (time < 0) {
				return DateNow() / 1000;
			  }
			  return time;
			}
			if (isDate(time)) {
			  // Convert to 123.456 UNIX timestamp
			  return DatePrototypeGetTime(time) / 1000;
			}
			throw new ERR_INVALID_ARG_TYPE(name, ['Date', 'Time in seconds'], time);
		  },
		  Dir: class Dir {
			constructor(handle, path, options) {
			  if (handle == null) throw new ERR_MISSING_ARGS('handle');
			  this[kDirHandle] = handle;
			  this[kDirBufferedEntries] = [];
			  this[kDirPath] = path;
			  this[kDirClosed] = false;

			  // Either `null` or an Array of pending operations (= functions to be called
			  // once the current operation is done).
			  this[kDirOperationQueue] = null;

			  this[kDirOptions] = {
				bufferSize: 32,
				...getOptions(options, {
				  encoding: 'utf8',
				}),
			  };

			  validateUint32(this[kDirOptions].bufferSize, 'options.bufferSize', true);

			  this[kDirReadPromisified] = FunctionPrototypeBind(
				internalUtil.promisify(this[kDirReadImpl]), this, false);
			  this[kDirClosePromisified] = FunctionPrototypeBind(
				internalUtil.promisify(this.close), this);
			}

			get path() {
			  return this[kDirPath];
			}

			read(callback) {
			  return this[kDirReadImpl](true, callback);
			}

			[kDirReadImpl](maybeSync, callback) {
			  if (this[kDirClosed] === true) {
				throw new ERR_DIR_CLOSED();
			  }

			  if (callback === undefined) {
				return this[kDirReadPromisified]();
			  }

			  validateFunction(callback, 'callback');

			  if (this[kDirOperationQueue] !== null) {
				ArrayPrototypePush(this[kDirOperationQueue], () => {
				  this[kDirReadImpl](maybeSync, callback);
				});
				return;
			  }

			  if (this[kDirBufferedEntries].length > 0) {
				try {
				  const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);

				  if (this[kDirOptions].recursive && dirent.isDirectory()) {
					this.readSyncRecursive(dirent);
				  }

				  if (maybeSync)
					process.nextTick(callback, null, dirent);
				  else
					callback(null, dirent);
				  return;
				} catch (error) {
				  return callback(error);
				}
			  }

			  const req = new FSReqCallback();
			  req.oncomplete = (err, result) => {
				process.nextTick(() => {
				  const queue = this[kDirOperationQueue];
				  this[kDirOperationQueue] = null;
				  for (const op of queue) op();
				});

				if (err || result === null) {
				  return callback(err, result);
				}

				try {
				  this.processReadResult(this[kDirPath], result);
				  const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);
				  if (this[kDirOptions].recursive && dirent.isDirectory()) {
					this.readSyncRecursive(dirent);
				  }
				  callback(null, dirent);
				} catch (error) {
				  callback(error);
				}
			  };

			  this[kDirOperationQueue] = [];
			  this[kDirHandle].read(
				this[kDirOptions].encoding,
				this[kDirOptions].bufferSize,
				req,
			  );
			}

			processReadResult(path, result) {
			  for (let i = 0; i < result.length; i += 2) {
				ArrayPrototypePush(
				  this[kDirBufferedEntries],
				  getDirent(
					path,
					result[i],
					result[i + 1],
					true, // Quirk to not introduce a breaking change.
				  ),
				);
			  }
			}

			readSyncRecursive(dirent) {
			  const ctx = { path: dirent.path };
			  const handle = dirBinding.opendir(
				pathModule.toNamespacedPath(dirent.path),
				this[kDirOptions].encoding,
				undefined,
				ctx,
			  );
			  handleErrorFromBinding(ctx);
			  const result = handle.read(
				this[kDirOptions].encoding,
				this[kDirOptions].bufferSize,
				undefined,
				ctx,
			  );

			  if (result) {
				this.processReadResult(dirent.path, result);
			  }

			  handle.close(undefined, ctx);
			  handleErrorFromBinding(ctx);
			}

			readSync() {
			  if (this[kDirClosed] === true) {
				throw new ERR_DIR_CLOSED();
			  }

			  if (this[kDirOperationQueue] !== null) {
				throw new ERR_DIR_CONCURRENT_OPERATION();
			  }

			  if (this[kDirBufferedEntries].length > 0) {
				const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);
				if (this[kDirOptions].recursive && dirent.isDirectory()) {
				  this.readSyncRecursive(dirent);
				}
				return dirent;
			  }

			  const ctx = { path: this[kDirPath] };
			  const result = this[kDirHandle].read(
				this[kDirOptions].encoding,
				this[kDirOptions].bufferSize,
				undefined,
				ctx,
			  );
			  handleErrorFromBinding(ctx);

			  if (result === null) {
				return result;
			  }

			  this.processReadResult(this[kDirPath], result);

			  const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);
			  if (this[kDirOptions].recursive && dirent.isDirectory()) {
				this.readSyncRecursive(dirent);
			  }
			  return dirent;
			}

			close(callback) {
			  // Promise
			  if (callback === undefined) {
				if (this[kDirClosed] === true) {
				  return PromiseReject(new ERR_DIR_CLOSED());
				}
				return this[kDirClosePromisified]();
			  }

			  // callback
			  validateFunction(callback, 'callback');

			  if (this[kDirClosed] === true) {
				process.nextTick(callback, new ERR_DIR_CLOSED());
				return;
			  }

			  if (this[kDirOperationQueue] !== null) {
				ArrayPrototypePush(this[kDirOperationQueue], () => {
				  this.close(callback);
				});
				return;
			  }

			  this[kDirClosed] = true;
			  const req = new FSReqCallback();
			  req.oncomplete = callback;
			  this[kDirHandle].close(req);
			}

			closeSync() {
			  if (this[kDirClosed] === true) {
				throw new ERR_DIR_CLOSED();
			  }

			  if (this[kDirOperationQueue] !== null) {
				throw new ERR_DIR_CONCURRENT_OPERATION();
			  }

			  this[kDirClosed] = true;
			  const ctx = { path: this[kDirPath] };
			  const result = this[kDirHandle].close(undefined, ctx);
			  handleErrorFromBinding(ctx);
			  return result;
			}

			async* entries() {
			  try {
				while (true) {
				  const result = await this[kDirReadPromisified]();
				  if (result === null) {
					break;
				  }
				  yield result;
				}
			  } finally {
				await this[kDirClosePromisified]();
			  }
			}
		  },
		  opendir: function opendir(path, options, callback) {
			callback = typeof options === 'function' ? options : callback;
			validateFunction(callback, 'callback');

			path = getValidatedPath(path);
			options = getOptions(options, {
			  encoding: 'utf8',
			});

			function opendirCallback(error, handle) {
			  if (error) {
				callback(error);
			  } else {
				callback(null, new Dir(handle, path, options));
			  }
			}

			const req = new FSReqCallback();
			req.oncomplete = opendirCallback;

			dirBinding.opendir(
			  pathModule.toNamespacedPath(path),
			  options.encoding,
			  req,
			);
		  },
		  opendirSync: function opendirSync(path, options) {
			path = getValidatedPath(path);
			options = getOptions(options, {
			  encoding: 'utf8',
			});

			const ctx = { path };
			const handle = dirBinding.opendir(
			  pathModule.toNamespacedPath(path),
			  options.encoding,
			  undefined,
			  ctx,
			);
			handleErrorFromBinding(ctx);

			return new Dir(handle, path, options);
		  },
		  F_OK: 0,
		  R_OK: 4,
		  W_OK: 2,
		  X_OK: 1,
		  constants: {
			UV_FS_SYMLINK_DIR: 1,
			UV_FS_SYMLINK_JUNCTION: 2,
			O_RDONLY: 0,
			O_WRONLY: 1,
			O_RDWR: 2,
			UV_DIRENT_UNKNOWN: 0,
			UV_DIRENT_FILE: 1,
			UV_DIRENT_DIR: 2,
			UV_DIRENT_LINK: 3,
			UV_DIRENT_FIFO: 4,
			UV_DIRENT_SOCKET: 5,
			UV_DIRENT_CHAR: 6,
			UV_DIRENT_BLOCK: 7,
			S_IFMT: 61440,
			S_IFREG: 32768,
			S_IFDIR: 16384,
			S_IFCHR: 8192,
			S_IFBLK: 24576,
			S_IFIFO: 4096,
			S_IFLNK: 40960,
			S_IFSOCK: 49152,
			O_CREAT: 512,
			O_EXCL: 2048,
			UV_FS_O_FILEMAP: 0,
			O_NOCTTY: 131072,
			O_TRUNC: 1024,
			O_APPEND: 8,
			O_DIRECTORY: 1048576,
			O_NOFOLLOW: 256,
			O_SYNC: 128,
			O_DSYNC: 4194304,
			O_SYMLINK: 2097152,
			O_NONBLOCK: 4,
			S_IRWXU: 448,
			S_IRUSR: 256,
			S_IWUSR: 128,
			S_IXUSR: 64,
			S_IRWXG: 56,
			S_IRGRP: 32,
			S_IWGRP: 16,
			S_IXGRP: 8,
			S_IRWXO: 7,
			S_IROTH: 4,
			S_IWOTH: 2,
			S_IXOTH: 1,
			F_OK: 0,
			R_OK: 4,
			W_OK: 2,
			X_OK: 1,
			UV_FS_COPYFILE_EXCL: 1,
			COPYFILE_EXCL: 1,
			UV_FS_COPYFILE_FICLONE: 2,
			COPYFILE_FICLONE: 2,
			UV_FS_COPYFILE_FICLONE_FORCE: 4,
			COPYFILE_FICLONE_FORCE: 4,
		  },
		  gracefulify: function patch (fs) {
			// Everything that references the open() function needs to be in here
			polyfills(fs)
			fs.gracefulify = patch

			fs.createReadStream = createReadStream
			fs.createWriteStream = createWriteStream
			var fs$readFile = fs.readFile
			fs.readFile = readFile
			function readFile (path, options, cb) {
			  if (typeof options === 'function')
				cb = options, options = null

			  return go$readFile(path, options, cb)

			  function go$readFile (path, options, cb, startTime) {
				return fs$readFile(path, options, function (err) {
				  if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
					enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])
				  else {
					if (typeof cb === 'function')
					  cb.apply(this, arguments)
				  }
				})
			  }
			}

			var fs$writeFile = fs.writeFile
			fs.writeFile = writeFile
			function writeFile (path, data, options, cb) {
			  if (typeof options === 'function')
				cb = options, options = null

			  return go$writeFile(path, data, options, cb)

			  function go$writeFile (path, data, options, cb, startTime) {
				return fs$writeFile(path, data, options, function (err) {
				  if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
					enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
				  else {
					if (typeof cb === 'function')
					  cb.apply(this, arguments)
				  }
				})
			  }
			}

			var fs$appendFile = fs.appendFile
			if (fs$appendFile)
			  fs.appendFile = appendFile
			function appendFile (path, data, options, cb) {
			  if (typeof options === 'function')
				cb = options, options = null

			  return go$appendFile(path, data, options, cb)

			  function go$appendFile (path, data, options, cb, startTime) {
				return fs$appendFile(path, data, options, function (err) {
				  if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
					enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
				  else {
					if (typeof cb === 'function')
					  cb.apply(this, arguments)
				  }
				})
			  }
			}

			var fs$copyFile = fs.copyFile
			if (fs$copyFile)
			  fs.copyFile = copyFile
			function copyFile (src, dest, flags, cb) {
			  if (typeof flags === 'function') {
				cb = flags
				flags = 0
			  }
			  return go$copyFile(src, dest, flags, cb)

			  function go$copyFile (src, dest, flags, cb, startTime) {
				return fs$copyFile(src, dest, flags, function (err) {
				  if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
					enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])
				  else {
					if (typeof cb === 'function')
					  cb.apply(this, arguments)
				  }
				})
			  }
			}

			var fs$readdir = fs.readdir
			fs.readdir = readdir
			var noReaddirOptionVersions = /^v[0-5]\./
			function readdir (path, options, cb) {
			  if (typeof options === 'function')
				cb = options, options = null

			  var go$readdir = noReaddirOptionVersions.test(process.version)
				? function go$readdir (path, options, cb, startTime) {
				  return fs$readdir(path, fs$readdirCallback(
					path, options, cb, startTime
				  ))
				}
				: function go$readdir (path, options, cb, startTime) {
				  return fs$readdir(path, options, fs$readdirCallback(
					path, options, cb, startTime
				  ))
				}

			  return go$readdir(path, options, cb)

			  function fs$readdirCallback (path, options, cb, startTime) {
				return function (err, files) {
				  if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
					enqueue([
					  go$readdir,
					  [path, options, cb],
					  err,
					  startTime || Date.now(),
					  Date.now()
					])
				  else {
					if (files && files.sort)
					  files.sort()

					if (typeof cb === 'function')
					  cb.call(this, err, files)
				  }
				}
			  }
			}

			if (process.version.substr(0, 4) === 'v0.8') {
			  var legStreams = legacy(fs)
			  ReadStream = legStreams.ReadStream
			  WriteStream = legStreams.WriteStream
			}

			var fs$ReadStream = fs.ReadStream
			if (fs$ReadStream) {
			  ReadStream.prototype = Object.create(fs$ReadStream.prototype)
			  ReadStream.prototype.open = ReadStream$open
			}

			var fs$WriteStream = fs.WriteStream
			if (fs$WriteStream) {
			  WriteStream.prototype = Object.create(fs$WriteStream.prototype)
			  WriteStream.prototype.open = WriteStream$open
			}

			Object.defineProperty(fs, 'ReadStream', {
			  get: function () {
				return ReadStream
			  },
			  set: function (val) {
				ReadStream = val
			  },
			  enumerable: true,
			  configurable: true
			})
			Object.defineProperty(fs, 'WriteStream', {
			  get: function () {
				return WriteStream
			  },
			  set: function (val) {
				WriteStream = val
			  },
			  enumerable: true,
			  configurable: true
			})

			// legacy names
			var FileReadStream = ReadStream
			Object.defineProperty(fs, 'FileReadStream', {
			  get: function () {
				return FileReadStream
			  },
			  set: function (val) {
				FileReadStream = val
			  },
			  enumerable: true,
			  configurable: true
			})
			var FileWriteStream = WriteStream
			Object.defineProperty(fs, 'FileWriteStream', {
			  get: function () {
				return FileWriteStream
			  },
			  set: function (val) {
				FileWriteStream = val
			  },
			  enumerable: true,
			  configurable: true
			})

			function ReadStream (path, options) {
			  if (this instanceof ReadStream)
				return fs$ReadStream.apply(this, arguments), this
			  else
				return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
			}

			function ReadStream$open () {
			  var that = this
			  open(that.path, that.flags, that.mode, function (err, fd) {
				if (err) {
				  if (that.autoClose)
					that.destroy()

				  that.emit('error', err)
				} else {
				  that.fd = fd
				  that.emit('open', fd)
				  that.read()
				}
			  })
			}

			function WriteStream (path, options) {
			  if (this instanceof WriteStream)
				return fs$WriteStream.apply(this, arguments), this
			  else
				return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
			}

			function WriteStream$open () {
			  var that = this
			  open(that.path, that.flags, that.mode, function (err, fd) {
				if (err) {
				  that.destroy()
				  that.emit('error', err)
				} else {
				  that.fd = fd
				  that.emit('open', fd)
				}
			  })
			}

			function createReadStream (path, options) {
			  return new fs.ReadStream(path, options)
			}

			function createWriteStream (path, options) {
			  return new fs.WriteStream(path, options)
			}

			var fs$open = fs.open
			fs.open = open
			function open (path, flags, mode, cb) {
			  if (typeof mode === 'function')
				cb = mode, mode = null

			  return go$open(path, flags, mode, cb)

			  function go$open (path, flags, mode, cb, startTime) {
				return fs$open(path, flags, mode, function (err, fd) {
				  if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
					enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])
				  else {
					if (typeof cb === 'function')
					  cb.apply(this, arguments)
				  }
				})
			  }
			}

			return fs
		  },
		  copySync: function copySync (src, dest, opts) {
			if (typeof opts === 'function') {
			  opts = { filter: opts }
			}

			opts = opts || {}
			opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
			opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

			// Warn about using preserveTimestamps on 32-bit node
			if (opts.preserveTimestamps && process.arch === 'ia32') {
			  console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
			  see https://github.com/jprichardson/node-fs-extra/issues/269`)
			}

			const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')
			stat.checkParentPathsSync(src, srcStat, dest, 'copy')
			return handleFilterAndCopy(destStat, src, dest, opts)
		  },
		  copy: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  emptyDirSync: function emptyDirSync (dir) {
			let items
			try {
			  items = fs.readdirSync(dir)
			} catch (err) {
			  return mkdir.mkdirsSync(dir)
			}

			items.forEach(item => {
			  item = path.join(dir, item)
			  remove.removeSync(item)
			})
		  },
		  emptydirSync: function emptyDirSync (dir) {
			let items
			try {
			  items = fs.readdirSync(dir)
			} catch (err) {
			  return mkdir.mkdirsSync(dir)
			}

			items.forEach(item => {
			  item = path.join(dir, item)
			  remove.removeSync(item)
			})
		  },
		  emptyDir: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  emptydir: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  createFile: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  createFileSync: function createFileSync (file) {
			let stats
			try {
			  stats = fs.statSync(file)
			} catch (e) {}
			if (stats && stats.isFile()) return

			const dir = path.dirname(file)
			if (!fs.existsSync(dir)) {
			  mkdir.mkdirsSync(dir)
			}

			fs.writeFileSync(file, '')
		  },
		  ensureFile: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  ensureFileSync: function createFileSync (file) {
			let stats
			try {
			  stats = fs.statSync(file)
			} catch (e) {}
			if (stats && stats.isFile()) return

			const dir = path.dirname(file)
			if (!fs.existsSync(dir)) {
			  mkdir.mkdirsSync(dir)
			}

			fs.writeFileSync(file, '')
		  },
		  createLink: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  createLinkSync: function createLinkSync (srcpath, dstpath) {
			const destinationExists = fs.existsSync(dstpath)
			if (destinationExists) return undefined

			try {
			  fs.lstatSync(srcpath)
			} catch (err) {
			  err.message = err.message.replace('lstat', 'ensureLink')
			  throw err
			}

			const dir = path.dirname(dstpath)
			const dirExists = fs.existsSync(dir)
			if (dirExists) return fs.linkSync(srcpath, dstpath)
			mkdir.mkdirsSync(dir)

			return fs.linkSync(srcpath, dstpath)
		  },
		  ensureLink: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  ensureLinkSync: function createLinkSync (srcpath, dstpath) {
			const destinationExists = fs.existsSync(dstpath)
			if (destinationExists) return undefined

			try {
			  fs.lstatSync(srcpath)
			} catch (err) {
			  err.message = err.message.replace('lstat', 'ensureLink')
			  throw err
			}

			const dir = path.dirname(dstpath)
			const dirExists = fs.existsSync(dir)
			if (dirExists) return fs.linkSync(srcpath, dstpath)
			mkdir.mkdirsSync(dir)

			return fs.linkSync(srcpath, dstpath)
		  },
		  createSymlink: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  createSymlinkSync: function createSymlinkSync (srcpath, dstpath, type) {
			const destinationExists = fs.existsSync(dstpath)
			if (destinationExists) return undefined

			const relative = symlinkPathsSync(srcpath, dstpath)
			srcpath = relative.toDst
			type = symlinkTypeSync(relative.toCwd, type)
			const dir = path.dirname(dstpath)
			const exists = fs.existsSync(dir)
			if (exists) return fs.symlinkSync(srcpath, dstpath, type)
			mkdirsSync(dir)
			return fs.symlinkSync(srcpath, dstpath, type)
		  },
		  ensureSymlink: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  ensureSymlinkSync: function createSymlinkSync (srcpath, dstpath, type) {
			const destinationExists = fs.existsSync(dstpath)
			if (destinationExists) return undefined

			const relative = symlinkPathsSync(srcpath, dstpath)
			srcpath = relative.toDst
			type = symlinkTypeSync(relative.toCwd, type)
			const dir = path.dirname(dstpath)
			const exists = fs.existsSync(dir)
			if (exists) return fs.symlinkSync(srcpath, dstpath, type)
			mkdirsSync(dir)
			return fs.symlinkSync(srcpath, dstpath, type)
		  },
		  readJson: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  readJsonSync: function readFileSync (file, options) {
			options = options || {}
			if (typeof options === 'string') {
			  options = {encoding: options}
			}

			var fs = options.fs || _fs

			var shouldThrow = true
			if ('throws' in options) {
			  shouldThrow = options.throws
			}

			try {
			  var content = fs.readFileSync(file, options)
			  content = stripBom(content)
			  return JSON.parse(content, options.reviver)
			} catch (err) {
			  if (shouldThrow) {
				err.message = file + ': ' + err.message
				throw err
			  } else {
				return null
			  }
			}
		  },
		  writeJson: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  writeJsonSync: function writeFileSync (file, obj, options) {
			options = options || {}
			var fs = options.fs || _fs

			var str = stringify(obj, options)
			// not sure if fs.writeFileSync returns anything, but just in case
			return fs.writeFileSync(file, str, options)
		  },
		  outputJson: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  outputJsonSync: function outputJsonSync (file, data, options) {
			const dir = path.dirname(file)

			if (!fs.existsSync(dir)) {
			  mkdir.mkdirsSync(dir)
			}

			jsonFile.writeJsonSync(file, data, options)
		  },
		  outputJSON: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  outputJSONSync: function outputJsonSync (file, data, options) {
			const dir = path.dirname(file)

			if (!fs.existsSync(dir)) {
			  mkdir.mkdirsSync(dir)
			}

			jsonFile.writeJsonSync(file, data, options)
		  },
		  writeJSON: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  writeJSONSync: function writeFileSync (file, obj, options) {
			options = options || {}
			var fs = options.fs || _fs

			var str = stringify(obj, options)
			// not sure if fs.writeFileSync returns anything, but just in case
			return fs.writeFileSync(file, str, options)
		  },
		  readJSON: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  readJSONSync: function readFileSync (file, options) {
			options = options || {}
			if (typeof options === 'string') {
			  options = {encoding: options}
			}

			var fs = options.fs || _fs

			var shouldThrow = true
			if ('throws' in options) {
			  shouldThrow = options.throws
			}

			try {
			  var content = fs.readFileSync(file, options)
			  content = stripBom(content)
			  return JSON.parse(content, options.reviver)
			} catch (err) {
			  if (shouldThrow) {
				err.message = file + ': ' + err.message
				throw err
			  } else {
				return null
			  }
			}
		  },
		  mkdirs: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  mkdirsSync: function mkdirsSync (p, opts, made) {
			if (!opts || typeof opts !== 'object') {
			  opts = { mode: opts }
			}

			let mode = opts.mode
			const xfs = opts.fs || fs

			if (process.platform === 'win32' && invalidWin32Path(p)) {
			  const errInval = new Error(p + ' contains invalid WIN32 path characters.')
			  errInval.code = 'EINVAL'
			  throw errInval
			}

			if (mode === undefined) {
			  mode = o777 & (~process.umask())
			}
			if (!made) made = null

			p = path.resolve(p)

			try {
			  xfs.mkdirSync(p, mode)
			  made = made || p
			} catch (err0) {
			  if (err0.code === 'ENOENT') {
				if (path.dirname(p) === p) throw err0
				made = mkdirsSync(path.dirname(p), opts, made)
				mkdirsSync(p, opts, made)
			  } else {
				// In the case of any other error, just see if there's a dir there
				// already. If so, then hooray!  If not, then something is borked.
				let stat
				try {
				  stat = xfs.statSync(p)
				} catch (err1) {
				  throw err0
				}
				if (!stat.isDirectory()) throw err0
			  }
			}

			return made
		  },
		  mkdirp: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  mkdirpSync: function mkdirsSync (p, opts, made) {
			if (!opts || typeof opts !== 'object') {
			  opts = { mode: opts }
			}

			let mode = opts.mode
			const xfs = opts.fs || fs

			if (process.platform === 'win32' && invalidWin32Path(p)) {
			  const errInval = new Error(p + ' contains invalid WIN32 path characters.')
			  errInval.code = 'EINVAL'
			  throw errInval
			}

			if (mode === undefined) {
			  mode = o777 & (~process.umask())
			}
			if (!made) made = null

			p = path.resolve(p)

			try {
			  xfs.mkdirSync(p, mode)
			  made = made || p
			} catch (err0) {
			  if (err0.code === 'ENOENT') {
				if (path.dirname(p) === p) throw err0
				made = mkdirsSync(path.dirname(p), opts, made)
				mkdirsSync(p, opts, made)
			  } else {
				// In the case of any other error, just see if there's a dir there
				// already. If so, then hooray!  If not, then something is borked.
				let stat
				try {
				  stat = xfs.statSync(p)
				} catch (err1) {
				  throw err0
				}
				if (!stat.isDirectory()) throw err0
			  }
			}

			return made
		  },
		  ensureDir: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  ensureDirSync: function mkdirsSync (p, opts, made) {
			if (!opts || typeof opts !== 'object') {
			  opts = { mode: opts }
			}

			let mode = opts.mode
			const xfs = opts.fs || fs

			if (process.platform === 'win32' && invalidWin32Path(p)) {
			  const errInval = new Error(p + ' contains invalid WIN32 path characters.')
			  errInval.code = 'EINVAL'
			  throw errInval
			}

			if (mode === undefined) {
			  mode = o777 & (~process.umask())
			}
			if (!made) made = null

			p = path.resolve(p)

			try {
			  xfs.mkdirSync(p, mode)
			  made = made || p
			} catch (err0) {
			  if (err0.code === 'ENOENT') {
				if (path.dirname(p) === p) throw err0
				made = mkdirsSync(path.dirname(p), opts, made)
				mkdirsSync(p, opts, made)
			  } else {
				// In the case of any other error, just see if there's a dir there
				// already. If so, then hooray!  If not, then something is borked.
				let stat
				try {
				  stat = xfs.statSync(p)
				} catch (err1) {
				  throw err0
				}
				if (!stat.isDirectory()) throw err0
			  }
			}

			return made
		  },
		  moveSync: function moveSync (src, dest, opts) {
			opts = opts || {}
			const overwrite = opts.overwrite || opts.clobber || false

			const { srcStat } = stat.checkPathsSync(src, dest, 'move')
			stat.checkParentPathsSync(src, srcStat, dest, 'move')
			mkdirpSync(path.dirname(dest))
			return doRename(src, dest, overwrite)
		  },
		  move: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  outputFile: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  outputFileSync: function outputFileSync (file, ...args) {
			const dir = path.dirname(file)
			if (fs.existsSync(dir)) {
			  return fs.writeFileSync(file, ...args)
			}
			mkdir.mkdirsSync(dir)
			fs.writeFileSync(file, ...args)
		  },
		  pathExists: function () {
			const cb = arguments[arguments.length - 1]
			if (typeof cb !== 'function') return fn.apply(this, arguments)
			else fn.apply(this, arguments).then(r => cb(null, r), cb)
		  },
		  pathExistsSync: function existsSync(path) {
			try {
			  path = getValidatedPath(path);
			} catch {
			  return false;
			}
			const ctx = { path };
			const nPath = pathModule.toNamespacedPath(path);
			binding.access(nPath, F_OK, undefined, ctx);

			// In case of an invalid symlink, `binding.access()` on win32
			// will **not** return an error and is therefore not enough.
			// Double check with `binding.stat()`.
			if (isWindows && ctx.errno === undefined) {
			  binding.stat(nPath, false, undefined, ctx);
			}

			return ctx.errno === undefined;
		  },
		  remove: function () {
			if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
			else {
			  return new Promise((resolve, reject) => {
				arguments[arguments.length] = (err, res) => {
				  if (err) return reject(err)
				  resolve(res)
				}
				arguments.length++
				fn.apply(this, arguments)
			  })
			}
		  },
		  removeSync: function rimrafSync (p, options) {
			let st

			options = options || {}
			defaults(options)

			assert(p, 'rimraf: missing path')
			assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
			assert(options, 'rimraf: missing options')
			assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

			try {
			  st = options.lstatSync(p)
			} catch (er) {
			  if (er.code === 'ENOENT') {
				return
			  }

			  // Windows can EPERM on stat.  Life is suffering.
			  if (er.code === 'EPERM' && isWindows) {
				fixWinEPERMSync(p, options, er)
			  }
			}

			try {
			  // sunos lets the root user unlink directories, which is... weird.
			  if (st && st.isDirectory()) {
				rmdirSync(p, options, null)
			  } else {
				options.unlinkSync(p)
			  }
			} catch (er) {
			  if (er.code === 'ENOENT') {
				return
			  } else if (er.code === 'EPERM') {
				return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
			  } else if (er.code !== 'EISDIR') {
				throw er
			  }
			  rmdirSync(p, options, er)
			}
		  },
		},
	  },
	  babelKit: {
		types: {
		  __internal__deprecationWarning: function deprecationWarning(oldName, newName, prefix = "") {
			if (warnings.has(oldName)) return;
			warnings.add(oldName);
			const {
			  internal,
			  trace
			} = captureShortStackTrace(1, 2);
			if (internal) {
			  return;
			}
			console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`\n${trace}`);
		  },
		  addComment: function addComment(node, type, content, line) {
			return (0, _addComments.default)(node, type, [{
			  type: line ? "CommentLine" : "CommentBlock",
			  value: content
			}]);
		  },
		  addComments: function addComments(node, type, comments) {
			if (!comments || !node) return node;
			const key = `${type}Comments`;
			if (node[key]) {
			  if (type === "leading") {
				node[key] = comments.concat(node[key]);
			  } else {
				node[key].push(...comments);
			  }
			} else {
			  node[key] = comments;
			}
			return node;
		  },
		  appendToMemberExpression: function appendToMemberExpression(member, append, computed = false) {
			member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
			member.property = append;
			member.computed = !!computed;
			return member;
		  },
		  assertNode: function assertNode(node) {
			if (!(0, _isNode.default)(node)) {
			  var _node$type;
			  const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
			  throw new TypeError(`Not a valid node of type "${type}"`);
			}
		  },
		  buildMatchMemberExpression: function buildMatchMemberExpression(match, allowPartial) {
			const parts = match.split(".");
			return member => (0, _matchesPattern.default)(member, parts, allowPartial);
		  },
		  clone: function clone(node) {
			return (0, _cloneNode.default)(node, false);
		  },
		  cloneDeep: function cloneDeep(node) {
			return (0, _cloneNode.default)(node);
		  },
		  cloneDeepWithoutLoc: function cloneDeepWithoutLoc(node) {
			return (0, _cloneNode.default)(node, true, true);
		  },
		  cloneNode: function cloneNode(node, deep = true, withoutLoc = false) {
			return cloneNodeInternal(node, deep, withoutLoc, new Map());
		  },
		  cloneWithoutLoc: function cloneWithoutLoc(node) {
			return (0, _cloneNode.default)(node, false, true);
		  },
		  createFlowUnionType: function createFlowUnionType(types) {
			const flattened = (0, _removeTypeDuplicates.default)(types);
			if (flattened.length === 1) {
			  return flattened[0];
			} else {
			  return (0, _index.unionTypeAnnotation)(flattened);
			}
		  },
		  createTSUnionType: function createTSUnionType(typeAnnotations) {
			const types = typeAnnotations.map(type => {
			  return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
			});
			const flattened = (0, _removeTypeDuplicates.default)(types);
			if (flattened.length === 1) {
			  return flattened[0];
			} else {
			  return (0, _index.tsUnionType)(flattened);
			}
		  },
		  createTypeAnnotationBasedOnTypeof: function createTypeAnnotationBasedOnTypeof(type) {
			switch (type) {
			  case "string":
				return (0, _index.stringTypeAnnotation)();
			  case "number":
				return (0, _index.numberTypeAnnotation)();
			  case "undefined":
				return (0, _index.voidTypeAnnotation)();
			  case "boolean":
				return (0, _index.booleanTypeAnnotation)();
			  case "function":
				return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
			  case "object":
				return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
			  case "symbol":
				return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
			  case "bigint":
				return (0, _index.anyTypeAnnotation)();
			}
			throw new Error("Invalid typeof value: " + type);
		  },
		  createUnionTypeAnnotation: function createFlowUnionType(types) {
			const flattened = (0, _removeTypeDuplicates.default)(types);
			if (flattened.length === 1) {
			  return flattened[0];
			} else {
			  return (0, _index.unionTypeAnnotation)(flattened);
			}
		  },
		  ensureBlock: function ensureBlock(node, key = "body") {
			const result = (0, _toBlock.default)(node[key], node);
			node[key] = result;
			return result;
		  },
		  getBindingIdentifiers: function getBindingIdentifiers(node, duplicates, outerOnly, newBindingsOnly) {
			const search = [].concat(node);
			const ids = Object.create(null);
			while (search.length) {
			  const id = search.shift();
			  if (!id) continue;
			  if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id))) {
				continue;
			  }
			  const keys = getBindingIdentifiers.keys[id.type];
			  if ((0, _index.isIdentifier)(id)) {
				if (duplicates) {
				  const _ids = ids[id.name] = ids[id.name] || [];
				  _ids.push(id);
				} else {
				  ids[id.name] = id;
				}
				continue;
			  }
			  if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
				if ((0, _index.isDeclaration)(id.declaration)) {
				  search.push(id.declaration);
				}
				continue;
			  }
			  if (outerOnly) {
				if ((0, _index.isFunctionDeclaration)(id)) {
				  search.push(id.id);
				  continue;
				}
				if ((0, _index.isFunctionExpression)(id)) {
				  continue;
				}
			  }
			  if (keys) {
				for (let i = 0; i < keys.length; i++) {
				  const key = keys[i];
				  const nodes = id[key];
				  if (nodes) {
					Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
				  }
				}
			  }
			}
			return ids;
		  },
		  getOuterBindingIdentifiers: function getOuterBindingIdentifiers(node, duplicates) {
			return (0, _getBindingIdentifiers.default)(node, duplicates, true);
		  },
		  inheritInnerComments: function inheritInnerComments(child, parent) {
			(0, _inherit.default)("innerComments", child, parent);
		  },
		  inheritLeadingComments: function inheritLeadingComments(child, parent) {
			(0, _inherit.default)("leadingComments", child, parent);
		  },
		  inheritTrailingComments: function inheritTrailingComments(child, parent) {
			(0, _inherit.default)("trailingComments", child, parent);
		  },
		  inherits: function inherits(child, parent) {
			if (!child || !parent) return child;
			for (const key of _index.INHERIT_KEYS.optional) {
			  if (child[key] == null) {
				child[key] = parent[key];
			  }
			}
			for (const key of Object.keys(parent)) {
			  if (key[0] === "_" && key !== "__clone") {
				child[key] = parent[key];
			  }
			}
			for (const key of _index.INHERIT_KEYS.force) {
			  child[key] = parent[key];
			}
			(0, _inheritsComments.default)(child, parent);
			return child;
		  },
		  inheritsComments: function inheritsComments(child, parent) {
			(0, _inheritTrailingComments.default)(child, parent);
			(0, _inheritLeadingComments.default)(child, parent);
			(0, _inheritInnerComments.default)(child, parent);
			return child;
		  },
		  is: function is(type, node, opts) {
			if (!node) return false;
			const matches = (0, _isType.default)(node.type, type);
			if (!matches) {
			  if (!opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
				return (0, _isPlaceholderType.default)(node.expectedNode, type);
			  }
			  return false;
			}
			if (typeof opts === "undefined") {
			  return true;
			} else {
			  return (0, _shallowEqual.default)(node, opts);
			}
		  },
		  isBinding: function isBinding(node, parent, grandparent) {
			if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
			  return false;
			}
			const keys = _getBindingIdentifiers.default.keys[parent.type];
			if (keys) {
			  for (let i = 0; i < keys.length; i++) {
				const key = keys[i];
				const val = parent[key];
				if (Array.isArray(val)) {
				  if (val.indexOf(node) >= 0) return true;
				} else {
				  if (val === node) return true;
				}
			  }
			}
			return false;
		  },
		  isBlockScoped: function isBlockScoped(node) {
			return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);
		  },
		  isImmutable: function isImmutable(node) {
			if ((0, _isType.default)(node.type, "Immutable")) return true;
			if ((0, _index.isIdentifier)(node)) {
			  if (node.name === "undefined") {
				return true;
			  } else {
				return false;
			  }
			}
			return false;
		  },
		  isLet: function isLet(node) {
			return (0, _index.isVariableDeclaration)(node) && (node.kind !== "var" || node[_index2.BLOCK_SCOPED_SYMBOL]);
		  },
		  isNode: function isNode(node) {
			return !!(node && _index.VISITOR_KEYS[node.type]);
		  },
		  isNodesEquivalent: function isNodesEquivalent(a, b) {
			if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
			  return a === b;
			}
			if (a.type !== b.type) {
			  return false;
			}
			const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
			const visitorKeys = _index.VISITOR_KEYS[a.type];
			for (const field of fields) {
			  const val_a = a[field];
			  const val_b = b[field];
			  if (typeof val_a !== typeof val_b) {
				return false;
			  }
			  if (val_a == null && val_b == null) {
				continue;
			  } else if (val_a == null || val_b == null) {
				return false;
			  }
			  if (Array.isArray(val_a)) {
				if (!Array.isArray(val_b)) {
				  return false;
				}
				if (val_a.length !== val_b.length) {
				  return false;
				}
				for (let i = 0; i < val_a.length; i++) {
				  if (!isNodesEquivalent(val_a[i], val_b[i])) {
					return false;
				  }
				}
				continue;
			  }
			  if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
				for (const key of Object.keys(val_a)) {
				  if (val_a[key] !== val_b[key]) {
					return false;
				  }
				}
				continue;
			  }
			  if (!isNodesEquivalent(val_a, val_b)) {
				return false;
			  }
			}
			return true;
		  },
		  isPlaceholderType: function isPlaceholderType(placeholderType, targetType) {
			if (placeholderType === targetType) return true;
			const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
			if (aliases) {
			  for (const alias of aliases) {
				if (targetType === alias) return true;
			  }
			}
			return false;
		  },
		  isReferenced: function isReferenced(node, parent, grandparent) {
			switch (parent.type) {
			  case "MemberExpression":
			  case "OptionalMemberExpression":
				if (parent.property === node) {
				  return !!parent.computed;
				}
				return parent.object === node;
			  case "JSXMemberExpression":
				return parent.object === node;
			  case "VariableDeclarator":
				return parent.init === node;
			  case "ArrowFunctionExpression":
				return parent.body === node;
			  case "PrivateName":
				return false;
			  case "ClassMethod":
			  case "ClassPrivateMethod":
			  case "ObjectMethod":
				if (parent.key === node) {
				  return !!parent.computed;
				}
				return false;
			  case "ObjectProperty":
				if (parent.key === node) {
				  return !!parent.computed;
				}
				return !grandparent || grandparent.type !== "ObjectPattern";
			  case "ClassProperty":
			  case "ClassAccessorProperty":
				if (parent.key === node) {
				  return !!parent.computed;
				}
				return true;
			  case "ClassPrivateProperty":
				return parent.key !== node;
			  case "ClassDeclaration":
			  case "ClassExpression":
				return parent.superClass === node;
			  case "AssignmentExpression":
				return parent.right === node;
			  case "AssignmentPattern":
				return parent.right === node;
			  case "LabeledStatement":
				return false;
			  case "CatchClause":
				return false;
			  case "RestElement":
				return false;
			  case "BreakStatement":
			  case "ContinueStatement":
				return false;
			  case "FunctionDeclaration":
			  case "FunctionExpression":
				return false;
			  case "ExportNamespaceSpecifier":
			  case "ExportDefaultSpecifier":
				return false;
			  case "ExportSpecifier":
				if (grandparent != null && grandparent.source) {
				  return false;
				}
				return parent.local === node;
			  case "ImportDefaultSpecifier":
			  case "ImportNamespaceSpecifier":
			  case "ImportSpecifier":
				return false;
			  case "ImportAttribute":
				return false;
			  case "JSXAttribute":
				return false;
			  case "ObjectPattern":
			  case "ArrayPattern":
				return false;
			  case "MetaProperty":
				return false;
			  case "ObjectTypeProperty":
				return parent.key !== node;
			  case "TSEnumMember":
				return parent.id !== node;
			  case "TSPropertySignature":
				if (parent.key === node) {
				  return !!parent.computed;
				}
				return true;
			}
			return true;
		  },
		  isScope: function isScope(node, parent) {
			if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
			  return false;
			}
			if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
			  return true;
			}
			return (0, _index.isScopable)(node);
		  },
		  isSpecifierDefault: function isSpecifierDefault(specifier) {
			return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
			  name: "default"
			});
		  },
		  isType: function isType(nodeType, targetType) {
			if (nodeType === targetType) return true;
			if (nodeType == null) return false;
			if (_index.ALIAS_KEYS[targetType]) return false;
			const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
			if (aliases) {
			  if (aliases[0] === nodeType) return true;
			  for (const alias of aliases) {
				if (nodeType === alias) return true;
			  }
			}
			return false;
		  },
		  isValidES3Identifier: function isValidES3Identifier(name) {
			return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
		  },
		  isValidIdentifier: function isValidIdentifier(name, reserved = true) {
			if (typeof name !== "string") return false;
			if (reserved) {
			  if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
				return false;
			  }
			}
			return (0, _helperValidatorIdentifier.isIdentifierName)(name);
		  },
		  isVar: function isVar(node) {
			return (0, _index.isVariableDeclaration)(node, {
			  kind: "var"
			}) && !node[_index2.BLOCK_SCOPED_SYMBOL];
		  },
		  matchesPattern: function matchesPattern(member, match, allowPartial) {
			if (!(0, _index.isMemberExpression)(member)) return false;
			const parts = Array.isArray(match) ? match : match.split(".");
			const nodes = [];
			let node;
			for (node = member; (0, _index.isMemberExpression)(node); node = node.object) {
			  nodes.push(node.property);
			}
			nodes.push(node);
			if (nodes.length < parts.length) return false;
			if (!allowPartial && nodes.length > parts.length) return false;
			for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
			  const node = nodes[j];
			  let value;
			  if ((0, _index.isIdentifier)(node)) {
				value = node.name;
			  } else if ((0, _index.isStringLiteral)(node)) {
				value = node.value;
			  } else if ((0, _index.isThisExpression)(node)) {
				value = "this";
			  } else {
				return false;
			  }
			  if (parts[i] !== value) return false;
			}
			return true;
		  },
		  prependToMemberExpression: function prependToMemberExpression(member, prepend) {
			if ((0, _index2.isSuper)(member.object)) {
			  throw new Error("Cannot prepend node to super property access (`super.foo`).");
			}
			member.object = (0, _index.memberExpression)(prepend, member.object);
			return member;
		  },
		  react: {
			isReactComponent: member => (0, _matchesPattern.default)(member, parts, allowPartial),
			isCompatTag: function isCompatTag(tagName) {
			  return !!tagName && /^[a-z]/.test(tagName);
			},
			buildChildren: function buildChildren(node) {
			  const elements = [];
			  for (let i = 0; i < node.children.length; i++) {
				let child = node.children[i];
				if ((0, _index.isJSXText)(child)) {
				  (0, _cleanJSXElementLiteralChild.default)(child, elements);
				  continue;
				}
				if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;
				if ((0, _index.isJSXEmptyExpression)(child)) continue;
				elements.push(child);
			  }
			  return elements;
			},
		  },
		  removeComments: function removeComments(node) {
			_index.COMMENT_KEYS.forEach(key => {
			  node[key] = null;
			});
			return node;
		  },
		  removeProperties: function removeProperties(node, opts = {}) {
			const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
			for (const key of map) {
			  if (node[key] != null) node[key] = undefined;
			}
			for (const key of Object.keys(node)) {
			  if (key[0] === "_" && node[key] != null) node[key] = undefined;
			}
			const symbols = Object.getOwnPropertySymbols(node);
			for (const sym of symbols) {
			  node[sym] = null;
			}
		  },
		  removePropertiesDeep: function removePropertiesDeep(tree, opts) {
			(0, _traverseFast.default)(tree, _removeProperties.default, opts);
			return tree;
		  },
		  removeTypeDuplicates: function removeTypeDuplicates(nodesIn) {
			const nodes = Array.from(nodesIn);
			const generics = new Map();
			const bases = new Map();
			const typeGroups = new Set();
			const types = [];
			for (let i = 0; i < nodes.length; i++) {
			  const node = nodes[i];
			  if (!node) continue;
			  if (types.indexOf(node) >= 0) {
				continue;
			  }
			  if ((0, _index.isAnyTypeAnnotation)(node)) {
				return [node];
			  }
			  if ((0, _index.isFlowBaseAnnotation)(node)) {
				bases.set(node.type, node);
				continue;
			  }
			  if ((0, _index.isUnionTypeAnnotation)(node)) {
				if (!typeGroups.has(node.types)) {
				  nodes.push(...node.types);
				  typeGroups.add(node.types);
				}
				continue;
			  }
			  if ((0, _index.isGenericTypeAnnotation)(node)) {
				const name = getQualifiedName(node.id);
				if (generics.has(name)) {
				  let existing = generics.get(name);
				  if (existing.typeParameters) {
					if (node.typeParameters) {
					  existing.typeParameters.params.push(...node.typeParameters.params);
					  existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
					}
				  } else {
					existing = node.typeParameters;
				  }
				} else {
				  generics.set(name, node);
				}
				continue;
			  }
			  types.push(node);
			}
			for (const [, baseType] of bases) {
			  types.push(baseType);
			}
			for (const [, genericName] of generics) {
			  types.push(genericName);
			}
			return types;
		  },
		  shallowEqual: function shallowEqual(actual, expected) {
			const keys = Object.keys(expected);
			for (const key of keys) {
			  if (actual[key] !== expected[key]) {
				return false;
			  }
			}
			return true;
		  },
		  toBindingIdentifierName: function toBindingIdentifierName(name) {
			name = (0, _toIdentifier.default)(name);
			if (name === "eval" || name === "arguments") name = "_" + name;
			return name;
		  },
		  toBlock: function toBlock(node, parent) {
			if ((0, _index.isBlockStatement)(node)) {
			  return node;
			}
			let blockNodes = [];
			if ((0, _index.isEmptyStatement)(node)) {
			  blockNodes = [];
			} else {
			  if (!(0, _index.isStatement)(node)) {
				if ((0, _index.isFunction)(parent)) {
				  node = (0, _index2.returnStatement)(node);
				} else {
				  node = (0, _index2.expressionStatement)(node);
				}
			  }
			  blockNodes = [node];
			}
			return (0, _index2.blockStatement)(blockNodes);
		  },
		  toComputedKey: function toComputedKey(node, key = node.key || node.property) {
			if (!node.computed && (0, _index.isIdentifier)(key)) key = (0, _index2.stringLiteral)(key.name);
			return key;
		  },
		  toExpression: function toExpression(node) {
			if ((0, _index.isExpressionStatement)(node)) {
			  node = node.expression;
			}
			if ((0, _index.isExpression)(node)) {
			  return node;
			}
			if ((0, _index.isClass)(node)) {
			  node.type = "ClassExpression";
			} else if ((0, _index.isFunction)(node)) {
			  node.type = "FunctionExpression";
			}
			if (!(0, _index.isExpression)(node)) {
			  throw new Error(`cannot turn ${node.type} to an expression`);
			}
			return node;
		  },
		  toIdentifier: function toIdentifier(input) {
			input = input + "";
			let name = "";
			for (const c of input) {
			  name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
			}
			name = name.replace(/^[-0-9]+/, "");
			name = name.replace(/[-\s]+(.)?/g, function (match, c) {
			  return c ? c.toUpperCase() : "";
			});
			if (!(0, _isValidIdentifier.default)(name)) {
			  name = `_${name}`;
			}
			return name || "_";
		  },
		  toKeyAlias: function toKeyAlias(node, key = node.key) {
			let alias;
			if (node.kind === "method") {
			  return toKeyAlias.increment() + "";
			} else if ((0, _index.isIdentifier)(key)) {
			  alias = key.name;
			} else if ((0, _index.isStringLiteral)(key)) {
			  alias = JSON.stringify(key.value);
			} else {
			  alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
			}
			if (node.computed) {
			  alias = `[${alias}]`;
			}
			if (node.static) {
			  alias = `static:${alias}`;
			}
			return alias;
		  },
		  toStatement: function toStatement(node, ignore) {
			if ((0, _index.isStatement)(node)) {
			  return node;
			}
			let mustHaveId = false;
			let newType;
			if ((0, _index.isClass)(node)) {
			  mustHaveId = true;
			  newType = "ClassDeclaration";
			} else if ((0, _index.isFunction)(node)) {
			  mustHaveId = true;
			  newType = "FunctionDeclaration";
			} else if ((0, _index.isAssignmentExpression)(node)) {
			  return (0, _index2.expressionStatement)(node);
			}
			if (mustHaveId && !node.id) {
			  newType = false;
			}
			if (!newType) {
			  if (ignore) {
				return false;
			  } else {
				throw new Error(`cannot turn ${node.type} to a statement`);
			  }
			}
			node.type = newType;
			return node;
		  },
		  traverse: function traverse(node, handlers, state) {
			if (typeof handlers === "function") {
			  handlers = {
				enter: handlers
			  };
			}
			const {
			  enter,
			  exit
			} = handlers;
			traverseSimpleImpl(node, enter, exit, state, []);
		  },
		  traverseFast: function traverseFast(node, enter, opts) {
			if (!node) return;
			const keys = _index.VISITOR_KEYS[node.type];
			if (!keys) return;
			opts = opts || {};
			enter(node, opts);
			for (const key of keys) {
			  const subNode = node[key];
			  if (Array.isArray(subNode)) {
				for (const node of subNode) {
				  traverseFast(node, enter, opts);
				}
			  } else {
				traverseFast(subNode, enter, opts);
			  }
			}
		  },
		  validate: function validate(node, key, val) {
			if (!node) return;
			const fields = _index.NODE_FIELDS[node.type];
			if (!fields) return;
			const field = fields[key];
			validateField(node, key, val, field);
			validateChild(node, key, val);
		  },
		  valueToNode: function valueToNode(value) {
			if (value === undefined) {
			  return (0, _index.identifier)("undefined");
			}
			if (value === true || value === false) {
			  return (0, _index.booleanLiteral)(value);
			}
			if (value === null) {
			  return (0, _index.nullLiteral)();
			}
			if (typeof value === "string") {
			  return (0, _index.stringLiteral)(value);
			}
			if (typeof value === "number") {
			  let result;
			  if (Number.isFinite(value)) {
				result = (0, _index.numericLiteral)(Math.abs(value));
			  } else {
				let numerator;
				if (Number.isNaN(value)) {
				  numerator = (0, _index.numericLiteral)(0);
				} else {
				  numerator = (0, _index.numericLiteral)(1);
				}
				result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
			  }
			  if (value < 0 || Object.is(value, -0)) {
				result = (0, _index.unaryExpression)("-", result);
			  }
			  return result;
			}
			if (isRegExp(value)) {
			  const pattern = value.source;
			  const flags = value.toString().match(/\/([a-z]+|)$/)[1];
			  return (0, _index.regExpLiteral)(pattern, flags);
			}
			if (Array.isArray(value)) {
			  return (0, _index.arrayExpression)(value.map(valueToNode));
			}
			if (isPlainObject(value)) {
			  const props = [];
			  for (const key of Object.keys(value)) {
				let nodeKey;
				if ((0, _isValidIdentifier.default)(key)) {
				  nodeKey = (0, _index.identifier)(key);
				} else {
				  nodeKey = (0, _index.stringLiteral)(key);
				}
				props.push((0, _index.objectProperty)(nodeKey, valueToNode(value[key])));
			  }
			  return (0, _index.objectExpression)(props);
			}
			throw new Error("don't know how to turn this value into a node");
		  },
		  assertAccessor: function assertAccessor(node, opts) {
			assert("Accessor", node, opts);
		  },
		  assertAnyTypeAnnotation: function assertAnyTypeAnnotation(node, opts) {
			assert("AnyTypeAnnotation", node, opts);
		  },
		  assertArgumentPlaceholder: function assertArgumentPlaceholder(node, opts) {
			assert("ArgumentPlaceholder", node, opts);
		  },
		  assertArrayExpression: function assertArrayExpression(node, opts) {
			assert("ArrayExpression", node, opts);
		  },
		  assertArrayPattern: function assertArrayPattern(node, opts) {
			assert("ArrayPattern", node, opts);
		  },
		  assertArrayTypeAnnotation: function assertArrayTypeAnnotation(node, opts) {
			assert("ArrayTypeAnnotation", node, opts);
		  },
		  assertArrowFunctionExpression: function assertArrowFunctionExpression(node, opts) {
			assert("ArrowFunctionExpression", node, opts);
		  },
		  assertAssignmentExpression: function assertAssignmentExpression(node, opts) {
			assert("AssignmentExpression", node, opts);
		  },
		  assertAssignmentPattern: function assertAssignmentPattern(node, opts) {
			assert("AssignmentPattern", node, opts);
		  },
		  assertAwaitExpression: function assertAwaitExpression(node, opts) {
			assert("AwaitExpression", node, opts);
		  },
		  assertBigIntLiteral: function assertBigIntLiteral(node, opts) {
			assert("BigIntLiteral", node, opts);
		  },
		  assertBinary: function assertBinary(node, opts) {
			assert("Binary", node, opts);
		  },
		  assertBinaryExpression: function assertBinaryExpression(node, opts) {
			assert("BinaryExpression", node, opts);
		  },
		  assertBindExpression: function assertBindExpression(node, opts) {
			assert("BindExpression", node, opts);
		  },
		  assertBlock: function assertBlock(node, opts) {
			assert("Block", node, opts);
		  },
		  assertBlockParent: function assertBlockParent(node, opts) {
			assert("BlockParent", node, opts);
		  },
		  assertBlockStatement: function assertBlockStatement(node, opts) {
			assert("BlockStatement", node, opts);
		  },
		  assertBooleanLiteral: function assertBooleanLiteral(node, opts) {
			assert("BooleanLiteral", node, opts);
		  },
		  assertBooleanLiteralTypeAnnotation: function assertBooleanLiteralTypeAnnotation(node, opts) {
			assert("BooleanLiteralTypeAnnotation", node, opts);
		  },
		  assertBooleanTypeAnnotation: function assertBooleanTypeAnnotation(node, opts) {
			assert("BooleanTypeAnnotation", node, opts);
		  },
		  assertBreakStatement: function assertBreakStatement(node, opts) {
			assert("BreakStatement", node, opts);
		  },
		  assertCallExpression: function assertCallExpression(node, opts) {
			assert("CallExpression", node, opts);
		  },
		  assertCatchClause: function assertCatchClause(node, opts) {
			assert("CatchClause", node, opts);
		  },
		  assertClass: function assertClass(node, opts) {
			assert("Class", node, opts);
		  },
		  assertClassAccessorProperty: function assertClassAccessorProperty(node, opts) {
			assert("ClassAccessorProperty", node, opts);
		  },
		  assertClassBody: function assertClassBody(node, opts) {
			assert("ClassBody", node, opts);
		  },
		  assertClassDeclaration: function assertClassDeclaration(node, opts) {
			assert("ClassDeclaration", node, opts);
		  },
		  assertClassExpression: function assertClassExpression(node, opts) {
			assert("ClassExpression", node, opts);
		  },
		  assertClassImplements: function assertClassImplements(node, opts) {
			assert("ClassImplements", node, opts);
		  },
		  assertClassMethod: function assertClassMethod(node, opts) {
			assert("ClassMethod", node, opts);
		  },
		  assertClassPrivateMethod: function assertClassPrivateMethod(node, opts) {
			assert("ClassPrivateMethod", node, opts);
		  },
		  assertClassPrivateProperty: function assertClassPrivateProperty(node, opts) {
			assert("ClassPrivateProperty", node, opts);
		  },
		  assertClassProperty: function assertClassProperty(node, opts) {
			assert("ClassProperty", node, opts);
		  },
		  assertCompletionStatement: function assertCompletionStatement(node, opts) {
			assert("CompletionStatement", node, opts);
		  },
		  assertConditional: function assertConditional(node, opts) {
			assert("Conditional", node, opts);
		  },
		  assertConditionalExpression: function assertConditionalExpression(node, opts) {
			assert("ConditionalExpression", node, opts);
		  },
		  assertContinueStatement: function assertContinueStatement(node, opts) {
			assert("ContinueStatement", node, opts);
		  },
		  assertDebuggerStatement: function assertDebuggerStatement(node, opts) {
			assert("DebuggerStatement", node, opts);
		  },
		  assertDecimalLiteral: function assertDecimalLiteral(node, opts) {
			assert("DecimalLiteral", node, opts);
		  },
		  assertDeclaration: function assertDeclaration(node, opts) {
			assert("Declaration", node, opts);
		  },
		  assertDeclareClass: function assertDeclareClass(node, opts) {
			assert("DeclareClass", node, opts);
		  },
		  assertDeclareExportAllDeclaration: function assertDeclareExportAllDeclaration(node, opts) {
			assert("DeclareExportAllDeclaration", node, opts);
		  },
		  assertDeclareExportDeclaration: function assertDeclareExportDeclaration(node, opts) {
			assert("DeclareExportDeclaration", node, opts);
		  },
		  assertDeclareFunction: function assertDeclareFunction(node, opts) {
			assert("DeclareFunction", node, opts);
		  },
		  assertDeclareInterface: function assertDeclareInterface(node, opts) {
			assert("DeclareInterface", node, opts);
		  },
		  assertDeclareModule: function assertDeclareModule(node, opts) {
			assert("DeclareModule", node, opts);
		  },
		  assertDeclareModuleExports: function assertDeclareModuleExports(node, opts) {
			assert("DeclareModuleExports", node, opts);
		  },
		  assertDeclareOpaqueType: function assertDeclareOpaqueType(node, opts) {
			assert("DeclareOpaqueType", node, opts);
		  },
		  assertDeclareTypeAlias: function assertDeclareTypeAlias(node, opts) {
			assert("DeclareTypeAlias", node, opts);
		  },
		  assertDeclareVariable: function assertDeclareVariable(node, opts) {
			assert("DeclareVariable", node, opts);
		  },
		  assertDeclaredPredicate: function assertDeclaredPredicate(node, opts) {
			assert("DeclaredPredicate", node, opts);
		  },
		  assertDecorator: function assertDecorator(node, opts) {
			assert("Decorator", node, opts);
		  },
		  assertDirective: function assertDirective(node, opts) {
			assert("Directive", node, opts);
		  },
		  assertDirectiveLiteral: function assertDirectiveLiteral(node, opts) {
			assert("DirectiveLiteral", node, opts);
		  },
		  assertDoExpression: function assertDoExpression(node, opts) {
			assert("DoExpression", node, opts);
		  },
		  assertDoWhileStatement: function assertDoWhileStatement(node, opts) {
			assert("DoWhileStatement", node, opts);
		  },
		  assertEmptyStatement: function assertEmptyStatement(node, opts) {
			assert("EmptyStatement", node, opts);
		  },
		  assertEmptyTypeAnnotation: function assertEmptyTypeAnnotation(node, opts) {
			assert("EmptyTypeAnnotation", node, opts);
		  },
		  assertEnumBody: function assertEnumBody(node, opts) {
			assert("EnumBody", node, opts);
		  },
		  assertEnumBooleanBody: function assertEnumBooleanBody(node, opts) {
			assert("EnumBooleanBody", node, opts);
		  },
		  assertEnumBooleanMember: function assertEnumBooleanMember(node, opts) {
			assert("EnumBooleanMember", node, opts);
		  },
		  assertEnumDeclaration: function assertEnumDeclaration(node, opts) {
			assert("EnumDeclaration", node, opts);
		  },
		  assertEnumDefaultedMember: function assertEnumDefaultedMember(node, opts) {
			assert("EnumDefaultedMember", node, opts);
		  },
		  assertEnumMember: function assertEnumMember(node, opts) {
			assert("EnumMember", node, opts);
		  },
		  assertEnumNumberBody: function assertEnumNumberBody(node, opts) {
			assert("EnumNumberBody", node, opts);
		  },
		  assertEnumNumberMember: function assertEnumNumberMember(node, opts) {
			assert("EnumNumberMember", node, opts);
		  },
		  assertEnumStringBody: function assertEnumStringBody(node, opts) {
			assert("EnumStringBody", node, opts);
		  },
		  assertEnumStringMember: function assertEnumStringMember(node, opts) {
			assert("EnumStringMember", node, opts);
		  },
		  assertEnumSymbolBody: function assertEnumSymbolBody(node, opts) {
			assert("EnumSymbolBody", node, opts);
		  },
		  assertExistsTypeAnnotation: function assertExistsTypeAnnotation(node, opts) {
			assert("ExistsTypeAnnotation", node, opts);
		  },
		  assertExportAllDeclaration: function assertExportAllDeclaration(node, opts) {
			assert("ExportAllDeclaration", node, opts);
		  },
		  assertExportDeclaration: function assertExportDeclaration(node, opts) {
			assert("ExportDeclaration", node, opts);
		  },
		  assertExportDefaultDeclaration: function assertExportDefaultDeclaration(node, opts) {
			assert("ExportDefaultDeclaration", node, opts);
		  },
		  assertExportDefaultSpecifier: function assertExportDefaultSpecifier(node, opts) {
			assert("ExportDefaultSpecifier", node, opts);
		  },
		  assertExportNamedDeclaration: function assertExportNamedDeclaration(node, opts) {
			assert("ExportNamedDeclaration", node, opts);
		  },
		  assertExportNamespaceSpecifier: function assertExportNamespaceSpecifier(node, opts) {
			assert("ExportNamespaceSpecifier", node, opts);
		  },
		  assertExportSpecifier: function assertExportSpecifier(node, opts) {
			assert("ExportSpecifier", node, opts);
		  },
		  assertExpression: function assertExpression(node, opts) {
			assert("Expression", node, opts);
		  },
		  assertExpressionStatement: function assertExpressionStatement(node, opts) {
			assert("ExpressionStatement", node, opts);
		  },
		  assertExpressionWrapper: function assertExpressionWrapper(node, opts) {
			assert("ExpressionWrapper", node, opts);
		  },
		  assertFile: function assertFile(node, opts) {
			assert("File", node, opts);
		  },
		  assertFlow: function assertFlow(node, opts) {
			assert("Flow", node, opts);
		  },
		  assertFlowBaseAnnotation: function assertFlowBaseAnnotation(node, opts) {
			assert("FlowBaseAnnotation", node, opts);
		  },
		  assertFlowDeclaration: function assertFlowDeclaration(node, opts) {
			assert("FlowDeclaration", node, opts);
		  },
		  assertFlowPredicate: function assertFlowPredicate(node, opts) {
			assert("FlowPredicate", node, opts);
		  },
		  assertFlowType: function assertFlowType(node, opts) {
			assert("FlowType", node, opts);
		  },
		  assertFor: function assertFor(node, opts) {
			assert("For", node, opts);
		  },
		  assertForInStatement: function assertForInStatement(node, opts) {
			assert("ForInStatement", node, opts);
		  },
		  assertForOfStatement: function assertForOfStatement(node, opts) {
			assert("ForOfStatement", node, opts);
		  },
		  assertForStatement: function assertForStatement(node, opts) {
			assert("ForStatement", node, opts);
		  },
		  assertForXStatement: function assertForXStatement(node, opts) {
			assert("ForXStatement", node, opts);
		  },
		  assertFunction: function assertFunction(node, opts) {
			assert("Function", node, opts);
		  },
		  assertFunctionDeclaration: function assertFunctionDeclaration(node, opts) {
			assert("FunctionDeclaration", node, opts);
		  },
		  assertFunctionExpression: function assertFunctionExpression(node, opts) {
			assert("FunctionExpression", node, opts);
		  },
		  assertFunctionParent: function assertFunctionParent(node, opts) {
			assert("FunctionParent", node, opts);
		  },
		  assertFunctionTypeAnnotation: function assertFunctionTypeAnnotation(node, opts) {
			assert("FunctionTypeAnnotation", node, opts);
		  },
		  assertFunctionTypeParam: function assertFunctionTypeParam(node, opts) {
			assert("FunctionTypeParam", node, opts);
		  },
		  assertGenericTypeAnnotation: function assertGenericTypeAnnotation(node, opts) {
			assert("GenericTypeAnnotation", node, opts);
		  },
		  assertIdentifier: function assertIdentifier(node, opts) {
			assert("Identifier", node, opts);
		  },
		  assertIfStatement: function assertIfStatement(node, opts) {
			assert("IfStatement", node, opts);
		  },
		  assertImmutable: function assertImmutable(node, opts) {
			assert("Immutable", node, opts);
		  },
		  assertImport: function assertImport(node, opts) {
			assert("Import", node, opts);
		  },
		  assertImportAttribute: function assertImportAttribute(node, opts) {
			assert("ImportAttribute", node, opts);
		  },
		  assertImportDeclaration: function assertImportDeclaration(node, opts) {
			assert("ImportDeclaration", node, opts);
		  },
		  assertImportDefaultSpecifier: function assertImportDefaultSpecifier(node, opts) {
			assert("ImportDefaultSpecifier", node, opts);
		  },
		  assertImportExpression: function assertImportExpression(node, opts) {
			assert("ImportExpression", node, opts);
		  },
		  assertImportNamespaceSpecifier: function assertImportNamespaceSpecifier(node, opts) {
			assert("ImportNamespaceSpecifier", node, opts);
		  },
		  assertImportOrExportDeclaration: function assertImportOrExportDeclaration(node, opts) {
			assert("ImportOrExportDeclaration", node, opts);
		  },
		  assertImportSpecifier: function assertImportSpecifier(node, opts) {
			assert("ImportSpecifier", node, opts);
		  },
		  assertIndexedAccessType: function assertIndexedAccessType(node, opts) {
			assert("IndexedAccessType", node, opts);
		  },
		  assertInferredPredicate: function assertInferredPredicate(node, opts) {
			assert("InferredPredicate", node, opts);
		  },
		  assertInterfaceDeclaration: function assertInterfaceDeclaration(node, opts) {
			assert("InterfaceDeclaration", node, opts);
		  },
		  assertInterfaceExtends: function assertInterfaceExtends(node, opts) {
			assert("InterfaceExtends", node, opts);
		  },
		  assertInterfaceTypeAnnotation: function assertInterfaceTypeAnnotation(node, opts) {
			assert("InterfaceTypeAnnotation", node, opts);
		  },
		  assertInterpreterDirective: function assertInterpreterDirective(node, opts) {
			assert("InterpreterDirective", node, opts);
		  },
		  assertIntersectionTypeAnnotation: function assertIntersectionTypeAnnotation(node, opts) {
			assert("IntersectionTypeAnnotation", node, opts);
		  },
		  assertJSX: function assertJSX(node, opts) {
			assert("JSX", node, opts);
		  },
		  assertJSXAttribute: function assertJSXAttribute(node, opts) {
			assert("JSXAttribute", node, opts);
		  },
		  assertJSXClosingElement: function assertJSXClosingElement(node, opts) {
			assert("JSXClosingElement", node, opts);
		  },
		  assertJSXClosingFragment: function assertJSXClosingFragment(node, opts) {
			assert("JSXClosingFragment", node, opts);
		  },
		  assertJSXElement: function assertJSXElement(node, opts) {
			assert("JSXElement", node, opts);
		  },
		  assertJSXEmptyExpression: function assertJSXEmptyExpression(node, opts) {
			assert("JSXEmptyExpression", node, opts);
		  },
		  assertJSXExpressionContainer: function assertJSXExpressionContainer(node, opts) {
			assert("JSXExpressionContainer", node, opts);
		  },
		  assertJSXFragment: function assertJSXFragment(node, opts) {
			assert("JSXFragment", node, opts);
		  },
		  assertJSXIdentifier: function assertJSXIdentifier(node, opts) {
			assert("JSXIdentifier", node, opts);
		  },
		  assertJSXMemberExpression: function assertJSXMemberExpression(node, opts) {
			assert("JSXMemberExpression", node, opts);
		  },
		  assertJSXNamespacedName: function assertJSXNamespacedName(node, opts) {
			assert("JSXNamespacedName", node, opts);
		  },
		  assertJSXOpeningElement: function assertJSXOpeningElement(node, opts) {
			assert("JSXOpeningElement", node, opts);
		  },
		  assertJSXOpeningFragment: function assertJSXOpeningFragment(node, opts) {
			assert("JSXOpeningFragment", node, opts);
		  },
		  assertJSXSpreadAttribute: function assertJSXSpreadAttribute(node, opts) {
			assert("JSXSpreadAttribute", node, opts);
		  },
		  assertJSXSpreadChild: function assertJSXSpreadChild(node, opts) {
			assert("JSXSpreadChild", node, opts);
		  },
		  assertJSXText: function assertJSXText(node, opts) {
			assert("JSXText", node, opts);
		  },
		  assertLVal: function assertLVal(node, opts) {
			assert("LVal", node, opts);
		  },
		  assertLabeledStatement: function assertLabeledStatement(node, opts) {
			assert("LabeledStatement", node, opts);
		  },
		  assertLiteral: function assertLiteral(node, opts) {
			assert("Literal", node, opts);
		  },
		  assertLogicalExpression: function assertLogicalExpression(node, opts) {
			assert("LogicalExpression", node, opts);
		  },
		  assertLoop: function assertLoop(node, opts) {
			assert("Loop", node, opts);
		  },
		  assertMemberExpression: function assertMemberExpression(node, opts) {
			assert("MemberExpression", node, opts);
		  },
		  assertMetaProperty: function assertMetaProperty(node, opts) {
			assert("MetaProperty", node, opts);
		  },
		  assertMethod: function assertMethod(node, opts) {
			assert("Method", node, opts);
		  },
		  assertMiscellaneous: function assertMiscellaneous(node, opts) {
			assert("Miscellaneous", node, opts);
		  },
		  assertMixedTypeAnnotation: function assertMixedTypeAnnotation(node, opts) {
			assert("MixedTypeAnnotation", node, opts);
		  },
		  assertModuleDeclaration: function assertModuleDeclaration(node, opts) {
			(0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
			assert("ModuleDeclaration", node, opts);
		  },
		  assertModuleExpression: function assertModuleExpression(node, opts) {
			assert("ModuleExpression", node, opts);
		  },
		  assertModuleSpecifier: function assertModuleSpecifier(node, opts) {
			assert("ModuleSpecifier", node, opts);
		  },
		  assertNewExpression: function assertNewExpression(node, opts) {
			assert("NewExpression", node, opts);
		  },
		  assertNoop: function assertNoop(node, opts) {
			assert("Noop", node, opts);
		  },
		  assertNullLiteral: function assertNullLiteral(node, opts) {
			assert("NullLiteral", node, opts);
		  },
		  assertNullLiteralTypeAnnotation: function assertNullLiteralTypeAnnotation(node, opts) {
			assert("NullLiteralTypeAnnotation", node, opts);
		  },
		  assertNullableTypeAnnotation: function assertNullableTypeAnnotation(node, opts) {
			assert("NullableTypeAnnotation", node, opts);
		  },
		  assertNumberLiteral: function assertNumberLiteral(node, opts) {
			(0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
			assert("NumberLiteral", node, opts);
		  },
		  assertNumberLiteralTypeAnnotation: function assertNumberLiteralTypeAnnotation(node, opts) {
			assert("NumberLiteralTypeAnnotation", node, opts);
		  },
		  assertNumberTypeAnnotation: function assertNumberTypeAnnotation(node, opts) {
			assert("NumberTypeAnnotation", node, opts);
		  },
		  assertNumericLiteral: function assertNumericLiteral(node, opts) {
			assert("NumericLiteral", node, opts);
		  },
		  assertObjectExpression: function assertObjectExpression(node, opts) {
			assert("ObjectExpression", node, opts);
		  },
		  assertObjectMember: function assertObjectMember(node, opts) {
			assert("ObjectMember", node, opts);
		  },
		  assertObjectMethod: function assertObjectMethod(node, opts) {
			assert("ObjectMethod", node, opts);
		  },
		  assertObjectPattern: function assertObjectPattern(node, opts) {
			assert("ObjectPattern", node, opts);
		  },
		  assertObjectProperty: function assertObjectProperty(node, opts) {
			assert("ObjectProperty", node, opts);
		  },
		  assertObjectTypeAnnotation: function assertObjectTypeAnnotation(node, opts) {
			assert("ObjectTypeAnnotation", node, opts);
		  },
		  assertObjectTypeCallProperty: function assertObjectTypeCallProperty(node, opts) {
			assert("ObjectTypeCallProperty", node, opts);
		  },
		  assertObjectTypeIndexer: function assertObjectTypeIndexer(node, opts) {
			assert("ObjectTypeIndexer", node, opts);
		  },
		  assertObjectTypeInternalSlot: function assertObjectTypeInternalSlot(node, opts) {
			assert("ObjectTypeInternalSlot", node, opts);
		  },
		  assertObjectTypeProperty: function assertObjectTypeProperty(node, opts) {
			assert("ObjectTypeProperty", node, opts);
		  },
		  assertObjectTypeSpreadProperty: function assertObjectTypeSpreadProperty(node, opts) {
			assert("ObjectTypeSpreadProperty", node, opts);
		  },
		  assertOpaqueType: function assertOpaqueType(node, opts) {
			assert("OpaqueType", node, opts);
		  },
		  assertOptionalCallExpression: function assertOptionalCallExpression(node, opts) {
			assert("OptionalCallExpression", node, opts);
		  },
		  assertOptionalIndexedAccessType: function assertOptionalIndexedAccessType(node, opts) {
			assert("OptionalIndexedAccessType", node, opts);
		  },
		  assertOptionalMemberExpression: function assertOptionalMemberExpression(node, opts) {
			assert("OptionalMemberExpression", node, opts);
		  },
		  assertParenthesizedExpression: function assertParenthesizedExpression(node, opts) {
			assert("ParenthesizedExpression", node, opts);
		  },
		  assertPattern: function assertPattern(node, opts) {
			assert("Pattern", node, opts);
		  },
		  assertPatternLike: function assertPatternLike(node, opts) {
			assert("PatternLike", node, opts);
		  },
		  assertPipelineBareFunction: function assertPipelineBareFunction(node, opts) {
			assert("PipelineBareFunction", node, opts);
		  },
		  assertPipelinePrimaryTopicReference: function assertPipelinePrimaryTopicReference(node, opts) {
			assert("PipelinePrimaryTopicReference", node, opts);
		  },
		  assertPipelineTopicExpression: function assertPipelineTopicExpression(node, opts) {
			assert("PipelineTopicExpression", node, opts);
		  },
		  assertPlaceholder: function assertPlaceholder(node, opts) {
			assert("Placeholder", node, opts);
		  },
		  assertPrivate: function assertPrivate(node, opts) {
			assert("Private", node, opts);
		  },
		  assertPrivateName: function assertPrivateName(node, opts) {
			assert("PrivateName", node, opts);
		  },
		  assertProgram: function assertProgram(node, opts) {
			assert("Program", node, opts);
		  },
		  assertProperty: function assertProperty(node, opts) {
			assert("Property", node, opts);
		  },
		  assertPureish: function assertPureish(node, opts) {
			assert("Pureish", node, opts);
		  },
		  assertQualifiedTypeIdentifier: function assertQualifiedTypeIdentifier(node, opts) {
			assert("QualifiedTypeIdentifier", node, opts);
		  },
		  assertRecordExpression: function assertRecordExpression(node, opts) {
			assert("RecordExpression", node, opts);
		  },
		  assertRegExpLiteral: function assertRegExpLiteral(node, opts) {
			assert("RegExpLiteral", node, opts);
		  },
		  assertRegexLiteral: function assertRegexLiteral(node, opts) {
			(0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
			assert("RegexLiteral", node, opts);
		  },
		  assertRestElement: function assertRestElement(node, opts) {
			assert("RestElement", node, opts);
		  },
		  assertRestProperty: function assertRestProperty(node, opts) {
			(0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
			assert("RestProperty", node, opts);
		  },
		  assertReturnStatement: function assertReturnStatement(node, opts) {
			assert("ReturnStatement", node, opts);
		  },
		  assertScopable: function assertScopable(node, opts) {
			assert("Scopable", node, opts);
		  },
		  assertSequenceExpression: function assertSequenceExpression(node, opts) {
			assert("SequenceExpression", node, opts);
		  },
		  assertSpreadElement: function assertSpreadElement(node, opts) {
			assert("SpreadElement", node, opts);
		  },
		  assertSpreadProperty: function assertSpreadProperty(node, opts) {
			(0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
			assert("SpreadProperty", node, opts);
		  },
		  assertStandardized: function assertStandardized(node, opts) {
			assert("Standardized", node, opts);
		  },
		  assertStatement: function assertStatement(node, opts) {
			assert("Statement", node, opts);
		  },
		  assertStaticBlock: function assertStaticBlock(node, opts) {
			assert("StaticBlock", node, opts);
		  },
		  assertStringLiteral: function assertStringLiteral(node, opts) {
			assert("StringLiteral", node, opts);
		  },
		  assertStringLiteralTypeAnnotation: function assertStringLiteralTypeAnnotation(node, opts) {
			assert("StringLiteralTypeAnnotation", node, opts);
		  },
		  assertStringTypeAnnotation: function assertStringTypeAnnotation(node, opts) {
			assert("StringTypeAnnotation", node, opts);
		  },
		  assertSuper: function assertSuper(node, opts) {
			assert("Super", node, opts);
		  },
		  assertSwitchCase: function assertSwitchCase(node, opts) {
			assert("SwitchCase", node, opts);
		  },
		  assertSwitchStatement: function assertSwitchStatement(node, opts) {
			assert("SwitchStatement", node, opts);
		  },
		  assertSymbolTypeAnnotation: function assertSymbolTypeAnnotation(node, opts) {
			assert("SymbolTypeAnnotation", node, opts);
		  },
		  assertTSAnyKeyword: function assertTSAnyKeyword(node, opts) {
			assert("TSAnyKeyword", node, opts);
		  },
		  assertTSArrayType: function assertTSArrayType(node, opts) {
			assert("TSArrayType", node, opts);
		  },
		  assertTSAsExpression: function assertTSAsExpression(node, opts) {
			assert("TSAsExpression", node, opts);
		  },
		  assertTSBaseType: function assertTSBaseType(node, opts) {
			assert("TSBaseType", node, opts);
		  },
		  assertTSBigIntKeyword: function assertTSBigIntKeyword(node, opts) {
			assert("TSBigIntKeyword", node, opts);
		  },
		  assertTSBooleanKeyword: function assertTSBooleanKeyword(node, opts) {
			assert("TSBooleanKeyword", node, opts);
		  },
		  assertTSCallSignatureDeclaration: function assertTSCallSignatureDeclaration(node, opts) {
			assert("TSCallSignatureDeclaration", node, opts);
		  },
		  assertTSConditionalType: function assertTSConditionalType(node, opts) {
			assert("TSConditionalType", node, opts);
		  },
		  assertTSConstructSignatureDeclaration: function assertTSConstructSignatureDeclaration(node, opts) {
			assert("TSConstructSignatureDeclaration", node, opts);
		  },
		  assertTSConstructorType: function assertTSConstructorType(node, opts) {
			assert("TSConstructorType", node, opts);
		  },
		  assertTSDeclareFunction: function assertTSDeclareFunction(node, opts) {
			assert("TSDeclareFunction", node, opts);
		  },
		  assertTSDeclareMethod: function assertTSDeclareMethod(node, opts) {
			assert("TSDeclareMethod", node, opts);
		  },
		  assertTSEntityName: function assertTSEntityName(node, opts) {
			assert("TSEntityName", node, opts);
		  },
		  assertTSEnumDeclaration: function assertTSEnumDeclaration(node, opts) {
			assert("TSEnumDeclaration", node, opts);
		  },
		  assertTSEnumMember: function assertTSEnumMember(node, opts) {
			assert("TSEnumMember", node, opts);
		  },
		  assertTSExportAssignment: function assertTSExportAssignment(node, opts) {
			assert("TSExportAssignment", node, opts);
		  },
		  assertTSExpressionWithTypeArguments: function assertTSExpressionWithTypeArguments(node, opts) {
			assert("TSExpressionWithTypeArguments", node, opts);
		  },
		  assertTSExternalModuleReference: function assertTSExternalModuleReference(node, opts) {
			assert("TSExternalModuleReference", node, opts);
		  },
		  assertTSFunctionType: function assertTSFunctionType(node, opts) {
			assert("TSFunctionType", node, opts);
		  },
		  assertTSImportEqualsDeclaration: function assertTSImportEqualsDeclaration(node, opts) {
			assert("TSImportEqualsDeclaration", node, opts);
		  },
		  assertTSImportType: function assertTSImportType(node, opts) {
			assert("TSImportType", node, opts);
		  },
		  assertTSIndexSignature: function assertTSIndexSignature(node, opts) {
			assert("TSIndexSignature", node, opts);
		  },
		  assertTSIndexedAccessType: function assertTSIndexedAccessType(node, opts) {
			assert("TSIndexedAccessType", node, opts);
		  },
		  assertTSInferType: function assertTSInferType(node, opts) {
			assert("TSInferType", node, opts);
		  },
		  assertTSInstantiationExpression: function assertTSInstantiationExpression(node, opts) {
			assert("TSInstantiationExpression", node, opts);
		  },
		  assertTSInterfaceBody: function assertTSInterfaceBody(node, opts) {
			assert("TSInterfaceBody", node, opts);
		  },
		  assertTSInterfaceDeclaration: function assertTSInterfaceDeclaration(node, opts) {
			assert("TSInterfaceDeclaration", node, opts);
		  },
		  assertTSIntersectionType: function assertTSIntersectionType(node, opts) {
			assert("TSIntersectionType", node, opts);
		  },
		  assertTSIntrinsicKeyword: function assertTSIntrinsicKeyword(node, opts) {
			assert("TSIntrinsicKeyword", node, opts);
		  },
		  assertTSLiteralType: function assertTSLiteralType(node, opts) {
			assert("TSLiteralType", node, opts);
		  },
		  assertTSMappedType: function assertTSMappedType(node, opts) {
			assert("TSMappedType", node, opts);
		  },
		  assertTSMethodSignature: function assertTSMethodSignature(node, opts) {
			assert("TSMethodSignature", node, opts);
		  },
		  assertTSModuleBlock: function assertTSModuleBlock(node, opts) {
			assert("TSModuleBlock", node, opts);
		  },
		  assertTSModuleDeclaration: function assertTSModuleDeclaration(node, opts) {
			assert("TSModuleDeclaration", node, opts);
		  },
		  assertTSNamedTupleMember: function assertTSNamedTupleMember(node, opts) {
			assert("TSNamedTupleMember", node, opts);
		  },
		  assertTSNamespaceExportDeclaration: function assertTSNamespaceExportDeclaration(node, opts) {
			assert("TSNamespaceExportDeclaration", node, opts);
		  },
		  assertTSNeverKeyword: function assertTSNeverKeyword(node, opts) {
			assert("TSNeverKeyword", node, opts);
		  },
		  assertTSNonNullExpression: function assertTSNonNullExpression(node, opts) {
			assert("TSNonNullExpression", node, opts);
		  },
		  assertTSNullKeyword: function assertTSNullKeyword(node, opts) {
			assert("TSNullKeyword", node, opts);
		  },
		  assertTSNumberKeyword: function assertTSNumberKeyword(node, opts) {
			assert("TSNumberKeyword", node, opts);
		  },
		  assertTSObjectKeyword: function assertTSObjectKeyword(node, opts) {
			assert("TSObjectKeyword", node, opts);
		  },
		  assertTSOptionalType: function assertTSOptionalType(node, opts) {
			assert("TSOptionalType", node, opts);
		  },
		  assertTSParameterProperty: function assertTSParameterProperty(node, opts) {
			assert("TSParameterProperty", node, opts);
		  },
		  assertTSParenthesizedType: function assertTSParenthesizedType(node, opts) {
			assert("TSParenthesizedType", node, opts);
		  },
		  assertTSPropertySignature: function assertTSPropertySignature(node, opts) {
			assert("TSPropertySignature", node, opts);
		  },
		  assertTSQualifiedName: function assertTSQualifiedName(node, opts) {
			assert("TSQualifiedName", node, opts);
		  },
		  assertTSRestType: function assertTSRestType(node, opts) {
			assert("TSRestType", node, opts);
		  },
		  assertTSSatisfiesExpression: function assertTSSatisfiesExpression(node, opts) {
			assert("TSSatisfiesExpression", node, opts);
		  },
		  assertTSStringKeyword: function assertTSStringKeyword(node, opts) {
			assert("TSStringKeyword", node, opts);
		  },
		  assertTSSymbolKeyword: function assertTSSymbolKeyword(node, opts) {
			assert("TSSymbolKeyword", node, opts);
		  },
		  assertTSThisType: function assertTSThisType(node, opts) {
			assert("TSThisType", node, opts);
		  },
		  assertTSTupleType: function assertTSTupleType(node, opts) {
			assert("TSTupleType", node, opts);
		  },
		  assertTSType: function assertTSType(node, opts) {
			assert("TSType", node, opts);
		  },
		  assertTSTypeAliasDeclaration: function assertTSTypeAliasDeclaration(node, opts) {
			assert("TSTypeAliasDeclaration", node, opts);
		  },
		  assertTSTypeAnnotation: function assertTSTypeAnnotation(node, opts) {
			assert("TSTypeAnnotation", node, opts);
		  },
		  assertTSTypeAssertion: function assertTSTypeAssertion(node, opts) {
			assert("TSTypeAssertion", node, opts);
		  },
		  assertTSTypeElement: function assertTSTypeElement(node, opts) {
			assert("TSTypeElement", node, opts);
		  },
		  assertTSTypeLiteral: function assertTSTypeLiteral(node, opts) {
			assert("TSTypeLiteral", node, opts);
		  },
		  assertTSTypeOperator: function assertTSTypeOperator(node, opts) {
			assert("TSTypeOperator", node, opts);
		  },
		  assertTSTypeParameter: function assertTSTypeParameter(node, opts) {
			assert("TSTypeParameter", node, opts);
		  },
		  assertTSTypeParameterDeclaration: function assertTSTypeParameterDeclaration(node, opts) {
			assert("TSTypeParameterDeclaration", node, opts);
		  },
		  assertTSTypeParameterInstantiation: function assertTSTypeParameterInstantiation(node, opts) {
			assert("TSTypeParameterInstantiation", node, opts);
		  },
		  assertTSTypePredicate: function assertTSTypePredicate(node, opts) {
			assert("TSTypePredicate", node, opts);
		  },
		  assertTSTypeQuery: function assertTSTypeQuery(node, opts) {
			assert("TSTypeQuery", node, opts);
		  },
		  assertTSTypeReference: function assertTSTypeReference(node, opts) {
			assert("TSTypeReference", node, opts);
		  },
		  assertTSUndefinedKeyword: function assertTSUndefinedKeyword(node, opts) {
			assert("TSUndefinedKeyword", node, opts);
		  },
		  assertTSUnionType: function assertTSUnionType(node, opts) {
			assert("TSUnionType", node, opts);
		  },
		  assertTSUnknownKeyword: function assertTSUnknownKeyword(node, opts) {
			assert("TSUnknownKeyword", node, opts);
		  },
		  assertTSVoidKeyword: function assertTSVoidKeyword(node, opts) {
			assert("TSVoidKeyword", node, opts);
		  },
		  assertTaggedTemplateExpression: function assertTaggedTemplateExpression(node, opts) {
			assert("TaggedTemplateExpression", node, opts);
		  },
		  assertTemplateElement: function assertTemplateElement(node, opts) {
			assert("TemplateElement", node, opts);
		  },
		  assertTemplateLiteral: function assertTemplateLiteral(node, opts) {
			assert("TemplateLiteral", node, opts);
		  },
		  assertTerminatorless: function assertTerminatorless(node, opts) {
			assert("Terminatorless", node, opts);
		  },
		  assertThisExpression: function assertThisExpression(node, opts) {
			assert("ThisExpression", node, opts);
		  },
		  assertThisTypeAnnotation: function assertThisTypeAnnotation(node, opts) {
			assert("ThisTypeAnnotation", node, opts);
		  },
		  assertThrowStatement: function assertThrowStatement(node, opts) {
			assert("ThrowStatement", node, opts);
		  },
		  assertTopicReference: function assertTopicReference(node, opts) {
			assert("TopicReference", node, opts);
		  },
		  assertTryStatement: function assertTryStatement(node, opts) {
			assert("TryStatement", node, opts);
		  },
		  assertTupleExpression: function assertTupleExpression(node, opts) {
			assert("TupleExpression", node, opts);
		  },
		  assertTupleTypeAnnotation: function assertTupleTypeAnnotation(node, opts) {
			assert("TupleTypeAnnotation", node, opts);
		  },
		  assertTypeAlias: function assertTypeAlias(node, opts) {
			assert("TypeAlias", node, opts);
		  },
		  assertTypeAnnotation: function assertTypeAnnotation(node, opts) {
			assert("TypeAnnotation", node, opts);
		  },
		  assertTypeCastExpression: function assertTypeCastExpression(node, opts) {
			assert("TypeCastExpression", node, opts);
		  },
		  assertTypeParameter: function assertTypeParameter(node, opts) {
			assert("TypeParameter", node, opts);
		  },
		  assertTypeParameterDeclaration: function assertTypeParameterDeclaration(node, opts) {
			assert("TypeParameterDeclaration", node, opts);
		  },
		  assertTypeParameterInstantiation: function assertTypeParameterInstantiation(node, opts) {
			assert("TypeParameterInstantiation", node, opts);
		  },
		  assertTypeScript: function assertTypeScript(node, opts) {
			assert("TypeScript", node, opts);
		  },
		  assertTypeofTypeAnnotation: function assertTypeofTypeAnnotation(node, opts) {
			assert("TypeofTypeAnnotation", node, opts);
		  },
		  assertUnaryExpression: function assertUnaryExpression(node, opts) {
			assert("UnaryExpression", node, opts);
		  },
		  assertUnaryLike: function assertUnaryLike(node, opts) {
			assert("UnaryLike", node, opts);
		  },
		  assertUnionTypeAnnotation: function assertUnionTypeAnnotation(node, opts) {
			assert("UnionTypeAnnotation", node, opts);
		  },
		  assertUpdateExpression: function assertUpdateExpression(node, opts) {
			assert("UpdateExpression", node, opts);
		  },
		  assertUserWhitespacable: function assertUserWhitespacable(node, opts) {
			assert("UserWhitespacable", node, opts);
		  },
		  assertV8IntrinsicIdentifier: function assertV8IntrinsicIdentifier(node, opts) {
			assert("V8IntrinsicIdentifier", node, opts);
		  },
		  assertVariableDeclaration: function assertVariableDeclaration(node, opts) {
			assert("VariableDeclaration", node, opts);
		  },
		  assertVariableDeclarator: function assertVariableDeclarator(node, opts) {
			assert("VariableDeclarator", node, opts);
		  },
		  assertVariance: function assertVariance(node, opts) {
			assert("Variance", node, opts);
		  },
		  assertVoidTypeAnnotation: function assertVoidTypeAnnotation(node, opts) {
			assert("VoidTypeAnnotation", node, opts);
		  },
		  assertWhile: function assertWhile(node, opts) {
			assert("While", node, opts);
		  },
		  assertWhileStatement: function assertWhileStatement(node, opts) {
			assert("WhileStatement", node, opts);
		  },
		  assertWithStatement: function assertWithStatement(node, opts) {
			assert("WithStatement", node, opts);
		  },
		  assertYieldExpression: function assertYieldExpression(node, opts) {
			assert("YieldExpression", node, opts);
		  },
		  anyTypeAnnotation: function anyTypeAnnotation() {
			return {
			  type: "AnyTypeAnnotation"
			};
		  },
		  argumentPlaceholder: function argumentPlaceholder() {
			return {
			  type: "ArgumentPlaceholder"
			};
		  },
		  arrayExpression: function arrayExpression(elements = []) {
			return (0, _validateNode.default)({
			  type: "ArrayExpression",
			  elements
			});
		  },
		  arrayPattern: function arrayPattern(elements) {
			return (0, _validateNode.default)({
			  type: "ArrayPattern",
			  elements
			});
		  },
		  arrayTypeAnnotation: function arrayTypeAnnotation(elementType) {
			return (0, _validateNode.default)({
			  type: "ArrayTypeAnnotation",
			  elementType
			});
		  },
		  arrowFunctionExpression: function arrowFunctionExpression(params, body, async = false) {
			return (0, _validateNode.default)({
			  type: "ArrowFunctionExpression",
			  params,
			  body,
			  async,
			  expression: null
			});
		  },
		  assignmentExpression: function assignmentExpression(operator, left, right) {
			return (0, _validateNode.default)({
			  type: "AssignmentExpression",
			  operator,
			  left,
			  right
			});
		  },
		  assignmentPattern: function assignmentPattern(left, right) {
			return (0, _validateNode.default)({
			  type: "AssignmentPattern",
			  left,
			  right
			});
		  },
		  awaitExpression: function awaitExpression(argument) {
			return (0, _validateNode.default)({
			  type: "AwaitExpression",
			  argument
			});
		  },
		  bigIntLiteral: function bigIntLiteral(value) {
			return (0, _validateNode.default)({
			  type: "BigIntLiteral",
			  value
			});
		  },
		  binaryExpression: function binaryExpression(operator, left, right) {
			return (0, _validateNode.default)({
			  type: "BinaryExpression",
			  operator,
			  left,
			  right
			});
		  },
		  bindExpression: function bindExpression(object, callee) {
			return (0, _validateNode.default)({
			  type: "BindExpression",
			  object,
			  callee
			});
		  },
		  blockStatement: function blockStatement(body, directives = []) {
			return (0, _validateNode.default)({
			  type: "BlockStatement",
			  body,
			  directives
			});
		  },
		  booleanLiteral: function booleanLiteral(value) {
			return (0, _validateNode.default)({
			  type: "BooleanLiteral",
			  value
			});
		  },
		  booleanLiteralTypeAnnotation: function booleanLiteralTypeAnnotation(value) {
			return (0, _validateNode.default)({
			  type: "BooleanLiteralTypeAnnotation",
			  value
			});
		  },
		  booleanTypeAnnotation: function booleanTypeAnnotation() {
			return {
			  type: "BooleanTypeAnnotation"
			};
		  },
		  breakStatement: function breakStatement(label = null) {
			return (0, _validateNode.default)({
			  type: "BreakStatement",
			  label
			});
		  },
		  callExpression: function callExpression(callee, _arguments) {
			return (0, _validateNode.default)({
			  type: "CallExpression",
			  callee,
			  arguments: _arguments
			});
		  },
		  catchClause: function catchClause(param = null, body) {
			return (0, _validateNode.default)({
			  type: "CatchClause",
			  param,
			  body
			});
		  },
		  classAccessorProperty: function classAccessorProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
			return (0, _validateNode.default)({
			  type: "ClassAccessorProperty",
			  key,
			  value,
			  typeAnnotation,
			  decorators,
			  computed,
			  static: _static
			});
		  },
		  classBody: function classBody(body) {
			return (0, _validateNode.default)({
			  type: "ClassBody",
			  body
			});
		  },
		  classDeclaration: function classDeclaration(id = null, superClass = null, body, decorators = null) {
			return (0, _validateNode.default)({
			  type: "ClassDeclaration",
			  id,
			  superClass,
			  body,
			  decorators
			});
		  },
		  classExpression: function classExpression(id = null, superClass = null, body, decorators = null) {
			return (0, _validateNode.default)({
			  type: "ClassExpression",
			  id,
			  superClass,
			  body,
			  decorators
			});
		  },
		  classImplements: function classImplements(id, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "ClassImplements",
			  id,
			  typeParameters
			});
		  },
		  classMethod: function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
			return (0, _validateNode.default)({
			  type: "ClassMethod",
			  kind,
			  key,
			  params,
			  body,
			  computed,
			  static: _static,
			  generator,
			  async
			});
		  },
		  classPrivateMethod: function classPrivateMethod(kind = "method", key, params, body, _static = false) {
			return (0, _validateNode.default)({
			  type: "ClassPrivateMethod",
			  kind,
			  key,
			  params,
			  body,
			  static: _static
			});
		  },
		  classPrivateProperty: function classPrivateProperty(key, value = null, decorators = null, _static = false) {
			return (0, _validateNode.default)({
			  type: "ClassPrivateProperty",
			  key,
			  value,
			  decorators,
			  static: _static
			});
		  },
		  classProperty: function classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
			return (0, _validateNode.default)({
			  type: "ClassProperty",
			  key,
			  value,
			  typeAnnotation,
			  decorators,
			  computed,
			  static: _static
			});
		  },
		  conditionalExpression: function conditionalExpression(test, consequent, alternate) {
			return (0, _validateNode.default)({
			  type: "ConditionalExpression",
			  test,
			  consequent,
			  alternate
			});
		  },
		  continueStatement: function continueStatement(label = null) {
			return (0, _validateNode.default)({
			  type: "ContinueStatement",
			  label
			});
		  },
		  debuggerStatement: function debuggerStatement() {
			return {
			  type: "DebuggerStatement"
			};
		  },
		  decimalLiteral: function decimalLiteral(value) {
			return (0, _validateNode.default)({
			  type: "DecimalLiteral",
			  value
			});
		  },
		  declareClass: function declareClass(id, typeParameters = null, _extends = null, body) {
			return (0, _validateNode.default)({
			  type: "DeclareClass",
			  id,
			  typeParameters,
			  extends: _extends,
			  body
			});
		  },
		  declareExportAllDeclaration: function declareExportAllDeclaration(source) {
			return (0, _validateNode.default)({
			  type: "DeclareExportAllDeclaration",
			  source
			});
		  },
		  declareExportDeclaration: function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
			return (0, _validateNode.default)({
			  type: "DeclareExportDeclaration",
			  declaration,
			  specifiers,
			  source
			});
		  },
		  declareFunction: function declareFunction(id) {
			return (0, _validateNode.default)({
			  type: "DeclareFunction",
			  id
			});
		  },
		  declareInterface: function declareInterface(id, typeParameters = null, _extends = null, body) {
			return (0, _validateNode.default)({
			  type: "DeclareInterface",
			  id,
			  typeParameters,
			  extends: _extends,
			  body
			});
		  },
		  declareModule: function declareModule(id, body, kind = null) {
			return (0, _validateNode.default)({
			  type: "DeclareModule",
			  id,
			  body,
			  kind
			});
		  },
		  declareModuleExports: function declareModuleExports(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "DeclareModuleExports",
			  typeAnnotation
			});
		  },
		  declareOpaqueType: function declareOpaqueType(id, typeParameters = null, supertype = null) {
			return (0, _validateNode.default)({
			  type: "DeclareOpaqueType",
			  id,
			  typeParameters,
			  supertype
			});
		  },
		  declareTypeAlias: function declareTypeAlias(id, typeParameters = null, right) {
			return (0, _validateNode.default)({
			  type: "DeclareTypeAlias",
			  id,
			  typeParameters,
			  right
			});
		  },
		  declareVariable: function declareVariable(id) {
			return (0, _validateNode.default)({
			  type: "DeclareVariable",
			  id
			});
		  },
		  declaredPredicate: function declaredPredicate(value) {
			return (0, _validateNode.default)({
			  type: "DeclaredPredicate",
			  value
			});
		  },
		  decorator: function decorator(expression) {
			return (0, _validateNode.default)({
			  type: "Decorator",
			  expression
			});
		  },
		  directive: function directive(value) {
			return (0, _validateNode.default)({
			  type: "Directive",
			  value
			});
		  },
		  directiveLiteral: function directiveLiteral(value) {
			return (0, _validateNode.default)({
			  type: "DirectiveLiteral",
			  value
			});
		  },
		  doExpression: function doExpression(body, async = false) {
			return (0, _validateNode.default)({
			  type: "DoExpression",
			  body,
			  async
			});
		  },
		  doWhileStatement: function doWhileStatement(test, body) {
			return (0, _validateNode.default)({
			  type: "DoWhileStatement",
			  test,
			  body
			});
		  },
		  emptyStatement: function emptyStatement() {
			return {
			  type: "EmptyStatement"
			};
		  },
		  emptyTypeAnnotation: function emptyTypeAnnotation() {
			return {
			  type: "EmptyTypeAnnotation"
			};
		  },
		  enumBooleanBody: function enumBooleanBody(members) {
			return (0, _validateNode.default)({
			  type: "EnumBooleanBody",
			  members,
			  explicitType: null,
			  hasUnknownMembers: null
			});
		  },
		  enumBooleanMember: function enumBooleanMember(id) {
			return (0, _validateNode.default)({
			  type: "EnumBooleanMember",
			  id,
			  init: null
			});
		  },
		  enumDeclaration: function enumDeclaration(id, body) {
			return (0, _validateNode.default)({
			  type: "EnumDeclaration",
			  id,
			  body
			});
		  },
		  enumDefaultedMember: function enumDefaultedMember(id) {
			return (0, _validateNode.default)({
			  type: "EnumDefaultedMember",
			  id
			});
		  },
		  enumNumberBody: function enumNumberBody(members) {
			return (0, _validateNode.default)({
			  type: "EnumNumberBody",
			  members,
			  explicitType: null,
			  hasUnknownMembers: null
			});
		  },
		  enumNumberMember: function enumNumberMember(id, init) {
			return (0, _validateNode.default)({
			  type: "EnumNumberMember",
			  id,
			  init
			});
		  },
		  enumStringBody: function enumStringBody(members) {
			return (0, _validateNode.default)({
			  type: "EnumStringBody",
			  members,
			  explicitType: null,
			  hasUnknownMembers: null
			});
		  },
		  enumStringMember: function enumStringMember(id, init) {
			return (0, _validateNode.default)({
			  type: "EnumStringMember",
			  id,
			  init
			});
		  },
		  enumSymbolBody: function enumSymbolBody(members) {
			return (0, _validateNode.default)({
			  type: "EnumSymbolBody",
			  members,
			  hasUnknownMembers: null
			});
		  },
		  existsTypeAnnotation: function existsTypeAnnotation() {
			return {
			  type: "ExistsTypeAnnotation"
			};
		  },
		  exportAllDeclaration: function exportAllDeclaration(source) {
			return (0, _validateNode.default)({
			  type: "ExportAllDeclaration",
			  source
			});
		  },
		  exportDefaultDeclaration: function exportDefaultDeclaration(declaration) {
			return (0, _validateNode.default)({
			  type: "ExportDefaultDeclaration",
			  declaration
			});
		  },
		  exportDefaultSpecifier: function exportDefaultSpecifier(exported) {
			return (0, _validateNode.default)({
			  type: "ExportDefaultSpecifier",
			  exported
			});
		  },
		  exportNamedDeclaration: function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
			return (0, _validateNode.default)({
			  type: "ExportNamedDeclaration",
			  declaration,
			  specifiers,
			  source
			});
		  },
		  exportNamespaceSpecifier: function exportNamespaceSpecifier(exported) {
			return (0, _validateNode.default)({
			  type: "ExportNamespaceSpecifier",
			  exported
			});
		  },
		  exportSpecifier: function exportSpecifier(local, exported) {
			return (0, _validateNode.default)({
			  type: "ExportSpecifier",
			  local,
			  exported
			});
		  },
		  expressionStatement: function expressionStatement(expression) {
			return (0, _validateNode.default)({
			  type: "ExpressionStatement",
			  expression
			});
		  },
		  file: function file(program, comments = null, tokens = null) {
			return (0, _validateNode.default)({
			  type: "File",
			  program,
			  comments,
			  tokens
			});
		  },
		  forInStatement: function forInStatement(left, right, body) {
			return (0, _validateNode.default)({
			  type: "ForInStatement",
			  left,
			  right,
			  body
			});
		  },
		  forOfStatement: function forOfStatement(left, right, body, _await = false) {
			return (0, _validateNode.default)({
			  type: "ForOfStatement",
			  left,
			  right,
			  body,
			  await: _await
			});
		  },
		  forStatement: function forStatement(init = null, test = null, update = null, body) {
			return (0, _validateNode.default)({
			  type: "ForStatement",
			  init,
			  test,
			  update,
			  body
			});
		  },
		  functionDeclaration: function functionDeclaration(id = null, params, body, generator = false, async = false) {
			return (0, _validateNode.default)({
			  type: "FunctionDeclaration",
			  id,
			  params,
			  body,
			  generator,
			  async
			});
		  },
		  functionExpression: function functionExpression(id = null, params, body, generator = false, async = false) {
			return (0, _validateNode.default)({
			  type: "FunctionExpression",
			  id,
			  params,
			  body,
			  generator,
			  async
			});
		  },
		  functionTypeAnnotation: function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
			return (0, _validateNode.default)({
			  type: "FunctionTypeAnnotation",
			  typeParameters,
			  params,
			  rest,
			  returnType
			});
		  },
		  functionTypeParam: function functionTypeParam(name = null, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "FunctionTypeParam",
			  name,
			  typeAnnotation
			});
		  },
		  genericTypeAnnotation: function genericTypeAnnotation(id, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "GenericTypeAnnotation",
			  id,
			  typeParameters
			});
		  },
		  identifier: function identifier(name) {
			return (0, _validateNode.default)({
			  type: "Identifier",
			  name
			});
		  },
		  ifStatement: function ifStatement(test, consequent, alternate = null) {
			return (0, _validateNode.default)({
			  type: "IfStatement",
			  test,
			  consequent,
			  alternate
			});
		  },
		  import: function _import() {
			return {
			  type: "Import"
			};
		  },
		  importAttribute: function importAttribute(key, value) {
			return (0, _validateNode.default)({
			  type: "ImportAttribute",
			  key,
			  value
			});
		  },
		  importDeclaration: function importDeclaration(specifiers, source) {
			return (0, _validateNode.default)({
			  type: "ImportDeclaration",
			  specifiers,
			  source
			});
		  },
		  importDefaultSpecifier: function importDefaultSpecifier(local) {
			return (0, _validateNode.default)({
			  type: "ImportDefaultSpecifier",
			  local
			});
		  },
		  importExpression: function importExpression(source, options = null) {
			return (0, _validateNode.default)({
			  type: "ImportExpression",
			  source,
			  options
			});
		  },
		  importNamespaceSpecifier: function importNamespaceSpecifier(local) {
			return (0, _validateNode.default)({
			  type: "ImportNamespaceSpecifier",
			  local
			});
		  },
		  importSpecifier: function importSpecifier(local, imported) {
			return (0, _validateNode.default)({
			  type: "ImportSpecifier",
			  local,
			  imported
			});
		  },
		  indexedAccessType: function indexedAccessType(objectType, indexType) {
			return (0, _validateNode.default)({
			  type: "IndexedAccessType",
			  objectType,
			  indexType
			});
		  },
		  inferredPredicate: function inferredPredicate() {
			return {
			  type: "InferredPredicate"
			};
		  },
		  interfaceDeclaration: function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
			return (0, _validateNode.default)({
			  type: "InterfaceDeclaration",
			  id,
			  typeParameters,
			  extends: _extends,
			  body
			});
		  },
		  interfaceExtends: function interfaceExtends(id, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "InterfaceExtends",
			  id,
			  typeParameters
			});
		  },
		  interfaceTypeAnnotation: function interfaceTypeAnnotation(_extends = null, body) {
			return (0, _validateNode.default)({
			  type: "InterfaceTypeAnnotation",
			  extends: _extends,
			  body
			});
		  },
		  interpreterDirective: function interpreterDirective(value) {
			return (0, _validateNode.default)({
			  type: "InterpreterDirective",
			  value
			});
		  },
		  intersectionTypeAnnotation: function intersectionTypeAnnotation(types) {
			return (0, _validateNode.default)({
			  type: "IntersectionTypeAnnotation",
			  types
			});
		  },
		  jsxAttribute: function jsxAttribute(name, value = null) {
			return (0, _validateNode.default)({
			  type: "JSXAttribute",
			  name,
			  value
			});
		  },
		  jSXAttribute: function jsxAttribute(name, value = null) {
			return (0, _validateNode.default)({
			  type: "JSXAttribute",
			  name,
			  value
			});
		  },
		  jsxClosingElement: function jsxClosingElement(name) {
			return (0, _validateNode.default)({
			  type: "JSXClosingElement",
			  name
			});
		  },
		  jSXClosingElement: function jsxClosingElement(name) {
			return (0, _validateNode.default)({
			  type: "JSXClosingElement",
			  name
			});
		  },
		  jsxClosingFragment: function jsxClosingFragment() {
			return {
			  type: "JSXClosingFragment"
			};
		  },
		  jSXClosingFragment: function jsxClosingFragment() {
			return {
			  type: "JSXClosingFragment"
			};
		  },
		  jsxElement: function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
			return (0, _validateNode.default)({
			  type: "JSXElement",
			  openingElement,
			  closingElement,
			  children,
			  selfClosing
			});
		  },
		  jSXElement: function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
			return (0, _validateNode.default)({
			  type: "JSXElement",
			  openingElement,
			  closingElement,
			  children,
			  selfClosing
			});
		  },
		  jsxEmptyExpression: function jsxEmptyExpression() {
			return {
			  type: "JSXEmptyExpression"
			};
		  },
		  jSXEmptyExpression: function jsxEmptyExpression() {
			return {
			  type: "JSXEmptyExpression"
			};
		  },
		  jsxExpressionContainer: function jsxExpressionContainer(expression) {
			return (0, _validateNode.default)({
			  type: "JSXExpressionContainer",
			  expression
			});
		  },
		  jSXExpressionContainer: function jsxExpressionContainer(expression) {
			return (0, _validateNode.default)({
			  type: "JSXExpressionContainer",
			  expression
			});
		  },
		  jsxFragment: function jsxFragment(openingFragment, closingFragment, children) {
			return (0, _validateNode.default)({
			  type: "JSXFragment",
			  openingFragment,
			  closingFragment,
			  children
			});
		  },
		  jSXFragment: function jsxFragment(openingFragment, closingFragment, children) {
			return (0, _validateNode.default)({
			  type: "JSXFragment",
			  openingFragment,
			  closingFragment,
			  children
			});
		  },
		  jsxIdentifier: function jsxIdentifier(name) {
			return (0, _validateNode.default)({
			  type: "JSXIdentifier",
			  name
			});
		  },
		  jSXIdentifier: function jsxIdentifier(name) {
			return (0, _validateNode.default)({
			  type: "JSXIdentifier",
			  name
			});
		  },
		  jsxMemberExpression: function jsxMemberExpression(object, property) {
			return (0, _validateNode.default)({
			  type: "JSXMemberExpression",
			  object,
			  property
			});
		  },
		  jSXMemberExpression: function jsxMemberExpression(object, property) {
			return (0, _validateNode.default)({
			  type: "JSXMemberExpression",
			  object,
			  property
			});
		  },
		  jsxNamespacedName: function jsxNamespacedName(namespace, name) {
			return (0, _validateNode.default)({
			  type: "JSXNamespacedName",
			  namespace,
			  name
			});
		  },
		  jSXNamespacedName: function jsxNamespacedName(namespace, name) {
			return (0, _validateNode.default)({
			  type: "JSXNamespacedName",
			  namespace,
			  name
			});
		  },
		  jsxOpeningElement: function jsxOpeningElement(name, attributes, selfClosing = false) {
			return (0, _validateNode.default)({
			  type: "JSXOpeningElement",
			  name,
			  attributes,
			  selfClosing
			});
		  },
		  jSXOpeningElement: function jsxOpeningElement(name, attributes, selfClosing = false) {
			return (0, _validateNode.default)({
			  type: "JSXOpeningElement",
			  name,
			  attributes,
			  selfClosing
			});
		  },
		  jsxOpeningFragment: function jsxOpeningFragment() {
			return {
			  type: "JSXOpeningFragment"
			};
		  },
		  jSXOpeningFragment: function jsxOpeningFragment() {
			return {
			  type: "JSXOpeningFragment"
			};
		  },
		  jsxSpreadAttribute: function jsxSpreadAttribute(argument) {
			return (0, _validateNode.default)({
			  type: "JSXSpreadAttribute",
			  argument
			});
		  },
		  jSXSpreadAttribute: function jsxSpreadAttribute(argument) {
			return (0, _validateNode.default)({
			  type: "JSXSpreadAttribute",
			  argument
			});
		  },
		  jsxSpreadChild: function jsxSpreadChild(expression) {
			return (0, _validateNode.default)({
			  type: "JSXSpreadChild",
			  expression
			});
		  },
		  jSXSpreadChild: function jsxSpreadChild(expression) {
			return (0, _validateNode.default)({
			  type: "JSXSpreadChild",
			  expression
			});
		  },
		  jsxText: function jsxText(value) {
			return (0, _validateNode.default)({
			  type: "JSXText",
			  value
			});
		  },
		  jSXText: function jsxText(value) {
			return (0, _validateNode.default)({
			  type: "JSXText",
			  value
			});
		  },
		  labeledStatement: function labeledStatement(label, body) {
			return (0, _validateNode.default)({
			  type: "LabeledStatement",
			  label,
			  body
			});
		  },
		  logicalExpression: function logicalExpression(operator, left, right) {
			return (0, _validateNode.default)({
			  type: "LogicalExpression",
			  operator,
			  left,
			  right
			});
		  },
		  memberExpression: function memberExpression(object, property, computed = false, optional = null) {
			return (0, _validateNode.default)({
			  type: "MemberExpression",
			  object,
			  property,
			  computed,
			  optional
			});
		  },
		  metaProperty: function metaProperty(meta, property) {
			return (0, _validateNode.default)({
			  type: "MetaProperty",
			  meta,
			  property
			});
		  },
		  mixedTypeAnnotation: function mixedTypeAnnotation() {
			return {
			  type: "MixedTypeAnnotation"
			};
		  },
		  moduleExpression: function moduleExpression(body) {
			return (0, _validateNode.default)({
			  type: "ModuleExpression",
			  body
			});
		  },
		  newExpression: function newExpression(callee, _arguments) {
			return (0, _validateNode.default)({
			  type: "NewExpression",
			  callee,
			  arguments: _arguments
			});
		  },
		  noop: function noop() {
			return {
			  type: "Noop"
			};
		  },
		  nullLiteral: function nullLiteral() {
			return {
			  type: "NullLiteral"
			};
		  },
		  nullLiteralTypeAnnotation: function nullLiteralTypeAnnotation() {
			return {
			  type: "NullLiteralTypeAnnotation"
			};
		  },
		  nullableTypeAnnotation: function nullableTypeAnnotation(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "NullableTypeAnnotation",
			  typeAnnotation
			});
		  },
		  numberLiteral: function NumberLiteral(value) {
			(0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
			return numericLiteral(value);
		  },
		  numberLiteralTypeAnnotation: function numberLiteralTypeAnnotation(value) {
			return (0, _validateNode.default)({
			  type: "NumberLiteralTypeAnnotation",
			  value
			});
		  },
		  numberTypeAnnotation: function numberTypeAnnotation() {
			return {
			  type: "NumberTypeAnnotation"
			};
		  },
		  numericLiteral: function numericLiteral(value) {
			return (0, _validateNode.default)({
			  type: "NumericLiteral",
			  value
			});
		  },
		  objectExpression: function objectExpression(properties) {
			return (0, _validateNode.default)({
			  type: "ObjectExpression",
			  properties
			});
		  },
		  objectMethod: function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
			return (0, _validateNode.default)({
			  type: "ObjectMethod",
			  kind,
			  key,
			  params,
			  body,
			  computed,
			  generator,
			  async
			});
		  },
		  objectPattern: function objectPattern(properties) {
			return (0, _validateNode.default)({
			  type: "ObjectPattern",
			  properties
			});
		  },
		  objectProperty: function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
			return (0, _validateNode.default)({
			  type: "ObjectProperty",
			  key,
			  value,
			  computed,
			  shorthand,
			  decorators
			});
		  },
		  objectTypeAnnotation: function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeAnnotation",
			  properties,
			  indexers,
			  callProperties,
			  internalSlots,
			  exact
			});
		  },
		  objectTypeCallProperty: function objectTypeCallProperty(value) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeCallProperty",
			  value,
			  static: null
			});
		  },
		  objectTypeIndexer: function objectTypeIndexer(id = null, key, value, variance = null) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeIndexer",
			  id,
			  key,
			  value,
			  variance,
			  static: null
			});
		  },
		  objectTypeInternalSlot: function objectTypeInternalSlot(id, value, optional, _static, method) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeInternalSlot",
			  id,
			  value,
			  optional,
			  static: _static,
			  method
			});
		  },
		  objectTypeProperty: function objectTypeProperty(key, value, variance = null) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeProperty",
			  key,
			  value,
			  variance,
			  kind: null,
			  method: null,
			  optional: null,
			  proto: null,
			  static: null
			});
		  },
		  objectTypeSpreadProperty: function objectTypeSpreadProperty(argument) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeSpreadProperty",
			  argument
			});
		  },
		  opaqueType: function opaqueType(id, typeParameters = null, supertype = null, impltype) {
			return (0, _validateNode.default)({
			  type: "OpaqueType",
			  id,
			  typeParameters,
			  supertype,
			  impltype
			});
		  },
		  optionalCallExpression: function optionalCallExpression(callee, _arguments, optional) {
			return (0, _validateNode.default)({
			  type: "OptionalCallExpression",
			  callee,
			  arguments: _arguments,
			  optional
			});
		  },
		  optionalIndexedAccessType: function optionalIndexedAccessType(objectType, indexType) {
			return (0, _validateNode.default)({
			  type: "OptionalIndexedAccessType",
			  objectType,
			  indexType,
			  optional: null
			});
		  },
		  optionalMemberExpression: function optionalMemberExpression(object, property, computed = false, optional) {
			return (0, _validateNode.default)({
			  type: "OptionalMemberExpression",
			  object,
			  property,
			  computed,
			  optional
			});
		  },
		  parenthesizedExpression: function parenthesizedExpression(expression) {
			return (0, _validateNode.default)({
			  type: "ParenthesizedExpression",
			  expression
			});
		  },
		  pipelineBareFunction: function pipelineBareFunction(callee) {
			return (0, _validateNode.default)({
			  type: "PipelineBareFunction",
			  callee
			});
		  },
		  pipelinePrimaryTopicReference: function pipelinePrimaryTopicReference() {
			return {
			  type: "PipelinePrimaryTopicReference"
			};
		  },
		  pipelineTopicExpression: function pipelineTopicExpression(expression) {
			return (0, _validateNode.default)({
			  type: "PipelineTopicExpression",
			  expression
			});
		  },
		  placeholder: function placeholder(expectedNode, name) {
			return (0, _validateNode.default)({
			  type: "Placeholder",
			  expectedNode,
			  name
			});
		  },
		  privateName: function privateName(id) {
			return (0, _validateNode.default)({
			  type: "PrivateName",
			  id
			});
		  },
		  program: function program(body, directives = [], sourceType = "script", interpreter = null) {
			return (0, _validateNode.default)({
			  type: "Program",
			  body,
			  directives,
			  sourceType,
			  interpreter
			});
		  },
		  qualifiedTypeIdentifier: function qualifiedTypeIdentifier(id, qualification) {
			return (0, _validateNode.default)({
			  type: "QualifiedTypeIdentifier",
			  id,
			  qualification
			});
		  },
		  recordExpression: function recordExpression(properties) {
			return (0, _validateNode.default)({
			  type: "RecordExpression",
			  properties
			});
		  },
		  regExpLiteral: function regExpLiteral(pattern, flags = "") {
			return (0, _validateNode.default)({
			  type: "RegExpLiteral",
			  pattern,
			  flags
			});
		  },
		  regexLiteral: function RegexLiteral(pattern, flags = "") {
			(0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
			return regExpLiteral(pattern, flags);
		  },
		  restElement: function restElement(argument) {
			return (0, _validateNode.default)({
			  type: "RestElement",
			  argument
			});
		  },
		  restProperty: function RestProperty(argument) {
			(0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
			return restElement(argument);
		  },
		  returnStatement: function returnStatement(argument = null) {
			return (0, _validateNode.default)({
			  type: "ReturnStatement",
			  argument
			});
		  },
		  sequenceExpression: function sequenceExpression(expressions) {
			return (0, _validateNode.default)({
			  type: "SequenceExpression",
			  expressions
			});
		  },
		  spreadElement: function spreadElement(argument) {
			return (0, _validateNode.default)({
			  type: "SpreadElement",
			  argument
			});
		  },
		  spreadProperty: function SpreadProperty(argument) {
			(0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
			return spreadElement(argument);
		  },
		  staticBlock: function staticBlock(body) {
			return (0, _validateNode.default)({
			  type: "StaticBlock",
			  body
			});
		  },
		  stringLiteral: function stringLiteral(value) {
			return (0, _validateNode.default)({
			  type: "StringLiteral",
			  value
			});
		  },
		  stringLiteralTypeAnnotation: function stringLiteralTypeAnnotation(value) {
			return (0, _validateNode.default)({
			  type: "StringLiteralTypeAnnotation",
			  value
			});
		  },
		  stringTypeAnnotation: function stringTypeAnnotation() {
			return {
			  type: "StringTypeAnnotation"
			};
		  },
		  super: function _super() {
			return {
			  type: "Super"
			};
		  },
		  switchCase: function switchCase(test = null, consequent) {
			return (0, _validateNode.default)({
			  type: "SwitchCase",
			  test,
			  consequent
			});
		  },
		  switchStatement: function switchStatement(discriminant, cases) {
			return (0, _validateNode.default)({
			  type: "SwitchStatement",
			  discriminant,
			  cases
			});
		  },
		  symbolTypeAnnotation: function symbolTypeAnnotation() {
			return {
			  type: "SymbolTypeAnnotation"
			};
		  },
		  taggedTemplateExpression: function taggedTemplateExpression(tag, quasi) {
			return (0, _validateNode.default)({
			  type: "TaggedTemplateExpression",
			  tag,
			  quasi
			});
		  },
		  templateElement: function templateElement(value, tail = false) {
			return (0, _validateNode.default)({
			  type: "TemplateElement",
			  value,
			  tail
			});
		  },
		  templateLiteral: function templateLiteral(quasis, expressions) {
			return (0, _validateNode.default)({
			  type: "TemplateLiteral",
			  quasis,
			  expressions
			});
		  },
		  thisExpression: function thisExpression() {
			return {
			  type: "ThisExpression"
			};
		  },
		  thisTypeAnnotation: function thisTypeAnnotation() {
			return {
			  type: "ThisTypeAnnotation"
			};
		  },
		  throwStatement: function throwStatement(argument) {
			return (0, _validateNode.default)({
			  type: "ThrowStatement",
			  argument
			});
		  },
		  topicReference: function topicReference() {
			return {
			  type: "TopicReference"
			};
		  },
		  tryStatement: function tryStatement(block, handler = null, finalizer = null) {
			return (0, _validateNode.default)({
			  type: "TryStatement",
			  block,
			  handler,
			  finalizer
			});
		  },
		  tsAnyKeyword: function tsAnyKeyword() {
			return {
			  type: "TSAnyKeyword"
			};
		  },
		  tSAnyKeyword: function tsAnyKeyword() {
			return {
			  type: "TSAnyKeyword"
			};
		  },
		  tsArrayType: function tsArrayType(elementType) {
			return (0, _validateNode.default)({
			  type: "TSArrayType",
			  elementType
			});
		  },
		  tSArrayType: function tsArrayType(elementType) {
			return (0, _validateNode.default)({
			  type: "TSArrayType",
			  elementType
			});
		  },
		  tsAsExpression: function tsAsExpression(expression, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSAsExpression",
			  expression,
			  typeAnnotation
			});
		  },
		  tSAsExpression: function tsAsExpression(expression, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSAsExpression",
			  expression,
			  typeAnnotation
			});
		  },
		  tsBigIntKeyword: function tsBigIntKeyword() {
			return {
			  type: "TSBigIntKeyword"
			};
		  },
		  tSBigIntKeyword: function tsBigIntKeyword() {
			return {
			  type: "TSBigIntKeyword"
			};
		  },
		  tsBooleanKeyword: function tsBooleanKeyword() {
			return {
			  type: "TSBooleanKeyword"
			};
		  },
		  tSBooleanKeyword: function tsBooleanKeyword() {
			return {
			  type: "TSBooleanKeyword"
			};
		  },
		  tsCallSignatureDeclaration: function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSCallSignatureDeclaration",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  tSCallSignatureDeclaration: function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSCallSignatureDeclaration",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  tsConditionalType: function tsConditionalType(checkType, extendsType, trueType, falseType) {
			return (0, _validateNode.default)({
			  type: "TSConditionalType",
			  checkType,
			  extendsType,
			  trueType,
			  falseType
			});
		  },
		  tSConditionalType: function tsConditionalType(checkType, extendsType, trueType, falseType) {
			return (0, _validateNode.default)({
			  type: "TSConditionalType",
			  checkType,
			  extendsType,
			  trueType,
			  falseType
			});
		  },
		  tsConstructSignatureDeclaration: function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSConstructSignatureDeclaration",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  tSConstructSignatureDeclaration: function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSConstructSignatureDeclaration",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  tsConstructorType: function tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSConstructorType",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  tSConstructorType: function tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSConstructorType",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  tsDeclareFunction: function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
			return (0, _validateNode.default)({
			  type: "TSDeclareFunction",
			  id,
			  typeParameters,
			  params,
			  returnType
			});
		  },
		  tSDeclareFunction: function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
			return (0, _validateNode.default)({
			  type: "TSDeclareFunction",
			  id,
			  typeParameters,
			  params,
			  returnType
			});
		  },
		  tsDeclareMethod: function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
			return (0, _validateNode.default)({
			  type: "TSDeclareMethod",
			  decorators,
			  key,
			  typeParameters,
			  params,
			  returnType
			});
		  },
		  tSDeclareMethod: function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
			return (0, _validateNode.default)({
			  type: "TSDeclareMethod",
			  decorators,
			  key,
			  typeParameters,
			  params,
			  returnType
			});
		  },
		  tsEnumDeclaration: function tsEnumDeclaration(id, members) {
			return (0, _validateNode.default)({
			  type: "TSEnumDeclaration",
			  id,
			  members
			});
		  },
		  tSEnumDeclaration: function tsEnumDeclaration(id, members) {
			return (0, _validateNode.default)({
			  type: "TSEnumDeclaration",
			  id,
			  members
			});
		  },
		  tsEnumMember: function tsEnumMember(id, initializer = null) {
			return (0, _validateNode.default)({
			  type: "TSEnumMember",
			  id,
			  initializer
			});
		  },
		  tSEnumMember: function tsEnumMember(id, initializer = null) {
			return (0, _validateNode.default)({
			  type: "TSEnumMember",
			  id,
			  initializer
			});
		  },
		  tsExportAssignment: function tsExportAssignment(expression) {
			return (0, _validateNode.default)({
			  type: "TSExportAssignment",
			  expression
			});
		  },
		  tSExportAssignment: function tsExportAssignment(expression) {
			return (0, _validateNode.default)({
			  type: "TSExportAssignment",
			  expression
			});
		  },
		  tsExpressionWithTypeArguments: function tsExpressionWithTypeArguments(expression, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSExpressionWithTypeArguments",
			  expression,
			  typeParameters
			});
		  },
		  tSExpressionWithTypeArguments: function tsExpressionWithTypeArguments(expression, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSExpressionWithTypeArguments",
			  expression,
			  typeParameters
			});
		  },
		  tsExternalModuleReference: function tsExternalModuleReference(expression) {
			return (0, _validateNode.default)({
			  type: "TSExternalModuleReference",
			  expression
			});
		  },
		  tSExternalModuleReference: function tsExternalModuleReference(expression) {
			return (0, _validateNode.default)({
			  type: "TSExternalModuleReference",
			  expression
			});
		  },
		  tsFunctionType: function tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSFunctionType",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  tSFunctionType: function tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSFunctionType",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  tsImportEqualsDeclaration: function tsImportEqualsDeclaration(id, moduleReference) {
			return (0, _validateNode.default)({
			  type: "TSImportEqualsDeclaration",
			  id,
			  moduleReference,
			  isExport: null
			});
		  },
		  tSImportEqualsDeclaration: function tsImportEqualsDeclaration(id, moduleReference) {
			return (0, _validateNode.default)({
			  type: "TSImportEqualsDeclaration",
			  id,
			  moduleReference,
			  isExport: null
			});
		  },
		  tsImportType: function tsImportType(argument, qualifier = null, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSImportType",
			  argument,
			  qualifier,
			  typeParameters
			});
		  },
		  tSImportType: function tsImportType(argument, qualifier = null, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSImportType",
			  argument,
			  qualifier,
			  typeParameters
			});
		  },
		  tsIndexSignature: function tsIndexSignature(parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSIndexSignature",
			  parameters,
			  typeAnnotation
			});
		  },
		  tSIndexSignature: function tsIndexSignature(parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSIndexSignature",
			  parameters,
			  typeAnnotation
			});
		  },
		  tsIndexedAccessType: function tsIndexedAccessType(objectType, indexType) {
			return (0, _validateNode.default)({
			  type: "TSIndexedAccessType",
			  objectType,
			  indexType
			});
		  },
		  tSIndexedAccessType: function tsIndexedAccessType(objectType, indexType) {
			return (0, _validateNode.default)({
			  type: "TSIndexedAccessType",
			  objectType,
			  indexType
			});
		  },
		  tsInferType: function tsInferType(typeParameter) {
			return (0, _validateNode.default)({
			  type: "TSInferType",
			  typeParameter
			});
		  },
		  tSInferType: function tsInferType(typeParameter) {
			return (0, _validateNode.default)({
			  type: "TSInferType",
			  typeParameter
			});
		  },
		  tsInstantiationExpression: function tsInstantiationExpression(expression, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSInstantiationExpression",
			  expression,
			  typeParameters
			});
		  },
		  tSInstantiationExpression: function tsInstantiationExpression(expression, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSInstantiationExpression",
			  expression,
			  typeParameters
			});
		  },
		  tsInterfaceBody: function tsInterfaceBody(body) {
			return (0, _validateNode.default)({
			  type: "TSInterfaceBody",
			  body
			});
		  },
		  tSInterfaceBody: function tsInterfaceBody(body) {
			return (0, _validateNode.default)({
			  type: "TSInterfaceBody",
			  body
			});
		  },
		  tsInterfaceDeclaration: function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
			return (0, _validateNode.default)({
			  type: "TSInterfaceDeclaration",
			  id,
			  typeParameters,
			  extends: _extends,
			  body
			});
		  },
		  tSInterfaceDeclaration: function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
			return (0, _validateNode.default)({
			  type: "TSInterfaceDeclaration",
			  id,
			  typeParameters,
			  extends: _extends,
			  body
			});
		  },
		  tsIntersectionType: function tsIntersectionType(types) {
			return (0, _validateNode.default)({
			  type: "TSIntersectionType",
			  types
			});
		  },
		  tSIntersectionType: function tsIntersectionType(types) {
			return (0, _validateNode.default)({
			  type: "TSIntersectionType",
			  types
			});
		  },
		  tsIntrinsicKeyword: function tsIntrinsicKeyword() {
			return {
			  type: "TSIntrinsicKeyword"
			};
		  },
		  tSIntrinsicKeyword: function tsIntrinsicKeyword() {
			return {
			  type: "TSIntrinsicKeyword"
			};
		  },
		  tsLiteralType: function tsLiteralType(literal) {
			return (0, _validateNode.default)({
			  type: "TSLiteralType",
			  literal
			});
		  },
		  tSLiteralType: function tsLiteralType(literal) {
			return (0, _validateNode.default)({
			  type: "TSLiteralType",
			  literal
			});
		  },
		  tsMappedType: function tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {
			return (0, _validateNode.default)({
			  type: "TSMappedType",
			  typeParameter,
			  typeAnnotation,
			  nameType
			});
		  },
		  tSMappedType: function tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {
			return (0, _validateNode.default)({
			  type: "TSMappedType",
			  typeParameter,
			  typeAnnotation,
			  nameType
			});
		  },
		  tsMethodSignature: function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSMethodSignature",
			  key,
			  typeParameters,
			  parameters,
			  typeAnnotation,
			  kind: null
			});
		  },
		  tSMethodSignature: function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSMethodSignature",
			  key,
			  typeParameters,
			  parameters,
			  typeAnnotation,
			  kind: null
			});
		  },
		  tsModuleBlock: function tsModuleBlock(body) {
			return (0, _validateNode.default)({
			  type: "TSModuleBlock",
			  body
			});
		  },
		  tSModuleBlock: function tsModuleBlock(body) {
			return (0, _validateNode.default)({
			  type: "TSModuleBlock",
			  body
			});
		  },
		  tsModuleDeclaration: function tsModuleDeclaration(id, body) {
			return (0, _validateNode.default)({
			  type: "TSModuleDeclaration",
			  id,
			  body
			});
		  },
		  tSModuleDeclaration: function tsModuleDeclaration(id, body) {
			return (0, _validateNode.default)({
			  type: "TSModuleDeclaration",
			  id,
			  body
			});
		  },
		  tsNamedTupleMember: function tsNamedTupleMember(label, elementType, optional = false) {
			return (0, _validateNode.default)({
			  type: "TSNamedTupleMember",
			  label,
			  elementType,
			  optional
			});
		  },
		  tSNamedTupleMember: function tsNamedTupleMember(label, elementType, optional = false) {
			return (0, _validateNode.default)({
			  type: "TSNamedTupleMember",
			  label,
			  elementType,
			  optional
			});
		  },
		  tsNamespaceExportDeclaration: function tsNamespaceExportDeclaration(id) {
			return (0, _validateNode.default)({
			  type: "TSNamespaceExportDeclaration",
			  id
			});
		  },
		  tSNamespaceExportDeclaration: function tsNamespaceExportDeclaration(id) {
			return (0, _validateNode.default)({
			  type: "TSNamespaceExportDeclaration",
			  id
			});
		  },
		  tsNeverKeyword: function tsNeverKeyword() {
			return {
			  type: "TSNeverKeyword"
			};
		  },
		  tSNeverKeyword: function tsNeverKeyword() {
			return {
			  type: "TSNeverKeyword"
			};
		  },
		  tsNonNullExpression: function tsNonNullExpression(expression) {
			return (0, _validateNode.default)({
			  type: "TSNonNullExpression",
			  expression
			});
		  },
		  tSNonNullExpression: function tsNonNullExpression(expression) {
			return (0, _validateNode.default)({
			  type: "TSNonNullExpression",
			  expression
			});
		  },
		  tsNullKeyword: function tsNullKeyword() {
			return {
			  type: "TSNullKeyword"
			};
		  },
		  tSNullKeyword: function tsNullKeyword() {
			return {
			  type: "TSNullKeyword"
			};
		  },
		  tsNumberKeyword: function tsNumberKeyword() {
			return {
			  type: "TSNumberKeyword"
			};
		  },
		  tSNumberKeyword: function tsNumberKeyword() {
			return {
			  type: "TSNumberKeyword"
			};
		  },
		  tsObjectKeyword: function tsObjectKeyword() {
			return {
			  type: "TSObjectKeyword"
			};
		  },
		  tSObjectKeyword: function tsObjectKeyword() {
			return {
			  type: "TSObjectKeyword"
			};
		  },
		  tsOptionalType: function tsOptionalType(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSOptionalType",
			  typeAnnotation
			});
		  },
		  tSOptionalType: function tsOptionalType(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSOptionalType",
			  typeAnnotation
			});
		  },
		  tsParameterProperty: function tsParameterProperty(parameter) {
			return (0, _validateNode.default)({
			  type: "TSParameterProperty",
			  parameter
			});
		  },
		  tSParameterProperty: function tsParameterProperty(parameter) {
			return (0, _validateNode.default)({
			  type: "TSParameterProperty",
			  parameter
			});
		  },
		  tsParenthesizedType: function tsParenthesizedType(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSParenthesizedType",
			  typeAnnotation
			});
		  },
		  tSParenthesizedType: function tsParenthesizedType(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSParenthesizedType",
			  typeAnnotation
			});
		  },
		  tsPropertySignature: function tsPropertySignature(key, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSPropertySignature",
			  key,
			  typeAnnotation,
			  kind: null
			});
		  },
		  tSPropertySignature: function tsPropertySignature(key, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSPropertySignature",
			  key,
			  typeAnnotation,
			  kind: null
			});
		  },
		  tsQualifiedName: function tsQualifiedName(left, right) {
			return (0, _validateNode.default)({
			  type: "TSQualifiedName",
			  left,
			  right
			});
		  },
		  tSQualifiedName: function tsQualifiedName(left, right) {
			return (0, _validateNode.default)({
			  type: "TSQualifiedName",
			  left,
			  right
			});
		  },
		  tsRestType: function tsRestType(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSRestType",
			  typeAnnotation
			});
		  },
		  tSRestType: function tsRestType(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSRestType",
			  typeAnnotation
			});
		  },
		  tsSatisfiesExpression: function tsSatisfiesExpression(expression, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSSatisfiesExpression",
			  expression,
			  typeAnnotation
			});
		  },
		  tSSatisfiesExpression: function tsSatisfiesExpression(expression, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSSatisfiesExpression",
			  expression,
			  typeAnnotation
			});
		  },
		  tsStringKeyword: function tsStringKeyword() {
			return {
			  type: "TSStringKeyword"
			};
		  },
		  tSStringKeyword: function tsStringKeyword() {
			return {
			  type: "TSStringKeyword"
			};
		  },
		  tsSymbolKeyword: function tsSymbolKeyword() {
			return {
			  type: "TSSymbolKeyword"
			};
		  },
		  tSSymbolKeyword: function tsSymbolKeyword() {
			return {
			  type: "TSSymbolKeyword"
			};
		  },
		  tsThisType: function tsThisType() {
			return {
			  type: "TSThisType"
			};
		  },
		  tSThisType: function tsThisType() {
			return {
			  type: "TSThisType"
			};
		  },
		  tsTupleType: function tsTupleType(elementTypes) {
			return (0, _validateNode.default)({
			  type: "TSTupleType",
			  elementTypes
			});
		  },
		  tSTupleType: function tsTupleType(elementTypes) {
			return (0, _validateNode.default)({
			  type: "TSTupleType",
			  elementTypes
			});
		  },
		  tsTypeAliasDeclaration: function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSTypeAliasDeclaration",
			  id,
			  typeParameters,
			  typeAnnotation
			});
		  },
		  tSTypeAliasDeclaration: function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSTypeAliasDeclaration",
			  id,
			  typeParameters,
			  typeAnnotation
			});
		  },
		  tsTypeAnnotation: function tsTypeAnnotation(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSTypeAnnotation",
			  typeAnnotation
			});
		  },
		  tSTypeAnnotation: function tsTypeAnnotation(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSTypeAnnotation",
			  typeAnnotation
			});
		  },
		  tsTypeAssertion: function tsTypeAssertion(typeAnnotation, expression) {
			return (0, _validateNode.default)({
			  type: "TSTypeAssertion",
			  typeAnnotation,
			  expression
			});
		  },
		  tSTypeAssertion: function tsTypeAssertion(typeAnnotation, expression) {
			return (0, _validateNode.default)({
			  type: "TSTypeAssertion",
			  typeAnnotation,
			  expression
			});
		  },
		  tsTypeLiteral: function tsTypeLiteral(members) {
			return (0, _validateNode.default)({
			  type: "TSTypeLiteral",
			  members
			});
		  },
		  tSTypeLiteral: function tsTypeLiteral(members) {
			return (0, _validateNode.default)({
			  type: "TSTypeLiteral",
			  members
			});
		  },
		  tsTypeOperator: function tsTypeOperator(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSTypeOperator",
			  typeAnnotation,
			  operator: null
			});
		  },
		  tSTypeOperator: function tsTypeOperator(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSTypeOperator",
			  typeAnnotation,
			  operator: null
			});
		  },
		  tsTypeParameter: function tsTypeParameter(constraint = null, _default = null, name) {
			return (0, _validateNode.default)({
			  type: "TSTypeParameter",
			  constraint,
			  default: _default,
			  name
			});
		  },
		  tSTypeParameter: function tsTypeParameter(constraint = null, _default = null, name) {
			return (0, _validateNode.default)({
			  type: "TSTypeParameter",
			  constraint,
			  default: _default,
			  name
			});
		  },
		  tsTypeParameterDeclaration: function tsTypeParameterDeclaration(params) {
			return (0, _validateNode.default)({
			  type: "TSTypeParameterDeclaration",
			  params
			});
		  },
		  tSTypeParameterDeclaration: function tsTypeParameterDeclaration(params) {
			return (0, _validateNode.default)({
			  type: "TSTypeParameterDeclaration",
			  params
			});
		  },
		  tsTypeParameterInstantiation: function tsTypeParameterInstantiation(params) {
			return (0, _validateNode.default)({
			  type: "TSTypeParameterInstantiation",
			  params
			});
		  },
		  tSTypeParameterInstantiation: function tsTypeParameterInstantiation(params) {
			return (0, _validateNode.default)({
			  type: "TSTypeParameterInstantiation",
			  params
			});
		  },
		  tsTypePredicate: function tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {
			return (0, _validateNode.default)({
			  type: "TSTypePredicate",
			  parameterName,
			  typeAnnotation,
			  asserts
			});
		  },
		  tSTypePredicate: function tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {
			return (0, _validateNode.default)({
			  type: "TSTypePredicate",
			  parameterName,
			  typeAnnotation,
			  asserts
			});
		  },
		  tsTypeQuery: function tsTypeQuery(exprName, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSTypeQuery",
			  exprName,
			  typeParameters
			});
		  },
		  tSTypeQuery: function tsTypeQuery(exprName, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSTypeQuery",
			  exprName,
			  typeParameters
			});
		  },
		  tsTypeReference: function tsTypeReference(typeName, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSTypeReference",
			  typeName,
			  typeParameters
			});
		  },
		  tSTypeReference: function tsTypeReference(typeName, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSTypeReference",
			  typeName,
			  typeParameters
			});
		  },
		  tsUndefinedKeyword: function tsUndefinedKeyword() {
			return {
			  type: "TSUndefinedKeyword"
			};
		  },
		  tSUndefinedKeyword: function tsUndefinedKeyword() {
			return {
			  type: "TSUndefinedKeyword"
			};
		  },
		  tsUnionType: function tsUnionType(types) {
			return (0, _validateNode.default)({
			  type: "TSUnionType",
			  types
			});
		  },
		  tSUnionType: function tsUnionType(types) {
			return (0, _validateNode.default)({
			  type: "TSUnionType",
			  types
			});
		  },
		  tsUnknownKeyword: function tsUnknownKeyword() {
			return {
			  type: "TSUnknownKeyword"
			};
		  },
		  tSUnknownKeyword: function tsUnknownKeyword() {
			return {
			  type: "TSUnknownKeyword"
			};
		  },
		  tsVoidKeyword: function tsVoidKeyword() {
			return {
			  type: "TSVoidKeyword"
			};
		  },
		  tSVoidKeyword: function tsVoidKeyword() {
			return {
			  type: "TSVoidKeyword"
			};
		  },
		  tupleExpression: function tupleExpression(elements = []) {
			return (0, _validateNode.default)({
			  type: "TupleExpression",
			  elements
			});
		  },
		  tupleTypeAnnotation: function tupleTypeAnnotation(types) {
			return (0, _validateNode.default)({
			  type: "TupleTypeAnnotation",
			  types
			});
		  },
		  typeAlias: function typeAlias(id, typeParameters = null, right) {
			return (0, _validateNode.default)({
			  type: "TypeAlias",
			  id,
			  typeParameters,
			  right
			});
		  },
		  typeAnnotation: function typeAnnotation(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TypeAnnotation",
			  typeAnnotation
			});
		  },
		  typeCastExpression: function typeCastExpression(expression, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TypeCastExpression",
			  expression,
			  typeAnnotation
			});
		  },
		  typeParameter: function typeParameter(bound = null, _default = null, variance = null) {
			return (0, _validateNode.default)({
			  type: "TypeParameter",
			  bound,
			  default: _default,
			  variance,
			  name: null
			});
		  },
		  typeParameterDeclaration: function typeParameterDeclaration(params) {
			return (0, _validateNode.default)({
			  type: "TypeParameterDeclaration",
			  params
			});
		  },
		  typeParameterInstantiation: function typeParameterInstantiation(params) {
			return (0, _validateNode.default)({
			  type: "TypeParameterInstantiation",
			  params
			});
		  },
		  typeofTypeAnnotation: function typeofTypeAnnotation(argument) {
			return (0, _validateNode.default)({
			  type: "TypeofTypeAnnotation",
			  argument
			});
		  },
		  unaryExpression: function unaryExpression(operator, argument, prefix = true) {
			return (0, _validateNode.default)({
			  type: "UnaryExpression",
			  operator,
			  argument,
			  prefix
			});
		  },
		  unionTypeAnnotation: function unionTypeAnnotation(types) {
			return (0, _validateNode.default)({
			  type: "UnionTypeAnnotation",
			  types
			});
		  },
		  updateExpression: function updateExpression(operator, argument, prefix = false) {
			return (0, _validateNode.default)({
			  type: "UpdateExpression",
			  operator,
			  argument,
			  prefix
			});
		  },
		  v8IntrinsicIdentifier: function v8IntrinsicIdentifier(name) {
			return (0, _validateNode.default)({
			  type: "V8IntrinsicIdentifier",
			  name
			});
		  },
		  variableDeclaration: function variableDeclaration(kind, declarations) {
			return (0, _validateNode.default)({
			  type: "VariableDeclaration",
			  kind,
			  declarations
			});
		  },
		  variableDeclarator: function variableDeclarator(id, init = null) {
			return (0, _validateNode.default)({
			  type: "VariableDeclarator",
			  id,
			  init
			});
		  },
		  variance: function variance(kind) {
			return (0, _validateNode.default)({
			  type: "Variance",
			  kind
			});
		  },
		  voidTypeAnnotation: function voidTypeAnnotation() {
			return {
			  type: "VoidTypeAnnotation"
			};
		  },
		  whileStatement: function whileStatement(test, body) {
			return (0, _validateNode.default)({
			  type: "WhileStatement",
			  test,
			  body
			});
		  },
		  withStatement: function withStatement(object, body) {
			return (0, _validateNode.default)({
			  type: "WithStatement",
			  object,
			  body
			});
		  },
		  yieldExpression: function yieldExpression(argument = null, delegate = false) {
			return (0, _validateNode.default)({
			  type: "YieldExpression",
			  argument,
			  delegate
			});
		  },
		  AnyTypeAnnotation: function anyTypeAnnotation() {
			return {
			  type: "AnyTypeAnnotation"
			};
		  },
		  ArgumentPlaceholder: function argumentPlaceholder() {
			return {
			  type: "ArgumentPlaceholder"
			};
		  },
		  ArrayExpression: function arrayExpression(elements = []) {
			return (0, _validateNode.default)({
			  type: "ArrayExpression",
			  elements
			});
		  },
		  ArrayPattern: function arrayPattern(elements) {
			return (0, _validateNode.default)({
			  type: "ArrayPattern",
			  elements
			});
		  },
		  ArrayTypeAnnotation: function arrayTypeAnnotation(elementType) {
			return (0, _validateNode.default)({
			  type: "ArrayTypeAnnotation",
			  elementType
			});
		  },
		  ArrowFunctionExpression: function arrowFunctionExpression(params, body, async = false) {
			return (0, _validateNode.default)({
			  type: "ArrowFunctionExpression",
			  params,
			  body,
			  async,
			  expression: null
			});
		  },
		  AssignmentExpression: function assignmentExpression(operator, left, right) {
			return (0, _validateNode.default)({
			  type: "AssignmentExpression",
			  operator,
			  left,
			  right
			});
		  },
		  AssignmentPattern: function assignmentPattern(left, right) {
			return (0, _validateNode.default)({
			  type: "AssignmentPattern",
			  left,
			  right
			});
		  },
		  AwaitExpression: function awaitExpression(argument) {
			return (0, _validateNode.default)({
			  type: "AwaitExpression",
			  argument
			});
		  },
		  BigIntLiteral: function bigIntLiteral(value) {
			return (0, _validateNode.default)({
			  type: "BigIntLiteral",
			  value
			});
		  },
		  BinaryExpression: function binaryExpression(operator, left, right) {
			return (0, _validateNode.default)({
			  type: "BinaryExpression",
			  operator,
			  left,
			  right
			});
		  },
		  BindExpression: function bindExpression(object, callee) {
			return (0, _validateNode.default)({
			  type: "BindExpression",
			  object,
			  callee
			});
		  },
		  BlockStatement: function blockStatement(body, directives = []) {
			return (0, _validateNode.default)({
			  type: "BlockStatement",
			  body,
			  directives
			});
		  },
		  BooleanLiteral: function booleanLiteral(value) {
			return (0, _validateNode.default)({
			  type: "BooleanLiteral",
			  value
			});
		  },
		  BooleanLiteralTypeAnnotation: function booleanLiteralTypeAnnotation(value) {
			return (0, _validateNode.default)({
			  type: "BooleanLiteralTypeAnnotation",
			  value
			});
		  },
		  BooleanTypeAnnotation: function booleanTypeAnnotation() {
			return {
			  type: "BooleanTypeAnnotation"
			};
		  },
		  BreakStatement: function breakStatement(label = null) {
			return (0, _validateNode.default)({
			  type: "BreakStatement",
			  label
			});
		  },
		  CallExpression: function callExpression(callee, _arguments) {
			return (0, _validateNode.default)({
			  type: "CallExpression",
			  callee,
			  arguments: _arguments
			});
		  },
		  CatchClause: function catchClause(param = null, body) {
			return (0, _validateNode.default)({
			  type: "CatchClause",
			  param,
			  body
			});
		  },
		  ClassAccessorProperty: function classAccessorProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
			return (0, _validateNode.default)({
			  type: "ClassAccessorProperty",
			  key,
			  value,
			  typeAnnotation,
			  decorators,
			  computed,
			  static: _static
			});
		  },
		  ClassBody: function classBody(body) {
			return (0, _validateNode.default)({
			  type: "ClassBody",
			  body
			});
		  },
		  ClassDeclaration: function classDeclaration(id = null, superClass = null, body, decorators = null) {
			return (0, _validateNode.default)({
			  type: "ClassDeclaration",
			  id,
			  superClass,
			  body,
			  decorators
			});
		  },
		  ClassExpression: function classExpression(id = null, superClass = null, body, decorators = null) {
			return (0, _validateNode.default)({
			  type: "ClassExpression",
			  id,
			  superClass,
			  body,
			  decorators
			});
		  },
		  ClassImplements: function classImplements(id, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "ClassImplements",
			  id,
			  typeParameters
			});
		  },
		  ClassMethod: function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
			return (0, _validateNode.default)({
			  type: "ClassMethod",
			  kind,
			  key,
			  params,
			  body,
			  computed,
			  static: _static,
			  generator,
			  async
			});
		  },
		  ClassPrivateMethod: function classPrivateMethod(kind = "method", key, params, body, _static = false) {
			return (0, _validateNode.default)({
			  type: "ClassPrivateMethod",
			  kind,
			  key,
			  params,
			  body,
			  static: _static
			});
		  },
		  ClassPrivateProperty: function classPrivateProperty(key, value = null, decorators = null, _static = false) {
			return (0, _validateNode.default)({
			  type: "ClassPrivateProperty",
			  key,
			  value,
			  decorators,
			  static: _static
			});
		  },
		  ClassProperty: function classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
			return (0, _validateNode.default)({
			  type: "ClassProperty",
			  key,
			  value,
			  typeAnnotation,
			  decorators,
			  computed,
			  static: _static
			});
		  },
		  ConditionalExpression: function conditionalExpression(test, consequent, alternate) {
			return (0, _validateNode.default)({
			  type: "ConditionalExpression",
			  test,
			  consequent,
			  alternate
			});
		  },
		  ContinueStatement: function continueStatement(label = null) {
			return (0, _validateNode.default)({
			  type: "ContinueStatement",
			  label
			});
		  },
		  DebuggerStatement: function debuggerStatement() {
			return {
			  type: "DebuggerStatement"
			};
		  },
		  DecimalLiteral: function decimalLiteral(value) {
			return (0, _validateNode.default)({
			  type: "DecimalLiteral",
			  value
			});
		  },
		  DeclareClass: function declareClass(id, typeParameters = null, _extends = null, body) {
			return (0, _validateNode.default)({
			  type: "DeclareClass",
			  id,
			  typeParameters,
			  extends: _extends,
			  body
			});
		  },
		  DeclareExportAllDeclaration: function declareExportAllDeclaration(source) {
			return (0, _validateNode.default)({
			  type: "DeclareExportAllDeclaration",
			  source
			});
		  },
		  DeclareExportDeclaration: function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
			return (0, _validateNode.default)({
			  type: "DeclareExportDeclaration",
			  declaration,
			  specifiers,
			  source
			});
		  },
		  DeclareFunction: function declareFunction(id) {
			return (0, _validateNode.default)({
			  type: "DeclareFunction",
			  id
			});
		  },
		  DeclareInterface: function declareInterface(id, typeParameters = null, _extends = null, body) {
			return (0, _validateNode.default)({
			  type: "DeclareInterface",
			  id,
			  typeParameters,
			  extends: _extends,
			  body
			});
		  },
		  DeclareModule: function declareModule(id, body, kind = null) {
			return (0, _validateNode.default)({
			  type: "DeclareModule",
			  id,
			  body,
			  kind
			});
		  },
		  DeclareModuleExports: function declareModuleExports(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "DeclareModuleExports",
			  typeAnnotation
			});
		  },
		  DeclareOpaqueType: function declareOpaqueType(id, typeParameters = null, supertype = null) {
			return (0, _validateNode.default)({
			  type: "DeclareOpaqueType",
			  id,
			  typeParameters,
			  supertype
			});
		  },
		  DeclareTypeAlias: function declareTypeAlias(id, typeParameters = null, right) {
			return (0, _validateNode.default)({
			  type: "DeclareTypeAlias",
			  id,
			  typeParameters,
			  right
			});
		  },
		  DeclareVariable: function declareVariable(id) {
			return (0, _validateNode.default)({
			  type: "DeclareVariable",
			  id
			});
		  },
		  DeclaredPredicate: function declaredPredicate(value) {
			return (0, _validateNode.default)({
			  type: "DeclaredPredicate",
			  value
			});
		  },
		  Decorator: function decorator(expression) {
			return (0, _validateNode.default)({
			  type: "Decorator",
			  expression
			});
		  },
		  Directive: function directive(value) {
			return (0, _validateNode.default)({
			  type: "Directive",
			  value
			});
		  },
		  DirectiveLiteral: function directiveLiteral(value) {
			return (0, _validateNode.default)({
			  type: "DirectiveLiteral",
			  value
			});
		  },
		  DoExpression: function doExpression(body, async = false) {
			return (0, _validateNode.default)({
			  type: "DoExpression",
			  body,
			  async
			});
		  },
		  DoWhileStatement: function doWhileStatement(test, body) {
			return (0, _validateNode.default)({
			  type: "DoWhileStatement",
			  test,
			  body
			});
		  },
		  EmptyStatement: function emptyStatement() {
			return {
			  type: "EmptyStatement"
			};
		  },
		  EmptyTypeAnnotation: function emptyTypeAnnotation() {
			return {
			  type: "EmptyTypeAnnotation"
			};
		  },
		  EnumBooleanBody: function enumBooleanBody(members) {
			return (0, _validateNode.default)({
			  type: "EnumBooleanBody",
			  members,
			  explicitType: null,
			  hasUnknownMembers: null
			});
		  },
		  EnumBooleanMember: function enumBooleanMember(id) {
			return (0, _validateNode.default)({
			  type: "EnumBooleanMember",
			  id,
			  init: null
			});
		  },
		  EnumDeclaration: function enumDeclaration(id, body) {
			return (0, _validateNode.default)({
			  type: "EnumDeclaration",
			  id,
			  body
			});
		  },
		  EnumDefaultedMember: function enumDefaultedMember(id) {
			return (0, _validateNode.default)({
			  type: "EnumDefaultedMember",
			  id
			});
		  },
		  EnumNumberBody: function enumNumberBody(members) {
			return (0, _validateNode.default)({
			  type: "EnumNumberBody",
			  members,
			  explicitType: null,
			  hasUnknownMembers: null
			});
		  },
		  EnumNumberMember: function enumNumberMember(id, init) {
			return (0, _validateNode.default)({
			  type: "EnumNumberMember",
			  id,
			  init
			});
		  },
		  EnumStringBody: function enumStringBody(members) {
			return (0, _validateNode.default)({
			  type: "EnumStringBody",
			  members,
			  explicitType: null,
			  hasUnknownMembers: null
			});
		  },
		  EnumStringMember: function enumStringMember(id, init) {
			return (0, _validateNode.default)({
			  type: "EnumStringMember",
			  id,
			  init
			});
		  },
		  EnumSymbolBody: function enumSymbolBody(members) {
			return (0, _validateNode.default)({
			  type: "EnumSymbolBody",
			  members,
			  hasUnknownMembers: null
			});
		  },
		  ExistsTypeAnnotation: function existsTypeAnnotation() {
			return {
			  type: "ExistsTypeAnnotation"
			};
		  },
		  ExportAllDeclaration: function exportAllDeclaration(source) {
			return (0, _validateNode.default)({
			  type: "ExportAllDeclaration",
			  source
			});
		  },
		  ExportDefaultDeclaration: function exportDefaultDeclaration(declaration) {
			return (0, _validateNode.default)({
			  type: "ExportDefaultDeclaration",
			  declaration
			});
		  },
		  ExportDefaultSpecifier: function exportDefaultSpecifier(exported) {
			return (0, _validateNode.default)({
			  type: "ExportDefaultSpecifier",
			  exported
			});
		  },
		  ExportNamedDeclaration: function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
			return (0, _validateNode.default)({
			  type: "ExportNamedDeclaration",
			  declaration,
			  specifiers,
			  source
			});
		  },
		  ExportNamespaceSpecifier: function exportNamespaceSpecifier(exported) {
			return (0, _validateNode.default)({
			  type: "ExportNamespaceSpecifier",
			  exported
			});
		  },
		  ExportSpecifier: function exportSpecifier(local, exported) {
			return (0, _validateNode.default)({
			  type: "ExportSpecifier",
			  local,
			  exported
			});
		  },
		  ExpressionStatement: function expressionStatement(expression) {
			return (0, _validateNode.default)({
			  type: "ExpressionStatement",
			  expression
			});
		  },
		  File: function file(program, comments = null, tokens = null) {
			return (0, _validateNode.default)({
			  type: "File",
			  program,
			  comments,
			  tokens
			});
		  },
		  ForInStatement: function forInStatement(left, right, body) {
			return (0, _validateNode.default)({
			  type: "ForInStatement",
			  left,
			  right,
			  body
			});
		  },
		  ForOfStatement: function forOfStatement(left, right, body, _await = false) {
			return (0, _validateNode.default)({
			  type: "ForOfStatement",
			  left,
			  right,
			  body,
			  await: _await
			});
		  },
		  ForStatement: function forStatement(init = null, test = null, update = null, body) {
			return (0, _validateNode.default)({
			  type: "ForStatement",
			  init,
			  test,
			  update,
			  body
			});
		  },
		  FunctionDeclaration: function functionDeclaration(id = null, params, body, generator = false, async = false) {
			return (0, _validateNode.default)({
			  type: "FunctionDeclaration",
			  id,
			  params,
			  body,
			  generator,
			  async
			});
		  },
		  FunctionExpression: function functionExpression(id = null, params, body, generator = false, async = false) {
			return (0, _validateNode.default)({
			  type: "FunctionExpression",
			  id,
			  params,
			  body,
			  generator,
			  async
			});
		  },
		  FunctionTypeAnnotation: function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
			return (0, _validateNode.default)({
			  type: "FunctionTypeAnnotation",
			  typeParameters,
			  params,
			  rest,
			  returnType
			});
		  },
		  FunctionTypeParam: function functionTypeParam(name = null, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "FunctionTypeParam",
			  name,
			  typeAnnotation
			});
		  },
		  GenericTypeAnnotation: function genericTypeAnnotation(id, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "GenericTypeAnnotation",
			  id,
			  typeParameters
			});
		  },
		  Identifier: function identifier(name) {
			return (0, _validateNode.default)({
			  type: "Identifier",
			  name
			});
		  },
		  IfStatement: function ifStatement(test, consequent, alternate = null) {
			return (0, _validateNode.default)({
			  type: "IfStatement",
			  test,
			  consequent,
			  alternate
			});
		  },
		  Import: function _import() {
			return {
			  type: "Import"
			};
		  },
		  ImportAttribute: function importAttribute(key, value) {
			return (0, _validateNode.default)({
			  type: "ImportAttribute",
			  key,
			  value
			});
		  },
		  ImportDeclaration: function importDeclaration(specifiers, source) {
			return (0, _validateNode.default)({
			  type: "ImportDeclaration",
			  specifiers,
			  source
			});
		  },
		  ImportDefaultSpecifier: function importDefaultSpecifier(local) {
			return (0, _validateNode.default)({
			  type: "ImportDefaultSpecifier",
			  local
			});
		  },
		  ImportExpression: function importExpression(source, options = null) {
			return (0, _validateNode.default)({
			  type: "ImportExpression",
			  source,
			  options
			});
		  },
		  ImportNamespaceSpecifier: function importNamespaceSpecifier(local) {
			return (0, _validateNode.default)({
			  type: "ImportNamespaceSpecifier",
			  local
			});
		  },
		  ImportSpecifier: function importSpecifier(local, imported) {
			return (0, _validateNode.default)({
			  type: "ImportSpecifier",
			  local,
			  imported
			});
		  },
		  IndexedAccessType: function indexedAccessType(objectType, indexType) {
			return (0, _validateNode.default)({
			  type: "IndexedAccessType",
			  objectType,
			  indexType
			});
		  },
		  InferredPredicate: function inferredPredicate() {
			return {
			  type: "InferredPredicate"
			};
		  },
		  InterfaceDeclaration: function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
			return (0, _validateNode.default)({
			  type: "InterfaceDeclaration",
			  id,
			  typeParameters,
			  extends: _extends,
			  body
			});
		  },
		  InterfaceExtends: function interfaceExtends(id, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "InterfaceExtends",
			  id,
			  typeParameters
			});
		  },
		  InterfaceTypeAnnotation: function interfaceTypeAnnotation(_extends = null, body) {
			return (0, _validateNode.default)({
			  type: "InterfaceTypeAnnotation",
			  extends: _extends,
			  body
			});
		  },
		  InterpreterDirective: function interpreterDirective(value) {
			return (0, _validateNode.default)({
			  type: "InterpreterDirective",
			  value
			});
		  },
		  IntersectionTypeAnnotation: function intersectionTypeAnnotation(types) {
			return (0, _validateNode.default)({
			  type: "IntersectionTypeAnnotation",
			  types
			});
		  },
		  JSXAttribute: function jsxAttribute(name, value = null) {
			return (0, _validateNode.default)({
			  type: "JSXAttribute",
			  name,
			  value
			});
		  },
		  JSXClosingElement: function jsxClosingElement(name) {
			return (0, _validateNode.default)({
			  type: "JSXClosingElement",
			  name
			});
		  },
		  JSXClosingFragment: function jsxClosingFragment() {
			return {
			  type: "JSXClosingFragment"
			};
		  },
		  JSXElement: function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
			return (0, _validateNode.default)({
			  type: "JSXElement",
			  openingElement,
			  closingElement,
			  children,
			  selfClosing
			});
		  },
		  JSXEmptyExpression: function jsxEmptyExpression() {
			return {
			  type: "JSXEmptyExpression"
			};
		  },
		  JSXExpressionContainer: function jsxExpressionContainer(expression) {
			return (0, _validateNode.default)({
			  type: "JSXExpressionContainer",
			  expression
			});
		  },
		  JSXFragment: function jsxFragment(openingFragment, closingFragment, children) {
			return (0, _validateNode.default)({
			  type: "JSXFragment",
			  openingFragment,
			  closingFragment,
			  children
			});
		  },
		  JSXIdentifier: function jsxIdentifier(name) {
			return (0, _validateNode.default)({
			  type: "JSXIdentifier",
			  name
			});
		  },
		  JSXMemberExpression: function jsxMemberExpression(object, property) {
			return (0, _validateNode.default)({
			  type: "JSXMemberExpression",
			  object,
			  property
			});
		  },
		  JSXNamespacedName: function jsxNamespacedName(namespace, name) {
			return (0, _validateNode.default)({
			  type: "JSXNamespacedName",
			  namespace,
			  name
			});
		  },
		  JSXOpeningElement: function jsxOpeningElement(name, attributes, selfClosing = false) {
			return (0, _validateNode.default)({
			  type: "JSXOpeningElement",
			  name,
			  attributes,
			  selfClosing
			});
		  },
		  JSXOpeningFragment: function jsxOpeningFragment() {
			return {
			  type: "JSXOpeningFragment"
			};
		  },
		  JSXSpreadAttribute: function jsxSpreadAttribute(argument) {
			return (0, _validateNode.default)({
			  type: "JSXSpreadAttribute",
			  argument
			});
		  },
		  JSXSpreadChild: function jsxSpreadChild(expression) {
			return (0, _validateNode.default)({
			  type: "JSXSpreadChild",
			  expression
			});
		  },
		  JSXText: function jsxText(value) {
			return (0, _validateNode.default)({
			  type: "JSXText",
			  value
			});
		  },
		  LabeledStatement: function labeledStatement(label, body) {
			return (0, _validateNode.default)({
			  type: "LabeledStatement",
			  label,
			  body
			});
		  },
		  LogicalExpression: function logicalExpression(operator, left, right) {
			return (0, _validateNode.default)({
			  type: "LogicalExpression",
			  operator,
			  left,
			  right
			});
		  },
		  MemberExpression: function memberExpression(object, property, computed = false, optional = null) {
			return (0, _validateNode.default)({
			  type: "MemberExpression",
			  object,
			  property,
			  computed,
			  optional
			});
		  },
		  MetaProperty: function metaProperty(meta, property) {
			return (0, _validateNode.default)({
			  type: "MetaProperty",
			  meta,
			  property
			});
		  },
		  MixedTypeAnnotation: function mixedTypeAnnotation() {
			return {
			  type: "MixedTypeAnnotation"
			};
		  },
		  ModuleExpression: function moduleExpression(body) {
			return (0, _validateNode.default)({
			  type: "ModuleExpression",
			  body
			});
		  },
		  NewExpression: function newExpression(callee, _arguments) {
			return (0, _validateNode.default)({
			  type: "NewExpression",
			  callee,
			  arguments: _arguments
			});
		  },
		  Noop: function noop() {
			return {
			  type: "Noop"
			};
		  },
		  NullLiteral: function nullLiteral() {
			return {
			  type: "NullLiteral"
			};
		  },
		  NullLiteralTypeAnnotation: function nullLiteralTypeAnnotation() {
			return {
			  type: "NullLiteralTypeAnnotation"
			};
		  },
		  NullableTypeAnnotation: function nullableTypeAnnotation(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "NullableTypeAnnotation",
			  typeAnnotation
			});
		  },
		  NumberLiteral: function NumberLiteral(value) {
			(0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
			return numericLiteral(value);
		  },
		  NumberLiteralTypeAnnotation: function numberLiteralTypeAnnotation(value) {
			return (0, _validateNode.default)({
			  type: "NumberLiteralTypeAnnotation",
			  value
			});
		  },
		  NumberTypeAnnotation: function numberTypeAnnotation() {
			return {
			  type: "NumberTypeAnnotation"
			};
		  },
		  NumericLiteral: function numericLiteral(value) {
			return (0, _validateNode.default)({
			  type: "NumericLiteral",
			  value
			});
		  },
		  ObjectExpression: function objectExpression(properties) {
			return (0, _validateNode.default)({
			  type: "ObjectExpression",
			  properties
			});
		  },
		  ObjectMethod: function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
			return (0, _validateNode.default)({
			  type: "ObjectMethod",
			  kind,
			  key,
			  params,
			  body,
			  computed,
			  generator,
			  async
			});
		  },
		  ObjectPattern: function objectPattern(properties) {
			return (0, _validateNode.default)({
			  type: "ObjectPattern",
			  properties
			});
		  },
		  ObjectProperty: function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
			return (0, _validateNode.default)({
			  type: "ObjectProperty",
			  key,
			  value,
			  computed,
			  shorthand,
			  decorators
			});
		  },
		  ObjectTypeAnnotation: function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeAnnotation",
			  properties,
			  indexers,
			  callProperties,
			  internalSlots,
			  exact
			});
		  },
		  ObjectTypeCallProperty: function objectTypeCallProperty(value) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeCallProperty",
			  value,
			  static: null
			});
		  },
		  ObjectTypeIndexer: function objectTypeIndexer(id = null, key, value, variance = null) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeIndexer",
			  id,
			  key,
			  value,
			  variance,
			  static: null
			});
		  },
		  ObjectTypeInternalSlot: function objectTypeInternalSlot(id, value, optional, _static, method) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeInternalSlot",
			  id,
			  value,
			  optional,
			  static: _static,
			  method
			});
		  },
		  ObjectTypeProperty: function objectTypeProperty(key, value, variance = null) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeProperty",
			  key,
			  value,
			  variance,
			  kind: null,
			  method: null,
			  optional: null,
			  proto: null,
			  static: null
			});
		  },
		  ObjectTypeSpreadProperty: function objectTypeSpreadProperty(argument) {
			return (0, _validateNode.default)({
			  type: "ObjectTypeSpreadProperty",
			  argument
			});
		  },
		  OpaqueType: function opaqueType(id, typeParameters = null, supertype = null, impltype) {
			return (0, _validateNode.default)({
			  type: "OpaqueType",
			  id,
			  typeParameters,
			  supertype,
			  impltype
			});
		  },
		  OptionalCallExpression: function optionalCallExpression(callee, _arguments, optional) {
			return (0, _validateNode.default)({
			  type: "OptionalCallExpression",
			  callee,
			  arguments: _arguments,
			  optional
			});
		  },
		  OptionalIndexedAccessType: function optionalIndexedAccessType(objectType, indexType) {
			return (0, _validateNode.default)({
			  type: "OptionalIndexedAccessType",
			  objectType,
			  indexType,
			  optional: null
			});
		  },
		  OptionalMemberExpression: function optionalMemberExpression(object, property, computed = false, optional) {
			return (0, _validateNode.default)({
			  type: "OptionalMemberExpression",
			  object,
			  property,
			  computed,
			  optional
			});
		  },
		  ParenthesizedExpression: function parenthesizedExpression(expression) {
			return (0, _validateNode.default)({
			  type: "ParenthesizedExpression",
			  expression
			});
		  },
		  PipelineBareFunction: function pipelineBareFunction(callee) {
			return (0, _validateNode.default)({
			  type: "PipelineBareFunction",
			  callee
			});
		  },
		  PipelinePrimaryTopicReference: function pipelinePrimaryTopicReference() {
			return {
			  type: "PipelinePrimaryTopicReference"
			};
		  },
		  PipelineTopicExpression: function pipelineTopicExpression(expression) {
			return (0, _validateNode.default)({
			  type: "PipelineTopicExpression",
			  expression
			});
		  },
		  Placeholder: function placeholder(expectedNode, name) {
			return (0, _validateNode.default)({
			  type: "Placeholder",
			  expectedNode,
			  name
			});
		  },
		  PrivateName: function privateName(id) {
			return (0, _validateNode.default)({
			  type: "PrivateName",
			  id
			});
		  },
		  Program: function program(body, directives = [], sourceType = "script", interpreter = null) {
			return (0, _validateNode.default)({
			  type: "Program",
			  body,
			  directives,
			  sourceType,
			  interpreter
			});
		  },
		  QualifiedTypeIdentifier: function qualifiedTypeIdentifier(id, qualification) {
			return (0, _validateNode.default)({
			  type: "QualifiedTypeIdentifier",
			  id,
			  qualification
			});
		  },
		  RecordExpression: function recordExpression(properties) {
			return (0, _validateNode.default)({
			  type: "RecordExpression",
			  properties
			});
		  },
		  RegExpLiteral: function regExpLiteral(pattern, flags = "") {
			return (0, _validateNode.default)({
			  type: "RegExpLiteral",
			  pattern,
			  flags
			});
		  },
		  RegexLiteral: function RegexLiteral(pattern, flags = "") {
			(0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
			return regExpLiteral(pattern, flags);
		  },
		  RestElement: function restElement(argument) {
			return (0, _validateNode.default)({
			  type: "RestElement",
			  argument
			});
		  },
		  RestProperty: function RestProperty(argument) {
			(0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
			return restElement(argument);
		  },
		  ReturnStatement: function returnStatement(argument = null) {
			return (0, _validateNode.default)({
			  type: "ReturnStatement",
			  argument
			});
		  },
		  SequenceExpression: function sequenceExpression(expressions) {
			return (0, _validateNode.default)({
			  type: "SequenceExpression",
			  expressions
			});
		  },
		  SpreadElement: function spreadElement(argument) {
			return (0, _validateNode.default)({
			  type: "SpreadElement",
			  argument
			});
		  },
		  SpreadProperty: function SpreadProperty(argument) {
			(0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
			return spreadElement(argument);
		  },
		  StaticBlock: function staticBlock(body) {
			return (0, _validateNode.default)({
			  type: "StaticBlock",
			  body
			});
		  },
		  StringLiteral: function stringLiteral(value) {
			return (0, _validateNode.default)({
			  type: "StringLiteral",
			  value
			});
		  },
		  StringLiteralTypeAnnotation: function stringLiteralTypeAnnotation(value) {
			return (0, _validateNode.default)({
			  type: "StringLiteralTypeAnnotation",
			  value
			});
		  },
		  StringTypeAnnotation: function stringTypeAnnotation() {
			return {
			  type: "StringTypeAnnotation"
			};
		  },
		  Super: function _super() {
			return {
			  type: "Super"
			};
		  },
		  SwitchCase: function switchCase(test = null, consequent) {
			return (0, _validateNode.default)({
			  type: "SwitchCase",
			  test,
			  consequent
			});
		  },
		  SwitchStatement: function switchStatement(discriminant, cases) {
			return (0, _validateNode.default)({
			  type: "SwitchStatement",
			  discriminant,
			  cases
			});
		  },
		  SymbolTypeAnnotation: function symbolTypeAnnotation() {
			return {
			  type: "SymbolTypeAnnotation"
			};
		  },
		  TSAnyKeyword: function tsAnyKeyword() {
			return {
			  type: "TSAnyKeyword"
			};
		  },
		  TSArrayType: function tsArrayType(elementType) {
			return (0, _validateNode.default)({
			  type: "TSArrayType",
			  elementType
			});
		  },
		  TSAsExpression: function tsAsExpression(expression, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSAsExpression",
			  expression,
			  typeAnnotation
			});
		  },
		  TSBigIntKeyword: function tsBigIntKeyword() {
			return {
			  type: "TSBigIntKeyword"
			};
		  },
		  TSBooleanKeyword: function tsBooleanKeyword() {
			return {
			  type: "TSBooleanKeyword"
			};
		  },
		  TSCallSignatureDeclaration: function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSCallSignatureDeclaration",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  TSConditionalType: function tsConditionalType(checkType, extendsType, trueType, falseType) {
			return (0, _validateNode.default)({
			  type: "TSConditionalType",
			  checkType,
			  extendsType,
			  trueType,
			  falseType
			});
		  },
		  TSConstructSignatureDeclaration: function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSConstructSignatureDeclaration",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  TSConstructorType: function tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSConstructorType",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  TSDeclareFunction: function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
			return (0, _validateNode.default)({
			  type: "TSDeclareFunction",
			  id,
			  typeParameters,
			  params,
			  returnType
			});
		  },
		  TSDeclareMethod: function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
			return (0, _validateNode.default)({
			  type: "TSDeclareMethod",
			  decorators,
			  key,
			  typeParameters,
			  params,
			  returnType
			});
		  },
		  TSEnumDeclaration: function tsEnumDeclaration(id, members) {
			return (0, _validateNode.default)({
			  type: "TSEnumDeclaration",
			  id,
			  members
			});
		  },
		  TSEnumMember: function tsEnumMember(id, initializer = null) {
			return (0, _validateNode.default)({
			  type: "TSEnumMember",
			  id,
			  initializer
			});
		  },
		  TSExportAssignment: function tsExportAssignment(expression) {
			return (0, _validateNode.default)({
			  type: "TSExportAssignment",
			  expression
			});
		  },
		  TSExpressionWithTypeArguments: function tsExpressionWithTypeArguments(expression, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSExpressionWithTypeArguments",
			  expression,
			  typeParameters
			});
		  },
		  TSExternalModuleReference: function tsExternalModuleReference(expression) {
			return (0, _validateNode.default)({
			  type: "TSExternalModuleReference",
			  expression
			});
		  },
		  TSFunctionType: function tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSFunctionType",
			  typeParameters,
			  parameters,
			  typeAnnotation
			});
		  },
		  TSImportEqualsDeclaration: function tsImportEqualsDeclaration(id, moduleReference) {
			return (0, _validateNode.default)({
			  type: "TSImportEqualsDeclaration",
			  id,
			  moduleReference,
			  isExport: null
			});
		  },
		  TSImportType: function tsImportType(argument, qualifier = null, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSImportType",
			  argument,
			  qualifier,
			  typeParameters
			});
		  },
		  TSIndexSignature: function tsIndexSignature(parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSIndexSignature",
			  parameters,
			  typeAnnotation
			});
		  },
		  TSIndexedAccessType: function tsIndexedAccessType(objectType, indexType) {
			return (0, _validateNode.default)({
			  type: "TSIndexedAccessType",
			  objectType,
			  indexType
			});
		  },
		  TSInferType: function tsInferType(typeParameter) {
			return (0, _validateNode.default)({
			  type: "TSInferType",
			  typeParameter
			});
		  },
		  TSInstantiationExpression: function tsInstantiationExpression(expression, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSInstantiationExpression",
			  expression,
			  typeParameters
			});
		  },
		  TSInterfaceBody: function tsInterfaceBody(body) {
			return (0, _validateNode.default)({
			  type: "TSInterfaceBody",
			  body
			});
		  },
		  TSInterfaceDeclaration: function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
			return (0, _validateNode.default)({
			  type: "TSInterfaceDeclaration",
			  id,
			  typeParameters,
			  extends: _extends,
			  body
			});
		  },
		  TSIntersectionType: function tsIntersectionType(types) {
			return (0, _validateNode.default)({
			  type: "TSIntersectionType",
			  types
			});
		  },
		  TSIntrinsicKeyword: function tsIntrinsicKeyword() {
			return {
			  type: "TSIntrinsicKeyword"
			};
		  },
		  TSLiteralType: function tsLiteralType(literal) {
			return (0, _validateNode.default)({
			  type: "TSLiteralType",
			  literal
			});
		  },
		  TSMappedType: function tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {
			return (0, _validateNode.default)({
			  type: "TSMappedType",
			  typeParameter,
			  typeAnnotation,
			  nameType
			});
		  },
		  TSMethodSignature: function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSMethodSignature",
			  key,
			  typeParameters,
			  parameters,
			  typeAnnotation,
			  kind: null
			});
		  },
		  TSModuleBlock: function tsModuleBlock(body) {
			return (0, _validateNode.default)({
			  type: "TSModuleBlock",
			  body
			});
		  },
		  TSModuleDeclaration: function tsModuleDeclaration(id, body) {
			return (0, _validateNode.default)({
			  type: "TSModuleDeclaration",
			  id,
			  body
			});
		  },
		  TSNamedTupleMember: function tsNamedTupleMember(label, elementType, optional = false) {
			return (0, _validateNode.default)({
			  type: "TSNamedTupleMember",
			  label,
			  elementType,
			  optional
			});
		  },
		  TSNamespaceExportDeclaration: function tsNamespaceExportDeclaration(id) {
			return (0, _validateNode.default)({
			  type: "TSNamespaceExportDeclaration",
			  id
			});
		  },
		  TSNeverKeyword: function tsNeverKeyword() {
			return {
			  type: "TSNeverKeyword"
			};
		  },
		  TSNonNullExpression: function tsNonNullExpression(expression) {
			return (0, _validateNode.default)({
			  type: "TSNonNullExpression",
			  expression
			});
		  },
		  TSNullKeyword: function tsNullKeyword() {
			return {
			  type: "TSNullKeyword"
			};
		  },
		  TSNumberKeyword: function tsNumberKeyword() {
			return {
			  type: "TSNumberKeyword"
			};
		  },
		  TSObjectKeyword: function tsObjectKeyword() {
			return {
			  type: "TSObjectKeyword"
			};
		  },
		  TSOptionalType: function tsOptionalType(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSOptionalType",
			  typeAnnotation
			});
		  },
		  TSParameterProperty: function tsParameterProperty(parameter) {
			return (0, _validateNode.default)({
			  type: "TSParameterProperty",
			  parameter
			});
		  },
		  TSParenthesizedType: function tsParenthesizedType(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSParenthesizedType",
			  typeAnnotation
			});
		  },
		  TSPropertySignature: function tsPropertySignature(key, typeAnnotation = null) {
			return (0, _validateNode.default)({
			  type: "TSPropertySignature",
			  key,
			  typeAnnotation,
			  kind: null
			});
		  },
		  TSQualifiedName: function tsQualifiedName(left, right) {
			return (0, _validateNode.default)({
			  type: "TSQualifiedName",
			  left,
			  right
			});
		  },
		  TSRestType: function tsRestType(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSRestType",
			  typeAnnotation
			});
		  },
		  TSSatisfiesExpression: function tsSatisfiesExpression(expression, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSSatisfiesExpression",
			  expression,
			  typeAnnotation
			});
		  },
		  TSStringKeyword: function tsStringKeyword() {
			return {
			  type: "TSStringKeyword"
			};
		  },
		  TSSymbolKeyword: function tsSymbolKeyword() {
			return {
			  type: "TSSymbolKeyword"
			};
		  },
		  TSThisType: function tsThisType() {
			return {
			  type: "TSThisType"
			};
		  },
		  TSTupleType: function tsTupleType(elementTypes) {
			return (0, _validateNode.default)({
			  type: "TSTupleType",
			  elementTypes
			});
		  },
		  TSTypeAliasDeclaration: function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSTypeAliasDeclaration",
			  id,
			  typeParameters,
			  typeAnnotation
			});
		  },
		  TSTypeAnnotation: function tsTypeAnnotation(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSTypeAnnotation",
			  typeAnnotation
			});
		  },
		  TSTypeAssertion: function tsTypeAssertion(typeAnnotation, expression) {
			return (0, _validateNode.default)({
			  type: "TSTypeAssertion",
			  typeAnnotation,
			  expression
			});
		  },
		  TSTypeLiteral: function tsTypeLiteral(members) {
			return (0, _validateNode.default)({
			  type: "TSTypeLiteral",
			  members
			});
		  },
		  TSTypeOperator: function tsTypeOperator(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TSTypeOperator",
			  typeAnnotation,
			  operator: null
			});
		  },
		  TSTypeParameter: function tsTypeParameter(constraint = null, _default = null, name) {
			return (0, _validateNode.default)({
			  type: "TSTypeParameter",
			  constraint,
			  default: _default,
			  name
			});
		  },
		  TSTypeParameterDeclaration: function tsTypeParameterDeclaration(params) {
			return (0, _validateNode.default)({
			  type: "TSTypeParameterDeclaration",
			  params
			});
		  },
		  TSTypeParameterInstantiation: function tsTypeParameterInstantiation(params) {
			return (0, _validateNode.default)({
			  type: "TSTypeParameterInstantiation",
			  params
			});
		  },
		  TSTypePredicate: function tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {
			return (0, _validateNode.default)({
			  type: "TSTypePredicate",
			  parameterName,
			  typeAnnotation,
			  asserts
			});
		  },
		  TSTypeQuery: function tsTypeQuery(exprName, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSTypeQuery",
			  exprName,
			  typeParameters
			});
		  },
		  TSTypeReference: function tsTypeReference(typeName, typeParameters = null) {
			return (0, _validateNode.default)({
			  type: "TSTypeReference",
			  typeName,
			  typeParameters
			});
		  },
		  TSUndefinedKeyword: function tsUndefinedKeyword() {
			return {
			  type: "TSUndefinedKeyword"
			};
		  },
		  TSUnionType: function tsUnionType(types) {
			return (0, _validateNode.default)({
			  type: "TSUnionType",
			  types
			});
		  },
		  TSUnknownKeyword: function tsUnknownKeyword() {
			return {
			  type: "TSUnknownKeyword"
			};
		  },
		  TSVoidKeyword: function tsVoidKeyword() {
			return {
			  type: "TSVoidKeyword"
			};
		  },
		  TaggedTemplateExpression: function taggedTemplateExpression(tag, quasi) {
			return (0, _validateNode.default)({
			  type: "TaggedTemplateExpression",
			  tag,
			  quasi
			});
		  },
		  TemplateElement: function templateElement(value, tail = false) {
			return (0, _validateNode.default)({
			  type: "TemplateElement",
			  value,
			  tail
			});
		  },
		  TemplateLiteral: function templateLiteral(quasis, expressions) {
			return (0, _validateNode.default)({
			  type: "TemplateLiteral",
			  quasis,
			  expressions
			});
		  },
		  ThisExpression: function thisExpression() {
			return {
			  type: "ThisExpression"
			};
		  },
		  ThisTypeAnnotation: function thisTypeAnnotation() {
			return {
			  type: "ThisTypeAnnotation"
			};
		  },
		  ThrowStatement: function throwStatement(argument) {
			return (0, _validateNode.default)({
			  type: "ThrowStatement",
			  argument
			});
		  },
		  TopicReference: function topicReference() {
			return {
			  type: "TopicReference"
			};
		  },
		  TryStatement: function tryStatement(block, handler = null, finalizer = null) {
			return (0, _validateNode.default)({
			  type: "TryStatement",
			  block,
			  handler,
			  finalizer
			});
		  },
		  TupleExpression: function tupleExpression(elements = []) {
			return (0, _validateNode.default)({
			  type: "TupleExpression",
			  elements
			});
		  },
		  TupleTypeAnnotation: function tupleTypeAnnotation(types) {
			return (0, _validateNode.default)({
			  type: "TupleTypeAnnotation",
			  types
			});
		  },
		  TypeAlias: function typeAlias(id, typeParameters = null, right) {
			return (0, _validateNode.default)({
			  type: "TypeAlias",
			  id,
			  typeParameters,
			  right
			});
		  },
		  TypeAnnotation: function typeAnnotation(typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TypeAnnotation",
			  typeAnnotation
			});
		  },
		  TypeCastExpression: function typeCastExpression(expression, typeAnnotation) {
			return (0, _validateNode.default)({
			  type: "TypeCastExpression",
			  expression,
			  typeAnnotation
			});
		  },
		  TypeParameter: function typeParameter(bound = null, _default = null, variance = null) {
			return (0, _validateNode.default)({
			  type: "TypeParameter",
			  bound,
			  default: _default,
			  variance,
			  name: null
			});
		  },
		  TypeParameterDeclaration: function typeParameterDeclaration(params) {
			return (0, _validateNode.default)({
			  type: "TypeParameterDeclaration",
			  params
			});
		  },
		  TypeParameterInstantiation: function typeParameterInstantiation(params) {
			return (0, _validateNode.default)({
			  type: "TypeParameterInstantiation",
			  params
			});
		  },
		  TypeofTypeAnnotation: function typeofTypeAnnotation(argument) {
			return (0, _validateNode.default)({
			  type: "TypeofTypeAnnotation",
			  argument
			});
		  },
		  UnaryExpression: function unaryExpression(operator, argument, prefix = true) {
			return (0, _validateNode.default)({
			  type: "UnaryExpression",
			  operator,
			  argument,
			  prefix
			});
		  },
		  UnionTypeAnnotation: function unionTypeAnnotation(types) {
			return (0, _validateNode.default)({
			  type: "UnionTypeAnnotation",
			  types
			});
		  },
		  UpdateExpression: function updateExpression(operator, argument, prefix = false) {
			return (0, _validateNode.default)({
			  type: "UpdateExpression",
			  operator,
			  argument,
			  prefix
			});
		  },
		  V8IntrinsicIdentifier: function v8IntrinsicIdentifier(name) {
			return (0, _validateNode.default)({
			  type: "V8IntrinsicIdentifier",
			  name
			});
		  },
		  VariableDeclaration: function variableDeclaration(kind, declarations) {
			return (0, _validateNode.default)({
			  type: "VariableDeclaration",
			  kind,
			  declarations
			});
		  },
		  VariableDeclarator: function variableDeclarator(id, init = null) {
			return (0, _validateNode.default)({
			  type: "VariableDeclarator",
			  id,
			  init
			});
		  },
		  Variance: function variance(kind) {
			return (0, _validateNode.default)({
			  type: "Variance",
			  kind
			});
		  },
		  VoidTypeAnnotation: function voidTypeAnnotation() {
			return {
			  type: "VoidTypeAnnotation"
			};
		  },
		  WhileStatement: function whileStatement(test, body) {
			return (0, _validateNode.default)({
			  type: "WhileStatement",
			  test,
			  body
			});
		  },
		  WithStatement: function withStatement(object, body) {
			return (0, _validateNode.default)({
			  type: "WithStatement",
			  object,
			  body
			});
		  },
		  YieldExpression: function yieldExpression(argument = null, delegate = false) {
			return (0, _validateNode.default)({
			  type: "YieldExpression",
			  argument,
			  delegate
			});
		  },
		  buildUndefinedNode: function buildUndefinedNode() {
			return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
		  },
		  ACCESSOR_TYPES: [
			"ClassAccessorProperty",
		  ],
		  BINARY_TYPES: [
			"BinaryExpression",
			"LogicalExpression",
		  ],
		  BLOCKPARENT_TYPES: [
			"BlockStatement",
			"CatchClause",
			"DoWhileStatement",
			"ForInStatement",
			"ForStatement",
			"FunctionDeclaration",
			"FunctionExpression",
			"Program",
			"ObjectMethod",
			"SwitchStatement",
			"WhileStatement",
			"ArrowFunctionExpression",
			"ForOfStatement",
			"ClassMethod",
			"ClassPrivateMethod",
			"StaticBlock",
			"TSModuleBlock",
		  ],
		  BLOCK_TYPES: [
			"BlockStatement",
			"Program",
			"TSModuleBlock",
		  ],
		  CLASS_TYPES: [
			"ClassExpression",
			"ClassDeclaration",
		  ],
		  COMPLETIONSTATEMENT_TYPES: [
			"BreakStatement",
			"ContinueStatement",
			"ReturnStatement",
			"ThrowStatement",
		  ],
		  CONDITIONAL_TYPES: [
			"ConditionalExpression",
			"IfStatement",
		  ],
		  DECLARATION_TYPES: [
			"FunctionDeclaration",
			"VariableDeclaration",
			"ClassDeclaration",
			"ExportAllDeclaration",
			"ExportDefaultDeclaration",
			"ExportNamedDeclaration",
			"ImportDeclaration",
			"DeclareClass",
			"DeclareFunction",
			"DeclareInterface",
			"DeclareModule",
			"DeclareModuleExports",
			"DeclareTypeAlias",
			"DeclareOpaqueType",
			"DeclareVariable",
			"DeclareExportDeclaration",
			"DeclareExportAllDeclaration",
			"InterfaceDeclaration",
			"OpaqueType",
			"TypeAlias",
			"EnumDeclaration",
			"TSDeclareFunction",
			"TSInterfaceDeclaration",
			"TSTypeAliasDeclaration",
			"TSEnumDeclaration",
			"TSModuleDeclaration",
		  ],
		  ENUMBODY_TYPES: [
			"EnumBooleanBody",
			"EnumNumberBody",
			"EnumStringBody",
			"EnumSymbolBody",
		  ],
		  ENUMMEMBER_TYPES: [
			"EnumBooleanMember",
			"EnumNumberMember",
			"EnumStringMember",
			"EnumDefaultedMember",
		  ],
		  EXPORTDECLARATION_TYPES: [
			"ExportAllDeclaration",
			"ExportDefaultDeclaration",
			"ExportNamedDeclaration",
		  ],
		  EXPRESSIONWRAPPER_TYPES: [
			"ExpressionStatement",
			"ParenthesizedExpression",
			"TypeCastExpression",
		  ],
		  EXPRESSION_TYPES: [
			"ArrayExpression",
			"AssignmentExpression",
			"BinaryExpression",
			"CallExpression",
			"ConditionalExpression",
			"FunctionExpression",
			"Identifier",
			"StringLiteral",
			"NumericLiteral",
			"NullLiteral",
			"BooleanLiteral",
			"RegExpLiteral",
			"LogicalExpression",
			"MemberExpression",
			"NewExpression",
			"ObjectExpression",
			"SequenceExpression",
			"ParenthesizedExpression",
			"ThisExpression",
			"UnaryExpression",
			"UpdateExpression",
			"ArrowFunctionExpression",
			"ClassExpression",
			"ImportExpression",
			"MetaProperty",
			"Super",
			"TaggedTemplateExpression",
			"TemplateLiteral",
			"YieldExpression",
			"AwaitExpression",
			"Import",
			"BigIntLiteral",
			"OptionalMemberExpression",
			"OptionalCallExpression",
			"TypeCastExpression",
			"JSXElement",
			"JSXFragment",
			"BindExpression",
			"DoExpression",
			"RecordExpression",
			"TupleExpression",
			"DecimalLiteral",
			"ModuleExpression",
			"TopicReference",
			"PipelineTopicExpression",
			"PipelineBareFunction",
			"PipelinePrimaryTopicReference",
			"TSInstantiationExpression",
			"TSAsExpression",
			"TSSatisfiesExpression",
			"TSTypeAssertion",
			"TSNonNullExpression",
		  ],
		  FLOWBASEANNOTATION_TYPES: [
			"AnyTypeAnnotation",
			"BooleanTypeAnnotation",
			"NullLiteralTypeAnnotation",
			"MixedTypeAnnotation",
			"EmptyTypeAnnotation",
			"NumberTypeAnnotation",
			"StringTypeAnnotation",
			"SymbolTypeAnnotation",
			"ThisTypeAnnotation",
			"VoidTypeAnnotation",
		  ],
		  FLOWDECLARATION_TYPES: [
			"DeclareClass",
			"DeclareFunction",
			"DeclareInterface",
			"DeclareModule",
			"DeclareModuleExports",
			"DeclareTypeAlias",
			"DeclareOpaqueType",
			"DeclareVariable",
			"DeclareExportDeclaration",
			"DeclareExportAllDeclaration",
			"InterfaceDeclaration",
			"OpaqueType",
			"TypeAlias",
		  ],
		  FLOWPREDICATE_TYPES: [
			"DeclaredPredicate",
			"InferredPredicate",
		  ],
		  FLOWTYPE_TYPES: [
			"AnyTypeAnnotation",
			"ArrayTypeAnnotation",
			"BooleanTypeAnnotation",
			"BooleanLiteralTypeAnnotation",
			"NullLiteralTypeAnnotation",
			"ExistsTypeAnnotation",
			"FunctionTypeAnnotation",
			"GenericTypeAnnotation",
			"InterfaceTypeAnnotation",
			"IntersectionTypeAnnotation",
			"MixedTypeAnnotation",
			"EmptyTypeAnnotation",
			"NullableTypeAnnotation",
			"NumberLiteralTypeAnnotation",
			"NumberTypeAnnotation",
			"ObjectTypeAnnotation",
			"StringLiteralTypeAnnotation",
			"StringTypeAnnotation",
			"SymbolTypeAnnotation",
			"ThisTypeAnnotation",
			"TupleTypeAnnotation",
			"TypeofTypeAnnotation",
			"UnionTypeAnnotation",
			"VoidTypeAnnotation",
			"IndexedAccessType",
			"OptionalIndexedAccessType",
		  ],
		  FLOW_TYPES: [
			"AnyTypeAnnotation",
			"ArrayTypeAnnotation",
			"BooleanTypeAnnotation",
			"BooleanLiteralTypeAnnotation",
			"NullLiteralTypeAnnotation",
			"ClassImplements",
			"DeclareClass",
			"DeclareFunction",
			"DeclareInterface",
			"DeclareModule",
			"DeclareModuleExports",
			"DeclareTypeAlias",
			"DeclareOpaqueType",
			"DeclareVariable",
			"DeclareExportDeclaration",
			"DeclareExportAllDeclaration",
			"DeclaredPredicate",
			"ExistsTypeAnnotation",
			"FunctionTypeAnnotation",
			"FunctionTypeParam",
			"GenericTypeAnnotation",
			"InferredPredicate",
			"InterfaceExtends",
			"InterfaceDeclaration",
			"InterfaceTypeAnnotation",
			"IntersectionTypeAnnotation",
			"MixedTypeAnnotation",
			"EmptyTypeAnnotation",
			"NullableTypeAnnotation",
			"NumberLiteralTypeAnnotation",
			"NumberTypeAnnotation",
			"ObjectTypeAnnotation",
			"ObjectTypeInternalSlot",
			"ObjectTypeCallProperty",
			"ObjectTypeIndexer",
			"ObjectTypeProperty",
			"ObjectTypeSpreadProperty",
			"OpaqueType",
			"QualifiedTypeIdentifier",
			"StringLiteralTypeAnnotation",
			"StringTypeAnnotation",
			"SymbolTypeAnnotation",
			"ThisTypeAnnotation",
			"TupleTypeAnnotation",
			"TypeofTypeAnnotation",
			"TypeAlias",
			"TypeAnnotation",
			"TypeCastExpression",
			"TypeParameter",
			"TypeParameterDeclaration",
			"TypeParameterInstantiation",
			"UnionTypeAnnotation",
			"Variance",
			"VoidTypeAnnotation",
			"EnumDeclaration",
			"EnumBooleanBody",
			"EnumNumberBody",
			"EnumStringBody",
			"EnumSymbolBody",
			"EnumBooleanMember",
			"EnumNumberMember",
			"EnumStringMember",
			"EnumDefaultedMember",
			"IndexedAccessType",
			"OptionalIndexedAccessType",
		  ],
		  FORXSTATEMENT_TYPES: [
			"ForInStatement",
			"ForOfStatement",
		  ],
		  FOR_TYPES: [
			"ForInStatement",
			"ForStatement",
			"ForOfStatement",
		  ],
		  FUNCTIONPARENT_TYPES: [
			"FunctionDeclaration",
			"FunctionExpression",
			"ObjectMethod",
			"ArrowFunctionExpression",
			"ClassMethod",
			"ClassPrivateMethod",
			"StaticBlock",
			"TSModuleBlock",
		  ],
		  FUNCTION_TYPES: [
			"FunctionDeclaration",
			"FunctionExpression",
			"ObjectMethod",
			"ArrowFunctionExpression",
			"ClassMethod",
			"ClassPrivateMethod",
		  ],
		  IMMUTABLE_TYPES: [
			"StringLiteral",
			"NumericLiteral",
			"NullLiteral",
			"BooleanLiteral",
			"BigIntLiteral",
			"JSXAttribute",
			"JSXClosingElement",
			"JSXElement",
			"JSXExpressionContainer",
			"JSXSpreadChild",
			"JSXOpeningElement",
			"JSXText",
			"JSXFragment",
			"JSXOpeningFragment",
			"JSXClosingFragment",
			"DecimalLiteral",
		  ],
		  IMPORTOREXPORTDECLARATION_TYPES: [
			"ExportAllDeclaration",
			"ExportDefaultDeclaration",
			"ExportNamedDeclaration",
			"ImportDeclaration",
		  ],
		  JSX_TYPES: [
			"JSXAttribute",
			"JSXClosingElement",
			"JSXElement",
			"JSXEmptyExpression",
			"JSXExpressionContainer",
			"JSXSpreadChild",
			"JSXIdentifier",
			"JSXMemberExpression",
			"JSXNamespacedName",
			"JSXOpeningElement",
			"JSXSpreadAttribute",
			"JSXText",
			"JSXFragment",
			"JSXOpeningFragment",
			"JSXClosingFragment",
		  ],
		  LITERAL_TYPES: [
			"StringLiteral",
			"NumericLiteral",
			"NullLiteral",
			"BooleanLiteral",
			"RegExpLiteral",
			"TemplateLiteral",
			"BigIntLiteral",
			"DecimalLiteral",
		  ],
		  LOOP_TYPES: [
			"DoWhileStatement",
			"ForInStatement",
			"ForStatement",
			"WhileStatement",
			"ForOfStatement",
		  ],
		  LVAL_TYPES: [
			"Identifier",
			"MemberExpression",
			"RestElement",
			"AssignmentPattern",
			"ArrayPattern",
			"ObjectPattern",
			"TSParameterProperty",
			"TSAsExpression",
			"TSSatisfiesExpression",
			"TSTypeAssertion",
			"TSNonNullExpression",
		  ],
		  METHOD_TYPES: [
			"ObjectMethod",
			"ClassMethod",
			"ClassPrivateMethod",
		  ],
		  MISCELLANEOUS_TYPES: [
			"Noop",
			"Placeholder",
			"V8IntrinsicIdentifier",
		  ],
		  MODULEDECLARATION_TYPES: [
			"ExportAllDeclaration",
			"ExportDefaultDeclaration",
			"ExportNamedDeclaration",
			"ImportDeclaration",
		  ],
		  MODULESPECIFIER_TYPES: [
			"ExportSpecifier",
			"ImportDefaultSpecifier",
			"ImportNamespaceSpecifier",
			"ImportSpecifier",
			"ExportNamespaceSpecifier",
			"ExportDefaultSpecifier",
		  ],
		  OBJECTMEMBER_TYPES: [
			"ObjectMethod",
			"ObjectProperty",
		  ],
		  PATTERNLIKE_TYPES: [
			"Identifier",
			"RestElement",
			"AssignmentPattern",
			"ArrayPattern",
			"ObjectPattern",
			"TSAsExpression",
			"TSSatisfiesExpression",
			"TSTypeAssertion",
			"TSNonNullExpression",
		  ],
		  PATTERN_TYPES: [
			"AssignmentPattern",
			"ArrayPattern",
			"ObjectPattern",
		  ],
		  PRIVATE_TYPES: [
			"ClassPrivateProperty",
			"ClassPrivateMethod",
			"PrivateName",
		  ],
		  PROPERTY_TYPES: [
			"ObjectProperty",
			"ClassProperty",
			"ClassAccessorProperty",
			"ClassPrivateProperty",
		  ],
		  PUREISH_TYPES: [
			"FunctionDeclaration",
			"FunctionExpression",
			"StringLiteral",
			"NumericLiteral",
			"NullLiteral",
			"BooleanLiteral",
			"RegExpLiteral",
			"ArrowFunctionExpression",
			"BigIntLiteral",
			"DecimalLiteral",
		  ],
		  SCOPABLE_TYPES: [
			"BlockStatement",
			"CatchClause",
			"DoWhileStatement",
			"ForInStatement",
			"ForStatement",
			"FunctionDeclaration",
			"FunctionExpression",
			"Program",
			"ObjectMethod",
			"SwitchStatement",
			"WhileStatement",
			"ArrowFunctionExpression",
			"ClassExpression",
			"ClassDeclaration",
			"ForOfStatement",
			"ClassMethod",
			"ClassPrivateMethod",
			"StaticBlock",
			"TSModuleBlock",
		  ],
		  STANDARDIZED_TYPES: [
			"ArrayExpression",
			"AssignmentExpression",
			"BinaryExpression",
			"InterpreterDirective",
			"Directive",
			"DirectiveLiteral",
			"BlockStatement",
			"BreakStatement",
			"CallExpression",
			"CatchClause",
			"ConditionalExpression",
			"ContinueStatement",
			"DebuggerStatement",
			"DoWhileStatement",
			"EmptyStatement",
			"ExpressionStatement",
			"File",
			"ForInStatement",
			"ForStatement",
			"FunctionDeclaration",
			"FunctionExpression",
			"Identifier",
			"IfStatement",
			"LabeledStatement",
			"StringLiteral",
			"NumericLiteral",
			"NullLiteral",
			"BooleanLiteral",
			"RegExpLiteral",
			"LogicalExpression",
			"MemberExpression",
			"NewExpression",
			"Program",
			"ObjectExpression",
			"ObjectMethod",
			"ObjectProperty",
			"RestElement",
			"ReturnStatement",
			"SequenceExpression",
			"ParenthesizedExpression",
			"SwitchCase",
			"SwitchStatement",
			"ThisExpression",
			"ThrowStatement",
			"TryStatement",
			"UnaryExpression",
			"UpdateExpression",
			"VariableDeclaration",
			"VariableDeclarator",
			"WhileStatement",
			"WithStatement",
			"AssignmentPattern",
			"ArrayPattern",
			"ArrowFunctionExpression",
			"ClassBody",
			"ClassExpression",
			"ClassDeclaration",
			"ExportAllDeclaration",
			"ExportDefaultDeclaration",
			"ExportNamedDeclaration",
			"ExportSpecifier",
			"ForOfStatement",
			"ImportDeclaration",
			"ImportDefaultSpecifier",
			"ImportNamespaceSpecifier",
			"ImportSpecifier",
			"ImportExpression",
			"MetaProperty",
			"ClassMethod",
			"ObjectPattern",
			"SpreadElement",
			"Super",
			"TaggedTemplateExpression",
			"TemplateElement",
			"TemplateLiteral",
			"YieldExpression",
			"AwaitExpression",
			"Import",
			"BigIntLiteral",
			"ExportNamespaceSpecifier",
			"OptionalMemberExpression",
			"OptionalCallExpression",
			"ClassProperty",
			"ClassAccessorProperty",
			"ClassPrivateProperty",
			"ClassPrivateMethod",
			"PrivateName",
			"StaticBlock",
		  ],
		  STATEMENT_TYPES: [
			"BlockStatement",
			"BreakStatement",
			"ContinueStatement",
			"DebuggerStatement",
			"DoWhileStatement",
			"EmptyStatement",
			"ExpressionStatement",
			"ForInStatement",
			"ForStatement",
			"FunctionDeclaration",
			"IfStatement",
			"LabeledStatement",
			"ReturnStatement",
			"SwitchStatement",
			"ThrowStatement",
			"TryStatement",
			"VariableDeclaration",
			"WhileStatement",
			"WithStatement",
			"ClassDeclaration",
			"ExportAllDeclaration",
			"ExportDefaultDeclaration",
			"ExportNamedDeclaration",
			"ForOfStatement",
			"ImportDeclaration",
			"DeclareClass",
			"DeclareFunction",
			"DeclareInterface",
			"DeclareModule",
			"DeclareModuleExports",
			"DeclareTypeAlias",
			"DeclareOpaqueType",
			"DeclareVariable",
			"DeclareExportDeclaration",
			"DeclareExportAllDeclaration",
			"InterfaceDeclaration",
			"OpaqueType",
			"TypeAlias",
			"EnumDeclaration",
			"TSDeclareFunction",
			"TSInterfaceDeclaration",
			"TSTypeAliasDeclaration",
			"TSEnumDeclaration",
			"TSModuleDeclaration",
			"TSImportEqualsDeclaration",
			"TSExportAssignment",
			"TSNamespaceExportDeclaration",
		  ],
		  TERMINATORLESS_TYPES: [
			"BreakStatement",
			"ContinueStatement",
			"ReturnStatement",
			"ThrowStatement",
			"YieldExpression",
			"AwaitExpression",
		  ],
		  TSBASETYPE_TYPES: [
			"TSAnyKeyword",
			"TSBooleanKeyword",
			"TSBigIntKeyword",
			"TSIntrinsicKeyword",
			"TSNeverKeyword",
			"TSNullKeyword",
			"TSNumberKeyword",
			"TSObjectKeyword",
			"TSStringKeyword",
			"TSSymbolKeyword",
			"TSUndefinedKeyword",
			"TSUnknownKeyword",
			"TSVoidKeyword",
			"TSThisType",
			"TSLiteralType",
		  ],
		  TSENTITYNAME_TYPES: [
			"Identifier",
			"TSQualifiedName",
		  ],
		  TSTYPEELEMENT_TYPES: [
			"TSCallSignatureDeclaration",
			"TSConstructSignatureDeclaration",
			"TSPropertySignature",
			"TSMethodSignature",
			"TSIndexSignature",
		  ],
		  TSTYPE_TYPES: [
			"TSAnyKeyword",
			"TSBooleanKeyword",
			"TSBigIntKeyword",
			"TSIntrinsicKeyword",
			"TSNeverKeyword",
			"TSNullKeyword",
			"TSNumberKeyword",
			"TSObjectKeyword",
			"TSStringKeyword",
			"TSSymbolKeyword",
			"TSUndefinedKeyword",
			"TSUnknownKeyword",
			"TSVoidKeyword",
			"TSThisType",
			"TSFunctionType",
			"TSConstructorType",
			"TSTypeReference",
			"TSTypePredicate",
			"TSTypeQuery",
			"TSTypeLiteral",
			"TSArrayType",
			"TSTupleType",
			"TSOptionalType",
			"TSRestType",
			"TSUnionType",
			"TSIntersectionType",
			"TSConditionalType",
			"TSInferType",
			"TSParenthesizedType",
			"TSTypeOperator",
			"TSIndexedAccessType",
			"TSMappedType",
			"TSLiteralType",
			"TSExpressionWithTypeArguments",
			"TSImportType",
		  ],
		  TYPESCRIPT_TYPES: [
			"TSParameterProperty",
			"TSDeclareFunction",
			"TSDeclareMethod",
			"TSQualifiedName",
			"TSCallSignatureDeclaration",
			"TSConstructSignatureDeclaration",
			"TSPropertySignature",
			"TSMethodSignature",
			"TSIndexSignature",
			"TSAnyKeyword",
			"TSBooleanKeyword",
			"TSBigIntKeyword",
			"TSIntrinsicKeyword",
			"TSNeverKeyword",
			"TSNullKeyword",
			"TSNumberKeyword",
			"TSObjectKeyword",
			"TSStringKeyword",
			"TSSymbolKeyword",
			"TSUndefinedKeyword",
			"TSUnknownKeyword",
			"TSVoidKeyword",
			"TSThisType",
			"TSFunctionType",
			"TSConstructorType",
			"TSTypeReference",
			"TSTypePredicate",
			"TSTypeQuery",
			"TSTypeLiteral",
			"TSArrayType",
			"TSTupleType",
			"TSOptionalType",
			"TSRestType",
			"TSNamedTupleMember",
			"TSUnionType",
			"TSIntersectionType",
			"TSConditionalType",
			"TSInferType",
			"TSParenthesizedType",
			"TSTypeOperator",
			"TSIndexedAccessType",
			"TSMappedType",
			"TSLiteralType",
			"TSExpressionWithTypeArguments",
			"TSInterfaceDeclaration",
			"TSInterfaceBody",
			"TSTypeAliasDeclaration",
			"TSInstantiationExpression",
			"TSAsExpression",
			"TSSatisfiesExpression",
			"TSTypeAssertion",
			"TSEnumDeclaration",
			"TSEnumMember",
			"TSModuleDeclaration",
			"TSModuleBlock",
			"TSImportType",
			"TSImportEqualsDeclaration",
			"TSExternalModuleReference",
			"TSNonNullExpression",
			"TSExportAssignment",
			"TSNamespaceExportDeclaration",
			"TSTypeAnnotation",
			"TSTypeParameterInstantiation",
			"TSTypeParameterDeclaration",
			"TSTypeParameter",
		  ],
		  UNARYLIKE_TYPES: [
			"UnaryExpression",
			"SpreadElement",
		  ],
		  USERWHITESPACABLE_TYPES: [
			"ObjectMethod",
			"ObjectProperty",
			"ObjectTypeInternalSlot",
			"ObjectTypeCallProperty",
			"ObjectTypeIndexer",
			"ObjectTypeProperty",
			"ObjectTypeSpreadProperty",
		  ],
		  WHILE_TYPES: [
			"DoWhileStatement",
			"WhileStatement",
		  ],
		  ASSIGNMENT_OPERATORS: [
			"=",
			"+=",
			"-=",
			"/=",
			"%=",
			"*=",
			"**=",
			"&=",
			"|=",
			">>=",
			">>>=",
			"<<=",
			"^=",
			"||=",
			"&&=",
			"??=",
		  ],
		  BINARY_OPERATORS: [
			"+",
			"-",
			"/",
			"%",
			"*",
			"**",
			"&",
			"|",
			">>",
			">>>",
			"<<",
			"^",
			"==",
			"===",
			"!=",
			"!==",
			"in",
			"instanceof",
			">",
			"<",
			">=",
			"<=",
			"|>",
		  ],
		  BLOCK_SCOPED_SYMBOL: Symbol(var used to be block scoped),
		  BOOLEAN_BINARY_OPERATORS: [
			"==",
			"===",
			"!=",
			"!==",
			"in",
			"instanceof",
			">",
			"<",
			">=",
			"<=",
		  ],
		  BOOLEAN_NUMBER_BINARY_OPERATORS: [
			">",
			"<",
			">=",
			"<=",
		  ],
		  BOOLEAN_UNARY_OPERATORS: [
			"delete",
			"!",
		  ],
		  COMMENT_KEYS: [
			"leadingComments",
			"trailingComments",
			"innerComments",
		  ],
		  COMPARISON_BINARY_OPERATORS: [
			"==",
			"===",
			"!=",
			"!==",
			"in",
			"instanceof",
		  ],
		  EQUALITY_BINARY_OPERATORS: [
			"==",
			"===",
			"!=",
			"!==",
		  ],
		  FLATTENABLE_KEYS: [
			"body",
			"expressions",
		  ],
		  FOR_INIT_KEYS: [
			"left",
			"init",
		  ],
		  INHERIT_KEYS: {
			optional: [
			  "typeAnnotation",
			  "typeParameters",
			  "returnType",
			],
			force: [
			  "start",
			  "loc",
			  "end",
			],
		  },
		  LOGICAL_OPERATORS: [
			"||",
			"&&",
			"??",
		  ],
		  NOT_LOCAL_BINDING: Symbol(should not be considered a local binding),
		  NUMBER_BINARY_OPERATORS: [
			"-",
			"/",
			"%",
			"*",
			"**",
			"&",
			"|",
			">>",
			">>>",
			"<<",
			"^",
		  ],
		  NUMBER_UNARY_OPERATORS: [
			"+",
			"-",
			"~",
		  ],
		  STATEMENT_OR_BLOCK_KEYS: [
			"consequent",
			"body",
			"alternate",
		  ],
		  STRING_UNARY_OPERATORS: [
			"typeof",
		  ],
		  UNARY_OPERATORS: [
			"void",
			"throw",
			"delete",
			"!",
			"+",
			"-",
			"~",
			"typeof",
		  ],
		  UPDATE_OPERATORS: [
			"++",
			"--",
		  ],
		  ALIAS_KEYS: {
			ArrayExpression: [
			  "Standardized",
			  "Expression",
			],
			AssignmentExpression: [
			  "Standardized",
			  "Expression",
			],
			BinaryExpression: [
			  "Standardized",
			  "Binary",
			  "Expression",
			],
			InterpreterDirective: [
			  "Standardized",
			],
			Directive: [
			  "Standardized",
			],
			DirectiveLiteral: [
			  "Standardized",
			],
			BlockStatement: [
			  "Standardized",
			  "Scopable",
			  "BlockParent",
			  "Block",
			  "Statement",
			],
			BreakStatement: [
			  "Standardized",
			  "Statement",
			  "Terminatorless",
			  "CompletionStatement",
			],
			CallExpression: [
			  "Standardized",
			  "Expression",
			],
			CatchClause: [
			  "Standardized",
			  "Scopable",
			  "BlockParent",
			],
			ConditionalExpression: [
			  "Standardized",
			  "Expression",
			  "Conditional",
			],
			ContinueStatement: [
			  "Standardized",
			  "Statement",
			  "Terminatorless",
			  "CompletionStatement",
			],
			DebuggerStatement: [
			  "Standardized",
			  "Statement",
			],
			DoWhileStatement: [
			  "Standardized",
			  "Statement",
			  "BlockParent",
			  "Loop",
			  "While",
			  "Scopable",
			],
			EmptyStatement: [
			  "Standardized",
			  "Statement",
			],
			ExpressionStatement: [
			  "Standardized",
			  "Statement",
			  "ExpressionWrapper",
			],
			File: [
			  "Standardized",
			],
			ForInStatement: [
			  "Standardized",
			  "Scopable",
			  "Statement",
			  "For",
			  "BlockParent",
			  "Loop",
			  "ForXStatement",
			],
			ForStatement: [
			  "Standardized",
			  "Scopable",
			  "Statement",
			  "For",
			  "BlockParent",
			  "Loop",
			],
			FunctionDeclaration: [
			  "Standardized",
			  "Scopable",
			  "Function",
			  "BlockParent",
			  "FunctionParent",
			  "Statement",
			  "Pureish",
			  "Declaration",
			],
			FunctionExpression: [
			  "Standardized",
			  "Scopable",
			  "Function",
			  "BlockParent",
			  "FunctionParent",
			  "Expression",
			  "Pureish",
			],
			Identifier: [
			  "Standardized",
			  "Expression",
			  "PatternLike",
			  "LVal",
			  "TSEntityName",
			],
			IfStatement: [
			  "Standardized",
			  "Statement",
			  "Conditional",
			],
			LabeledStatement: [
			  "Standardized",
			  "Statement",
			],
			StringLiteral: [
			  "Standardized",
			  "Expression",
			  "Pureish",
			  "Literal",
			  "Immutable",
			],
			NumericLiteral: [
			  "Standardized",
			  "Expression",
			  "Pureish",
			  "Literal",
			  "Immutable",
			],
			NullLiteral: [
			  "Standardized",
			  "Expression",
			  "Pureish",
			  "Literal",
			  "Immutable",
			],
			BooleanLiteral: [
			  "Standardized",
			  "Expression",
			  "Pureish",
			  "Literal",
			  "Immutable",
			],
			RegExpLiteral: [
			  "Standardized",
			  "Expression",
			  "Pureish",
			  "Literal",
			],
			LogicalExpression: [
			  "Standardized",
			  "Binary",
			  "Expression",
			],
			MemberExpression: [
			  "Standardized",
			  "Expression",
			  "LVal",
			],
			NewExpression: [
			  "Standardized",
			  "Expression",
			],
			Program: [
			  "Standardized",
			  "Scopable",
			  "BlockParent",
			  "Block",
			],
			ObjectExpression: [
			  "Standardized",
			  "Expression",
			],
			ObjectMethod: [
			  "Standardized",
			  "UserWhitespacable",
			  "Function",
			  "Scopable",
			  "BlockParent",
			  "FunctionParent",
			  "Method",
			  "ObjectMember",
			],
			ObjectProperty: [
			  "Standardized",
			  "UserWhitespacable",
			  "Property",
			  "ObjectMember",
			],
			RestElement: [
			  "Standardized",
			  "LVal",
			  "PatternLike",
			],
			ReturnStatement: [
			  "Standardized",
			  "Statement",
			  "Terminatorless",
			  "CompletionStatement",
			],
			SequenceExpression: [
			  "Standardized",
			  "Expression",
			],
			ParenthesizedExpression: [
			  "Standardized",
			  "Expression",
			  "ExpressionWrapper",
			],
			SwitchCase: [
			  "Standardized",
			],
			SwitchStatement: [
			  "Standardized",
			  "Statement",
			  "BlockParent",
			  "Scopable",
			],
			ThisExpression: [
			  "Standardized",
			  "Expression",
			],
			ThrowStatement: [
			  "Standardized",
			  "Statement",
			  "Terminatorless",
			  "CompletionStatement",
			],
			TryStatement: [
			  "Standardized",
			  "Statement",
			],
			UnaryExpression: [
			  "Standardized",
			  "UnaryLike",
			  "Expression",
			],
			UpdateExpression: [
			  "Standardized",
			  "Expression",
			],
			VariableDeclaration: [
			  "Standardized",
			  "Statement",
			  "Declaration",
			],
			VariableDeclarator: [
			  "Standardized",
			],
			WhileStatement: [
			  "Standardized",
			  "Statement",
			  "BlockParent",
			  "Loop",
			  "While",
			  "Scopable",
			],
			WithStatement: [
			  "Standardized",
			  "Statement",
			],
			AssignmentPattern: [
			  "Standardized",
			  "Pattern",
			  "PatternLike",
			  "LVal",
			],
			ArrayPattern: [
			  "Standardized",
			  "Pattern",
			  "PatternLike",
			  "LVal",
			],
			ArrowFunctionExpression: [
			  "Standardized",
			  "Scopable",
			  "Function",
			  "BlockParent",
			  "FunctionParent",
			  "Expression",
			  "Pureish",
			],
			ClassBody: [
			  "Standardized",
			],
			ClassExpression: [
			  "Standardized",
			  "Scopable",
			  "Class",
			  "Expression",
			],
			ClassDeclaration: [
			  "Standardized",
			  "Scopable",
			  "Class",
			  "Statement",
			  "Declaration",
			],
			ExportAllDeclaration: [
			  "Standardized",
			  "Statement",
			  "Declaration",
			  "ImportOrExportDeclaration",
			  "ExportDeclaration",
			],
			ExportDefaultDeclaration: [
			  "Standardized",
			  "Statement",
			  "Declaration",
			  "ImportOrExportDeclaration",
			  "ExportDeclaration",
			],
			ExportNamedDeclaration: [
			  "Standardized",
			  "Statement",
			  "Declaration",
			  "ImportOrExportDeclaration",
			  "ExportDeclaration",
			],
			ExportSpecifier: [
			  "Standardized",
			  "ModuleSpecifier",
			],
			ForOfStatement: [
			  "Standardized",
			  "Scopable",
			  "Statement",
			  "For",
			  "BlockParent",
			  "Loop",
			  "ForXStatement",
			],
			ImportDeclaration: [
			  "Standardized",
			  "Statement",
			  "Declaration",
			  "ImportOrExportDeclaration",
			],
			ImportDefaultSpecifier: [
			  "Standardized",
			  "ModuleSpecifier",
			],
			ImportNamespaceSpecifier: [
			  "Standardized",
			  "ModuleSpecifier",
			],
			ImportSpecifier: [
			  "Standardized",
			  "ModuleSpecifier",
			],
			ImportExpression: [
			  "Standardized",
			  "Expression",
			],
			MetaProperty: [
			  "Standardized",
			  "Expression",
			],
			ClassMethod: [
			  "Standardized",
			  "Function",
			  "Scopable",
			  "BlockParent",
			  "FunctionParent",
			  "Method",
			],
			ObjectPattern: [
			  "Standardized",
			  "Pattern",
			  "PatternLike",
			  "LVal",
			],
			SpreadElement: [
			  "Standardized",
			  "UnaryLike",
			],
			Super: [
			  "Standardized",
			  "Expression",
			],
			TaggedTemplateExpression: [
			  "Standardized",
			  "Expression",
			],
			TemplateElement: [
			  "Standardized",
			],
			TemplateLiteral: [
			  "Standardized",
			  "Expression",
			  "Literal",
			],
			YieldExpression: [
			  "Standardized",
			  "Expression",
			  "Terminatorless",
			],
			AwaitExpression: [
			  "Standardized",
			  "Expression",
			  "Terminatorless",
			],
			Import: [
			  "Standardized",
			  "Expression",
			],
			BigIntLiteral: [
			  "Standardized",
			  "Expression",
			  "Pureish",
			  "Literal",
			  "Immutable",
			],
			ExportNamespaceSpecifier: [
			  "Standardized",
			  "ModuleSpecifier",
			],
			OptionalMemberExpression: [
			  "Standardized",
			  "Expression",
			],
			OptionalCallExpression: [
			  "Standardized",
			  "Expression",
			],
			ClassProperty: [
			  "Standardized",
			  "Property",
			],
			ClassAccessorProperty: [
			  "Standardized",
			  "Property",
			  "Accessor",
			],
			ClassPrivateProperty: [
			  "Standardized",
			  "Property",
			  "Private",
			],
			ClassPrivateMethod: [
			  "Standardized",
			  "Function",
			  "Scopable",
			  "BlockParent",
			  "FunctionParent",
			  "Method",
			  "Private",
			],
			PrivateName: [
			  "Standardized",
			  "Private",
			],
			StaticBlock: [
			  "Standardized",
			  "Scopable",
			  "BlockParent",
			  "FunctionParent",
			],
			AnyTypeAnnotation: [
			  "Flow",
			  "FlowType",
			  "FlowBaseAnnotation",
			],
			ArrayTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			BooleanTypeAnnotation: [
			  "Flow",
			  "FlowType",
			  "FlowBaseAnnotation",
			],
			BooleanLiteralTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			NullLiteralTypeAnnotation: [
			  "Flow",
			  "FlowType",
			  "FlowBaseAnnotation",
			],
			ClassImplements: [
			  "Flow",
			],
			DeclareClass: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			DeclareFunction: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			DeclareInterface: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			DeclareModule: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			DeclareModuleExports: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			DeclareTypeAlias: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			DeclareOpaqueType: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			DeclareVariable: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			DeclareExportDeclaration: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			DeclareExportAllDeclaration: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			DeclaredPredicate: [
			  "Flow",
			  "FlowPredicate",
			],
			ExistsTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			FunctionTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			FunctionTypeParam: [
			  "Flow",
			],
			GenericTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			InferredPredicate: [
			  "Flow",
			  "FlowPredicate",
			],
			InterfaceExtends: [
			  "Flow",
			],
			InterfaceDeclaration: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			InterfaceTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			IntersectionTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			MixedTypeAnnotation: [
			  "Flow",
			  "FlowType",
			  "FlowBaseAnnotation",
			],
			EmptyTypeAnnotation: [
			  "Flow",
			  "FlowType",
			  "FlowBaseAnnotation",
			],
			NullableTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			NumberLiteralTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			NumberTypeAnnotation: [
			  "Flow",
			  "FlowType",
			  "FlowBaseAnnotation",
			],
			ObjectTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			ObjectTypeInternalSlot: [
			  "Flow",
			  "UserWhitespacable",
			],
			ObjectTypeCallProperty: [
			  "Flow",
			  "UserWhitespacable",
			],
			ObjectTypeIndexer: [
			  "Flow",
			  "UserWhitespacable",
			],
			ObjectTypeProperty: [
			  "Flow",
			  "UserWhitespacable",
			],
			ObjectTypeSpreadProperty: [
			  "Flow",
			  "UserWhitespacable",
			],
			OpaqueType: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			QualifiedTypeIdentifier: [
			  "Flow",
			],
			StringLiteralTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			StringTypeAnnotation: [
			  "Flow",
			  "FlowType",
			  "FlowBaseAnnotation",
			],
			SymbolTypeAnnotation: [
			  "Flow",
			  "FlowType",
			  "FlowBaseAnnotation",
			],
			ThisTypeAnnotation: [
			  "Flow",
			  "FlowType",
			  "FlowBaseAnnotation",
			],
			TupleTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			TypeofTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			TypeAlias: [
			  "Flow",
			  "FlowDeclaration",
			  "Statement",
			  "Declaration",
			],
			TypeAnnotation: [
			  "Flow",
			],
			TypeCastExpression: [
			  "Flow",
			  "ExpressionWrapper",
			  "Expression",
			],
			TypeParameter: [
			  "Flow",
			],
			TypeParameterDeclaration: [
			  "Flow",
			],
			TypeParameterInstantiation: [
			  "Flow",
			],
			UnionTypeAnnotation: [
			  "Flow",
			  "FlowType",
			],
			Variance: [
			  "Flow",
			],
			VoidTypeAnnotation: [
			  "Flow",
			  "FlowType",
			  "FlowBaseAnnotation",
			],
			EnumDeclaration: [
			  "Flow",
			  "Statement",
			  "Declaration",
			],
			EnumBooleanBody: [
			  "Flow",
			  "EnumBody",
			],
			EnumNumberBody: [
			  "Flow",
			  "EnumBody",
			],
			EnumStringBody: [
			  "Flow",
			  "EnumBody",
			],
			EnumSymbolBody: [
			  "Flow",
			  "EnumBody",
			],
			EnumBooleanMember: [
			  "Flow",
			  "EnumMember",
			],
			EnumNumberMember: [
			  "Flow",
			  "EnumMember",
			],
			EnumStringMember: [
			  "Flow",
			  "EnumMember",
			],
			EnumDefaultedMember: [
			  "Flow",
			  "EnumMember",
			],
			IndexedAccessType: [
			  "Flow",
			  "FlowType",
			],
			OptionalIndexedAccessType: [
			  "Flow",
			  "FlowType",
			],
			JSXAttribute: [
			  "JSX",
			  "Immutable",
			],
			JSXClosingElement: [
			  "JSX",
			  "Immutable",
			],
			JSXElement: [
			  "JSX",
			  "Immutable",
			  "Expression",
			],
			JSXEmptyExpression: [
			  "JSX",
			],
			JSXExpressionContainer: [
			  "JSX",
			  "Immutable",
			],
			JSXSpreadChild: [
			  "JSX",
			  "Immutable",
			],
			JSXIdentifier: [
			  "JSX",
			],
			JSXMemberExpression: [
			  "JSX",
			],
			JSXNamespacedName: [
			  "JSX",
			],
			JSXOpeningElement: [
			  "JSX",
			  "Immutable",
			],
			JSXSpreadAttribute: [
			  "JSX",
			],
			JSXText: [
			  "JSX",
			  "Immutable",
			],
			JSXFragment: [
			  "JSX",
			  "Immutable",
			  "Expression",
			],
			JSXOpeningFragment: [
			  "JSX",
			  "Immutable",
			],
			JSXClosingFragment: [
			  "JSX",
			  "Immutable",
			],
			Noop: [
			  "Miscellaneous",
			],
			Placeholder: [
			  "Miscellaneous",
			],
			V8IntrinsicIdentifier: [
			  "Miscellaneous",
			],
			ArgumentPlaceholder: [
			],
			BindExpression: [
			  "Expression",
			],
			ImportAttribute: [
			],
			Decorator: [
			],
			DoExpression: [
			  "Expression",
			],
			ExportDefaultSpecifier: [
			  "ModuleSpecifier",
			],
			RecordExpression: [
			  "Expression",
			],
			TupleExpression: [
			  "Expression",
			],
			DecimalLiteral: [
			  "Expression",
			  "Pureish",
			  "Literal",
			  "Immutable",
			],
			ModuleExpression: [
			  "Expression",
			],
			TopicReference: [
			  "Expression",
			],
			PipelineTopicExpression: [
			  "Expression",
			],
			PipelineBareFunction: [
			  "Expression",
			],
			PipelinePrimaryTopicReference: [
			  "Expression",
			],
			TSParameterProperty: [
			  "TypeScript",
			  "LVal",
			],
			TSDeclareFunction: [
			  "TypeScript",
			  "Statement",
			  "Declaration",
			],
			TSDeclareMethod: [
			  "TypeScript",
			],
			TSQualifiedName: [
			  "TypeScript",
			  "TSEntityName",
			],
			TSCallSignatureDeclaration: [
			  "TypeScript",
			  "TSTypeElement",
			],
			TSConstructSignatureDeclaration: [
			  "TypeScript",
			  "TSTypeElement",
			],
			TSPropertySignature: [
			  "TypeScript",
			  "TSTypeElement",
			],
			TSMethodSignature: [
			  "TypeScript",
			  "TSTypeElement",
			],
			TSIndexSignature: [
			  "TypeScript",
			  "TSTypeElement",
			],
			TSAnyKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSBooleanKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSBigIntKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSIntrinsicKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSNeverKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSNullKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSNumberKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSObjectKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSStringKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSSymbolKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSUndefinedKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSUnknownKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSVoidKeyword: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSThisType: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSFunctionType: [
			  "TypeScript",
			  "TSType",
			],
			TSConstructorType: [
			  "TypeScript",
			  "TSType",
			],
			TSTypeReference: [
			  "TypeScript",
			  "TSType",
			],
			TSTypePredicate: [
			  "TypeScript",
			  "TSType",
			],
			TSTypeQuery: [
			  "TypeScript",
			  "TSType",
			],
			TSTypeLiteral: [
			  "TypeScript",
			  "TSType",
			],
			TSArrayType: [
			  "TypeScript",
			  "TSType",
			],
			TSTupleType: [
			  "TypeScript",
			  "TSType",
			],
			TSOptionalType: [
			  "TypeScript",
			  "TSType",
			],
			TSRestType: [
			  "TypeScript",
			  "TSType",
			],
			TSNamedTupleMember: [
			  "TypeScript",
			],
			TSUnionType: [
			  "TypeScript",
			  "TSType",
			],
			TSIntersectionType: [
			  "TypeScript",
			  "TSType",
			],
			TSConditionalType: [
			  "TypeScript",
			  "TSType",
			],
			TSInferType: [
			  "TypeScript",
			  "TSType",
			],
			TSParenthesizedType: [
			  "TypeScript",
			  "TSType",
			],
			TSTypeOperator: [
			  "TypeScript",
			  "TSType",
			],
			TSIndexedAccessType: [
			  "TypeScript",
			  "TSType",
			],
			TSMappedType: [
			  "TypeScript",
			  "TSType",
			],
			TSLiteralType: [
			  "TypeScript",
			  "TSType",
			  "TSBaseType",
			],
			TSExpressionWithTypeArguments: [
			  "TypeScript",
			  "TSType",
			],
			TSInterfaceDeclaration: [
			  "TypeScript",
			  "Statement",
			  "Declaration",
			],
			TSInterfaceBody: [
			  "TypeScript",
			],
			TSTypeAliasDeclaration: [
			  "TypeScript",
			  "Statement",
			  "Declaration",
			],
			TSInstantiationExpression: [
			  "TypeScript",
			  "Expression",
			],
			TSAsExpression: [
			  "TypeScript",
			  "Expression",
			  "LVal",
			  "PatternLike",
			],
			TSSatisfiesExpression: [
			  "TypeScript",
			  "Expression",
			  "LVal",
			  "PatternLike",
			],
			TSTypeAssertion: [
			  "TypeScript",
			  "Expression",
			  "LVal",
			  "PatternLike",
			],
			TSEnumDeclaration: [
			  "TypeScript",
			  "Statement",
			  "Declaration",
			],
			TSEnumMember: [
			  "TypeScript",
			],
			TSModuleDeclaration: [
			  "TypeScript",
			  "Statement",
			  "Declaration",
			],
			TSModuleBlock: [
			  "TypeScript",
			  "Scopable",
			  "Block",
			  "BlockParent",
			  "FunctionParent",
			],
			TSImportType: [
			  "TypeScript",
			  "TSType",
			],
			TSImportEqualsDeclaration: [
			  "TypeScript",
			  "Statement",
			],
			TSExternalModuleReference: [
			  "TypeScript",
			],
			TSNonNullExpression: [
			  "TypeScript",
			  "Expression",
			  "LVal",
			  "PatternLike",
			],
			TSExportAssignment: [
			  "TypeScript",
			  "Statement",
			],
			TSNamespaceExportDeclaration: [
			  "TypeScript",
			  "Statement",
			],
			TSTypeAnnotation: [
			  "TypeScript",
			],
			TSTypeParameterInstantiation: [
			  "TypeScript",
			],
			TSTypeParameterDeclaration: [
			  "TypeScript",
			],
			TSTypeParameter: [
			  "TypeScript",
			],
		  },
		  BUILDER_KEYS: {
			ArrayExpression: [
			  "elements",
			],
			AssignmentExpression: [
			  "operator",
			  "left",
			  "right",
			],
			BinaryExpression: [
			  "operator",
			  "left",
			  "right",
			],
			InterpreterDirective: [
			  "value",
			],
			Directive: [
			  "value",
			],
			DirectiveLiteral: [
			  "value",
			],
			BlockStatement: [
			  "body",
			  "directives",
			],
			BreakStatement: [
			  "label",
			],
			CallExpression: [
			  "callee",
			  "arguments",
			],
			CatchClause: [
			  "param",
			  "body",
			],
			ConditionalExpression: [
			  "test",
			  "consequent",
			  "alternate",
			],
			ContinueStatement: [
			  "label",
			],
			DebuggerStatement: [
			],
			DoWhileStatement: [
			  "test",
			  "body",
			],
			EmptyStatement: [
			],
			ExpressionStatement: [
			  "expression",
			],
			File: [
			  "program",
			  "comments",
			  "tokens",
			],
			ForInStatement: [
			  "left",
			  "right",
			  "body",
			],
			ForStatement: [
			  "init",
			  "test",
			  "update",
			  "body",
			],
			FunctionDeclaration: [
			  "id",
			  "params",
			  "body",
			  "generator",
			  "async",
			],
			FunctionExpression: [
			  "id",
			  "params",
			  "body",
			  "generator",
			  "async",
			],
			Identifier: [
			  "name",
			],
			IfStatement: [
			  "test",
			  "consequent",
			  "alternate",
			],
			LabeledStatement: [
			  "label",
			  "body",
			],
			StringLiteral: [
			  "value",
			],
			NumericLiteral: [
			  "value",
			],
			NullLiteral: [
			],
			BooleanLiteral: [
			  "value",
			],
			RegExpLiteral: [
			  "pattern",
			  "flags",
			],
			LogicalExpression: [
			  "operator",
			  "left",
			  "right",
			],
			MemberExpression: [
			  "object",
			  "property",
			  "computed",
			  "optional",
			],
			NewExpression: [
			  "callee",
			  "arguments",
			],
			Program: [
			  "body",
			  "directives",
			  "sourceType",
			  "interpreter",
			],
			ObjectExpression: [
			  "properties",
			],
			ObjectMethod: [
			  "kind",
			  "key",
			  "params",
			  "body",
			  "computed",
			  "generator",
			  "async",
			],
			ObjectProperty: [
			  "key",
			  "value",
			  "computed",
			  "shorthand",
			  "decorators",
			],
			RestElement: [
			  "argument",
			],
			ReturnStatement: [
			  "argument",
			],
			SequenceExpression: [
			  "expressions",
			],
			ParenthesizedExpression: [
			  "expression",
			],
			SwitchCase: [
			  "test",
			  "consequent",
			],
			SwitchStatement: [
			  "discriminant",
			  "cases",
			],
			ThisExpression: [
			],
			ThrowStatement: [
			  "argument",
			],
			TryStatement: [
			  "block",
			  "handler",
			  "finalizer",
			],
			UnaryExpression: [
			  "operator",
			  "argument",
			  "prefix",
			],
			UpdateExpression: [
			  "operator",
			  "argument",
			  "prefix",
			],
			VariableDeclaration: [
			  "kind",
			  "declarations",
			],
			VariableDeclarator: [
			  "id",
			  "init",
			],
			WhileStatement: [
			  "test",
			  "body",
			],
			WithStatement: [
			  "object",
			  "body",
			],
			AssignmentPattern: [
			  "left",
			  "right",
			],
			ArrayPattern: [
			  "elements",
			],
			ArrowFunctionExpression: [
			  "params",
			  "body",
			  "async",
			],
			ClassBody: [
			  "body",
			],
			ClassExpression: [
			  "id",
			  "superClass",
			  "body",
			  "decorators",
			],
			ClassDeclaration: [
			  "id",
			  "superClass",
			  "body",
			  "decorators",
			],
			ExportAllDeclaration: [
			  "source",
			],
			ExportDefaultDeclaration: [
			  "declaration",
			],
			ExportNamedDeclaration: [
			  "declaration",
			  "specifiers",
			  "source",
			],
			ExportSpecifier: [
			  "local",
			  "exported",
			],
			ForOfStatement: [
			  "left",
			  "right",
			  "body",
			  "await",
			],
			ImportDeclaration: [
			  "specifiers",
			  "source",
			],
			ImportDefaultSpecifier: [
			  "local",
			],
			ImportNamespaceSpecifier: [
			  "local",
			],
			ImportSpecifier: [
			  "local",
			  "imported",
			],
			ImportExpression: [
			  "source",
			  "options",
			],
			MetaProperty: [
			  "meta",
			  "property",
			],
			ClassMethod: [
			  "kind",
			  "key",
			  "params",
			  "body",
			  "computed",
			  "static",
			  "generator",
			  "async",
			],
			ObjectPattern: [
			  "properties",
			],
			SpreadElement: [
			  "argument",
			],
			Super: [
			],
			TaggedTemplateExpression: [
			  "tag",
			  "quasi",
			],
			TemplateElement: [
			  "value",
			  "tail",
			],
			TemplateLiteral: [
			  "quasis",
			  "expressions",
			],
			YieldExpression: [
			  "argument",
			  "delegate",
			],
			AwaitExpression: [
			  "argument",
			],
			Import: [
			],
			BigIntLiteral: [
			  "value",
			],
			ExportNamespaceSpecifier: [
			  "exported",
			],
			OptionalMemberExpression: [
			  "object",
			  "property",
			  "computed",
			  "optional",
			],
			OptionalCallExpression: [
			  "callee",
			  "arguments",
			  "optional",
			],
			ClassProperty: [
			  "key",
			  "value",
			  "typeAnnotation",
			  "decorators",
			  "computed",
			  "static",
			],
			ClassAccessorProperty: [
			  "key",
			  "value",
			  "typeAnnotation",
			  "decorators",
			  "computed",
			  "static",
			],
			ClassPrivateProperty: [
			  "key",
			  "value",
			  "decorators",
			  "static",
			],
			ClassPrivateMethod: [
			  "kind",
			  "key",
			  "params",
			  "body",
			  "static",
			],
			PrivateName: [
			  "id",
			],
			StaticBlock: [
			  "body",
			],
			AnyTypeAnnotation: [
			],
			ArrayTypeAnnotation: [
			  "elementType",
			],
			BooleanTypeAnnotation: [
			],
			BooleanLiteralTypeAnnotation: [
			  "value",
			],
			NullLiteralTypeAnnotation: [
			],
			ClassImplements: [
			  "id",
			  "typeParameters",
			],
			DeclareClass: [
			  "id",
			  "typeParameters",
			  "extends",
			  "body",
			],
			DeclareFunction: [
			  "id",
			],
			DeclareInterface: [
			  "id",
			  "typeParameters",
			  "extends",
			  "body",
			],
			DeclareModule: [
			  "id",
			  "body",
			  "kind",
			],
			DeclareModuleExports: [
			  "typeAnnotation",
			],
			DeclareTypeAlias: [
			  "id",
			  "typeParameters",
			  "right",
			],
			DeclareOpaqueType: [
			  "id",
			  "typeParameters",
			  "supertype",
			],
			DeclareVariable: [
			  "id",
			],
			DeclareExportDeclaration: [
			  "declaration",
			  "specifiers",
			  "source",
			],
			DeclareExportAllDeclaration: [
			  "source",
			],
			DeclaredPredicate: [
			  "value",
			],
			ExistsTypeAnnotation: [
			],
			FunctionTypeAnnotation: [
			  "typeParameters",
			  "params",
			  "rest",
			  "returnType",
			],
			FunctionTypeParam: [
			  "name",
			  "typeAnnotation",
			],
			GenericTypeAnnotation: [
			  "id",
			  "typeParameters",
			],
			InferredPredicate: [
			],
			InterfaceExtends: [
			  "id",
			  "typeParameters",
			],
			InterfaceDeclaration: [
			  "id",
			  "typeParameters",
			  "extends",
			  "body",
			],
			InterfaceTypeAnnotation: [
			  "extends",
			  "body",
			],
			IntersectionTypeAnnotation: [
			  "types",
			],
			MixedTypeAnnotation: [
			],
			EmptyTypeAnnotation: [
			],
			NullableTypeAnnotation: [
			  "typeAnnotation",
			],
			NumberLiteralTypeAnnotation: [
			  "value",
			],
			NumberTypeAnnotation: [
			],
			ObjectTypeAnnotation: [
			  "properties",
			  "indexers",
			  "callProperties",
			  "internalSlots",
			  "exact",
			],
			ObjectTypeInternalSlot: [
			  "id",
			  "value",
			  "optional",
			  "static",
			  "method",
			],
			ObjectTypeCallProperty: [
			  "value",
			],
			ObjectTypeIndexer: [
			  "id",
			  "key",
			  "value",
			  "variance",
			],
			ObjectTypeProperty: [
			  "key",
			  "value",
			  "variance",
			],
			ObjectTypeSpreadProperty: [
			  "argument",
			],
			OpaqueType: [
			  "id",
			  "typeParameters",
			  "supertype",
			  "impltype",
			],
			QualifiedTypeIdentifier: [
			  "id",
			  "qualification",
			],
			StringLiteralTypeAnnotation: [
			  "value",
			],
			StringTypeAnnotation: [
			],
			SymbolTypeAnnotation: [
			],
			ThisTypeAnnotation: [
			],
			TupleTypeAnnotation: [
			  "types",
			],
			TypeofTypeAnnotation: [
			  "argument",
			],
			TypeAlias: [
			  "id",
			  "typeParameters",
			  "right",
			],
			TypeAnnotation: [
			  "typeAnnotation",
			],
			TypeCastExpression: [
			  "expression",
			  "typeAnnotation",
			],
			TypeParameter: [
			  "bound",
			  "default",
			  "variance",
			],
			TypeParameterDeclaration: [
			  "params",
			],
			TypeParameterInstantiation: [
			  "params",
			],
			UnionTypeAnnotation: [
			  "types",
			],
			Variance: [
			  "kind",
			],
			VoidTypeAnnotation: [
			],
			EnumDeclaration: [
			  "id",
			  "body",
			],
			EnumBooleanBody: [
			  "members",
			],
			EnumNumberBody: [
			  "members",
			],
			EnumStringBody: [
			  "members",
			],
			EnumSymbolBody: [
			  "members",
			],
			EnumBooleanMember: [
			  "id",
			],
			EnumNumberMember: [
			  "id",
			  "init",
			],
			EnumStringMember: [
			  "id",
			  "init",
			],
			EnumDefaultedMember: [
			  "id",
			],
			IndexedAccessType: [
			  "objectType",
			  "indexType",
			],
			OptionalIndexedAccessType: [
			  "objectType",
			  "indexType",
			],
			JSXAttribute: [
			  "name",
			  "value",
			],
			JSXClosingElement: [
			  "name",
			],
			JSXElement: [
			  "openingElement",
			  "closingElement",
			  "children",
			  "selfClosing",
			],
			JSXEmptyExpression: [
			],
			JSXExpressionContainer: [
			  "expression",
			],
			JSXSpreadChild: [
			  "expression",
			],
			JSXIdentifier: [
			  "name",
			],
			JSXMemberExpression: [
			  "object",
			  "property",
			],
			JSXNamespacedName: [
			  "namespace",
			  "name",
			],
			JSXOpeningElement: [
			  "name",
			  "attributes",
			  "selfClosing",
			],
			JSXSpreadAttribute: [
			  "argument",
			],
			JSXText: [
			  "value",
			],
			JSXFragment: [
			  "openingFragment",
			  "closingFragment",
			  "children",
			],
			JSXOpeningFragment: [
			],
			JSXClosingFragment: [
			],
			Noop: [
			],
			Placeholder: [
			  "expectedNode",
			  "name",
			],
			V8IntrinsicIdentifier: [
			  "name",
			],
			ArgumentPlaceholder: [
			],
			BindExpression: [
			  "object",
			  "callee",
			],
			ImportAttribute: [
			  "key",
			  "value",
			],
			Decorator: [
			  "expression",
			],
			DoExpression: [
			  "body",
			  "async",
			],
			ExportDefaultSpecifier: [
			  "exported",
			],
			RecordExpression: [
			  "properties",
			],
			TupleExpression: [
			  "elements",
			],
			DecimalLiteral: [
			  "value",
			],
			ModuleExpression: [
			  "body",
			],
			TopicReference: [
			],
			PipelineTopicExpression: [
			  "expression",
			],
			PipelineBareFunction: [
			  "callee",
			],
			PipelinePrimaryTopicReference: [
			],
			TSParameterProperty: [
			  "parameter",
			],
			TSDeclareFunction: [
			  "id",
			  "typeParameters",
			  "params",
			  "returnType",
			],
			TSDeclareMethod: [
			  "decorators",
			  "key",
			  "typeParameters",
			  "params",
			  "returnType",
			],
			TSQualifiedName: [
			  "left",
			  "right",
			],
			TSCallSignatureDeclaration: [
			  "typeParameters",
			  "parameters",
			  "typeAnnotation",
			],
			TSConstructSignatureDeclaration: [
			  "typeParameters",
			  "parameters",
			  "typeAnnotation",
			],
			TSPropertySignature: [
			  "key",
			  "typeAnnotation",
			],
			TSMethodSignature: [
			  "key",
			  "typeParameters",
			  "parameters",
			  "typeAnnotation",
			],
			TSIndexSignature: [
			  "parameters",
			  "typeAnnotation",
			],
			TSAnyKeyword: [
			],
			TSBooleanKeyword: [
			],
			TSBigIntKeyword: [
			],
			TSIntrinsicKeyword: [
			],
			TSNeverKeyword: [
			],
			TSNullKeyword: [
			],
			TSNumberKeyword: [
			],
			TSObjectKeyword: [
			],
			TSStringKeyword: [
			],
			TSSymbolKeyword: [
			],
			TSUndefinedKeyword: [
			],
			TSUnknownKeyword: [
			],
			TSVoidKeyword: [
			],
			TSThisType: [
			],
			TSFunctionType: [
			  "typeParameters",
			  "parameters",
			  "typeAnnotation",
			],
			TSConstructorType: [
			  "typeParameters",
			  "parameters",
			  "typeAnnotation",
			],
			TSTypeReference: [
			  "typeName",
			  "typeParameters",
			],
			TSTypePredicate: [
			  "parameterName",
			  "typeAnnotation",
			  "asserts",
			],
			TSTypeQuery: [
			  "exprName",
			  "typeParameters",
			],
			TSTypeLiteral: [
			  "members",
			],
			TSArrayType: [
			  "elementType",
			],
			TSTupleType: [
			  "elementTypes",
			],
			TSOptionalType: [
			  "typeAnnotation",
			],
			TSRestType: [
			  "typeAnnotation",
			],
			TSNamedTupleMember: [
			  "label",
			  "elementType",
			  "optional",
			],
			TSUnionType: [
			  "types",
			],
			TSIntersectionType: [
			  "types",
			],
			TSConditionalType: [
			  "checkType",
			  "extendsType",
			  "trueType",
			  "falseType",
			],
			TSInferType: [
			  "typeParameter",
			],
			TSParenthesizedType: [
			  "typeAnnotation",
			],
			TSTypeOperator: [
			  "typeAnnotation",
			],
			TSIndexedAccessType: [
			  "objectType",
			  "indexType",
			],
			TSMappedType: [
			  "typeParameter",
			  "typeAnnotation",
			  "nameType",
			],
			TSLiteralType: [
			  "literal",
			],
			TSExpressionWithTypeArguments: [
			  "expression",
			  "typeParameters",
			],
			TSInterfaceDeclaration: [
			  "id",
			  "typeParameters",
			  "extends",
			  "body",
			],
			TSInterfaceBody: [
			  "body",
			],
			TSTypeAliasDeclaration: [
			  "id",
			  "typeParameters",
			  "typeAnnotation",
			],
			TSInstantiationExpression: [
			  "expression",
			  "typeParameters",
			],
			TSAsExpression: [
			  "expression",
			  "typeAnnotation",
			],
			TSSatisfiesExpression: [
			  "expression",
			  "typeAnnotation",
			],
			TSTypeAssertion: [
			  "typeAnnotation",
			  "expression",
			],
			TSEnumDeclaration: [
			  "id",
			  "members",
			],
			TSEnumMember: [
			  "id",
			  "initializer",
			],
			TSModuleDeclaration: [
			  "id",
			  "body",
			],
			TSModuleBlock: [
			  "body",
			],
			TSImportType: [
			  "argument",
			  "qualifier",
			  "typeParameters",
			],
			TSImportEqualsDeclaration: [
			  "id",
			  "moduleReference",
			],
			TSExternalModuleReference: [
			  "expression",
			],
			TSNonNullExpression: [
			  "expression",
			],
			TSExportAssignment: [
			  "expression",
			],
			TSNamespaceExportDeclaration: [
			  "id",
			],
			TSTypeAnnotation: [
			  "typeAnnotation",
			],
			TSTypeParameterInstantiation: [
			  "params",
			],
			TSTypeParameterDeclaration: [
			  "params",
			],
			TSTypeParameter: [
			  "constraint",
			  "default",
			  "name",
			],
		  },
		  DEPRECATED_ALIASES: {
			ModuleDeclaration: "ImportOrExportDeclaration",
		  },
		  DEPRECATED_KEYS: {
			NumberLiteral: "NumericLiteral",
			RegexLiteral: "RegExpLiteral",
			RestProperty: "RestElement",
			SpreadProperty: "SpreadElement",
		  },
		  FLIPPED_ALIAS_KEYS: {
			Standardized: [
			  "ArrayExpression",
			  "AssignmentExpression",
			  "BinaryExpression",
			  "InterpreterDirective",
			  "Directive",
			  "DirectiveLiteral",
			  "BlockStatement",
			  "BreakStatement",
			  "CallExpression",
			  "CatchClause",
			  "ConditionalExpression",
			  "ContinueStatement",
			  "DebuggerStatement",
			  "DoWhileStatement",
			  "EmptyStatement",
			  "ExpressionStatement",
			  "File",
			  "ForInStatement",
			  "ForStatement",
			  "FunctionDeclaration",
			  "FunctionExpression",
			  "Identifier",
			  "IfStatement",
			  "LabeledStatement",
			  "StringLiteral",
			  "NumericLiteral",
			  "NullLiteral",
			  "BooleanLiteral",
			  "RegExpLiteral",
			  "LogicalExpression",
			  "MemberExpression",
			  "NewExpression",
			  "Program",
			  "ObjectExpression",
			  "ObjectMethod",
			  "ObjectProperty",
			  "RestElement",
			  "ReturnStatement",
			  "SequenceExpression",
			  "ParenthesizedExpression",
			  "SwitchCase",
			  "SwitchStatement",
			  "ThisExpression",
			  "ThrowStatement",
			  "TryStatement",
			  "UnaryExpression",
			  "UpdateExpression",
			  "VariableDeclaration",
			  "VariableDeclarator",
			  "WhileStatement",
			  "WithStatement",
			  "AssignmentPattern",
			  "ArrayPattern",
			  "ArrowFunctionExpression",
			  "ClassBody",
			  "ClassExpression",
			  "ClassDeclaration",
			  "ExportAllDeclaration",
			  "ExportDefaultDeclaration",
			  "ExportNamedDeclaration",
			  "ExportSpecifier",
			  "ForOfStatement",
			  "ImportDeclaration",
			  "ImportDefaultSpecifier",
			  "ImportNamespaceSpecifier",
			  "ImportSpecifier",
			  "ImportExpression",
			  "MetaProperty",
			  "ClassMethod",
			  "ObjectPattern",
			  "SpreadElement",
			  "Super",
			  "TaggedTemplateExpression",
			  "TemplateElement",
			  "TemplateLiteral",
			  "YieldExpression",
			  "AwaitExpression",
			  "Import",
			  "BigIntLiteral",
			  "ExportNamespaceSpecifier",
			  "OptionalMemberExpression",
			  "OptionalCallExpression",
			  "ClassProperty",
			  "ClassAccessorProperty",
			  "ClassPrivateProperty",
			  "ClassPrivateMethod",
			  "PrivateName",
			  "StaticBlock",
			],
			Expression: [
			  "ArrayExpression",
			  "AssignmentExpression",
			  "BinaryExpression",
			  "CallExpression",
			  "ConditionalExpression",
			  "FunctionExpression",
			  "Identifier",
			  "StringLiteral",
			  "NumericLiteral",
			  "NullLiteral",
			  "BooleanLiteral",
			  "RegExpLiteral",
			  "LogicalExpression",
			  "MemberExpression",
			  "NewExpression",
			  "ObjectExpression",
			  "SequenceExpression",
			  "ParenthesizedExpression",
			  "ThisExpression",
			  "UnaryExpression",
			  "UpdateExpression",
			  "ArrowFunctionExpression",
			  "ClassExpression",
			  "ImportExpression",
			  "MetaProperty",
			  "Super",
			  "TaggedTemplateExpression",
			  "TemplateLiteral",
			  "YieldExpression",
			  "AwaitExpression",
			  "Import",
			  "BigIntLiteral",
			  "OptionalMemberExpression",
			  "OptionalCallExpression",
			  "TypeCastExpression",
			  "JSXElement",
			  "JSXFragment",
			  "BindExpression",
			  "DoExpression",
			  "RecordExpression",
			  "TupleExpression",
			  "DecimalLiteral",
			  "ModuleExpression",
			  "TopicReference",
			  "PipelineTopicExpression",
			  "PipelineBareFunction",
			  "PipelinePrimaryTopicReference",
			  "TSInstantiationExpression",
			  "TSAsExpression",
			  "TSSatisfiesExpression",
			  "TSTypeAssertion",
			  "TSNonNullExpression",
			],
			Binary: [
			  "BinaryExpression",
			  "LogicalExpression",
			],
			Scopable: [
			  "BlockStatement",
			  "CatchClause",
			  "DoWhileStatement",
			  "ForInStatement",
			  "ForStatement",
			  "FunctionDeclaration",
			  "FunctionExpression",
			  "Program",
			  "ObjectMethod",
			  "SwitchStatement",
			  "WhileStatement",
			  "ArrowFunctionExpression",
			  "ClassExpression",
			  "ClassDeclaration",
			  "ForOfStatement",
			  "ClassMethod",
			  "ClassPrivateMethod",
			  "StaticBlock",
			  "TSModuleBlock",
			],
			BlockParent: [
			  "BlockStatement",
			  "CatchClause",
			  "DoWhileStatement",
			  "ForInStatement",
			  "ForStatement",
			  "FunctionDeclaration",
			  "FunctionExpression",
			  "Program",
			  "ObjectMethod",
			  "SwitchStatement",
			  "WhileStatement",
			  "ArrowFunctionExpression",
			  "ForOfStatement",
			  "ClassMethod",
			  "ClassPrivateMethod",
			  "StaticBlock",
			  "TSModuleBlock",
			],
			Block: [
			  "BlockStatement",
			  "Program",
			  "TSModuleBlock",
			],
			Statement: [
			  "BlockStatement",
			  "BreakStatement",
			  "ContinueStatement",
			  "DebuggerStatement",
			  "DoWhileStatement",
			  "EmptyStatement",
			  "ExpressionStatement",
			  "ForInStatement",
			  "ForStatement",
			  "FunctionDeclaration",
			  "IfStatement",
			  "LabeledStatement",
			  "ReturnStatement",
			  "SwitchStatement",
			  "ThrowStatement",
			  "TryStatement",
			  "VariableDeclaration",
			  "WhileStatement",
			  "WithStatement",
			  "ClassDeclaration",
			  "ExportAllDeclaration",
			  "ExportDefaultDeclaration",
			  "ExportNamedDeclaration",
			  "ForOfStatement",
			  "ImportDeclaration",
			  "DeclareClass",
			  "DeclareFunction",
			  "DeclareInterface",
			  "DeclareModule",
			  "DeclareModuleExports",
			  "DeclareTypeAlias",
			  "DeclareOpaqueType",
			  "DeclareVariable",
			  "DeclareExportDeclaration",
			  "DeclareExportAllDeclaration",
			  "InterfaceDeclaration",
			  "OpaqueType",
			  "TypeAlias",
			  "EnumDeclaration",
			  "TSDeclareFunction",
			  "TSInterfaceDeclaration",
			  "TSTypeAliasDeclaration",
			  "TSEnumDeclaration",
			  "TSModuleDeclaration",
			  "TSImportEqualsDeclaration",
			  "TSExportAssignment",
			  "TSNamespaceExportDeclaration",
			],
			Terminatorless: [
			  "BreakStatement",
			  "ContinueStatement",
			  "ReturnStatement",
			  "ThrowStatement",
			  "YieldExpression",
			  "AwaitExpression",
			],
			CompletionStatement: [
			  "BreakStatement",
			  "ContinueStatement",
			  "ReturnStatement",
			  "ThrowStatement",
			],
			Conditional: [
			  "ConditionalExpression",
			  "IfStatement",
			],
			Loop: [
			  "DoWhileStatement",
			  "ForInStatement",
			  "ForStatement",
			  "WhileStatement",
			  "ForOfStatement",
			],
			While: [
			  "DoWhileStatement",
			  "WhileStatement",
			],
			ExpressionWrapper: [
			  "ExpressionStatement",
			  "ParenthesizedExpression",
			  "TypeCastExpression",
			],
			For: [
			  "ForInStatement",
			  "ForStatement",
			  "ForOfStatement",
			],
			ForXStatement: [
			  "ForInStatement",
			  "ForOfStatement",
			],
			Function: [
			  "FunctionDeclaration",
			  "FunctionExpression",
			  "ObjectMethod",
			  "ArrowFunctionExpression",
			  "ClassMethod",
			  "ClassPrivateMethod",
			],
			FunctionParent: [
			  "FunctionDeclaration",
			  "FunctionExpression",
			  "ObjectMethod",
			  "ArrowFunctionExpression",
			  "ClassMethod",
			  "ClassPrivateMethod",
			  "StaticBlock",
			  "TSModuleBlock",
			],
			Pureish: [
			  "FunctionDeclaration",
			  "FunctionExpression",
			  "StringLiteral",
			  "NumericLiteral",
			  "NullLiteral",
			  "BooleanLiteral",
			  "RegExpLiteral",
			  "ArrowFunctionExpression",
			  "BigIntLiteral",
			  "DecimalLiteral",
			],
			Declaration: [
			  "FunctionDeclaration",
			  "VariableDeclaration",
			  "ClassDeclaration",
			  "ExportAllDeclaration",
			  "ExportDefaultDeclaration",
			  "ExportNamedDeclaration",
			  "ImportDeclaration",
			  "DeclareClass",
			  "DeclareFunction",
			  "DeclareInterface",
			  "DeclareModule",
			  "DeclareModuleExports",
			  "DeclareTypeAlias",
			  "DeclareOpaqueType",
			  "DeclareVariable",
			  "DeclareExportDeclaration",
			  "DeclareExportAllDeclaration",
			  "InterfaceDeclaration",
			  "OpaqueType",
			  "TypeAlias",
			  "EnumDeclaration",
			  "TSDeclareFunction",
			  "TSInterfaceDeclaration",
			  "TSTypeAliasDeclaration",
			  "TSEnumDeclaration",
			  "TSModuleDeclaration",
			],
			PatternLike: [
			  "Identifier",
			  "RestElement",
			  "AssignmentPattern",
			  "ArrayPattern",
			  "ObjectPattern",
			  "TSAsExpression",
			  "TSSatisfiesExpression",
			  "TSTypeAssertion",
			  "TSNonNullExpression",
			],
			LVal: [
			  "Identifier",
			  "MemberExpression",
			  "RestElement",
			  "AssignmentPattern",
			  "ArrayPattern",
			  "ObjectPattern",
			  "TSParameterProperty",
			  "TSAsExpression",
			  "TSSatisfiesExpression",
			  "TSTypeAssertion",
			  "TSNonNullExpression",
			],
			TSEntityName: [
			  "Identifier",
			  "TSQualifiedName",
			],
			Literal: [
			  "StringLiteral",
			  "NumericLiteral",
			  "NullLiteral",
			  "BooleanLiteral",
			  "RegExpLiteral",
			  "TemplateLiteral",
			  "BigIntLiteral",
			  "DecimalLiteral",
			],
			Immutable: [
			  "StringLiteral",
			  "NumericLiteral",
			  "NullLiteral",
			  "BooleanLiteral",
			  "BigIntLiteral",
			  "JSXAttribute",
			  "JSXClosingElement",
			  "JSXElement",
			  "JSXExpressionContainer",
			  "JSXSpreadChild",
			  "JSXOpeningElement",
			  "JSXText",
			  "JSXFragment",
			  "JSXOpeningFragment",
			  "JSXClosingFragment",
			  "DecimalLiteral",
			],
			UserWhitespacable: [
			  "ObjectMethod",
			  "ObjectProperty",
			  "ObjectTypeInternalSlot",
			  "ObjectTypeCallProperty",
			  "ObjectTypeIndexer",
			  "ObjectTypeProperty",
			  "ObjectTypeSpreadProperty",
			],
			Method: [
			  "ObjectMethod",
			  "ClassMethod",
			  "ClassPrivateMethod",
			],
			ObjectMember: [
			  "ObjectMethod",
			  "ObjectProperty",
			],
			Property: [
			  "ObjectProperty",
			  "ClassProperty",
			  "ClassAccessorProperty",
			  "ClassPrivateProperty",
			],
			UnaryLike: [
			  "UnaryExpression",
			  "SpreadElement",
			],
			Pattern: [
			  "AssignmentPattern",
			  "ArrayPattern",
			  "ObjectPattern",
			],
			Class: [
			  "ClassExpression",
			  "ClassDeclaration",
			],
			ImportOrExportDeclaration: [
			  "ExportAllDeclaration",
			  "ExportDefaultDeclaration",
			  "ExportNamedDeclaration",
			  "ImportDeclaration",
			],
			ExportDeclaration: [
			  "ExportAllDeclaration",
			  "ExportDefaultDeclaration",
			  "ExportNamedDeclaration",
			],
			ModuleSpecifier: [
			  "ExportSpecifier",
			  "ImportDefaultSpecifier",
			  "ImportNamespaceSpecifier",
			  "ImportSpecifier",
			  "ExportNamespaceSpecifier",
			  "ExportDefaultSpecifier",
			],
			Accessor: [
			  "ClassAccessorProperty",
			],
			Private: [
			  "ClassPrivateProperty",
			  "ClassPrivateMethod",
			  "PrivateName",
			],
			Flow: [
			  "AnyTypeAnnotation",
			  "ArrayTypeAnnotation",
			  "BooleanTypeAnnotation",
			  "BooleanLiteralTypeAnnotation",
			  "NullLiteralTypeAnnotation",
			  "ClassImplements",
			  "DeclareClass",
			  "DeclareFunction",
			  "DeclareInterface",
			  "DeclareModule",
			  "DeclareModuleExports",
			  "DeclareTypeAlias",
			  "DeclareOpaqueType",
			  "DeclareVariable",
			  "DeclareExportDeclaration",
			  "DeclareExportAllDeclaration",
			  "DeclaredPredicate",
			  "ExistsTypeAnnotation",
			  "FunctionTypeAnnotation",
			  "FunctionTypeParam",
			  "GenericTypeAnnotation",
			  "InferredPredicate",
			  "InterfaceExtends",
			  "InterfaceDeclaration",
			  "InterfaceTypeAnnotation",
			  "IntersectionTypeAnnotation",
			  "MixedTypeAnnotation",
			  "EmptyTypeAnnotation",
			  "NullableTypeAnnotation",
			  "NumberLiteralTypeAnnotation",
			  "NumberTypeAnnotation",
			  "ObjectTypeAnnotation",
			  "ObjectTypeInternalSlot",
			  "ObjectTypeCallProperty",
			  "ObjectTypeIndexer",
			  "ObjectTypeProperty",
			  "ObjectTypeSpreadProperty",
			  "OpaqueType",
			  "QualifiedTypeIdentifier",
			  "StringLiteralTypeAnnotation",
			  "StringTypeAnnotation",
			  "SymbolTypeAnnotation",
			  "ThisTypeAnnotation",
			  "TupleTypeAnnotation",
			  "TypeofTypeAnnotation",
			  "TypeAlias",
			  "TypeAnnotation",
			  "TypeCastExpression",
			  "TypeParameter",
			  "TypeParameterDeclaration",
			  "TypeParameterInstantiation",
			  "UnionTypeAnnotation",
			  "Variance",
			  "VoidTypeAnnotation",
			  "EnumDeclaration",
			  "EnumBooleanBody",
			  "EnumNumberBody",
			  "EnumStringBody",
			  "EnumSymbolBody",
			  "EnumBooleanMember",
			  "EnumNumberMember",
			  "EnumStringMember",
			  "EnumDefaultedMember",
			  "IndexedAccessType",
			  "OptionalIndexedAccessType",
			],
			FlowType: [
			  "AnyTypeAnnotation",
			  "ArrayTypeAnnotation",
			  "BooleanTypeAnnotation",
			  "BooleanLiteralTypeAnnotation",
			  "NullLiteralTypeAnnotation",
			  "ExistsTypeAnnotation",
			  "FunctionTypeAnnotation",
			  "GenericTypeAnnotation",
			  "InterfaceTypeAnnotation",
			  "IntersectionTypeAnnotation",
			  "MixedTypeAnnotation",
			  "EmptyTypeAnnotation",
			  "NullableTypeAnnotation",
			  "NumberLiteralTypeAnnotation",
			  "NumberTypeAnnotation",
			  "ObjectTypeAnnotation",
			  "StringLiteralTypeAnnotation",
			  "StringTypeAnnotation",
			  "SymbolTypeAnnotation",
			  "ThisTypeAnnotation",
			  "TupleTypeAnnotation",
			  "TypeofTypeAnnotation",
			  "UnionTypeAnnotation",
			  "VoidTypeAnnotation",
			  "IndexedAccessType",
			  "OptionalIndexedAccessType",
			],
			FlowBaseAnnotation: [
			  "AnyTypeAnnotation",
			  "BooleanTypeAnnotation",
			  "NullLiteralTypeAnnotation",
			  "MixedTypeAnnotation",
			  "EmptyTypeAnnotation",
			  "NumberTypeAnnotation",
			  "StringTypeAnnotation",
			  "SymbolTypeAnnotation",
			  "ThisTypeAnnotation",
			  "VoidTypeAnnotation",
			],
			FlowDeclaration: [
			  "DeclareClass",
			  "DeclareFunction",
			  "DeclareInterface",
			  "DeclareModule",
			  "DeclareModuleExports",
			  "DeclareTypeAlias",
			  "DeclareOpaqueType",
			  "DeclareVariable",
			  "DeclareExportDeclaration",
			  "DeclareExportAllDeclaration",
			  "InterfaceDeclaration",
			  "OpaqueType",
			  "TypeAlias",
			],
			FlowPredicate: [
			  "DeclaredPredicate",
			  "InferredPredicate",
			],
			EnumBody: [
			  "EnumBooleanBody",
			  "EnumNumberBody",
			  "EnumStringBody",
			  "EnumSymbolBody",
			],
			EnumMember: [
			  "EnumBooleanMember",
			  "EnumNumberMember",
			  "EnumStringMember",
			  "EnumDefaultedMember",
			],
			JSX: [
			  "JSXAttribute",
			  "JSXClosingElement",
			  "JSXElement",
			  "JSXEmptyExpression",
			  "JSXExpressionContainer",
			  "JSXSpreadChild",
			  "JSXIdentifier",
			  "JSXMemberExpression",
			  "JSXNamespacedName",
			  "JSXOpeningElement",
			  "JSXSpreadAttribute",
			  "JSXText",
			  "JSXFragment",
			  "JSXOpeningFragment",
			  "JSXClosingFragment",
			],
			Miscellaneous: [
			  "Noop",
			  "Placeholder",
			  "V8IntrinsicIdentifier",
			],
			TypeScript: [
			  "TSParameterProperty",
			  "TSDeclareFunction",
			  "TSDeclareMethod",
			  "TSQualifiedName",
			  "TSCallSignatureDeclaration",
			  "TSConstructSignatureDeclaration",
			  "TSPropertySignature",
			  "TSMethodSignature",
			  "TSIndexSignature",
			  "TSAnyKeyword",
			  "TSBooleanKeyword",
			  "TSBigIntKeyword",
			  "TSIntrinsicKeyword",
			  "TSNeverKeyword",
			  "TSNullKeyword",
			  "TSNumberKeyword",
			  "TSObjectKeyword",
			  "TSStringKeyword",
			  "TSSymbolKeyword",
			  "TSUndefinedKeyword",
			  "TSUnknownKeyword",
			  "TSVoidKeyword",
			  "TSThisType",
			  "TSFunctionType",
			  "TSConstructorType",
			  "TSTypeReference",
			  "TSTypePredicate",
			  "TSTypeQuery",
			  "TSTypeLiteral",
			  "TSArrayType",
			  "TSTupleType",
			  "TSOptionalType",
			  "TSRestType",
			  "TSNamedTupleMember",
			  "TSUnionType",
			  "TSIntersectionType",
			  "TSConditionalType",
			  "TSInferType",
			  "TSParenthesizedType",
			  "TSTypeOperator",
			  "TSIndexedAccessType",
			  "TSMappedType",
			  "TSLiteralType",
			  "TSExpressionWithTypeArguments",
			  "TSInterfaceDeclaration",
			  "TSInterfaceBody",
			  "TSTypeAliasDeclaration",
			  "TSInstantiationExpression",
			  "TSAsExpression",
			  "TSSatisfiesExpression",
			  "TSTypeAssertion",
			  "TSEnumDeclaration",
			  "TSEnumMember",
			  "TSModuleDeclaration",
			  "TSModuleBlock",
			  "TSImportType",
			  "TSImportEqualsDeclaration",
			  "TSExternalModuleReference",
			  "TSNonNullExpression",
			  "TSExportAssignment",
			  "TSNamespaceExportDeclaration",
			  "TSTypeAnnotation",
			  "TSTypeParameterInstantiation",
			  "TSTypeParameterDeclaration",
			  "TSTypeParameter",
			],
			TSTypeElement: [
			  "TSCallSignatureDeclaration",
			  "TSConstructSignatureDeclaration",
			  "TSPropertySignature",
			  "TSMethodSignature",
			  "TSIndexSignature",
			],
			TSType: [
			  "TSAnyKeyword",
			  "TSBooleanKeyword",
			  "TSBigIntKeyword",
			  "TSIntrinsicKeyword",
			  "TSNeverKeyword",
			  "TSNullKeyword",
			  "TSNumberKeyword",
			  "TSObjectKeyword",
			  "TSStringKeyword",
			  "TSSymbolKeyword",
			  "TSUndefinedKeyword",
			  "TSUnknownKeyword",
			  "TSVoidKeyword",
			  "TSThisType",
			  "TSFunctionType",
			  "TSConstructorType",
			  "TSTypeReference",
			  "TSTypePredicate",
			  "TSTypeQuery",
			  "TSTypeLiteral",
			  "TSArrayType",
			  "TSTupleType",
			  "TSOptionalType",
			  "TSRestType",
			  "TSUnionType",
			  "TSIntersectionType",
			  "TSConditionalType",
			  "TSInferType",
			  "TSParenthesizedType",
			  "TSTypeOperator",
			  "TSIndexedAccessType",
			  "TSMappedType",
			  "TSLiteralType",
			  "TSExpressionWithTypeArguments",
			  "TSImportType",
			],
			TSBaseType: [
			  "TSAnyKeyword",
			  "TSBooleanKeyword",
			  "TSBigIntKeyword",
			  "TSIntrinsicKeyword",
			  "TSNeverKeyword",
			  "TSNullKeyword",
			  "TSNumberKeyword",
			  "TSObjectKeyword",
			  "TSStringKeyword",
			  "TSSymbolKeyword",
			  "TSUndefinedKeyword",
			  "TSUnknownKeyword",
			  "TSVoidKeyword",
			  "TSThisType",
			  "TSLiteralType",
			],
			ModuleDeclaration: [
			  "ExportAllDeclaration",
			  "ExportDefaultDeclaration",
			  "ExportNamedDeclaration",
			  "ImportDeclaration",
			],
		  },
		  NODE_FIELDS: {
			ArrayExpression: {
			  elements: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: [
				],
			  },
			},
			AssignmentExpression: {
			  operator: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  left: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  right: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			BinaryExpression: {
			  operator: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: null,
			  },
			  left: {
				validate: function (node, key, val) {
				  const validator = node.operator === "in" ? inOp : expression;
				  validator(node, key, val);
				},
				default: null,
			  },
			  right: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			InterpreterDirective: {
			  value: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			Directive: {
			  value: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			DirectiveLiteral: {
			  value: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			BlockStatement: {
			  directives: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: [
				],
			  },
			  body: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			BreakStatement: {
			  label: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			CallExpression: {
			  callee: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  arguments: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  typeArguments: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			CatchClause: {
			  param: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			ConditionalExpression: {
			  test: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  consequent: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  alternate: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			ContinueStatement: {
			  label: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			DebuggerStatement: {
			},
			DoWhileStatement: {
			  test: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			EmptyStatement: {
			},
			ExpressionStatement: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			File: {
			  program: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  comments: {
				validate: () => {},
				optional: true,
				default: null,
			  },
			  tokens: {
				validate: function validator(node, key, val) {
				  if (!Array.isArray(val)) return;
				  for (let i = 0; i < val.length; i++) {
					const subkey = `${key}[${i}]`;
					const v = val[i];
					callback(node, subkey, v);
					if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			ForInStatement: {
			  left: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  right: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			ForStatement: {
			  init: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  test: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  update: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			FunctionDeclaration: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  generator: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  async: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  declare: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  returnType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  predicate: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			FunctionExpression: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  generator: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  async: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  returnType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  predicate: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			Identifier: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  name: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			IfStatement: {
			  test: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  consequent: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  alternate: {
				optional: true,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			LabeledStatement: {
			  label: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			StringLiteral: {
			  value: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			NumericLiteral: {
			  value: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			NullLiteral: {
			},
			BooleanLiteral: {
			  value: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			RegExpLiteral: {
			  pattern: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  flags: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: "",
			  },
			},
			LogicalExpression: {
			  operator: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: null,
			  },
			  left: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  right: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			MemberExpression: {
			  object: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  property: {
				validate: function (node, key, val) {
				  const validator = node.computed ? computed : normal;
				  validator(node, key, val);
				},
				default: null,
			  },
			  computed: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			NewExpression: {
			  callee: {
				default: null,
				optional: undefined,
				deprecated: undefined,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
			  },
			  arguments: {
				default: null,
				optional: undefined,
				deprecated: undefined,
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
			  },
			  optional: {
				default: null,
				optional: true,
				deprecated: undefined,
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
			  },
			  typeArguments: {
				default: null,
				optional: true,
				deprecated: undefined,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
			  },
			  typeParameters: {
				default: null,
				optional: true,
				deprecated: undefined,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
			  },
			},
			Program: {
			  sourceType: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: "script",
			  },
			  interpreter: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
				optional: true,
			  },
			  directives: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: [
				],
			  },
			  body: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			ObjectExpression: {
			  properties: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			ObjectMethod: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  generator: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  async: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  returnType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  kind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: "method",
			  },
			  computed: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  key: {
				validate: function (node, key, val) {
				  const validator = node.computed ? computed : normal;
				  validator(node, key, val);
				},
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			ObjectProperty: {
			  computed: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  key: {
				validate: function (node, key, val) {
				  const validator = node.computed ? computed : normal;
				  validator(node, key, val);
				},
				default: null,
			  },
			  value: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  shorthand: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: false,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			RestElement: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  argument: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			ReturnStatement: {
			  argument: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			SequenceExpression: {
			  expressions: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			ParenthesizedExpression: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			SwitchCase: {
			  test: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  consequent: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			SwitchStatement: {
			  discriminant: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  cases: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			ThisExpression: {
			},
			ThrowStatement: {
			  argument: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TryStatement: {
			  block: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  handler: {
				optional: true,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  finalizer: {
				optional: true,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			UnaryExpression: {
			  prefix: {
				default: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  argument: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  operator: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: null,
			  },
			},
			UpdateExpression: {
			  prefix: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  argument: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  operator: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: null,
			  },
			},
			VariableDeclaration: {
			  declare: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  kind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: null,
			  },
			  declarations: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			VariableDeclarator: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  definite: {
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  init: {
				optional: true,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			WhileStatement: {
			  test: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			WithStatement: {
			  object: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			AssignmentPattern: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  left: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  right: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			ArrayPattern: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  elements: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			ArrowFunctionExpression: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  generator: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  async: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  returnType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  expression: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  predicate: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			ClassBody: {
			  body: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			ClassExpression: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  superClass: {
				optional: true,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  superTypeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  implements: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  mixins: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			ClassDeclaration: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  superClass: {
				optional: true,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  superTypeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  implements: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  mixins: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  declare: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  abstract: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			ExportAllDeclaration: {
			  source: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  exportKind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  attributes: {
				optional: true,
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  assertions: {
				optional: true,
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			ExportDefaultDeclaration: {
			  declaration: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  exportKind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			ExportNamedDeclaration: {
			  declaration: {
				optional: true,
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  attributes: {
				optional: true,
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  assertions: {
				optional: true,
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  specifiers: {
				default: [
				],
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
			  },
			  source: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  exportKind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			ExportSpecifier: {
			  local: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  exported: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  exportKind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			ForOfStatement: {
			  left: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  right: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  await: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			},
			ImportDeclaration: {
			  attributes: {
				optional: true,
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  assertions: {
				optional: true,
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  module: {
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  phase: {
				default: null,
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
			  },
			  specifiers: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  source: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  importKind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			ImportDefaultSpecifier: {
			  local: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			ImportNamespaceSpecifier: {
			  local: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			ImportSpecifier: {
			  local: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  imported: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  importKind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			ImportExpression: {
			  phase: {
				default: null,
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
			  },
			  source: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  options: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			MetaProperty: {
			  meta: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  property: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			ClassMethod: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  generator: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  async: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  abstract: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  accessibility: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  static: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  override: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  computed: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  key: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  kind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: "method",
			  },
			  access: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  returnType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			ObjectPattern: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  properties: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			SpreadElement: {
			  argument: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			Super: {
			},
			TaggedTemplateExpression: {
			  tag: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  quasi: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TemplateElement: {
			  value: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  tail: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			},
			TemplateLiteral: {
			  quasis: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  expressions: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			YieldExpression: {
			  delegate: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: false,
			  },
			  argument: {
				optional: true,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			AwaitExpression: {
			  argument: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			Import: {
			},
			BigIntLiteral: {
			  value: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			ExportNamespaceSpecifier: {
			  exported: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			OptionalMemberExpression: {
			  object: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  property: {
				validate: function (node, key, val) {
				  const validator = node.computed ? computed : normal;
				  validator(node, key, val);
				},
				default: null,
			  },
			  computed: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			OptionalCallExpression: {
			  callee: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  arguments: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  typeArguments: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			ClassProperty: {
			  abstract: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  accessibility: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  static: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  override: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  computed: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  key: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  value: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  definite: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  readonly: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  declare: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  variance: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			ClassAccessorProperty: {
			  abstract: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  accessibility: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  static: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  override: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  computed: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  key: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  value: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  definite: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  readonly: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  declare: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  variance: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			ClassPrivateProperty: {
			  key: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  value: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  static: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: false,
			  },
			  readonly: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  definite: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  variance: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			ClassPrivateMethod: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  generator: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  async: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  abstract: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  accessibility: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  static: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  override: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  computed: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  key: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  kind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: "method",
			  },
			  access: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  returnType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			PrivateName: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			StaticBlock: {
			  body: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			AnyTypeAnnotation: {
			},
			ArrayTypeAnnotation: {
			  elementType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			BooleanTypeAnnotation: {
			},
			BooleanLiteralTypeAnnotation: {
			  value: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			NullLiteralTypeAnnotation: {
			},
			ClassImplements: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			DeclareClass: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  extends: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  mixins: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  implements: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			DeclareFunction: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  predicate: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			DeclareInterface: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  extends: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			DeclareModule: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  kind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			DeclareModuleExports: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			DeclareTypeAlias: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  right: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			DeclareOpaqueType: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  supertype: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  impltype: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			DeclareVariable: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			DeclareExportDeclaration: {
			  declaration: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  specifiers: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  source: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  default: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			DeclareExportAllDeclaration: {
			  source: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  exportKind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			DeclaredPredicate: {
			  value: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			ExistsTypeAnnotation: {
			},
			FunctionTypeAnnotation: {
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  rest: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  this: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  returnType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			FunctionTypeParam: {
			  name: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			GenericTypeAnnotation: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			InferredPredicate: {
			},
			InterfaceExtends: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			InterfaceDeclaration: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  extends: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			InterfaceTypeAnnotation: {
			  extends: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			IntersectionTypeAnnotation: {
			  types: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			MixedTypeAnnotation: {
			},
			EmptyTypeAnnotation: {
			},
			NullableTypeAnnotation: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			NumberLiteralTypeAnnotation: {
			  value: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			NumberTypeAnnotation: {
			},
			ObjectTypeAnnotation: {
			  properties: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  indexers: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: [
				],
			  },
			  callProperties: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: [
				],
			  },
			  internalSlots: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: [
				],
			  },
			  exact: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: false,
			  },
			  inexact: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			ObjectTypeInternalSlot: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  value: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  static: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  method: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			ObjectTypeCallProperty: {
			  value: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  static: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			ObjectTypeIndexer: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  key: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  value: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  static: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  variance: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			ObjectTypeProperty: {
			  key: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  value: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  kind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: null,
			  },
			  static: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  proto: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  variance: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  method: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			ObjectTypeSpreadProperty: {
			  argument: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			OpaqueType: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  supertype: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  impltype: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			QualifiedTypeIdentifier: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  qualification: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			StringLiteralTypeAnnotation: {
			  value: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			StringTypeAnnotation: {
			},
			SymbolTypeAnnotation: {
			},
			ThisTypeAnnotation: {
			},
			TupleTypeAnnotation: {
			  types: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			TypeofTypeAnnotation: {
			  argument: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TypeAlias: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  right: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TypeAnnotation: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TypeCastExpression: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TypeParameter: {
			  name: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  bound: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  default: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  variance: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TypeParameterDeclaration: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			TypeParameterInstantiation: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			UnionTypeAnnotation: {
			  types: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			Variance: {
			  kind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: null,
			  },
			},
			VoidTypeAnnotation: {
			},
			EnumDeclaration: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			EnumBooleanBody: {
			  explicitType: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  members: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  hasUnknownMembers: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			EnumNumberBody: {
			  explicitType: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  members: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  hasUnknownMembers: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			EnumStringBody: {
			  explicitType: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  members: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  hasUnknownMembers: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			EnumSymbolBody: {
			  members: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  hasUnknownMembers: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			EnumBooleanMember: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  init: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			EnumNumberMember: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  init: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			EnumStringMember: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  init: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			EnumDefaultedMember: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			IndexedAccessType: {
			  objectType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  indexType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			OptionalIndexedAccessType: {
			  objectType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  indexType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			JSXAttribute: {
			  name: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  value: {
				optional: true,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			JSXClosingElement: {
			  name: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			JSXElement: {
			  openingElement: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  closingElement: {
				optional: true,
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  children: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  selfClosing: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			JSXEmptyExpression: {
			},
			JSXExpressionContainer: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			JSXSpreadChild: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			JSXIdentifier: {
			  name: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			JSXMemberExpression: {
			  object: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  property: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			JSXNamespacedName: {
			  namespace: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  name: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			JSXOpeningElement: {
			  name: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  selfClosing: {
				default: false,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  attributes: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			JSXSpreadAttribute: {
			  argument: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			JSXText: {
			  value: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			JSXFragment: {
			  openingFragment: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  closingFragment: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  children: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			JSXOpeningFragment: {
			},
			JSXClosingFragment: {
			},
			Noop: {
			},
			Placeholder: {
			  name: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  expectedNode: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: null,
			  },
			},
			V8IntrinsicIdentifier: {
			  name: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			ArgumentPlaceholder: {
			},
			BindExpression: {
			  object: {
				validate: () => {},
				default: null,
			  },
			  callee: {
				validate: () => {},
				default: null,
			  },
			},
			ImportAttribute: {
			  key: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  value: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			Decorator: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			DoExpression: {
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  async: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: false,
			  },
			},
			ExportDefaultSpecifier: {
			  exported: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			RecordExpression: {
			  properties: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			TupleExpression: {
			  elements: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: [
				],
			  },
			},
			DecimalLiteral: {
			  value: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			},
			ModuleExpression: {
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TopicReference: {
			},
			PipelineTopicExpression: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			PipelineBareFunction: {
			  callee: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			PipelinePrimaryTopicReference: {
			},
			TSParameterProperty: {
			  accessibility: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  readonly: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  parameter: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  override: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			TSDeclareFunction: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  generator: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  async: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  declare: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  returnType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSDeclareMethod: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  generator: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  async: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  abstract: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  accessibility: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  static: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  override: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  computed: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  key: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  kind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: "method",
				optional: true,
			  },
			  access: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  decorators: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  returnType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSQualifiedName: {
			  left: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  right: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSCallSignatureDeclaration: {
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  parameters: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSConstructSignatureDeclaration: {
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  parameters: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSPropertySignature: {
			  key: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  computed: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  readonly: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  kind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: null,
			  },
			},
			TSMethodSignature: {
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  parameters: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  key: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  computed: {
				default: false,
				optional: true,
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  kind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				default: null,
			  },
			},
			TSIndexSignature: {
			  readonly: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  static: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  parameters: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSAnyKeyword: {
			},
			TSBooleanKeyword: {
			},
			TSBigIntKeyword: {
			},
			TSIntrinsicKeyword: {
			},
			TSNeverKeyword: {
			},
			TSNullKeyword: {
			},
			TSNumberKeyword: {
			},
			TSObjectKeyword: {
			},
			TSStringKeyword: {
			},
			TSSymbolKeyword: {
			},
			TSUndefinedKeyword: {
			},
			TSUnknownKeyword: {
			},
			TSVoidKeyword: {
			},
			TSThisType: {
			},
			TSFunctionType: {
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  parameters: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSConstructorType: {
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  parameters: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  abstract: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			TSTypeReference: {
			  typeName: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSTypePredicate: {
			  parameterName: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  asserts: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			TSTypeQuery: {
			  exprName: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSTypeLiteral: {
			  members: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			TSArrayType: {
			  elementType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSTupleType: {
			  elementTypes: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			TSOptionalType: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSRestType: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSNamedTupleMember: {
			  label: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: false,
			  },
			  elementType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSUnionType: {
			  types: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			TSIntersectionType: {
			  types: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			TSConditionalType: {
			  checkType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  extendsType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  trueType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  falseType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSInferType: {
			  typeParameter: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSParenthesizedType: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSTypeOperator: {
			  operator: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSIndexedAccessType: {
			  objectType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  indexType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSMappedType: {
			  readonly: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  typeParameter: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  optional: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  nameType: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSLiteralType: {
			  literal: {
				validate: function validator(parent, key, node) {
				  if ((0, _is.default)("UnaryExpression", node)) {
					unaryOperator(node, "operator", node.operator);
					unaryExpression(node, "argument", node.argument);
				  } else {
					literal(parent, key, node);
				  }
				},
				default: null,
			  },
			},
			TSExpressionWithTypeArguments: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSInterfaceDeclaration: {
			  declare: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  extends: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				optional: true,
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSInterfaceBody: {
			  body: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			TSTypeAliasDeclaration: {
			  declare: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSInstantiationExpression: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSAsExpression: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSSatisfiesExpression: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSTypeAssertion: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSEnumDeclaration: {
			  declare: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  const: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  members: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			  initializer: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSEnumMember: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  initializer: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSModuleDeclaration: {
			  declare: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  global: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  body: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSModuleBlock: {
			  body: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			TSImportType: {
			  argument: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  qualifier: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  typeParameters: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  options: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
			TSImportEqualsDeclaration: {
			  isExport: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  moduleReference: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			  importKind: {
				validate: function validate(node, key, val) {
				  if (values.indexOf(val) < 0) {
					throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			},
			TSExternalModuleReference: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSNonNullExpression: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSExportAssignment: {
			  expression: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSNamespaceExportDeclaration: {
			  id: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSTypeAnnotation: {
			  typeAnnotation: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				default: null,
			  },
			},
			TSTypeParameterInstantiation: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			TSTypeParameterDeclaration: {
			  params: {
				validate: function validate(...args) {
				  for (const fn of fns) {
					fn(...args);
				  }
				},
				default: null,
			  },
			},
			TSTypeParameter: {
			  name: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				default: null,
			  },
			  in: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  out: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  const: {
				validate: function validate(node, key, val) {
				  const valid = getType(val) === type;
				  if (!valid) {
					throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
				  }
				},
				optional: true,
				default: null,
			  },
			  constraint: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			  default: {
				validate: function validate(node, key, val) {
				  for (const type of types) {
					if ((0, _is.default)(type, val)) {
					  (0, _validate.validateChild)(node, key, val);
					  return;
					}
				  }
				  throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
				},
				optional: true,
				default: null,
			  },
			},
		  },
		  NODE_PARENT_VALIDATIONS: {
			FunctionDeclaration: () => {},
			Identifier: function(parent, key, node) {
			  if (!process.env.BABEL_TYPES_8_BREAKING) return;
			  const match = /\.(\w+)$/.exec(key);
			  if (!match) return;
			  const [, parentKey] = match;
			  const nonComp = {
				computed: false
			  };
			  if (parentKey === "property") {
				if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
				if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
			  } else if (parentKey === "key") {
				if ((0, _is.default)("Property", parent, nonComp)) return;
				if ((0, _is.default)("Method", parent, nonComp)) return;
			  } else if (parentKey === "exported") {
				if ((0, _is.default)("ExportSpecifier", parent)) return;
			  } else if (parentKey === "imported") {
				if ((0, _is.default)("ImportSpecifier", parent, {
				  imported: node
				})) return;
			  } else if (parentKey === "meta") {
				if ((0, _is.default)("MetaProperty", parent, {
				  meta: node
				})) return;
			  }
			  if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
				throw new TypeError(`"${node.name}" is not a valid identifier`);
			  }
			},
			ObjectProperty: function (parent, key, node) {
			  if (!process.env.BABEL_TYPES_8_BREAKING) return;
			  const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
			  validator(node, "value", node.value);
			},
			RestElement: function(parent, key) {
			  if (!process.env.BABEL_TYPES_8_BREAKING) return;
			  const match = /(\w+)\[(\d+)\]/.exec(key);
			  if (!match) throw new Error("Internal Babel error: malformed key.");
			  const [, listKey, index] = match;
			  if (parent[listKey].length > +index + 1) {
				throw new TypeError(`RestElement must be last element of ${listKey}`);
			  }
			},
			VariableDeclaration: function(parent, key, node) {
			  if (!process.env.BABEL_TYPES_8_BREAKING) return;
			  if (!(0, _is.default)("ForXStatement", parent, {
				left: node
			  })) return;
			  if (node.declarations.length !== 1) {
				throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
			  }
			},
			ClassDeclaration: function (parent, key, node) {
			  if (!process.env.BABEL_TYPES_8_BREAKING) return;
			  if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
				identifier(node, "id", node.id);
			  }
			},
		  },
		  PLACEHOLDERS: [
			"Identifier",
			"StringLiteral",
			"Expression",
			"Statement",
			"Declaration",
			"BlockStatement",
			"ClassBody",
			"Pattern",
		  ],
		  PLACEHOLDERS_ALIAS: {
			Declaration: [
			  "Statement",
			],
			Pattern: [
			  "PatternLike",
			  "LVal",
			],
			Identifier: [
			  "Standardized",
			  "Expression",
			  "PatternLike",
			  "LVal",
			  "TSEntityName",
			],
			StringLiteral: [
			  "Standardized",
			  "Expression",
			  "Pureish",
			  "Literal",
			  "Immutable",
			],
			BlockStatement: [
			  "Standardized",
			  "Scopable",
			  "BlockParent",
			  "Block",
			  "Statement",
			],
			ClassBody: [
			  "Standardized",
			],
		  },
		  PLACEHOLDERS_FLIPPED_ALIAS: {
			Statement: [
			  "Declaration",
			  "BlockStatement",
			],
			PatternLike: [
			  "Pattern",
			  "Identifier",
			],
			LVal: [
			  "Pattern",
			  "Identifier",
			],
			Standardized: [
			  "Identifier",
			  "StringLiteral",
			  "BlockStatement",
			  "ClassBody",
			],
			Expression: [
			  "Identifier",
			  "StringLiteral",
			],
			TSEntityName: [
			  "Identifier",
			],
			Pureish: [
			  "StringLiteral",
			],
			Literal: [
			  "StringLiteral",
			],
			Immutable: [
			  "StringLiteral",
			],
			Scopable: [
			  "BlockStatement",
			],
			BlockParent: [
			  "BlockStatement",
			],
			Block: [
			  "BlockStatement",
			],
		  },
		  TYPES: [
			"ArrayExpression",
			"AssignmentExpression",
			"BinaryExpression",
			"InterpreterDirective",
			"Directive",
			"DirectiveLiteral",
			"BlockStatement",
			"BreakStatement",
			"CallExpression",
			"CatchClause",
			"ConditionalExpression",
			"ContinueStatement",
			"DebuggerStatement",
			"DoWhileStatement",
			"EmptyStatement",
			"ExpressionStatement",
			"File",
			"ForInStatement",
			"ForStatement",
			"FunctionDeclaration",
			"FunctionExpression",
			"Identifier",
			"IfStatement",
			"LabeledStatement",
			"StringLiteral",
			"NumericLiteral",
			"NullLiteral",
			"BooleanLiteral",
			"RegExpLiteral",
			"LogicalExpression",
			"MemberExpression",
			"NewExpression",
			"Program",
			"ObjectExpression",
			"ObjectMethod",
			"ObjectProperty",
			"RestElement",
			"ReturnStatement",
			"SequenceExpression",
			"ParenthesizedExpression",
			"SwitchCase",
			"SwitchStatement",
			"ThisExpression",
			"ThrowStatement",
			"TryStatement",
			"UnaryExpression",
			"UpdateExpression",
			"VariableDeclaration",
			"VariableDeclarator",
			"WhileStatement",
			"WithStatement",
			"AssignmentPattern",
			"ArrayPattern",
			"ArrowFunctionExpression",
			"ClassBody",
			"ClassExpression",
			"ClassDeclaration",
			"ExportAllDeclaration",
			"ExportDefaultDeclaration",
			"ExportNamedDeclaration",
			"ExportSpecifier",
			"ForOfStatement",
			"ImportDeclaration",
			"ImportDefaultSpecifier",
			"ImportNamespaceSpecifier",
			"ImportSpecifier",
			"ImportExpression",
			"MetaProperty",
			"ClassMethod",
			"ObjectPattern",
			"SpreadElement",
			"Super",
			"TaggedTemplateExpression",
			"TemplateElement",
			"TemplateLiteral",
			"YieldExpression",
			"AwaitExpression",
			"Import",
			"BigIntLiteral",
			"ExportNamespaceSpecifier",
			"OptionalMemberExpression",
			"OptionalCallExpression",
			"ClassProperty",
			"ClassAccessorProperty",
			"ClassPrivateProperty",
			"ClassPrivateMethod",
			"PrivateName",
			"StaticBlock",
			"AnyTypeAnnotation",
			"ArrayTypeAnnotation",
			"BooleanTypeAnnotation",
			"BooleanLiteralTypeAnnotation",
			"NullLiteralTypeAnnotation",
			"ClassImplements",
			"DeclareClass",
			"DeclareFunction",
			"DeclareInterface",
			"DeclareModule",
			"DeclareModuleExports",
			"DeclareTypeAlias",
			"DeclareOpaqueType",
			"DeclareVariable",
			"DeclareExportDeclaration",
			"DeclareExportAllDeclaration",
			"DeclaredPredicate",
			"ExistsTypeAnnotation",
			"FunctionTypeAnnotation",
			"FunctionTypeParam",
			"GenericTypeAnnotation",
			"InferredPredicate",
			"InterfaceExtends",
			"InterfaceDeclaration",
			"InterfaceTypeAnnotation",
			"IntersectionTypeAnnotation",
			"MixedTypeAnnotation",
			"EmptyTypeAnnotation",
			"NullableTypeAnnotation",
			"NumberLiteralTypeAnnotation",
			"NumberTypeAnnotation",
			"ObjectTypeAnnotation",
			"ObjectTypeInternalSlot",
			"ObjectTypeCallProperty",
			"ObjectTypeIndexer",
			"ObjectTypeProperty",
			"ObjectTypeSpreadProperty",
			"OpaqueType",
			"QualifiedTypeIdentifier",
			"StringLiteralTypeAnnotation",
			"StringTypeAnnotation",
			"SymbolTypeAnnotation",
			"ThisTypeAnnotation",
			"TupleTypeAnnotation",
			"TypeofTypeAnnotation",
			"TypeAlias",
			"TypeAnnotation",
			"TypeCastExpression",
			"TypeParameter",
			"TypeParameterDeclaration",
			"TypeParameterInstantiation",
			"UnionTypeAnnotation",
			"Variance",
			"VoidTypeAnnotation",
			"EnumDeclaration",
			"EnumBooleanBody",
			"EnumNumberBody",
			"EnumStringBody",
			"EnumSymbolBody",
			"EnumBooleanMember",
			"EnumNumberMember",
			"EnumStringMember",
			"EnumDefaultedMember",
			"IndexedAccessType",
			"OptionalIndexedAccessType",
			"JSXAttribute",
			"JSXClosingElement",
			"JSXElement",
			"JSXEmptyExpression",
			"JSXExpressionContainer",
			"JSXSpreadChild",
			"JSXIdentifier",
			"JSXMemberExpression",
			"JSXNamespacedName",
			"JSXOpeningElement",
			"JSXSpreadAttribute",
			"JSXText",
			"JSXFragment",
			"JSXOpeningFragment",
			"JSXClosingFragment",
			"Noop",
			"Placeholder",
			"V8IntrinsicIdentifier",
			"ArgumentPlaceholder",
			"BindExpression",
			"ImportAttribute",
			"Decorator",
			"DoExpression",
			"ExportDefaultSpecifier",
			"RecordExpression",
			"TupleExpression",
			"DecimalLiteral",
			"ModuleExpression",
			"TopicReference",
			"PipelineTopicExpression",
			"PipelineBareFunction",
			"PipelinePrimaryTopicReference",
			"TSParameterProperty",
			"TSDeclareFunction",
			"TSDeclareMethod",
			"TSQualifiedName",
			"TSCallSignatureDeclaration",
			"TSConstructSignatureDeclaration",
			"TSPropertySignature",
			"TSMethodSignature",
			"TSIndexSignature",
			"TSAnyKeyword",
			"TSBooleanKeyword",
			"TSBigIntKeyword",
			"TSIntrinsicKeyword",
			"TSNeverKeyword",
			"TSNullKeyword",
			"TSNumberKeyword",
			"TSObjectKeyword",
			"TSStringKeyword",
			"TSSymbolKeyword",
			"TSUndefinedKeyword",
			"TSUnknownKeyword",
			"TSVoidKeyword",
			"TSThisType",
			"TSFunctionType",
			"TSConstructorType",
			"TSTypeReference",
			"TSTypePredicate",
			"TSTypeQuery",
			"TSTypeLiteral",
			"TSArrayType",
			"TSTupleType",
			"TSOptionalType",
			"TSRestType",
			"TSNamedTupleMember",
			"TSUnionType",
			"TSIntersectionType",
			"TSConditionalType",
			"TSInferType",
			"TSParenthesizedType",
			"TSTypeOperator",
			"TSIndexedAccessType",
			"TSMappedType",
			"TSLiteralType",
			"TSExpressionWithTypeArguments",
			"TSInterfaceDeclaration",
			"TSInterfaceBody",
			"TSTypeAliasDeclaration",
			"TSInstantiationExpression",
			"TSAsExpression",
			"TSSatisfiesExpression",
			"TSTypeAssertion",
			"TSEnumDeclaration",
			"TSEnumMember",
			"TSModuleDeclaration",
			"TSModuleBlock",
			"TSImportType",
			"TSImportEqualsDeclaration",
			"TSExternalModuleReference",
			"TSNonNullExpression",
			"TSExportAssignment",
			"TSNamespaceExportDeclaration",
			"TSTypeAnnotation",
			"TSTypeParameterInstantiation",
			"TSTypeParameterDeclaration",
			"TSTypeParameter",
			"Standardized",
			"Expression",
			"Binary",
			"Scopable",
			"BlockParent",
			"Block",
			"Statement",
			"Terminatorless",
			"CompletionStatement",
			"Conditional",
			"Loop",
			"While",
			"ExpressionWrapper",
			"For",
			"ForXStatement",
			"Function",
			"FunctionParent",
			"Pureish",
			"Declaration",
			"PatternLike",
			"LVal",
			"TSEntityName",
			"Literal",
			"Immutable",
			"UserWhitespacable",
			"Method",
			"ObjectMember",
			"Property",
			"UnaryLike",
			"Pattern",
			"Class",
			"ImportOrExportDeclaration",
			"ExportDeclaration",
			"ModuleSpecifier",
			"Accessor",
			"Private",
			"Flow",
			"FlowType",
			"FlowBaseAnnotation",
			"FlowDeclaration",
			"FlowPredicate",
			"EnumBody",
			"EnumMember",
			"JSX",
			"Miscellaneous",
			"TypeScript",
			"TSTypeElement",
			"TSType",
			"TSBaseType",
			"ModuleDeclaration",
			"NumberLiteral",
			"RegexLiteral",
			"RestProperty",
			"SpreadProperty",
			"BindingIdentifier",
			"BlockScoped",
			"ExistentialTypeParam",
			"ForAwaitStatement",
			"Generated",
			"NumericLiteralTypeAnnotation",
			"Pure",
			"Referenced",
			"ReferencedIdentifier",
			"ReferencedMemberExpression",
			"Scope",
			"User",
			"Var",
		  ],
		  VISITOR_KEYS: {
			ArrayExpression: [
			  "elements",
			],
			AssignmentExpression: [
			  "left",
			  "right",
			],
			BinaryExpression: [
			  "left",
			  "right",
			],
			InterpreterDirective: [
			],
			Directive: [
			  "value",
			],
			DirectiveLiteral: [
			],
			BlockStatement: [
			  "directives",
			  "body",
			],
			BreakStatement: [
			  "label",
			],
			CallExpression: [
			  "callee",
			  "arguments",
			  "typeParameters",
			  "typeArguments",
			],
			CatchClause: [
			  "param",
			  "body",
			],
			ConditionalExpression: [
			  "test",
			  "consequent",
			  "alternate",
			],
			ContinueStatement: [
			  "label",
			],
			DebuggerStatement: [
			],
			DoWhileStatement: [
			  "test",
			  "body",
			],
			EmptyStatement: [
			],
			ExpressionStatement: [
			  "expression",
			],
			File: [
			  "program",
			],
			ForInStatement: [
			  "left",
			  "right",
			  "body",
			],
			ForStatement: [
			  "init",
			  "test",
			  "update",
			  "body",
			],
			FunctionDeclaration: [
			  "id",
			  "params",
			  "body",
			  "returnType",
			  "typeParameters",
			],
			FunctionExpression: [
			  "id",
			  "params",
			  "body",
			  "returnType",
			  "typeParameters",
			],
			Identifier: [
			  "typeAnnotation",
			  "decorators",
			],
			IfStatement: [
			  "test",
			  "consequent",
			  "alternate",
			],
			LabeledStatement: [
			  "label",
			  "body",
			],
			StringLiteral: [
			],
			NumericLiteral: [
			],
			NullLiteral: [
			],
			BooleanLiteral: [
			],
			RegExpLiteral: [
			],
			LogicalExpression: [
			  "left",
			  "right",
			],
			MemberExpression: [
			  "object",
			  "property",
			],
			NewExpression: [
			  "callee",
			  "arguments",
			  "typeParameters",
			  "typeArguments",
			],
			Program: [
			  "directives",
			  "body",
			],
			ObjectExpression: [
			  "properties",
			],
			ObjectMethod: [
			  "key",
			  "params",
			  "body",
			  "decorators",
			  "returnType",
			  "typeParameters",
			],
			ObjectProperty: [
			  "key",
			  "value",
			  "decorators",
			],
			RestElement: [
			  "argument",
			  "typeAnnotation",
			],
			ReturnStatement: [
			  "argument",
			],
			SequenceExpression: [
			  "expressions",
			],
			ParenthesizedExpression: [
			  "expression",
			],
			SwitchCase: [
			  "test",
			  "consequent",
			],
			SwitchStatement: [
			  "discriminant",
			  "cases",
			],
			ThisExpression: [
			],
			ThrowStatement: [
			  "argument",
			],
			TryStatement: [
			  "block",
			  "handler",
			  "finalizer",
			],
			UnaryExpression: [
			  "argument",
			],
			UpdateExpression: [
			  "argument",
			],
			VariableDeclaration: [
			  "declarations",
			],
			VariableDeclarator: [
			  "id",
			  "init",
			],
			WhileStatement: [
			  "test",
			  "body",
			],
			WithStatement: [
			  "object",
			  "body",
			],
			AssignmentPattern: [
			  "left",
			  "right",
			  "decorators",
			],
			ArrayPattern: [
			  "elements",
			  "typeAnnotation",
			],
			ArrowFunctionExpression: [
			  "params",
			  "body",
			  "returnType",
			  "typeParameters",
			],
			ClassBody: [
			  "body",
			],
			ClassExpression: [
			  "id",
			  "body",
			  "superClass",
			  "mixins",
			  "typeParameters",
			  "superTypeParameters",
			  "implements",
			  "decorators",
			],
			ClassDeclaration: [
			  "id",
			  "body",
			  "superClass",
			  "mixins",
			  "typeParameters",
			  "superTypeParameters",
			  "implements",
			  "decorators",
			],
			ExportAllDeclaration: [
			  "source",
			  "attributes",
			  "assertions",
			],
			ExportDefaultDeclaration: [
			  "declaration",
			],
			ExportNamedDeclaration: [
			  "declaration",
			  "specifiers",
			  "source",
			  "attributes",
			  "assertions",
			],
			ExportSpecifier: [
			  "local",
			  "exported",
			],
			ForOfStatement: [
			  "left",
			  "right",
			  "body",
			],
			ImportDeclaration: [
			  "specifiers",
			  "source",
			  "attributes",
			  "assertions",
			],
			ImportDefaultSpecifier: [
			  "local",
			],
			ImportNamespaceSpecifier: [
			  "local",
			],
			ImportSpecifier: [
			  "local",
			  "imported",
			],
			ImportExpression: [
			  "source",
			  "options",
			],
			MetaProperty: [
			  "meta",
			  "property",
			],
			ClassMethod: [
			  "key",
			  "params",
			  "body",
			  "decorators",
			  "returnType",
			  "typeParameters",
			],
			ObjectPattern: [
			  "properties",
			  "typeAnnotation",
			  "decorators",
			],
			SpreadElement: [
			  "argument",
			],
			Super: [
			],
			TaggedTemplateExpression: [
			  "tag",
			  "quasi",
			  "typeParameters",
			],
			TemplateElement: [
			],
			TemplateLiteral: [
			  "quasis",
			  "expressions",
			],
			YieldExpression: [
			  "argument",
			],
			AwaitExpression: [
			  "argument",
			],
			Import: [
			],
			BigIntLiteral: [
			],
			ExportNamespaceSpecifier: [
			  "exported",
			],
			OptionalMemberExpression: [
			  "object",
			  "property",
			],
			OptionalCallExpression: [
			  "callee",
			  "arguments",
			  "typeParameters",
			  "typeArguments",
			],
			ClassProperty: [
			  "key",
			  "value",
			  "typeAnnotation",
			  "decorators",
			],
			ClassAccessorProperty: [
			  "key",
			  "value",
			  "typeAnnotation",
			  "decorators",
			],
			ClassPrivateProperty: [
			  "key",
			  "value",
			  "decorators",
			  "typeAnnotation",
			],
			ClassPrivateMethod: [
			  "key",
			  "params",
			  "body",
			  "decorators",
			  "returnType",
			  "typeParameters",
			],
			PrivateName: [
			  "id",
			],
			StaticBlock: [
			  "body",
			],
			AnyTypeAnnotation: [
			],
			ArrayTypeAnnotation: [
			  "elementType",
			],
			BooleanTypeAnnotation: [
			],
			BooleanLiteralTypeAnnotation: [
			],
			NullLiteralTypeAnnotation: [
			],
			ClassImplements: [
			  "id",
			  "typeParameters",
			],
			DeclareClass: [
			  "id",
			  "typeParameters",
			  "extends",
			  "mixins",
			  "implements",
			  "body",
			],
			DeclareFunction: [
			  "id",
			],
			DeclareInterface: [
			  "id",
			  "typeParameters",
			  "extends",
			  "body",
			],
			DeclareModule: [
			  "id",
			  "body",
			],
			DeclareModuleExports: [
			  "typeAnnotation",
			],
			DeclareTypeAlias: [
			  "id",
			  "typeParameters",
			  "right",
			],
			DeclareOpaqueType: [
			  "id",
			  "typeParameters",
			  "supertype",
			],
			DeclareVariable: [
			  "id",
			],
			DeclareExportDeclaration: [
			  "declaration",
			  "specifiers",
			  "source",
			],
			DeclareExportAllDeclaration: [
			  "source",
			],
			DeclaredPredicate: [
			  "value",
			],
			ExistsTypeAnnotation: [
			],
			FunctionTypeAnnotation: [
			  "typeParameters",
			  "params",
			  "rest",
			  "returnType",
			],
			FunctionTypeParam: [
			  "name",
			  "typeAnnotation",
			],
			GenericTypeAnnotation: [
			  "id",
			  "typeParameters",
			],
			InferredPredicate: [
			],
			InterfaceExtends: [
			  "id",
			  "typeParameters",
			],
			InterfaceDeclaration: [
			  "id",
			  "typeParameters",
			  "extends",
			  "body",
			],
			InterfaceTypeAnnotation: [
			  "extends",
			  "body",
			],
			IntersectionTypeAnnotation: [
			  "types",
			],
			MixedTypeAnnotation: [
			],
			EmptyTypeAnnotation: [
			],
			NullableTypeAnnotation: [
			  "typeAnnotation",
			],
			NumberLiteralTypeAnnotation: [
			],
			NumberTypeAnnotation: [
			],
			ObjectTypeAnnotation: [
			  "properties",
			  "indexers",
			  "callProperties",
			  "internalSlots",
			],
			ObjectTypeInternalSlot: [
			  "id",
			  "value",
			  "optional",
			  "static",
			  "method",
			],
			ObjectTypeCallProperty: [
			  "value",
			],
			ObjectTypeIndexer: [
			  "id",
			  "key",
			  "value",
			  "variance",
			],
			ObjectTypeProperty: [
			  "key",
			  "value",
			  "variance",
			],
			ObjectTypeSpreadProperty: [
			  "argument",
			],
			OpaqueType: [
			  "id",
			  "typeParameters",
			  "supertype",
			  "impltype",
			],
			QualifiedTypeIdentifier: [
			  "id",
			  "qualification",
			],
			StringLiteralTypeAnnotation: [
			],
			StringTypeAnnotation: [
			],
			SymbolTypeAnnotation: [
			],
			ThisTypeAnnotation: [
			],
			TupleTypeAnnotation: [
			  "types",
			],
			TypeofTypeAnnotation: [
			  "argument",
			],
			TypeAlias: [
			  "id",
			  "typeParameters",
			  "right",
			],
			TypeAnnotation: [
			  "typeAnnotation",
			],
			TypeCastExpression: [
			  "expression",
			  "typeAnnotation",
			],
			TypeParameter: [
			  "bound",
			  "default",
			  "variance",
			],
			TypeParameterDeclaration: [
			  "params",
			],
			TypeParameterInstantiation: [
			  "params",
			],
			UnionTypeAnnotation: [
			  "types",
			],
			Variance: [
			],
			VoidTypeAnnotation: [
			],
			EnumDeclaration: [
			  "id",
			  "body",
			],
			EnumBooleanBody: [
			  "members",
			],
			EnumNumberBody: [
			  "members",
			],
			EnumStringBody: [
			  "members",
			],
			EnumSymbolBody: [
			  "members",
			],
			EnumBooleanMember: [
			  "id",
			],
			EnumNumberMember: [
			  "id",
			  "init",
			],
			EnumStringMember: [
			  "id",
			  "init",
			],
			EnumDefaultedMember: [
			  "id",
			],
			IndexedAccessType: [
			  "objectType",
			  "indexType",
			],
			OptionalIndexedAccessType: [
			  "objectType",
			  "indexType",
			],
			JSXAttribute: [
			  "name",
			  "value",
			],
			JSXClosingElement: [
			  "name",
			],
			JSXElement: [
			  "openingElement",
			  "children",
			  "closingElement",
			],
			JSXEmptyExpression: [
			],
			JSXExpressionContainer: [
			  "expression",
			],
			JSXSpreadChild: [
			  "expression",
			],
			JSXIdentifier: [
			],
			JSXMemberExpression: [
			  "object",
			  "property",
			],
			JSXNamespacedName: [
			  "namespace",
			  "name",
			],
			JSXOpeningElement: [
			  "name",
			  "attributes",
			],
			JSXSpreadAttribute: [
			  "argument",
			],
			JSXText: [
			],
			JSXFragment: [
			  "openingFragment",
			  "children",
			  "closingFragment",
			],
			JSXOpeningFragment: [
			],
			JSXClosingFragment: [
			],
			Noop: [
			],
			Placeholder: [
			],
			V8IntrinsicIdentifier: [
			],
			ArgumentPlaceholder: [
			],
			BindExpression: [
			  "object",
			  "callee",
			],
			ImportAttribute: [
			  "key",
			  "value",
			],
			Decorator: [
			  "expression",
			],
			DoExpression: [
			  "body",
			],
			ExportDefaultSpecifier: [
			  "exported",
			],
			RecordExpression: [
			  "properties",
			],
			TupleExpression: [
			  "elements",
			],
			DecimalLiteral: [
			],
			ModuleExpression: [
			  "body",
			],
			TopicReference: [
			],
			PipelineTopicExpression: [
			  "expression",
			],
			PipelineBareFunction: [
			  "callee",
			],
			PipelinePrimaryTopicReference: [
			],
			TSParameterProperty: [
			  "parameter",
			],
			TSDeclareFunction: [
			  "id",
			  "typeParameters",
			  "params",
			  "returnType",
			],
			TSDeclareMethod: [
			  "decorators",
			  "key",
			  "typeParameters",
			  "params",
			  "returnType",
			],
			TSQualifiedName: [
			  "left",
			  "right",
			],
			TSCallSignatureDeclaration: [
			  "typeParameters",
			  "parameters",
			  "typeAnnotation",
			],
			TSConstructSignatureDeclaration: [
			  "typeParameters",
			  "parameters",
			  "typeAnnotation",
			],
			TSPropertySignature: [
			  "key",
			  "typeAnnotation",
			],
			TSMethodSignature: [
			  "key",
			  "typeParameters",
			  "parameters",
			  "typeAnnotation",
			],
			TSIndexSignature: [
			  "parameters",
			  "typeAnnotation",
			],
			TSAnyKeyword: [
			],
			TSBooleanKeyword: [
			],
			TSBigIntKeyword: [
			],
			TSIntrinsicKeyword: [
			],
			TSNeverKeyword: [
			],
			TSNullKeyword: [
			],
			TSNumberKeyword: [
			],
			TSObjectKeyword: [
			],
			TSStringKeyword: [
			],
			TSSymbolKeyword: [
			],
			TSUndefinedKeyword: [
			],
			TSUnknownKeyword: [
			],
			TSVoidKeyword: [
			],
			TSThisType: [
			],
			TSFunctionType: [
			  "typeParameters",
			  "parameters",
			  "typeAnnotation",
			],
			TSConstructorType: [
			  "typeParameters",
			  "parameters",
			  "typeAnnotation",
			],
			TSTypeReference: [
			  "typeName",
			  "typeParameters",
			],
			TSTypePredicate: [
			  "parameterName",
			  "typeAnnotation",
			],
			TSTypeQuery: [
			  "exprName",
			  "typeParameters",
			],
			TSTypeLiteral: [
			  "members",
			],
			TSArrayType: [
			  "elementType",
			],
			TSTupleType: [
			  "elementTypes",
			],
			TSOptionalType: [
			  "typeAnnotation",
			],
			TSRestType: [
			  "typeAnnotation",
			],
			TSNamedTupleMember: [
			  "label",
			  "elementType",
			],
			TSUnionType: [
			  "types",
			],
			TSIntersectionType: [
			  "types",
			],
			TSConditionalType: [
			  "checkType",
			  "extendsType",
			  "trueType",
			  "falseType",
			],
			TSInferType: [
			  "typeParameter",
			],
			TSParenthesizedType: [
			  "typeAnnotation",
			],
			TSTypeOperator: [
			  "typeAnnotation",
			],
			TSIndexedAccessType: [
			  "objectType",
			  "indexType",
			],
			TSMappedType: [
			  "typeParameter",
			  "typeAnnotation",
			  "nameType",
			],
			TSLiteralType: [
			  "literal",
			],
			TSExpressionWithTypeArguments: [
			  "expression",
			  "typeParameters",
			],
			TSInterfaceDeclaration: [
			  "id",
			  "typeParameters",
			  "extends",
			  "body",
			],
			TSInterfaceBody: [
			  "body",
			],
			TSTypeAliasDeclaration: [
			  "id",
			  "typeParameters",
			  "typeAnnotation",
			],
			TSInstantiationExpression: [
			  "expression",
			  "typeParameters",
			],
			TSAsExpression: [
			  "expression",
			  "typeAnnotation",
			],
			TSSatisfiesExpression: [
			  "expression",
			  "typeAnnotation",
			],
			TSTypeAssertion: [
			  "typeAnnotation",
			  "expression",
			],
			TSEnumDeclaration: [
			  "id",
			  "members",
			],
			TSEnumMember: [
			  "id",
			  "initializer",
			],
			TSModuleDeclaration: [
			  "id",
			  "body",
			],
			TSModuleBlock: [
			  "body",
			],
			TSImportType: [
			  "argument",
			  "qualifier",
			  "typeParameters",
			],
			TSImportEqualsDeclaration: [
			  "id",
			  "moduleReference",
			],
			TSExternalModuleReference: [
			  "expression",
			],
			TSNonNullExpression: [
			  "expression",
			],
			TSExportAssignment: [
			  "expression",
			],
			TSNamespaceExportDeclaration: [
			  "id",
			],
			TSTypeAnnotation: [
			  "typeAnnotation",
			],
			TSTypeParameterInstantiation: [
			  "params",
			],
			TSTypeParameterDeclaration: [
			  "params",
			],
			TSTypeParameter: [
			  "constraint",
			  "default",
			],
		  },
		  isAccessor: function isAccessor(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ClassAccessorProperty":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isAnyTypeAnnotation: function isAnyTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "AnyTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isArgumentPlaceholder: function isArgumentPlaceholder(node, opts) {
			if (!node) return false;
			if (node.type !== "ArgumentPlaceholder") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isArrayExpression: function isArrayExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "ArrayExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isArrayPattern: function isArrayPattern(node, opts) {
			if (!node) return false;
			if (node.type !== "ArrayPattern") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isArrayTypeAnnotation: function isArrayTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "ArrayTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isArrowFunctionExpression: function isArrowFunctionExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "ArrowFunctionExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isAssignmentExpression: function isAssignmentExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "AssignmentExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isAssignmentPattern: function isAssignmentPattern(node, opts) {
			if (!node) return false;
			if (node.type !== "AssignmentPattern") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isAwaitExpression: function isAwaitExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "AwaitExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isBigIntLiteral: function isBigIntLiteral(node, opts) {
			if (!node) return false;
			if (node.type !== "BigIntLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isBinary: function isBinary(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "BinaryExpression":
			  case "LogicalExpression":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isBinaryExpression: function isBinaryExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "BinaryExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isBindExpression: function isBindExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "BindExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isBlock: function isBlock(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "BlockStatement":
			  case "Program":
			  case "TSModuleBlock":
				break;
			  case "Placeholder":
				if (node.expectedNode === "BlockStatement") break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isBlockParent: function isBlockParent(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "BlockStatement":
			  case "CatchClause":
			  case "DoWhileStatement":
			  case "ForInStatement":
			  case "ForStatement":
			  case "FunctionDeclaration":
			  case "FunctionExpression":
			  case "Program":
			  case "ObjectMethod":
			  case "SwitchStatement":
			  case "WhileStatement":
			  case "ArrowFunctionExpression":
			  case "ForOfStatement":
			  case "ClassMethod":
			  case "ClassPrivateMethod":
			  case "StaticBlock":
			  case "TSModuleBlock":
				break;
			  case "Placeholder":
				if (node.expectedNode === "BlockStatement") break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isBlockStatement: function isBlockStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "BlockStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isBooleanLiteral: function isBooleanLiteral(node, opts) {
			if (!node) return false;
			if (node.type !== "BooleanLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isBooleanLiteralTypeAnnotation: function isBooleanLiteralTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "BooleanLiteralTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isBooleanTypeAnnotation: function isBooleanTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "BooleanTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isBreakStatement: function isBreakStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "BreakStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isCallExpression: function isCallExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "CallExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isCatchClause: function isCatchClause(node, opts) {
			if (!node) return false;
			if (node.type !== "CatchClause") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isClass: function isClass(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ClassExpression":
			  case "ClassDeclaration":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isClassAccessorProperty: function isClassAccessorProperty(node, opts) {
			if (!node) return false;
			if (node.type !== "ClassAccessorProperty") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isClassBody: function isClassBody(node, opts) {
			if (!node) return false;
			if (node.type !== "ClassBody") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isClassDeclaration: function isClassDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "ClassDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isClassExpression: function isClassExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "ClassExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isClassImplements: function isClassImplements(node, opts) {
			if (!node) return false;
			if (node.type !== "ClassImplements") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isClassMethod: function isClassMethod(node, opts) {
			if (!node) return false;
			if (node.type !== "ClassMethod") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isClassPrivateMethod: function isClassPrivateMethod(node, opts) {
			if (!node) return false;
			if (node.type !== "ClassPrivateMethod") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isClassPrivateProperty: function isClassPrivateProperty(node, opts) {
			if (!node) return false;
			if (node.type !== "ClassPrivateProperty") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isClassProperty: function isClassProperty(node, opts) {
			if (!node) return false;
			if (node.type !== "ClassProperty") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isCompletionStatement: function isCompletionStatement(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "BreakStatement":
			  case "ContinueStatement":
			  case "ReturnStatement":
			  case "ThrowStatement":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isConditional: function isConditional(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ConditionalExpression":
			  case "IfStatement":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isConditionalExpression: function isConditionalExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "ConditionalExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isContinueStatement: function isContinueStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "ContinueStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDebuggerStatement: function isDebuggerStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "DebuggerStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDecimalLiteral: function isDecimalLiteral(node, opts) {
			if (!node) return false;
			if (node.type !== "DecimalLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclaration: function isDeclaration(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "FunctionDeclaration":
			  case "VariableDeclaration":
			  case "ClassDeclaration":
			  case "ExportAllDeclaration":
			  case "ExportDefaultDeclaration":
			  case "ExportNamedDeclaration":
			  case "ImportDeclaration":
			  case "DeclareClass":
			  case "DeclareFunction":
			  case "DeclareInterface":
			  case "DeclareModule":
			  case "DeclareModuleExports":
			  case "DeclareTypeAlias":
			  case "DeclareOpaqueType":
			  case "DeclareVariable":
			  case "DeclareExportDeclaration":
			  case "DeclareExportAllDeclaration":
			  case "InterfaceDeclaration":
			  case "OpaqueType":
			  case "TypeAlias":
			  case "EnumDeclaration":
			  case "TSDeclareFunction":
			  case "TSInterfaceDeclaration":
			  case "TSTypeAliasDeclaration":
			  case "TSEnumDeclaration":
			  case "TSModuleDeclaration":
				break;
			  case "Placeholder":
				if (node.expectedNode === "Declaration") break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclareClass: function isDeclareClass(node, opts) {
			if (!node) return false;
			if (node.type !== "DeclareClass") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclareExportAllDeclaration: function isDeclareExportAllDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "DeclareExportAllDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclareExportDeclaration: function isDeclareExportDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "DeclareExportDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclareFunction: function isDeclareFunction(node, opts) {
			if (!node) return false;
			if (node.type !== "DeclareFunction") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclareInterface: function isDeclareInterface(node, opts) {
			if (!node) return false;
			if (node.type !== "DeclareInterface") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclareModule: function isDeclareModule(node, opts) {
			if (!node) return false;
			if (node.type !== "DeclareModule") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclareModuleExports: function isDeclareModuleExports(node, opts) {
			if (!node) return false;
			if (node.type !== "DeclareModuleExports") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclareOpaqueType: function isDeclareOpaqueType(node, opts) {
			if (!node) return false;
			if (node.type !== "DeclareOpaqueType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclareTypeAlias: function isDeclareTypeAlias(node, opts) {
			if (!node) return false;
			if (node.type !== "DeclareTypeAlias") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclareVariable: function isDeclareVariable(node, opts) {
			if (!node) return false;
			if (node.type !== "DeclareVariable") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDeclaredPredicate: function isDeclaredPredicate(node, opts) {
			if (!node) return false;
			if (node.type !== "DeclaredPredicate") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDecorator: function isDecorator(node, opts) {
			if (!node) return false;
			if (node.type !== "Decorator") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDirective: function isDirective(node, opts) {
			if (!node) return false;
			if (node.type !== "Directive") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDirectiveLiteral: function isDirectiveLiteral(node, opts) {
			if (!node) return false;
			if (node.type !== "DirectiveLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDoExpression: function isDoExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "DoExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isDoWhileStatement: function isDoWhileStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "DoWhileStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEmptyStatement: function isEmptyStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "EmptyStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEmptyTypeAnnotation: function isEmptyTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "EmptyTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEnumBody: function isEnumBody(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "EnumBooleanBody":
			  case "EnumNumberBody":
			  case "EnumStringBody":
			  case "EnumSymbolBody":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEnumBooleanBody: function isEnumBooleanBody(node, opts) {
			if (!node) return false;
			if (node.type !== "EnumBooleanBody") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEnumBooleanMember: function isEnumBooleanMember(node, opts) {
			if (!node) return false;
			if (node.type !== "EnumBooleanMember") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEnumDeclaration: function isEnumDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "EnumDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEnumDefaultedMember: function isEnumDefaultedMember(node, opts) {
			if (!node) return false;
			if (node.type !== "EnumDefaultedMember") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEnumMember: function isEnumMember(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "EnumBooleanMember":
			  case "EnumNumberMember":
			  case "EnumStringMember":
			  case "EnumDefaultedMember":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEnumNumberBody: function isEnumNumberBody(node, opts) {
			if (!node) return false;
			if (node.type !== "EnumNumberBody") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEnumNumberMember: function isEnumNumberMember(node, opts) {
			if (!node) return false;
			if (node.type !== "EnumNumberMember") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEnumStringBody: function isEnumStringBody(node, opts) {
			if (!node) return false;
			if (node.type !== "EnumStringBody") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEnumStringMember: function isEnumStringMember(node, opts) {
			if (!node) return false;
			if (node.type !== "EnumStringMember") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isEnumSymbolBody: function isEnumSymbolBody(node, opts) {
			if (!node) return false;
			if (node.type !== "EnumSymbolBody") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isExistsTypeAnnotation: function isExistsTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "ExistsTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isExportAllDeclaration: function isExportAllDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "ExportAllDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isExportDeclaration: function isExportDeclaration(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ExportAllDeclaration":
			  case "ExportDefaultDeclaration":
			  case "ExportNamedDeclaration":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isExportDefaultDeclaration: function isExportDefaultDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "ExportDefaultDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isExportDefaultSpecifier: function isExportDefaultSpecifier(node, opts) {
			if (!node) return false;
			if (node.type !== "ExportDefaultSpecifier") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isExportNamedDeclaration: function isExportNamedDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "ExportNamedDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isExportNamespaceSpecifier: function isExportNamespaceSpecifier(node, opts) {
			if (!node) return false;
			if (node.type !== "ExportNamespaceSpecifier") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isExportSpecifier: function isExportSpecifier(node, opts) {
			if (!node) return false;
			if (node.type !== "ExportSpecifier") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isExpression: function isExpression(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ArrayExpression":
			  case "AssignmentExpression":
			  case "BinaryExpression":
			  case "CallExpression":
			  case "ConditionalExpression":
			  case "FunctionExpression":
			  case "Identifier":
			  case "StringLiteral":
			  case "NumericLiteral":
			  case "NullLiteral":
			  case "BooleanLiteral":
			  case "RegExpLiteral":
			  case "LogicalExpression":
			  case "MemberExpression":
			  case "NewExpression":
			  case "ObjectExpression":
			  case "SequenceExpression":
			  case "ParenthesizedExpression":
			  case "ThisExpression":
			  case "UnaryExpression":
			  case "UpdateExpression":
			  case "ArrowFunctionExpression":
			  case "ClassExpression":
			  case "ImportExpression":
			  case "MetaProperty":
			  case "Super":
			  case "TaggedTemplateExpression":
			  case "TemplateLiteral":
			  case "YieldExpression":
			  case "AwaitExpression":
			  case "Import":
			  case "BigIntLiteral":
			  case "OptionalMemberExpression":
			  case "OptionalCallExpression":
			  case "TypeCastExpression":
			  case "JSXElement":
			  case "JSXFragment":
			  case "BindExpression":
			  case "DoExpression":
			  case "RecordExpression":
			  case "TupleExpression":
			  case "DecimalLiteral":
			  case "ModuleExpression":
			  case "TopicReference":
			  case "PipelineTopicExpression":
			  case "PipelineBareFunction":
			  case "PipelinePrimaryTopicReference":
			  case "TSInstantiationExpression":
			  case "TSAsExpression":
			  case "TSSatisfiesExpression":
			  case "TSTypeAssertion":
			  case "TSNonNullExpression":
				break;
			  case "Placeholder":
				switch (node.expectedNode) {
				  case "Expression":
				  case "Identifier":
				  case "StringLiteral":
					break;
				  default:
					return false;
				}
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isExpressionStatement: function isExpressionStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "ExpressionStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isExpressionWrapper: function isExpressionWrapper(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ExpressionStatement":
			  case "ParenthesizedExpression":
			  case "TypeCastExpression":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFile: function isFile(node, opts) {
			if (!node) return false;
			if (node.type !== "File") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFlow: function isFlow(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "AnyTypeAnnotation":
			  case "ArrayTypeAnnotation":
			  case "BooleanTypeAnnotation":
			  case "BooleanLiteralTypeAnnotation":
			  case "NullLiteralTypeAnnotation":
			  case "ClassImplements":
			  case "DeclareClass":
			  case "DeclareFunction":
			  case "DeclareInterface":
			  case "DeclareModule":
			  case "DeclareModuleExports":
			  case "DeclareTypeAlias":
			  case "DeclareOpaqueType":
			  case "DeclareVariable":
			  case "DeclareExportDeclaration":
			  case "DeclareExportAllDeclaration":
			  case "DeclaredPredicate":
			  case "ExistsTypeAnnotation":
			  case "FunctionTypeAnnotation":
			  case "FunctionTypeParam":
			  case "GenericTypeAnnotation":
			  case "InferredPredicate":
			  case "InterfaceExtends":
			  case "InterfaceDeclaration":
			  case "InterfaceTypeAnnotation":
			  case "IntersectionTypeAnnotation":
			  case "MixedTypeAnnotation":
			  case "EmptyTypeAnnotation":
			  case "NullableTypeAnnotation":
			  case "NumberLiteralTypeAnnotation":
			  case "NumberTypeAnnotation":
			  case "ObjectTypeAnnotation":
			  case "ObjectTypeInternalSlot":
			  case "ObjectTypeCallProperty":
			  case "ObjectTypeIndexer":
			  case "ObjectTypeProperty":
			  case "ObjectTypeSpreadProperty":
			  case "OpaqueType":
			  case "QualifiedTypeIdentifier":
			  case "StringLiteralTypeAnnotation":
			  case "StringTypeAnnotation":
			  case "SymbolTypeAnnotation":
			  case "ThisTypeAnnotation":
			  case "TupleTypeAnnotation":
			  case "TypeofTypeAnnotation":
			  case "TypeAlias":
			  case "TypeAnnotation":
			  case "TypeCastExpression":
			  case "TypeParameter":
			  case "TypeParameterDeclaration":
			  case "TypeParameterInstantiation":
			  case "UnionTypeAnnotation":
			  case "Variance":
			  case "VoidTypeAnnotation":
			  case "EnumDeclaration":
			  case "EnumBooleanBody":
			  case "EnumNumberBody":
			  case "EnumStringBody":
			  case "EnumSymbolBody":
			  case "EnumBooleanMember":
			  case "EnumNumberMember":
			  case "EnumStringMember":
			  case "EnumDefaultedMember":
			  case "IndexedAccessType":
			  case "OptionalIndexedAccessType":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFlowBaseAnnotation: function isFlowBaseAnnotation(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "AnyTypeAnnotation":
			  case "BooleanTypeAnnotation":
			  case "NullLiteralTypeAnnotation":
			  case "MixedTypeAnnotation":
			  case "EmptyTypeAnnotation":
			  case "NumberTypeAnnotation":
			  case "StringTypeAnnotation":
			  case "SymbolTypeAnnotation":
			  case "ThisTypeAnnotation":
			  case "VoidTypeAnnotation":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFlowDeclaration: function isFlowDeclaration(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "DeclareClass":
			  case "DeclareFunction":
			  case "DeclareInterface":
			  case "DeclareModule":
			  case "DeclareModuleExports":
			  case "DeclareTypeAlias":
			  case "DeclareOpaqueType":
			  case "DeclareVariable":
			  case "DeclareExportDeclaration":
			  case "DeclareExportAllDeclaration":
			  case "InterfaceDeclaration":
			  case "OpaqueType":
			  case "TypeAlias":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFlowPredicate: function isFlowPredicate(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "DeclaredPredicate":
			  case "InferredPredicate":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFlowType: function isFlowType(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "AnyTypeAnnotation":
			  case "ArrayTypeAnnotation":
			  case "BooleanTypeAnnotation":
			  case "BooleanLiteralTypeAnnotation":
			  case "NullLiteralTypeAnnotation":
			  case "ExistsTypeAnnotation":
			  case "FunctionTypeAnnotation":
			  case "GenericTypeAnnotation":
			  case "InterfaceTypeAnnotation":
			  case "IntersectionTypeAnnotation":
			  case "MixedTypeAnnotation":
			  case "EmptyTypeAnnotation":
			  case "NullableTypeAnnotation":
			  case "NumberLiteralTypeAnnotation":
			  case "NumberTypeAnnotation":
			  case "ObjectTypeAnnotation":
			  case "StringLiteralTypeAnnotation":
			  case "StringTypeAnnotation":
			  case "SymbolTypeAnnotation":
			  case "ThisTypeAnnotation":
			  case "TupleTypeAnnotation":
			  case "TypeofTypeAnnotation":
			  case "UnionTypeAnnotation":
			  case "VoidTypeAnnotation":
			  case "IndexedAccessType":
			  case "OptionalIndexedAccessType":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFor: function isFor(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ForInStatement":
			  case "ForStatement":
			  case "ForOfStatement":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isForInStatement: function isForInStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "ForInStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isForOfStatement: function isForOfStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "ForOfStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isForStatement: function isForStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "ForStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isForXStatement: function isForXStatement(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ForInStatement":
			  case "ForOfStatement":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFunction: function isFunction(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "FunctionDeclaration":
			  case "FunctionExpression":
			  case "ObjectMethod":
			  case "ArrowFunctionExpression":
			  case "ClassMethod":
			  case "ClassPrivateMethod":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFunctionDeclaration: function isFunctionDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "FunctionDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFunctionExpression: function isFunctionExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "FunctionExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFunctionParent: function isFunctionParent(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "FunctionDeclaration":
			  case "FunctionExpression":
			  case "ObjectMethod":
			  case "ArrowFunctionExpression":
			  case "ClassMethod":
			  case "ClassPrivateMethod":
			  case "StaticBlock":
			  case "TSModuleBlock":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFunctionTypeAnnotation: function isFunctionTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "FunctionTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isFunctionTypeParam: function isFunctionTypeParam(node, opts) {
			if (!node) return false;
			if (node.type !== "FunctionTypeParam") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isGenericTypeAnnotation: function isGenericTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "GenericTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isIdentifier: function isIdentifier(node, opts) {
			if (!node) return false;
			if (node.type !== "Identifier") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isIfStatement: function isIfStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "IfStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isImport: function isImport(node, opts) {
			if (!node) return false;
			if (node.type !== "Import") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isImportAttribute: function isImportAttribute(node, opts) {
			if (!node) return false;
			if (node.type !== "ImportAttribute") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isImportDeclaration: function isImportDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "ImportDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isImportDefaultSpecifier: function isImportDefaultSpecifier(node, opts) {
			if (!node) return false;
			if (node.type !== "ImportDefaultSpecifier") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isImportExpression: function isImportExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "ImportExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isImportNamespaceSpecifier: function isImportNamespaceSpecifier(node, opts) {
			if (!node) return false;
			if (node.type !== "ImportNamespaceSpecifier") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isImportOrExportDeclaration: function isImportOrExportDeclaration(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ExportAllDeclaration":
			  case "ExportDefaultDeclaration":
			  case "ExportNamedDeclaration":
			  case "ImportDeclaration":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isImportSpecifier: function isImportSpecifier(node, opts) {
			if (!node) return false;
			if (node.type !== "ImportSpecifier") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isIndexedAccessType: function isIndexedAccessType(node, opts) {
			if (!node) return false;
			if (node.type !== "IndexedAccessType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isInferredPredicate: function isInferredPredicate(node, opts) {
			if (!node) return false;
			if (node.type !== "InferredPredicate") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isInterfaceDeclaration: function isInterfaceDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "InterfaceDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isInterfaceExtends: function isInterfaceExtends(node, opts) {
			if (!node) return false;
			if (node.type !== "InterfaceExtends") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isInterfaceTypeAnnotation: function isInterfaceTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "InterfaceTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isInterpreterDirective: function isInterpreterDirective(node, opts) {
			if (!node) return false;
			if (node.type !== "InterpreterDirective") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isIntersectionTypeAnnotation: function isIntersectionTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "IntersectionTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSX: function isJSX(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "JSXAttribute":
			  case "JSXClosingElement":
			  case "JSXElement":
			  case "JSXEmptyExpression":
			  case "JSXExpressionContainer":
			  case "JSXSpreadChild":
			  case "JSXIdentifier":
			  case "JSXMemberExpression":
			  case "JSXNamespacedName":
			  case "JSXOpeningElement":
			  case "JSXSpreadAttribute":
			  case "JSXText":
			  case "JSXFragment":
			  case "JSXOpeningFragment":
			  case "JSXClosingFragment":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXAttribute: function isJSXAttribute(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXAttribute") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXClosingElement: function isJSXClosingElement(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXClosingElement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXClosingFragment: function isJSXClosingFragment(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXClosingFragment") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXElement: function isJSXElement(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXElement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXEmptyExpression: function isJSXEmptyExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXEmptyExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXExpressionContainer: function isJSXExpressionContainer(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXExpressionContainer") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXFragment: function isJSXFragment(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXFragment") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXIdentifier: function isJSXIdentifier(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXIdentifier") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXMemberExpression: function isJSXMemberExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXMemberExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXNamespacedName: function isJSXNamespacedName(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXNamespacedName") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXOpeningElement: function isJSXOpeningElement(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXOpeningElement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXOpeningFragment: function isJSXOpeningFragment(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXOpeningFragment") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXSpreadAttribute: function isJSXSpreadAttribute(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXSpreadAttribute") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXSpreadChild: function isJSXSpreadChild(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXSpreadChild") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isJSXText: function isJSXText(node, opts) {
			if (!node) return false;
			if (node.type !== "JSXText") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isLVal: function isLVal(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "Identifier":
			  case "MemberExpression":
			  case "RestElement":
			  case "AssignmentPattern":
			  case "ArrayPattern":
			  case "ObjectPattern":
			  case "TSParameterProperty":
			  case "TSAsExpression":
			  case "TSSatisfiesExpression":
			  case "TSTypeAssertion":
			  case "TSNonNullExpression":
				break;
			  case "Placeholder":
				switch (node.expectedNode) {
				  case "Pattern":
				  case "Identifier":
					break;
				  default:
					return false;
				}
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isLabeledStatement: function isLabeledStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "LabeledStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isLiteral: function isLiteral(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "StringLiteral":
			  case "NumericLiteral":
			  case "NullLiteral":
			  case "BooleanLiteral":
			  case "RegExpLiteral":
			  case "TemplateLiteral":
			  case "BigIntLiteral":
			  case "DecimalLiteral":
				break;
			  case "Placeholder":
				if (node.expectedNode === "StringLiteral") break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isLogicalExpression: function isLogicalExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "LogicalExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isLoop: function isLoop(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "DoWhileStatement":
			  case "ForInStatement":
			  case "ForStatement":
			  case "WhileStatement":
			  case "ForOfStatement":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isMemberExpression: function isMemberExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "MemberExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isMetaProperty: function isMetaProperty(node, opts) {
			if (!node) return false;
			if (node.type !== "MetaProperty") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isMethod: function isMethod(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ObjectMethod":
			  case "ClassMethod":
			  case "ClassPrivateMethod":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isMiscellaneous: function isMiscellaneous(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "Noop":
			  case "Placeholder":
			  case "V8IntrinsicIdentifier":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isMixedTypeAnnotation: function isMixedTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "MixedTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isModuleDeclaration: function isModuleDeclaration(node, opts) {
			(0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
			return isImportOrExportDeclaration(node, opts);
		  },
		  isModuleExpression: function isModuleExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "ModuleExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isModuleSpecifier: function isModuleSpecifier(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ExportSpecifier":
			  case "ImportDefaultSpecifier":
			  case "ImportNamespaceSpecifier":
			  case "ImportSpecifier":
			  case "ExportNamespaceSpecifier":
			  case "ExportDefaultSpecifier":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isNewExpression: function isNewExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "NewExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isNoop: function isNoop(node, opts) {
			if (!node) return false;
			if (node.type !== "Noop") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isNullLiteral: function isNullLiteral(node, opts) {
			if (!node) return false;
			if (node.type !== "NullLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isNullLiteralTypeAnnotation: function isNullLiteralTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "NullLiteralTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isNullableTypeAnnotation: function isNullableTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "NullableTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isNumberLiteral: function isNumberLiteral(node, opts) {
			(0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
			if (!node) return false;
			if (node.type !== "NumberLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isNumberLiteralTypeAnnotation: function isNumberLiteralTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "NumberLiteralTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isNumberTypeAnnotation: function isNumberTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "NumberTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isNumericLiteral: function isNumericLiteral(node, opts) {
			if (!node) return false;
			if (node.type !== "NumericLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isObjectExpression: function isObjectExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "ObjectExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isObjectMember: function isObjectMember(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ObjectMethod":
			  case "ObjectProperty":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isObjectMethod: function isObjectMethod(node, opts) {
			if (!node) return false;
			if (node.type !== "ObjectMethod") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isObjectPattern: function isObjectPattern(node, opts) {
			if (!node) return false;
			if (node.type !== "ObjectPattern") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isObjectProperty: function isObjectProperty(node, opts) {
			if (!node) return false;
			if (node.type !== "ObjectProperty") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isObjectTypeAnnotation: function isObjectTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "ObjectTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isObjectTypeCallProperty: function isObjectTypeCallProperty(node, opts) {
			if (!node) return false;
			if (node.type !== "ObjectTypeCallProperty") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isObjectTypeIndexer: function isObjectTypeIndexer(node, opts) {
			if (!node) return false;
			if (node.type !== "ObjectTypeIndexer") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isObjectTypeInternalSlot: function isObjectTypeInternalSlot(node, opts) {
			if (!node) return false;
			if (node.type !== "ObjectTypeInternalSlot") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isObjectTypeProperty: function isObjectTypeProperty(node, opts) {
			if (!node) return false;
			if (node.type !== "ObjectTypeProperty") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isObjectTypeSpreadProperty: function isObjectTypeSpreadProperty(node, opts) {
			if (!node) return false;
			if (node.type !== "ObjectTypeSpreadProperty") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isOpaqueType: function isOpaqueType(node, opts) {
			if (!node) return false;
			if (node.type !== "OpaqueType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isOptionalCallExpression: function isOptionalCallExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "OptionalCallExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isOptionalIndexedAccessType: function isOptionalIndexedAccessType(node, opts) {
			if (!node) return false;
			if (node.type !== "OptionalIndexedAccessType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isOptionalMemberExpression: function isOptionalMemberExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "OptionalMemberExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isParenthesizedExpression: function isParenthesizedExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "ParenthesizedExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isPattern: function isPattern(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "AssignmentPattern":
			  case "ArrayPattern":
			  case "ObjectPattern":
				break;
			  case "Placeholder":
				if (node.expectedNode === "Pattern") break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isPatternLike: function isPatternLike(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "Identifier":
			  case "RestElement":
			  case "AssignmentPattern":
			  case "ArrayPattern":
			  case "ObjectPattern":
			  case "TSAsExpression":
			  case "TSSatisfiesExpression":
			  case "TSTypeAssertion":
			  case "TSNonNullExpression":
				break;
			  case "Placeholder":
				switch (node.expectedNode) {
				  case "Pattern":
				  case "Identifier":
					break;
				  default:
					return false;
				}
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isPipelineBareFunction: function isPipelineBareFunction(node, opts) {
			if (!node) return false;
			if (node.type !== "PipelineBareFunction") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isPipelinePrimaryTopicReference: function isPipelinePrimaryTopicReference(node, opts) {
			if (!node) return false;
			if (node.type !== "PipelinePrimaryTopicReference") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isPipelineTopicExpression: function isPipelineTopicExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "PipelineTopicExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isPlaceholder: function isPlaceholder(node, opts) {
			if (!node) return false;
			if (node.type !== "Placeholder") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isPrivate: function isPrivate(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ClassPrivateProperty":
			  case "ClassPrivateMethod":
			  case "PrivateName":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isPrivateName: function isPrivateName(node, opts) {
			if (!node) return false;
			if (node.type !== "PrivateName") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isProgram: function isProgram(node, opts) {
			if (!node) return false;
			if (node.type !== "Program") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isProperty: function isProperty(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ObjectProperty":
			  case "ClassProperty":
			  case "ClassAccessorProperty":
			  case "ClassPrivateProperty":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isPureish: function isPureish(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "FunctionDeclaration":
			  case "FunctionExpression":
			  case "StringLiteral":
			  case "NumericLiteral":
			  case "NullLiteral":
			  case "BooleanLiteral":
			  case "RegExpLiteral":
			  case "ArrowFunctionExpression":
			  case "BigIntLiteral":
			  case "DecimalLiteral":
				break;
			  case "Placeholder":
				if (node.expectedNode === "StringLiteral") break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isQualifiedTypeIdentifier: function isQualifiedTypeIdentifier(node, opts) {
			if (!node) return false;
			if (node.type !== "QualifiedTypeIdentifier") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isRecordExpression: function isRecordExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "RecordExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isRegExpLiteral: function isRegExpLiteral(node, opts) {
			if (!node) return false;
			if (node.type !== "RegExpLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isRegexLiteral: function isRegexLiteral(node, opts) {
			(0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
			if (!node) return false;
			if (node.type !== "RegexLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isRestElement: function isRestElement(node, opts) {
			if (!node) return false;
			if (node.type !== "RestElement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isRestProperty: function isRestProperty(node, opts) {
			(0, _deprecationWarning.default)("isRestProperty", "isRestElement");
			if (!node) return false;
			if (node.type !== "RestProperty") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isReturnStatement: function isReturnStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "ReturnStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isScopable: function isScopable(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "BlockStatement":
			  case "CatchClause":
			  case "DoWhileStatement":
			  case "ForInStatement":
			  case "ForStatement":
			  case "FunctionDeclaration":
			  case "FunctionExpression":
			  case "Program":
			  case "ObjectMethod":
			  case "SwitchStatement":
			  case "WhileStatement":
			  case "ArrowFunctionExpression":
			  case "ClassExpression":
			  case "ClassDeclaration":
			  case "ForOfStatement":
			  case "ClassMethod":
			  case "ClassPrivateMethod":
			  case "StaticBlock":
			  case "TSModuleBlock":
				break;
			  case "Placeholder":
				if (node.expectedNode === "BlockStatement") break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isSequenceExpression: function isSequenceExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "SequenceExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isSpreadElement: function isSpreadElement(node, opts) {
			if (!node) return false;
			if (node.type !== "SpreadElement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isSpreadProperty: function isSpreadProperty(node, opts) {
			(0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
			if (!node) return false;
			if (node.type !== "SpreadProperty") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isStandardized: function isStandardized(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ArrayExpression":
			  case "AssignmentExpression":
			  case "BinaryExpression":
			  case "InterpreterDirective":
			  case "Directive":
			  case "DirectiveLiteral":
			  case "BlockStatement":
			  case "BreakStatement":
			  case "CallExpression":
			  case "CatchClause":
			  case "ConditionalExpression":
			  case "ContinueStatement":
			  case "DebuggerStatement":
			  case "DoWhileStatement":
			  case "EmptyStatement":
			  case "ExpressionStatement":
			  case "File":
			  case "ForInStatement":
			  case "ForStatement":
			  case "FunctionDeclaration":
			  case "FunctionExpression":
			  case "Identifier":
			  case "IfStatement":
			  case "LabeledStatement":
			  case "StringLiteral":
			  case "NumericLiteral":
			  case "NullLiteral":
			  case "BooleanLiteral":
			  case "RegExpLiteral":
			  case "LogicalExpression":
			  case "MemberExpression":
			  case "NewExpression":
			  case "Program":
			  case "ObjectExpression":
			  case "ObjectMethod":
			  case "ObjectProperty":
			  case "RestElement":
			  case "ReturnStatement":
			  case "SequenceExpression":
			  case "ParenthesizedExpression":
			  case "SwitchCase":
			  case "SwitchStatement":
			  case "ThisExpression":
			  case "ThrowStatement":
			  case "TryStatement":
			  case "UnaryExpression":
			  case "UpdateExpression":
			  case "VariableDeclaration":
			  case "VariableDeclarator":
			  case "WhileStatement":
			  case "WithStatement":
			  case "AssignmentPattern":
			  case "ArrayPattern":
			  case "ArrowFunctionExpression":
			  case "ClassBody":
			  case "ClassExpression":
			  case "ClassDeclaration":
			  case "ExportAllDeclaration":
			  case "ExportDefaultDeclaration":
			  case "ExportNamedDeclaration":
			  case "ExportSpecifier":
			  case "ForOfStatement":
			  case "ImportDeclaration":
			  case "ImportDefaultSpecifier":
			  case "ImportNamespaceSpecifier":
			  case "ImportSpecifier":
			  case "ImportExpression":
			  case "MetaProperty":
			  case "ClassMethod":
			  case "ObjectPattern":
			  case "SpreadElement":
			  case "Super":
			  case "TaggedTemplateExpression":
			  case "TemplateElement":
			  case "TemplateLiteral":
			  case "YieldExpression":
			  case "AwaitExpression":
			  case "Import":
			  case "BigIntLiteral":
			  case "ExportNamespaceSpecifier":
			  case "OptionalMemberExpression":
			  case "OptionalCallExpression":
			  case "ClassProperty":
			  case "ClassAccessorProperty":
			  case "ClassPrivateProperty":
			  case "ClassPrivateMethod":
			  case "PrivateName":
			  case "StaticBlock":
				break;
			  case "Placeholder":
				switch (node.expectedNode) {
				  case "Identifier":
				  case "StringLiteral":
				  case "BlockStatement":
				  case "ClassBody":
					break;
				  default:
					return false;
				}
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isStatement: function isStatement(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "BlockStatement":
			  case "BreakStatement":
			  case "ContinueStatement":
			  case "DebuggerStatement":
			  case "DoWhileStatement":
			  case "EmptyStatement":
			  case "ExpressionStatement":
			  case "ForInStatement":
			  case "ForStatement":
			  case "FunctionDeclaration":
			  case "IfStatement":
			  case "LabeledStatement":
			  case "ReturnStatement":
			  case "SwitchStatement":
			  case "ThrowStatement":
			  case "TryStatement":
			  case "VariableDeclaration":
			  case "WhileStatement":
			  case "WithStatement":
			  case "ClassDeclaration":
			  case "ExportAllDeclaration":
			  case "ExportDefaultDeclaration":
			  case "ExportNamedDeclaration":
			  case "ForOfStatement":
			  case "ImportDeclaration":
			  case "DeclareClass":
			  case "DeclareFunction":
			  case "DeclareInterface":
			  case "DeclareModule":
			  case "DeclareModuleExports":
			  case "DeclareTypeAlias":
			  case "DeclareOpaqueType":
			  case "DeclareVariable":
			  case "DeclareExportDeclaration":
			  case "DeclareExportAllDeclaration":
			  case "InterfaceDeclaration":
			  case "OpaqueType":
			  case "TypeAlias":
			  case "EnumDeclaration":
			  case "TSDeclareFunction":
			  case "TSInterfaceDeclaration":
			  case "TSTypeAliasDeclaration":
			  case "TSEnumDeclaration":
			  case "TSModuleDeclaration":
			  case "TSImportEqualsDeclaration":
			  case "TSExportAssignment":
			  case "TSNamespaceExportDeclaration":
				break;
			  case "Placeholder":
				switch (node.expectedNode) {
				  case "Statement":
				  case "Declaration":
				  case "BlockStatement":
					break;
				  default:
					return false;
				}
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isStaticBlock: function isStaticBlock(node, opts) {
			if (!node) return false;
			if (node.type !== "StaticBlock") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isStringLiteral: function isStringLiteral(node, opts) {
			if (!node) return false;
			if (node.type !== "StringLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isStringLiteralTypeAnnotation: function isStringLiteralTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "StringLiteralTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isStringTypeAnnotation: function isStringTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "StringTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isSuper: function isSuper(node, opts) {
			if (!node) return false;
			if (node.type !== "Super") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isSwitchCase: function isSwitchCase(node, opts) {
			if (!node) return false;
			if (node.type !== "SwitchCase") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isSwitchStatement: function isSwitchStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "SwitchStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isSymbolTypeAnnotation: function isSymbolTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "SymbolTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSAnyKeyword: function isTSAnyKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSAnyKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSArrayType: function isTSArrayType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSArrayType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSAsExpression: function isTSAsExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "TSAsExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSBaseType: function isTSBaseType(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "TSAnyKeyword":
			  case "TSBooleanKeyword":
			  case "TSBigIntKeyword":
			  case "TSIntrinsicKeyword":
			  case "TSNeverKeyword":
			  case "TSNullKeyword":
			  case "TSNumberKeyword":
			  case "TSObjectKeyword":
			  case "TSStringKeyword":
			  case "TSSymbolKeyword":
			  case "TSUndefinedKeyword":
			  case "TSUnknownKeyword":
			  case "TSVoidKeyword":
			  case "TSThisType":
			  case "TSLiteralType":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSBigIntKeyword: function isTSBigIntKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSBigIntKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSBooleanKeyword: function isTSBooleanKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSBooleanKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSCallSignatureDeclaration: function isTSCallSignatureDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "TSCallSignatureDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSConditionalType: function isTSConditionalType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSConditionalType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSConstructSignatureDeclaration: function isTSConstructSignatureDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "TSConstructSignatureDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSConstructorType: function isTSConstructorType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSConstructorType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSDeclareFunction: function isTSDeclareFunction(node, opts) {
			if (!node) return false;
			if (node.type !== "TSDeclareFunction") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSDeclareMethod: function isTSDeclareMethod(node, opts) {
			if (!node) return false;
			if (node.type !== "TSDeclareMethod") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSEntityName: function isTSEntityName(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "Identifier":
			  case "TSQualifiedName":
				break;
			  case "Placeholder":
				if (node.expectedNode === "Identifier") break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSEnumDeclaration: function isTSEnumDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "TSEnumDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSEnumMember: function isTSEnumMember(node, opts) {
			if (!node) return false;
			if (node.type !== "TSEnumMember") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSExportAssignment: function isTSExportAssignment(node, opts) {
			if (!node) return false;
			if (node.type !== "TSExportAssignment") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSExpressionWithTypeArguments: function isTSExpressionWithTypeArguments(node, opts) {
			if (!node) return false;
			if (node.type !== "TSExpressionWithTypeArguments") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSExternalModuleReference: function isTSExternalModuleReference(node, opts) {
			if (!node) return false;
			if (node.type !== "TSExternalModuleReference") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSFunctionType: function isTSFunctionType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSFunctionType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSImportEqualsDeclaration: function isTSImportEqualsDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "TSImportEqualsDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSImportType: function isTSImportType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSImportType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSIndexSignature: function isTSIndexSignature(node, opts) {
			if (!node) return false;
			if (node.type !== "TSIndexSignature") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSIndexedAccessType: function isTSIndexedAccessType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSIndexedAccessType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSInferType: function isTSInferType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSInferType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSInstantiationExpression: function isTSInstantiationExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "TSInstantiationExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSInterfaceBody: function isTSInterfaceBody(node, opts) {
			if (!node) return false;
			if (node.type !== "TSInterfaceBody") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSInterfaceDeclaration: function isTSInterfaceDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "TSInterfaceDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSIntersectionType: function isTSIntersectionType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSIntersectionType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSIntrinsicKeyword: function isTSIntrinsicKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSIntrinsicKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSLiteralType: function isTSLiteralType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSLiteralType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSMappedType: function isTSMappedType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSMappedType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSMethodSignature: function isTSMethodSignature(node, opts) {
			if (!node) return false;
			if (node.type !== "TSMethodSignature") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSModuleBlock: function isTSModuleBlock(node, opts) {
			if (!node) return false;
			if (node.type !== "TSModuleBlock") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSModuleDeclaration: function isTSModuleDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "TSModuleDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSNamedTupleMember: function isTSNamedTupleMember(node, opts) {
			if (!node) return false;
			if (node.type !== "TSNamedTupleMember") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSNamespaceExportDeclaration: function isTSNamespaceExportDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "TSNamespaceExportDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSNeverKeyword: function isTSNeverKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSNeverKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSNonNullExpression: function isTSNonNullExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "TSNonNullExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSNullKeyword: function isTSNullKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSNullKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSNumberKeyword: function isTSNumberKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSNumberKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSObjectKeyword: function isTSObjectKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSObjectKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSOptionalType: function isTSOptionalType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSOptionalType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSParameterProperty: function isTSParameterProperty(node, opts) {
			if (!node) return false;
			if (node.type !== "TSParameterProperty") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSParenthesizedType: function isTSParenthesizedType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSParenthesizedType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSPropertySignature: function isTSPropertySignature(node, opts) {
			if (!node) return false;
			if (node.type !== "TSPropertySignature") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSQualifiedName: function isTSQualifiedName(node, opts) {
			if (!node) return false;
			if (node.type !== "TSQualifiedName") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSRestType: function isTSRestType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSRestType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSSatisfiesExpression: function isTSSatisfiesExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "TSSatisfiesExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSStringKeyword: function isTSStringKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSStringKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSSymbolKeyword: function isTSSymbolKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSSymbolKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSThisType: function isTSThisType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSThisType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTupleType: function isTSTupleType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTupleType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSType: function isTSType(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "TSAnyKeyword":
			  case "TSBooleanKeyword":
			  case "TSBigIntKeyword":
			  case "TSIntrinsicKeyword":
			  case "TSNeverKeyword":
			  case "TSNullKeyword":
			  case "TSNumberKeyword":
			  case "TSObjectKeyword":
			  case "TSStringKeyword":
			  case "TSSymbolKeyword":
			  case "TSUndefinedKeyword":
			  case "TSUnknownKeyword":
			  case "TSVoidKeyword":
			  case "TSThisType":
			  case "TSFunctionType":
			  case "TSConstructorType":
			  case "TSTypeReference":
			  case "TSTypePredicate":
			  case "TSTypeQuery":
			  case "TSTypeLiteral":
			  case "TSArrayType":
			  case "TSTupleType":
			  case "TSOptionalType":
			  case "TSRestType":
			  case "TSUnionType":
			  case "TSIntersectionType":
			  case "TSConditionalType":
			  case "TSInferType":
			  case "TSParenthesizedType":
			  case "TSTypeOperator":
			  case "TSIndexedAccessType":
			  case "TSMappedType":
			  case "TSLiteralType":
			  case "TSExpressionWithTypeArguments":
			  case "TSImportType":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypeAliasDeclaration: function isTSTypeAliasDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTypeAliasDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypeAnnotation: function isTSTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypeAssertion: function isTSTypeAssertion(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTypeAssertion") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypeElement: function isTSTypeElement(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "TSCallSignatureDeclaration":
			  case "TSConstructSignatureDeclaration":
			  case "TSPropertySignature":
			  case "TSMethodSignature":
			  case "TSIndexSignature":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypeLiteral: function isTSTypeLiteral(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTypeLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypeOperator: function isTSTypeOperator(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTypeOperator") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypeParameter: function isTSTypeParameter(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTypeParameter") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypeParameterDeclaration: function isTSTypeParameterDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTypeParameterDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypeParameterInstantiation: function isTSTypeParameterInstantiation(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTypeParameterInstantiation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypePredicate: function isTSTypePredicate(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTypePredicate") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypeQuery: function isTSTypeQuery(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTypeQuery") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSTypeReference: function isTSTypeReference(node, opts) {
			if (!node) return false;
			if (node.type !== "TSTypeReference") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSUndefinedKeyword: function isTSUndefinedKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSUndefinedKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSUnionType: function isTSUnionType(node, opts) {
			if (!node) return false;
			if (node.type !== "TSUnionType") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSUnknownKeyword: function isTSUnknownKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSUnknownKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTSVoidKeyword: function isTSVoidKeyword(node, opts) {
			if (!node) return false;
			if (node.type !== "TSVoidKeyword") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTaggedTemplateExpression: function isTaggedTemplateExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "TaggedTemplateExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTemplateElement: function isTemplateElement(node, opts) {
			if (!node) return false;
			if (node.type !== "TemplateElement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTemplateLiteral: function isTemplateLiteral(node, opts) {
			if (!node) return false;
			if (node.type !== "TemplateLiteral") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTerminatorless: function isTerminatorless(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "BreakStatement":
			  case "ContinueStatement":
			  case "ReturnStatement":
			  case "ThrowStatement":
			  case "YieldExpression":
			  case "AwaitExpression":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isThisExpression: function isThisExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "ThisExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isThisTypeAnnotation: function isThisTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "ThisTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isThrowStatement: function isThrowStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "ThrowStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTopicReference: function isTopicReference(node, opts) {
			if (!node) return false;
			if (node.type !== "TopicReference") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTryStatement: function isTryStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "TryStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTupleExpression: function isTupleExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "TupleExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTupleTypeAnnotation: function isTupleTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "TupleTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTypeAlias: function isTypeAlias(node, opts) {
			if (!node) return false;
			if (node.type !== "TypeAlias") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTypeAnnotation: function isTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "TypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTypeCastExpression: function isTypeCastExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "TypeCastExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTypeParameter: function isTypeParameter(node, opts) {
			if (!node) return false;
			if (node.type !== "TypeParameter") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTypeParameterDeclaration: function isTypeParameterDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "TypeParameterDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTypeParameterInstantiation: function isTypeParameterInstantiation(node, opts) {
			if (!node) return false;
			if (node.type !== "TypeParameterInstantiation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTypeScript: function isTypeScript(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "TSParameterProperty":
			  case "TSDeclareFunction":
			  case "TSDeclareMethod":
			  case "TSQualifiedName":
			  case "TSCallSignatureDeclaration":
			  case "TSConstructSignatureDeclaration":
			  case "TSPropertySignature":
			  case "TSMethodSignature":
			  case "TSIndexSignature":
			  case "TSAnyKeyword":
			  case "TSBooleanKeyword":
			  case "TSBigIntKeyword":
			  case "TSIntrinsicKeyword":
			  case "TSNeverKeyword":
			  case "TSNullKeyword":
			  case "TSNumberKeyword":
			  case "TSObjectKeyword":
			  case "TSStringKeyword":
			  case "TSSymbolKeyword":
			  case "TSUndefinedKeyword":
			  case "TSUnknownKeyword":
			  case "TSVoidKeyword":
			  case "TSThisType":
			  case "TSFunctionType":
			  case "TSConstructorType":
			  case "TSTypeReference":
			  case "TSTypePredicate":
			  case "TSTypeQuery":
			  case "TSTypeLiteral":
			  case "TSArrayType":
			  case "TSTupleType":
			  case "TSOptionalType":
			  case "TSRestType":
			  case "TSNamedTupleMember":
			  case "TSUnionType":
			  case "TSIntersectionType":
			  case "TSConditionalType":
			  case "TSInferType":
			  case "TSParenthesizedType":
			  case "TSTypeOperator":
			  case "TSIndexedAccessType":
			  case "TSMappedType":
			  case "TSLiteralType":
			  case "TSExpressionWithTypeArguments":
			  case "TSInterfaceDeclaration":
			  case "TSInterfaceBody":
			  case "TSTypeAliasDeclaration":
			  case "TSInstantiationExpression":
			  case "TSAsExpression":
			  case "TSSatisfiesExpression":
			  case "TSTypeAssertion":
			  case "TSEnumDeclaration":
			  case "TSEnumMember":
			  case "TSModuleDeclaration":
			  case "TSModuleBlock":
			  case "TSImportType":
			  case "TSImportEqualsDeclaration":
			  case "TSExternalModuleReference":
			  case "TSNonNullExpression":
			  case "TSExportAssignment":
			  case "TSNamespaceExportDeclaration":
			  case "TSTypeAnnotation":
			  case "TSTypeParameterInstantiation":
			  case "TSTypeParameterDeclaration":
			  case "TSTypeParameter":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isTypeofTypeAnnotation: function isTypeofTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "TypeofTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isUnaryExpression: function isUnaryExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "UnaryExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isUnaryLike: function isUnaryLike(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "UnaryExpression":
			  case "SpreadElement":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isUnionTypeAnnotation: function isUnionTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "UnionTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isUpdateExpression: function isUpdateExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "UpdateExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isUserWhitespacable: function isUserWhitespacable(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "ObjectMethod":
			  case "ObjectProperty":
			  case "ObjectTypeInternalSlot":
			  case "ObjectTypeCallProperty":
			  case "ObjectTypeIndexer":
			  case "ObjectTypeProperty":
			  case "ObjectTypeSpreadProperty":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isV8IntrinsicIdentifier: function isV8IntrinsicIdentifier(node, opts) {
			if (!node) return false;
			if (node.type !== "V8IntrinsicIdentifier") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isVariableDeclaration: function isVariableDeclaration(node, opts) {
			if (!node) return false;
			if (node.type !== "VariableDeclaration") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isVariableDeclarator: function isVariableDeclarator(node, opts) {
			if (!node) return false;
			if (node.type !== "VariableDeclarator") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isVariance: function isVariance(node, opts) {
			if (!node) return false;
			if (node.type !== "Variance") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isVoidTypeAnnotation: function isVoidTypeAnnotation(node, opts) {
			if (!node) return false;
			if (node.type !== "VoidTypeAnnotation") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isWhile: function isWhile(node, opts) {
			if (!node) return false;
			switch (node.type) {
			  case "DoWhileStatement":
			  case "WhileStatement":
				break;
			  default:
				return false;
			}
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isWhileStatement: function isWhileStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "WhileStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isWithStatement: function isWithStatement(node, opts) {
			if (!node) return false;
			if (node.type !== "WithStatement") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  isYieldExpression: function isYieldExpression(node, opts) {
			if (!node) return false;
			if (node.type !== "YieldExpression") return false;
			return opts == null || (0, _shallowEqual.default)(node, opts);
		  },
		  toSequenceExpression: function toSequenceExpression(nodes, scope) {
			if (!(nodes != null && nodes.length)) return;
			const declars = [];
			const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
			if (!result) return;
			for (const declar of declars) {
			  scope.push(declar);
			}
			return result;
		  },
		},
		parse: function parse(input, options) {
		  var _options;
		  if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
			options = Object.assign({}, options);
			try {
			  options.sourceType = "module";
			  const parser = getParser(options, input);
			  const ast = parser.parse();
			  if (parser.sawUnambiguousESM) {
				return ast;
			  }
			  if (parser.ambiguousScriptDifferentAst) {
				try {
				  options.sourceType = "script";
				  return getParser(options, input).parse();
				} catch (_unused) {}
			  } else {
				ast.program.sourceType = "script";
			  }
			  return ast;
			} catch (moduleError) {
			  try {
				options.sourceType = "script";
				return getParser(options, input).parse();
			  } catch (_unused2) {}
			  throw moduleError;
			}
		  } else {
			return getParser(options, input).parse();
		  }
		},
		generate: function generate(ast, opts = {}, code) {
		  const format = normalizeOptions(code, opts);
		  const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
		  const printer = new _printer.default(format, map);
		  return printer.generate(ast);
		},
		traverse: function traverse(parent, opts = {}, scope, state, parentPath, visitSelf) {
		  if (!parent) return;
		  if (!opts.noScope && !scope) {
			if (parent.type !== "Program" && parent.type !== "File") {
			  throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + `Instead of that you tried to traverse a ${parent.type} node without ` + "passing scope and parentPath.");
			}
		  }
		  if (!parentPath && visitSelf) {
			throw new Error("visitSelf can only be used when providing a NodePath.");
		  }
		  if (!VISITOR_KEYS[parent.type]) {
			return;
		  }
		  visitors.explode(opts);
		  (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, null, visitSelf);
		},
	  },
	  default: [Circular],
	},
	initialConfig: {
	  env: {
	  },
	},
	initialGlobalConfig: {
	  plugins: [
	  ],
	  presets: [
	  ],
	},
	paths: {
	  appPath: "/Users/ruochuan/git-source/github/taro",
	  nodeModulesPath: "/Users/ruochuan/git-source/github/taro/node_modules",
	},
	runnerUtils: {
	  DEFAULT_Components: {
	  },
	  VITE_COMPILER_LABEL: "taro:compiler",
	  IMAGE_LIMIT: 2048,
	  FONT_LIMIT: 10240,
	  MEDIA_LIMIT: 10240,
	  MultiPlatformPlugin: class MultiPlatformPlugin {
		constructor(source, target, options) {
			this.source = source;
			this.target = target;
			this.options = options || {};
		}
		apply(resolver) {
			const target = resolver.ensureHook(this.target);
			resolver
				.getHook(this.source)
				.tapAsync('MultiPlatformPlugin', (request, resolveContext, callback) => {
				var _a, _b, _c;
				const innerRequest = request.request || request.path;
				if (!innerRequest || (request.context.hasOwnProperty('issuer') && !request.context.issuer))
					return callback();
				if (!path.extname(innerRequest)) {
					let srcRequest;
					if (path.isAbsolute(innerRequest)) {
						// absolute path
						srcRequest = innerRequest;
					}
					else if (!path.isAbsolute(innerRequest) && /^\./.test(innerRequest)) {
						// relative path
						srcRequest = path.resolve(request.path, request.request);
					}
					else {
						return callback();
					}
					if (/node_modules/.test(srcRequest) && !this.includes(srcRequest)) {
						return callback();
					}
					const extensions = (_c = (_b = (_a = this.options.chain) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.extensions) === null || _c === void 0 ? void 0 : _c.values();
					const newRequestStr = helper_1.default.resolveMainFilePath(srcRequest, extensions);
					if (newRequestStr === innerRequest)
						return callback();
					const obj = Object.assign({}, request, {
						request: newRequestStr
					});
					return resolver.doResolve(target, obj, 'resolve multi platform file path', resolveContext, (err, result) => {
						if (err)
							return callback(err);
						if (result === undefined)
							return callback(null, null);
						return callback(null, result);
					});
				}
				callback();
			});
		}
		includes(filePath) {
			if (!this.options.include || !this.options.include.length)
				return false;
			filePath = filePath.replace(path.sep, '/');
			const res = this.options.include.find(item => filePath.includes(item));
			return Boolean(res);
		}
	  },
	  getBundleResult: function getBundleResult(url, projectDirectory = undefined) {
		return __awaiter(this, void 0, void 0, function* () {
			let bundler = new scss_bundle_1.Bundler();
			if (projectDirectory) {
				bundler = new scss_bundle_1.Bundler(undefined, projectDirectory);
			}
			const res = yield bundler.bundle(url);
			return res;
		});
	  },
	  getBundleContent: function getBundleContent(resource, projectDirectory = undefined) {
		return __awaiter(this, void 0, void 0, function* () {
			let result = '';
			try {
				if (typeof resource === 'string') {
					const res = yield getBundleResult(resource, projectDirectory);
					result = res.bundledContent;
				}
				if (Array.isArray(resource)) {
					for (const url of resource) {
						const res = yield getBundleResult(url, projectDirectory);
						result += res.bundledContent || '';
					}
				}
			}
			catch (error) {
				throw new Error(error);
			}
			return result;
		});
	  },
	  getSassLoaderOption: function getSassLoaderOption({ sass, sassLoaderOption }) {
		return __awaiter(this, void 0, void 0, function* () {
			sassLoaderOption = sassLoaderOption || {};
			let bundledContent = '';
			if (!sass) {
				return sassLoaderOption;
			}
			const { resource, projectDirectory } = sass;
			if (resource) {
				checkPath(resource, projectDirectory);
				const content = yield getBundleContent(resource, projectDirectory);
				bundledContent += content;
			}
			if (sass.data) {
				bundledContent += sass.data;
			}
			return Object.assign(Object.assign({}, sassLoaderOption), { additionalData: sassLoaderOption.data ? `${sassLoaderOption.data}${bundledContent}` : bundledContent });
		});
	  },
	  getViteH5CompilerContext: function getViteH5CompilerContext(rollupPluginContext) {
		return __awaiter(this, void 0, void 0, function* () {
			const info = process.env.NODE_ENV === 'production'
				? rollupPluginContext.getModuleInfo(constant_1.VITE_COMPILER_LABEL)
				: yield rollupPluginContext.load({ id: constant_1.VITE_COMPILER_LABEL });
			const compiler = info === null || info === void 0 ? void 0 : info.meta.viteCompilerContext;
			return compiler;
		});
	  },
	  getViteHarmonyCompilerContext: function getViteHarmonyCompilerContext(rollupPluginContext) {
		const info = rollupPluginContext.getModuleInfo(constant_1.VITE_COMPILER_LABEL);
		const compiler = info === null || info === void 0 ? void 0 : info.meta.viteCompilerContext;
		return compiler;
	  },
	  getViteMiniCompilerContext: function getViteMiniCompilerContext(rollupPluginContext) {
		const info = rollupPluginContext.getModuleInfo(constant_1.VITE_COMPILER_LABEL);
		const compiler = info === null || info === void 0 ? void 0 : info.meta.viteCompilerContext;
		return compiler;
	  },
	},
	cliCommandsPath: "/Users/ruochuan/git-source/github/taro/packages/taro-cli/dist/presets/commands",
	cliCommands: [
	  "build",
	  "config",
	  "create",
	  "global-config",
	  "help",
	  "info",
	  "init",
	  "inspect",
	  "update",
	],
	runOpts: {
	  _: [
		"init",
		"taro-init-debug",
	  ],
	  options: {
		appPath: "/Users/ruochuan/git-source/github/taro",
		projectName: "taro-init-debug",
		description: undefined,
		typescript: undefined,
		framework: undefined,
		compiler: undefined,
		npm: undefined,
		templateSource: undefined,
		clone: false,
		template: undefined,
		css: undefined,
	  },
	  isHelp: false,
	},
	plugins: {
	},
	extraPlugins: {
	},
	globalExtraPlugins: {
	},
  }
