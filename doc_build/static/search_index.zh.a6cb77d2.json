[{"id":0,"title":"我是如何踏上前端这条路的","content":"#\n\n写于2016-09-07 21:48:12\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n感觉最近我是如何XXX的这类标题挺火的。 杭州举办G20峰会，9月1日~7日，放假7天，带了本《ES6\n标准入门》回家。在火车上看了几集《微微一笑很倾城》，让我回忆起大学生活。就想着下次返杭的时候可以在火车上，写篇文章记录下，自己的前端学习之路。\n\n> 1、刚好可以对现在大四迷茫的学弟学妹们，有些指引。 2、还可以借此回忆下大学生活。 3、锻炼自己写长文的逻辑能力。\n\n当然，学习是座大山，人们沿着不同的路登山，分享着自己看到的风景，别人不一定看得到你看到的风景，体会得了你的心情。\n\n\n接触前端#\n\n2012年，那年大一，只记得上学期参加了四个社团，参加社团的各种活动，比较忙，另外自己收集一些电子书放到我那一点都不智能的手机上看。下学期，我所在的社团计算机协\n会（后文简称计协），当时教网页制作（嗯，那时不叫前端开发），当然我报名去参加了。比我们大一级的学长用着Dreamweaver软件\n给我们教学，超链接，图片，音乐，视频，FLASH等。总之感觉很有趣。也要我们做出一些作品，交作业。但那时我并没有电脑。所以就没做。\n\n\n江西省网页制作与设计技能大赛#\n\n大二任职计协会长，举办各类活动。也没怎么学习前端开发之类的知识。学习方面好像也就是平时上上课而已，再就是学习电脑方面的技巧，帮助别人解决电脑问题，为此也写了挺多\n这类技术文章。比如：《【教程】Ｕ盘、硬盘安装原版win7、8.1、10系统》，《近期上网拨号客户端出现拨号异常、711错误解决方案》。在大学，懂点电脑，会装几个\n软件，重装个系统，在别人眼中就会被看做是大神，并且很受欢迎。后来实在忙，就写了篇文章：《对不起，我不能帮你修电脑了》。\n\n转眼间，就到了2014年4月（大二下学期），我所在的信息学院，组织参加省级网页大赛，同时派老师给予培训指导。这时，老师N每周四（或五）给我们上了几周课，主要讲H\nTML和CSS，还给我们他录制的视频，当时觉得老师好厉害。\n\n后来让我们出作品，我们就找设计（陶美）学院的学生给我们设计网页视觉稿。虽然她们学的是设计，但也不是很懂网页设计这块。于是我就自己参照一个视觉比较好的网站，自己仿\n照着写了一个。当时还是比较忙，只有晚上有时间，所以总共八个页面，好像写了将近10天。主要用了HTML，CSS，js，jQuery。现在放在github上，点击可\n以访问，时尚影楼，那时并不是很懂js和jQuery。后来比赛结果出来了，竟然是省级一等奖。其实一等奖有挺多的。这次网页赛，我们学校获得了很多奖项。大二末，图书馆\n一老师找到我们，想让我们暑假回去学点PHP，开学好让我们上手，帮他做项目。\n\n我们信息学院邀请了10级计科的H学长，给我们这些迷茫的学弟学妹开了一次经验分享会，说到腾讯招人的标准。因为他就是课题组研发部的一员。说到课题组研发部的各种好处，\n跟着里面的老师L学习PHP，学到60％就够找好工作了。总之意思就是要进课题组学习。\n\n大二暑假，家里没网，我就在学校，下载好各种PHP学习资源，暑假就在家看着PHP相关的视频等，一套PHP视频也是100多集，基本看完了，也写了些代码。当时也学了j\navascript，一套JS视频100多集没有看完。其实到后来基本都忘了。另外，大二暑假，线上面试了乔布简历，通过成为了乔布简历校园大使。\n\n\n加入课题组研发部#\n\n大三上学期，卸任了计协会长，本以为这是大学最后一个职务，谁知这只是第一个。同学A，同学B跟着图书馆老师做PHP的项目。而我此时看着没啥事，就玩起了PPT，新媒体\n运营，又相继任职了校园网络中心团队的队长（关于这个我也写了篇文章《谈一谈校园网管这一工作》，一直任职到大四上学期）。校友总会志愿团常务团长（后来由于组织性质缘故\n，2014年11月，不到两个月就默认退出了），乔布简历江西省副主管，那时班上竞选班干，班主任说我们计协会长卸任了怎么不竞选一个职务。我说不用了，我并没有说还有这\n么多职务。上学期刚开始不久，我们专业老师也邀请了11级的学长学姐分享他们的一些经验。后来我们成立了信管学习小组，规定时间来主教自习。主要是为了学习网站开发。但后\n来效果不佳，我也较忙，就散了。\n\nPPT水平在涨进，主要体现在我做的优秀班集体评选PPT上，传说就是凭借这次展示，让学校领导记住了做PPT还有这么好的人，后来（2015年5月13日）就被找去做更\n名大学工作汇报PPT，再后来就有了这张图 PPT制作主要经历:\n\n\n\n也写了一些关于PPT制作的文章，比如：《要做PPT，一直找不到资源？》。开发水平并没有多少涨进。\n\n大三下学期，我和同学A，B一起加入了课题组学习，做任务。5月19日，成立了移动互联协会，又任职移动互联协会首届会长，一直任职到大四上学期。成立这社团，主要目的就\n是为了培养开发，后来给学弟学妹们培训HTML，CSS，和PPT，PS等，感觉他们真幸福。现在回想起来，在课题组，老师好像真的没给我什么实质性的开发任务。好像就让\n我做些与开发不那么相关的事情。可能是我个人原因。\n\n4月，九家培训机构到我们信息学院做宣讲，他们的目的很明显，就是招人去培训。下午跟千锋教育的老师聊了挺久，主要是了解了他们机构是如何授课等。当然，他们极力希望我能\n去他们的好程序员班，但我肯定不会考虑培训。当时听完，晚上总结了一张图：\n\n\n\n到学期末（6月），让我和同学A一起做设计学院网站（给了设计稿），用迅时CMS搭建网站后台（Asp.net）。主要是我做。那时相当于隔了一年多，要重新捡起HTML\n，CSS，JS。连引入的jQuery和自己写的JS顺序都能弄反，连jQuery的选项卡都写不来。熬了几次夜，在同学A和老师的指导下。终于完成了。这时，我开始感受\n到，就业压力，我究竟要往哪条路走。是新媒体运营（PPT），或者是PHP开发，还是前端开发？\n如果走新媒体运营（PPT），那么要开个微信公众号，写PPT相关文章，PPT演界网卖模板，等等。\n\n\n真正意义上开始学前端开发#\n\n大三暑假，课题组业务需求，我和同学A，B，都留在课题组做任务学习。前期我还在学PHP，后来室友L，在杭州暑假实习，他说前端也比较火。刚好又在网易云课堂，看到网易\n推出前端微专业第二期。价格一千多。虽然对于在更名大学办公室做PPT和做网络中心团队队长赚了少许钱的我来说，不是很贵，但上学期报名了驾照（3K+），所以就买不起了\n。但那时我就确定了方向，前端开发，因为入门相对容易，并且所见即所得，喜欢视觉交互，和之前玩PPT是同样注重视觉交互和逻辑。\n\n另外在PHP方面根本没做什么项目。要走前端，原生JavaScript必学！于是在知乎上看到说智能社的JS视频《精通JavaScript开发》，这套课程不错。那时\n就没多想，先看完这套课程再学其他的。很多时候，你想学的太多，都在同时学，往往效果不好，而是先学什么再学什么。记得那时，晚上9点断网，他们在打牌，我回去后在看下载\n好的视频。学完这条课程后，感觉有些提升，至少熟练了下写代码。 学完这套后，就在慕课网学习其他前端相关知识。\n\n8月，课题组组建了一支团队，参加互联网+大赛，当时学校比较重视这次比赛，召集参赛者在学校机房培训，解决吃住问题（在教工食堂吃了10多天），我一不小心又成了临时班\n长，协助就业处的老师处理相关事务。我还负责团队赛项目计划书的撰写和PPT制作。\n\n后来我们团队（指尖上的陶艺项目）依次进入校赛，省赛，国赛，最后10月份到吉林大学（吉林长春）参赛国赛，获得国赛金奖（前30）和最佳创意奖，载誉归来之时，学校领导\n在校门口接我们，学校党委书记说奖励我们团队10万元。刚开始以为不会分到没多少钱。后来就有钱买课程了。双十一期间，就买了网易云课堂的前端开发微专业第三期，系统的学\n习前端开发。另外还买了妙味课堂的视频课程学习。有人说，你要学知识，把市面上这类书都买下来，看懂并消化。那你肯定就有提升了。\n\n11月，老师N让我做学工处的网站，同样是Asp.net的后台。这次就没做多久，也没做设计学院网站那么痛苦。\n12月，开始做毕业设计，是用php+mySql做第二课堂管理系统。1月5日，提前答辩通过。\n\n\n大四寒假#\n\n开发水平自我感觉很差的我，当然是不忘抓住这段时间，提升自己的。看妙味课堂的视频。学着前端微专业，看课程，查资料，讨论区讨论，做作业，改作业。提交作业有截止日期。\n感觉这段时间挺充实的。\n\n也在考虑大四下学期是否去学校，校内实习，还是去公司实习。N sir 是推荐我去公司实习，能学挺多。\n虽然11月份参加了学校的招聘会，有公司问我用过Bootstrap吗，我说没有。后来有几家公司，叫我去实习，我没去。主要是以下考虑：\n\n> 1、公司前端团队好，实习则好。不好，不如自学。 2、自己不足还有很多，希望能继续学完前端开发微专业，获得优秀学员，也许能进好一点的公司。\n> 3、毕竟不考研，以后有的是工作时间，还不如继续享受下最后一学期的校园生活。\n\n\n大四最后一个学期#\n\n开学伊始，我和同学A，B都没去公司实习，重新来到了课题组。刚去不久，老师N就推荐我去南昌，算是实习，说有搞PHP的愿意带一个人一起做项目。后来委婉的拒绝了。因为\n已经不想走PHP开发路线，想走前端开发路线。但本学期，老师交给我的任务依旧是PHP开发的。第二课堂管理系统（PHP+MySql，CI框架）。因为不是很赶，我就前\n端微专业，百度前端技术学院任务，（妙味课堂的vip视频）三线并行。4月初，完成了前端微专业大作业，获得优秀学员证书。\n\n在学校，上班是996（早上9点上班，晚上9点下班，中午休息1-2小时）。周日老师不在办公室，而我一般在（同学A，B不在）。因为我太Low了，所以只好多花点时间学\n习。有段时间，都是24点前提交完代码，才去刷牙洗脸睡觉。晚上躺着睡前还在牛客网刷题，或者看视频，或者看前端开发类电子书。\n\n\n面试，入职杭州一家移动互联网公司#\n\n4月底投简历，5月劳动节一过，我和同学A就来杭州面试。我求职还算顺利，面试了3天，共9家。有的给了offer，就选了一家我认为比较合适的。6月1日入职杭州一家阿\n里高管出来创业的移动互联网公司，公司和阿里一样使用花名，我自己挑选了一个，叫轩辕。于是把网上各种昵称，改成了轩辕Rowboat。\n\n> 轩辕Rowboat由来：轩辕(公司花名)。Rowboat，英文名，拆解：Row(音：罗)boat(意：小船(音：小川))。其实还挺喜欢这花名的，轩辕（剑），\n> 剑未佩妥，出门便是江湖。\n\n> 再后来（2019年1月初）改为若川(被占用则是若川i)。\n\n> 公司使用的技术主要有：HTML5，模板语言（velocity，thymeleaf，handlebarsjs，underscorejs，lodash工具库等）\n> ，CSS3，Less，Sass，JS，jQuery，zeptojs，bootstrap，angularjs，vuejs，git，gulp，webpack，E\n> S6等（React，nodejs暂时没用到）。\n\n不知不觉就写了挺多字，感觉一路走来，在网易云课堂购买了付费课程（office，前端微专业等）两千左右（已赚回）。\n当没有时间，有钱时，可以选择付费学习，投资学习，回报很大。 技术提升需要一定的过程，脚踏实地走好每一步，先定好一个个小目标，然后去一一实现。\n看过很多前端大神成长路线，也是从刚开始啥都不会，一步一步变成前端大神的。\n\n","routePath":"/20160907-How-do-I-set-foot-on-the-front-end-of-the-road/","lang":"zh","toc":[{"text":"接触前端","id":"接触前端","depth":2,"charIndex":412},{"text":"江西省网页制作与设计技能大赛","id":"江西省网页制作与设计技能大赛","depth":2,"charIndex":633},{"text":"加入课题组研发部","id":"加入课题组研发部","depth":2,"charIndex":1544},{"text":"真正意义上开始学前端开发","id":"真正意义上开始学前端开发","depth":2,"charIndex":2628},{"text":"大四寒假","id":"大四寒假","depth":2,"charIndex":3534},{"text":"大四最后一个学期","id":"大四最后一个学期","depth":2,"charIndex":3865},{"text":"面试，入职杭州一家移动互联网公司","id":"面试入职杭州一家移动互联网公司","depth":2,"charIndex":4242}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"工作作一年后，我有些感悟","content":"#\n\n写于 2017-06-02 22:20:53\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n去年6月1日，入职那天早上下着小雨。在公司取了一个花名：轩辕，后来把网上昵称基本都改成了轩辕Rowboat，再后来（2019年1月初）改为若川(被占用则是若川i\n)。还记得那天晚上朋友请我吃小龙虾。\n\n今年，6月1日，有新同事入职。已经毕业工作一年了，刚好有些感悟就写出来。\n\n\n学习工作#\n\n从校园到职场\n\n主动认识同事。\n\n虽然不太可能与每一个同事都能相处的特别熟。但对于新人，都会被拉入一些群。这时候，可以加同事QQ或者微信等（同事一般不会拒绝），便于之后沟通交流工作。\n\n这时候有的人能够主动快速得认识团队里的同事。有的人则是入职了很久都不认识对面的同事。\n\n把离别看得平淡了许多。大学毕业后，很多人一晃一年没见，是再正常不过的事了。\n\n同事离职后，即使还在同一个城市，但交集就变少了。\n\n有江湖的地方就有规矩，职场也有。在职场只要用心去发现，能够学到公司的管理方式等。\n\n认清自己的定位\n\n常和别人开玩笑说，自己是来自贫困的小山村的一个大学生，职业是：说的高端一点是前端开发工程师，说的通俗易懂点则是做网站的程序猿。嗯，这就算是一种定位。\n\n像我这样的人几百万。想起一个朋友说：感觉你在IT方面很厉害。我说：你只是认识万千程序猿中的一个而已。\n\n学无止境，提升竞争力\n\n智联招聘网显示：web前端开发是竞争最激烈的职业。\n\n上次听一次segmentfault的讲堂，其中有提到慕课网有很多用户，其中400万是前端开发。\n\n有时候会想我这一年是不是学习方式不对，不够努力，或者说能否再努力一点，是不是能够进入更好的大公司，能够得到更好的成长。\n\n事实证明，自身能力不够，有机遇来了，会抓不住。\n\n比如：之前有面试过淘宝，然而技术一般，没能通过面试。\n\n\n现实生活#\n\n我读大学买了电脑考了驾照，四年花了家里4万块左右（从大一暑假买电脑开始算到大四结束，用Excel统计家里打了25200元给我）。而在杭州待一年光吃住就得花近3万\n块（吃饭按一天40元算，一个月1200，租房1100+）。\n\n最近看的电视剧《欢乐颂2》中，身为90后的程序猿应勤在大上海买了车买了房（好像还提到是全额付款）。现实中在大上海房价均价5.5万/平米，有人分析单靠程序猿那点工\n资（虽然IT行业相对其他行业薪资高些）是不太可能的。\n\n\n展望未来#\n\n看到毕业几年的同事过着怎样的生活，可以推测出几年后的自己大概过着怎样的生活。当然未来的一切都是未知的。但基本能看出自己一年后是过着怎样的生活。\n\n打个比方：月薪两万的薪资算是很不错了，但是在大城市算刚起步，为什么算刚起步，主要因为房价太高，买个房好几百万。（这里好多人误解以为是我的薪资，我注明下，是打个比\n方，薪资是比较私人的东西，不问薪资似乎成为了共识）比较优秀的前端开发工程师，工作三年后月薪大概能达到15K—20K，当然各城市不一。再往后，能达到年薪50万左右\n已经是非常不错了。\n\n如何提高收入，是大家关心的永恒的话题。5月份我们从学校课题组出来的三个同学回学校时，在高铁上上讨论过，毕业一年有什么感觉，大家都一致认为：要想单靠开发这点薪资，\n在大城市立足，是非常艰难的。然后想着有哪些赚钱之道，都可以去试试，刚毕业一年，还算很早。\n\n主要说到三条。第一条是：加入有潜力的团队初创公司（拿股份）。同学就说到他们老大的事迹，说刚靠程序猿这点工资在大城市过上小资生活是很艰难的，他之前加入阿里后来拿股\n份才开了现在的公司（大概意思是这样）。\n\n第二条是：拓展自己的人脉，找准风口，好创意，自己组建团队开发出有价值的产品。说到这条我就提到小密圈（付费圈子，我加入一个圈子收费200，有700+人加入，运营一\n年，就能得到14万的收入。）\n\n我自己也建了一个前端视野的小密圈（免费），发发自己关于前端开发的所见所想，也好沉淀沉淀，没打算怎么推广，但这里还是贴一下二维码，万一有人想加入呢。\n\n\n\n[前端视野-小密圈-一个人走得快，一群人走得远]\n\n前端视野-小密圈-一个人走得快，一群人走得远 还建有一个PPT视野的圈子，这个目前还没发过动态。\n\n第三条则是：发展一项兴趣爱好，打造个人品牌，做到可以赚大钱的地步。（有人刚毕业4K，毕业三年，凭借PPT，开商务PPT训练营收费课程，年薪50万）。他们经常问我\n可以多接些PPT来做，就可以赚点钱了，我说目前没有时间，也没有渠道，而且我也是只是万千PPT设计师中很渣的一员。\n\n想做到收入更高，除了做好本职工作和提升专业素养外，也需要跳出来看看外面的世界。\n\n上次和同学几人一起玩的时候，有个妹纸说了这句，何以解忧，唯有暴富。让我记忆犹新。\n\n事实上群体中确实有小概率事件发生，比如中个上千万的彩票，但是对于个体，这种事几乎不可能发生。而且有研究表明，中彩票的普通人，一般会在五年后用完这笔财富，最后还是\n普通人。\n\n所以说：提高自己在各方面的竞争力，比如：为人处事、沟通表达、团队协作等等，这也就是可迁移能力，以不变应对这个变化的世界，才是最重要的。\n\n这是我写在简书的文章：工作一年后，我有些感悟","routePath":"/20170602-After-a-year-s-work-I-had-some-insights/","lang":"zh","toc":[{"text":"学习工作","id":"学习工作","depth":2,"charIndex":308},{"text":"现实生活","id":"现实生活","depth":2,"charIndex":899},{"text":"展望未来","id":"展望未来","depth":2,"charIndex":1128}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"参加有赞前端技术开放日所感所想","content":"#\n\n> 写于2018-04-21 20:08:26\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n从2016年毕业在杭州工作以来，就比较热衷于参与杭州各类线下技术分享类活动。 之前参加过网易云课堂学习节、拉勾网理想之上、coding.net\n技术小馆、阿里D2两次、阿里work like\nalibaba沙龙、freeCodeCamp线下分享等...自己也参与到**freeCodeCamp(简称fCC)**，点击访问freeCodeCamp，杭州线\n下分享活动的组织中。\n\n\n为什么这么热衷于参加这类活动呢？#\n\n可能拿之前D2填写的参会理由可以很好的解答这个问题。\n\nD2报名填写的参会理由:\n\n> 1、了解讲师碰到的问题，有哪些解决方案，是如何解决的，学习他们的解决思路和方案。\n\n> 2、了解现在前端技术发展情况和未来发展趋势，把握学习方向。\n\n> 3、结交前端圈内朋友，让自己融入到更积极的技术氛围，促进自己的技术提升。\n\n\n为啥之前都没写文章总结下，而这次有赞前端技术开放日想总结下呢？#\n\n刚好看到知乎上有这个帖子。参加有赞前端技术开放日是种怎样的体验？\n\n因为之前都是免费的活动。好像也没什么可写的。觉得发条朋友圈简明扼要的总结下即可。这次有赞的活动是收费的，都这么多人参加，直播观看量3w人次（最高时），而且有其他\n城市的人过来。比如：罗辑思维（北京），简书（上海）。可见前端圈的小伙伴对参与这类活动也是十分活跃的，同时说明了有赞宣传的比较好。所以，觉得有必要写一下。技术方面\n不多写，可以回看PPT，或视频。\n\n可以看下官方微信公众号发布的活动总结文章，里面有PPT，视频回放等。 有赞技术活动首秀——有赞前端技术开放日圆满结束 主题主要有：\n\n> 1、主题一：有赞开源项目最佳实践\n\n> 2、主题二：本地调试线上代码——已开源，点击访问ZanProxy\n\n> 3、主题三：让前后端协作更高效——ZanAPI\n\n> 4、主题四：Node 在有赞的实践\n\n> 5、主题五：有赞内部代码管理工具串讲\n\n为什么会有这么多产出，主要有三点：\n\n> 1、业务逼的\n\n> 2、工程师文化\n\n> 3、注重技术基础\n\n感觉就是有赞前端技术团队，碰到什么问题，奔着高效工作的目的，提出解决方案，团队内部适用、推广，最后把做得比较好的项目开源。\n总之有赞前端技术团队靠谱、有追求。值得加入。\n\n我是12点多到达场地。这时人还不多。拍了两张照。\n\n\n\n\n\n\n回顾一下整场活动，主要有六点：#\n\n1、人脉圈子\n\n有赞前端技术负责人施德来（下文简称德来）分享的缘起，说杭州兑吧公司想去有赞参观参观，交流交流。于是干脆办一个技术开放日。然后邀请了杭州一些公司来参与。比如点我达\n、丁香园、兑吧等。 说明杭州各个公司的前端负责人的有技术圈子，都相互认识熟悉，而且比较注重交流。 有人脉圈子，对于程序员来说，很重要。\n\n2、正向反馈\n\n虽然有赞搞了很多成功的项目，但也有失败的项目。 所有的失败项目，总结起来，就一条：没有准确估计投入产出比。\n就是说没有正向反馈，就最后不了了之了。平时自己学习也是如此，如果没能看到正反馈，很难坚持下去。\n\n3、演讲能力\n\n德来宣称他们内部演讲已经练习过几次了。 程序员可能比较欠缺演讲能力，毕竟很少机会上台面对上百人演讲，分享技术。\n\n4、救场解围\n\nQ/A问答环节，可能有些问题讲师解答不是很清晰，或者说提问者不停追问，就容易导致僵持下去，现场尴尬，时间不可控等。 于是好几次都是德来来解答提问者的问题。\n\n5、技术（开源）项目本质上是：理念、套路、规范的工具化。\n\n这句话是德来说的，印象比较深刻。 比如开源的项目点击访问felint就是一个集成了 eslint、stylelint、git hook 的前端代码检查工具。\n规范定好，提交代码时强制校验，或者说随你怎么写，代码都一样，最后提交会验证一遍。 我司用的就是githooks git commit 时校验代码规范性。\n\n6、参与到开源项目\n\n有余力的情况下，可以参与到开源项目，也是对自己的一种提升。\n\n最后放两张照片\n\n\n\n\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客 掘金专栏，欢迎关注~\nsegmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/20180421-youzan-front-end-tech-open-day/","lang":"zh","toc":[{"text":"为什么这么热衷于参加这类活动呢？","id":"为什么这么热衷于参加这类活动呢","depth":3,"charIndex":359},{"text":"为啥之前都没写文章总结下，而这次有赞前端技术开放日想总结下呢？","id":"为啥之前都没写文章总结下而这次有赞前端技术开放日想总结下呢","depth":3,"charIndex":538},{"text":"回顾一下整场活动，主要有六点：","id":"回顾一下整场活动主要有六点","depth":3,"charIndex":1148},{"text":"关于","id":"关于","depth":2,"charIndex":1830},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"高考七年后、工作三年后的感悟","content":"#\n\n写于2019-06-12 23:44:27\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 这是一篇写在我的微信公众号【若川视野】的文章，现在同步发布在博客。 高考七年后、工作三年后的感悟\n\n以下是正文：\n\n> 本打算端午假期发表这文章，后来因为文章还需要有些调整，工作日又比较忙，就到今天周三才发。随便写了近3000字，文章最后有免费送书活动，欢迎留言参与。\n\n又一年高考结束了。转眼高考过去七年了，工作了三年。很多认识的同届的朋友同学研究生也毕业了，在大学认识的最后一批学弟学妹也毕业了。算是一个阶段结束了。\n\n\n高考很大程度决定人生轨迹#\n\n七年前（2012年）坐在自己家乡的小县城考场里，写着语文试卷。前面花的时间比较多，留下写作文的时间不太多，有些紧张。后来考数学时，也时不时有想着语文可能没考好。\n现在想想那时有着40多分钟就能写出不少于800字的作文，放在现在这能力有所退化。\n\n高考出分数后，自己研究和分析买的报考指南书籍。选择了一些专业和学校，凭着对这些专业和学校的简单认知，最后在网吧里报考了几所学校和专业。最后录取到了信息管理与信息\n系统这个专业。\n\n那个暑假，想想自己好像从来都没有离开过所在的小县城，对大学是怎么样的，是不清楚的。所以对即将到来的大学生活特别憧憬。\n就好比在大三即将毕业时，对社会和职场也可以说是所知甚少。\n\n2015年6月3日，课题组老师请我们同学三人和一位当时在深圳实习回校的同专业的大四学长，去他家吃饭。就跟学长闲聊了一些工作类的话题，大概意思就是压力还是挺大的，\n深圳租房也要一千多，房间还不大等等。\n（因为2013年大一参加过学校的招聘会，看到开发类应届生薪资5、6K，当时觉得还不错。）当听到租房就要一千多，顿时感觉对社会和职场知道的太少了。但在那个暑假确定\n了未来工作的方向。之前写过一篇文章：我是如何踏上前端这条路的\n\n那时我们几个人觉得，可能大学班上没有几个人会从事本专业相关的工作。但事实上毕业后还是有一大部分人选择了IT互联网行业。因为毕竟真的没有太多选择。我知道的很多名校\n毕业生也从其他行业转入互联网行业。\n\n回过头来看，高考其实挺重要的。至少决定了未来四年在哪个城市跟哪些人一起学习，很大程度决定工作的方向。虽然很多人毕业多年后，不一定会从事自己所学专业相关的工作。\n\n小时候也或多或少听到过一些读书无用论的话语。但工作三年后，发现行业知名大佬、公司领导等多数出自一流大学。一流大学毕业生大概率进入一线公司。那么一般大学的毕业生有\n没有机会进入一线公司，也是有的，毕竟有一部分人虽然在一般大学，但努力程度和能力会超越大部分人。\n放在没有互联网的时代，可能获取知识真的很难。而现在互联网时代不缺好课程好资料，可以很大程度上帮助到一部分人学习和成长。 有张图可能可以很好的表达这一情况。\n\n\n考研#\n\n现在再看考研，考研是提升眼界和视野比较好的方式之一，研究生还有一定的留在高校工作的机会，而本科生没有。双非院校，即使是计算机类专业，能考研尽量考研。2017年时\n和来杭州出差的大学老师聊天。作为复旦大学的博士老师建议，如果觉得写代码遇到了成长瓶颈，不妨再考个研，读个好学校，比如复旦交大等。这样毕业出来平台就不一样了。(当\n时想着，果然是复旦大学，随口说出来就是复旦交大之类的院校，毕竟是很难考上的。)\n\n\n归零#\n\n从小学到大学，大学到工作。 每一次都是一次归零，一次重新开始。 有人说：毕业前觉得自己有无限可能，毕业后回到了现实社会。\n投身IT技术岗，要早做打算。常言道：机会总是留给有准备的人。\n问过一些学习成绩比较好的学弟学妹，他们都感慨没有学好专业课。主要还是实践不多。导致跟企业要求相差比较多。但以往各方面就表现不错的人，往往能够快速适应新环境，同样\n做到表现不错。\n\n\n看着微信朋友圈，往往容易陷入羡慕别人的怪圈#\n\n这时候想起一个词语叫做幸存偏误。 这时参看百度百科：指的是只能看到经过某种筛选而产生的结果，而没有意识到筛选的过程，因此忽略了被筛选掉的关键信息。\n朋友圈动态也是大家筛选过才发出来的，一般来说朋友圈都是发好的一面，正能量的。\n以致于很多人都羡慕别人，就可能会觉得自己混的最差。我也会羡慕我的一些985、211高中同学和关系比较好读研究生的同学。\n正所谓：城外的人想进城，城里的人想出去。**但有些事情只有自己亲身体会，才会更加深刻。**纸上得来终觉浅，绝知此事要躬行。\n有段时间，各种文章分析拼多多号称的三亿用户从何而来。有人就说大学本科生仅有中国人口的4%。虽然大城市的人虽然很少用拼多多，但我们并不全面的了解中国。\n\n> 我们都知道中国有960平方公里的土地，但我们对她有多少城市，县，镇，村并没有完整的概念。\n> 有统计表明，中国约有300个“城市”，2856个“县”，41658个“乡镇”，662238个“村”。\n\n而我就是来自60多万“村”的一员。\n\n\n人脉圈子#\n\n工作后，人脉圈变窄。这估计是很多职场人共识之一。 工作所在城市即使有同学朋友，一年聚的次数最多也就1、2次。有距离的原因也有时间的原因。\n从小学到大学毕业，听别人说一旦毕业班上同学再也聚不齐了。像是危言耸听。但到现在为止，好像真是这样，全班人没聚齐过。大学算是认识挺多人，但各奔东西，相忘于江湖，是\n我们共同的结局。 圈子窄主要原因大多数职场人，打交道的人只是所在公司团队的人，认识的都是圈内的人。 人脉圈子有时候很有作用，这就需要平时有些积累。\n\n\n职场的困惑#\n\n职场的困惑往往是因为自身能力不足。想着改变，又无力改变。\n想起一次一群人聊天，问到大家的理想是什么，基本都回答没什么理想，我也是如此。很多人对自己未来规划和职业规划都是不明确的，或者说根本不是很了解自己。导致当下想改变\n，又不知道怎么改变，陷入恶性循环之中。\n**求变之前需要认识自己，问清自己想要什么，想做成什么样的人。**为了目标，自己能做到哪一步，有了一个大目标，制定确实可行的方案，根据自己执行情况，不断修正方案\n，不断得到正反馈，这种感觉很好。有那么一句话叫做不逼下自己，都不知道自己可以有多优秀。\n培养自己良好的习惯，不断的了解自己，定目标，刻意练习，得到正反馈，良性循环，提升自身的各方面的能力。\n\n\n未来还面临着很多选择#\n\n过去的20多年，有很多选择，选择大学和专业，选择考研与否，选择城市和行业，选择公司。未来还有很多选择。有时想到未来就会很焦虑，有种需要和时间赛跑的感觉。\n经常被朋友和同事问到，会一直在杭州待下去吗？此类问题我一般是这么回答，只能说最近几年会一直在杭州。随着大学毕业时间越长，越来越多可能影响一生的问题需要考虑。\n\n\n最后福利时间#\n\n只要您在若川视野微信公众号下留言，说出定目标最后怎么达成的故事或者为什么想看《刻意练习》这本书。截止到6月16日21点（本周日），我在留言区挑选5位觉得不错的留\n言，联系这5位同学，免费包邮送出《刻意练习》这本书，无需转发，无需集赞。\n\n最后附上毕业三年每年的年度总结文章和工作一年的感悟文章。 2016年度总结，毕业，工作 工作一年后，我有些感悟 2017年度总结，一如既往\n2018年度总结，平淡无奇\n\n文章同时发布在简书（方便后续修改），高考七年后、工作三年后的感悟。","routePath":"/20190612-after-3-year-work/","lang":"zh","toc":[{"text":"高考很大程度决定人生轨迹","id":"高考很大程度决定人生轨迹","depth":2,"charIndex":382},{"text":"考研","id":"考研","depth":2,"charIndex":1302},{"text":"归零","id":"归零","depth":2,"charIndex":1511},{"text":"看着微信朋友圈，往往容易陷入羡慕别人的怪圈","id":"看着微信朋友圈往往容易陷入羡慕别人的怪圈","depth":2,"charIndex":1699},{"text":"人脉圈子","id":"人脉圈子","depth":2,"charIndex":2155},{"text":"职场的困惑","id":"职场的困惑","depth":2,"charIndex":2388},{"text":"未来还面临着很多选择","id":"未来还面临着很多选择","depth":2,"charIndex":2704},{"text":"最后福利时间","id":"最后福利时间","depth":2,"charIndex":2875}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"关于我","content":"#\n\n\n简介#\n\n你好，我是若川。江西人，某不那么知名的陶瓷大学毕业生，目前在杭州从事前端开发工作，也是一名PPT爱好者。所知甚少，唯善学。常以若川为名混迹于江湖。\n\n为了能帮助到更多对源码感兴趣、想学会看源码、提升自己写作和前端技术能力的同学。帮助读者夯实基础，查漏补缺，开阔眼界，拓宽视野，知其然知其所以然。\n\n我倾力持续组织了3年多每周大家一起学习200行左右的源码共读活动，目前有5000+人参与。感兴趣的可以点此扫码加我微信 ruochuan02\n加群参与。我一直在源码共读微信群里，免费答疑解惑，有空会的都会解答。\n\n另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。\n\n> freeCodeCamp\n> （简称fCC）杭州社区组织者之一（简单说就是fCC杭州社区与杭州互联网公司共同举办线下技术分享交流活动，帮助开发者提高，曾与阿里、宋小菜、丁香园、微医、个推\n> 等公司合作过）。\n\n\n若川由来#\n\n虽然2016年毕业至2019-01-05\n21:41:46都是轩辕Rowboat这个网名，但觉得比较拗口。所以打算用自己名字川字组合，重新取过一个名字。（虽然谷歌搜索轩辕Rowboat，都是我，但还是决\n定启用新网名：若川）。 取自两个词语的上善若水，海纳百川。\n\n\n家乡#\n\n在很久很久以前，盘古开天辟地之时，后来...不知道经过了多少年。若川，出生于江西吉安欧阳修（不知道欧阳修是谁？醉翁之意不在酒，在乎山水之间也。这个应该知道）故里\n的一个贫困的小山村，究竟有多贫困呢，各地贫困指数不一，就不得而知了。你们只需要知道小马云，就是来自我们的小县城上的一个镇上。百度百科词条：小马云\n\n\n怎么走上前端路的#\n\n再后来，我一不小心来到了某不那么知名的陶瓷大学拜师学艺，当然可想而知，没有学闻名于世界的陶瓷相关技艺。拜师学艺期间，遇见两位\"师傅\"，和其他两名弟子一同学习PH\nP+MySql，从此开始了我的Web开发学习之路，也有一些成果。机缘巧合，拉了两个山派（社团），再一不小心玩起了PPT，后来发现自己更加喜欢前端，期间又听说有个\n叫网易的招收前端开发微专业三期弟子，于是走向了这条漫漫前端路。 一眨眼，四年过去了。2016年，下山来到了杭州闯江湖。深知时代在迅速发展，需不断学习。\n欲知更多详情请让鼠标走两步，看此文我是如何踏上前端这条路的。\n\n\n联系我#\n\n知识星球【前端视野·若川】，欢迎扫码免费加入。\n\n同时也建了一个微信群【前端视野交流群】，欢迎加入（可以加我微信好友，拉您进群）。\n\n主要发表一些前端所见所想，Vue、React、构建工具(比如：gulp、webpack)、Nodejs、设计模式、算法与数据结构等前端内容。一个人走得快，一群人\n走得远。\n\n为啥要创建这个呢，可以查看这篇文章工作一年后，我有些感悟，同行大概都会有类似感慨。\n\n同时建有一个微信交流群。(2019-06-20更新) 欢迎加入，可以加我微信ruochuan12，邀请您进群。\n\n掘金社区@若川，有时也活跃在掘金社区，欢迎关注。\n\n知乎@若川，偶尔逛逛知乎，也发发文章，目前很少回答问题。\n\nsegmentfault社区@若川，偶尔在SF社区答题，虽然目前只有少得可怜的6.2K声望(2012-01-31更新)。\n\ngithub@若川，常在 github 活跃。\n\n简书@若川i，偶尔在简书上写写文章。\n\n微博，偶尔在微博上更新日常。\n\n\n微信公众号和微信交流群#\n\n可能比较有趣的微信公众号，长按扫码关注。欢迎加我微信ruochuan12（注明来源，基本来者不拒），拉您进【前端视野交流群】，长期交流学习~\n\n","routePath":"/about/","lang":"zh","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"若川由来","id":"若川由来","depth":2,"charIndex":438},{"text":"家乡","id":"家乡","depth":2,"charIndex":579},{"text":"怎么走上前端路的","id":"怎么走上前端路的","depth":2,"charIndex":740},{"text":"联系我","id":"联系我","depth":2,"charIndex":1022},{"text":"微信公众号和微信交流群","id":"微信公众号和微信交流群","depth":2,"charIndex":1462}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"2016年度总结，毕业，工作","content":"#\n\n> 写于2017-01-07 21:40:38\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 1月4日的时候就写好了这篇文章，发年度总结说说的同时，在想是否有必要在空间发这篇日志，因为是使用markdown写的，排版是个问题，可以发表在简书啊（但是又\n> 包含很多个人信息）,后来觉得就没发。现在想想好像基本都是用手机看的，排版并不是那么重要，还是发出来吧，可能对读者有些启发。\n\n时间总是那么的快。2014年开始，就有了写个人年度总结的习惯。如果把2015年定义成PPT年，那么2016年则可以说是开发年。这一年相对比较平凡，还算满意。\n\n2015年的年底，准备好了提前答辩的相关事宜。2016年元旦放假三天，在学校的课题组办公室翻看着微博（微博有时间轴，可以看到每个月都发了什么，这也就是为什么我比\n较喜欢发微博的原因之一），做着PPT，用思维导图工具Xmind，写着年度总结——《2015年总结，淡化旧标签，无惧未来 》。\n\n翻看2016年的微博，看到大年初三的一条这样写着：\n\n> 猴年初三（2月10日），去舅舅家拜年。舅舅极力要求我在他家住，说以后工作了，忙着赚钱，更是没什么时间住了。舅妈以为我还是21岁……然而过完年，虚岁就是24岁\n> 了，其实明明是22岁半。好吧，确实老了。到了尴尬的年纪。按这样算，还有6年就30岁了……这六年要赚好多钱。\n\n最近听喜马拉雅付费精品中关于年度计划的，提到人生的8个方面,分别是身体健康、财务理财、人际社群、工作事业、家庭生活、学习成长、体验突破、休闲放松。于是根据这个把\n自己的2016年总结整理了一张思维导图和仿支付宝年账单做了一份年度总结PPT。\n\n\n\n\n\n\n未来的路在哪#\n\n1、看周围同事，基本就能看到自己几年后是过着怎样的生活。试想这样的生活是不是自己想要的，如果不是又将做什么来改变呢。老板有时给我们开会也会问：一个员工加入一家公\n司终究会离开，你是否会认真考虑【我会在这里干多少年？想成为什么样的人】。\n\n2、再看看自己的校友，在移动互联网领域比较出名的有杜瑶，CSS参考手册作者（css.doyoe.com），去哪儿网前端技术总监。猎豹移动副总裁陈勇。柴魁元,乐动\n卓越科技有限公司CTO等等。\n\n3、如果仅从开发这条路来看，很容易看到自己的天花板。而且业界都一致认为，程序员是吃青春饭，看自己身边同事就知道年长的非常少。G20放假那次回家，跟老爸聊天，老爸\n聊到年轻的时候赚点钱容易，年纪大了就不容易了。何况你这工作吃的是青春饭，以后怎么办。我说：到时候再看，转行吧。比如这篇文章：一位工作十年程序员给的忠告\n\n\n打造个人品牌（知识型IP）#\n\n《程序员必读的职业规划书》有提到打造个人品牌；公司年中大会上，我司创始人（前阿里副总裁）也谈到IP；参加的网红经济论坛上更是对网红（IP）有一些深层次的解读；《\n和秋叶一起学职场技能》书中也有提到如何打造个人品牌。\n虽然，以前的积累，微博粉丝超过了1千，微信好友快1000，两个QQ的好友基本不重复，超过1400，但这些都是最低层次的无门槛自媒体。\n\n我这名字，在我关注的圈子中，知道比较有名的大咖有小川叔。\n在公司叫花名（轩辕），于是把我在网络上的各种账号的昵称统一成轩辕Rowboat，再后来（2019年1月初）改为若川(被占用则是若川i)。也算是打造个人品牌的开始\n吧。\n\n2016年，这一年出现了很多知识变现的产品，比如：微信公众号打赏，简书打赏，知乎live，分答，在行，微博的问答，喜马拉雅付费精品等。\n\n原是程序员的彭小六就凭借着知识变现这一红利月入6位数。比如： 《凭着这3个字，我上个月挣了6位数》\n也有程序员靠之前人气等多方面的积累，开一次知乎live，分享知识，就能赚1万+。 之前在公众号看到的文章，《月入10W真的很难吗？》\n清华大学毕业阿何的一篇文章：《年轻人，如何挣到自己第一个100万？》 文尾总结：\n\n> 总结一下，对年轻人来说可操作性最强又能挣很多钱的方法，其实就三个步骤：\n\n> 第一：找到自己的一个特长，把它培养得足够出色\n\n> 第二：找到适合你的特长，又有足够用户注意的平台\n\n> 第三：在这个平台上深耕细作，打造品牌，获得收入\n\n> 每个人都有自己的特长，只要长时间持续打磨，总有一天能到“可以卖钱”的水平。\n\n虽然这类文章有点夸大其词，鸡汤文的感觉，但也不无道理。总之这是赚钱思维的一种转变。\n\nPPT圈内，布衣公子从2012年开始分享自己的PPT作品，他的作品影响着很多人。后来收费，一份作品就能卖到上万元。这是他分享他的故事时分享的五个故事。\n改变我命运的五个故事-布衣公子 要在大城市生活，培养一种或几种可以「变现」的能力，并且这些能力不受地域的限制，似乎变得重要起来。\n\n\n时间也是资源#\n\n时间管理是永恒的话题，这篇文章写的挺好：毕业三年，你如何与同龄人拉开差距？\n\n\n世界发展太快，需要不断学习#\n\n世界在发展，以前的很多岗位都不存在了。而且未来很多工作可以由机器人来完成，而且机器人比人类做得更优秀。另外年轻人的接触新鲜事物的学习能力相对比较强。那么持续学习\n，变得更加的重要了。","routePath":"/annual-summary/2016/","lang":"zh","toc":[{"text":"未来的路在哪","id":"未来的路在哪","depth":2,"charIndex":832},{"text":"打造个人品牌（知识型IP）","id":"打造个人品牌知识型ip","depth":2,"charIndex":1216},{"text":"时间也是资源","id":"时间也是资源","depth":2,"charIndex":2096},{"text":"世界发展太快，需要不断学习","id":"世界发展太快需要不断学习","depth":2,"charIndex":2145}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"2017年度总结，一如既往","content":"#\n\n> 写于2018-01-05 23:56:52\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n斗转星移，时光荏苒。2017年已经悄无声息的过去。2018年已经来临。本打算元旦完成这篇年度总结，但到现在才完整写完。\n\n年度总结有一些好处：可以回忆起几年前的点点滴滴，也可以发现一年里做的事确实不多，对自己有一定的指导意义。\n\n比如：回顾下这一年走过的路，拍过的照片，参加过的活动，认识的人，听过的歌，学过的课，写过的文章，读过的书。都是生活的点点滴滴...\n\n\n\n翻看着电脑上【N-年度总结】文件夹中2014~2016年年度总结。一般文件夹中有一份PPT和一份思维导图。\n\n新建了一个【2017年】的文件夹，翻看2017年微博整理出2017微博时间轴，继而整理出2017年的各个方面的思维导图。\n\n\n\n再看看2017年年初的年度大体计划，付出、收获这样的词汇，似乎不太合适。2018年的年度计划不敢写了。\n\n\n\n如果说2015年关键词是PPT，2016年说是毕业、开发，那么2017年依旧是开发。2017年和2016年基本一样，没什么波澜，一如既往。\n\n\n“丰富多彩的生活”#\n\n1月份，过年期间去舅舅家拜年，舅舅和姐夫都说我2016年工作后变了挺多，尤其酒量不错。大学室友说我工作后比较爱玩了，大学期间比较喜欢宅在寝室。其实我是那种宅也可\n以，游山玩水也可以的一类人。\n\n12月份，和一朋友聊天，她说了一句：看你朋友圈各方面蛮精彩的。想起高中关系比较好的几个同学都在985、211读研，虽然他们表示比较羡慕我朋友圈发的\"丰富多彩\"的\n生活，但我也比较羡慕他们的。这也许就是人们常说的围城吧。城外的人想进城，城里的人想出城。\n\n但事实上，我们总是习惯地去推测：看到一个人去图书馆，就推测TA博览群书。看到一个人发朋友圈在旅行，就推测TA经常在旅行。看到一个人去参加各种线下活动学习，就推测\nTA经常去参加这类活动。 于是将美好的别人与糟糕的自己对比，从而心生羡慕。但往往这种推测不准确。\n\n\n身体健康#\n\n这一年，每天基本都是12点10分左右，有时睡得比较晚上班就容易打哈欠，同事开玩笑说是不是早起偷能量了。\n\n基本也没怎么锻炼，（半小时左右）上半年基本走路上下班，下半年就成基本骑车上下班了。\n\n年初体检了一次，年底体检了一次，虽无大碍，但还是要注意身体。体检时听到体检机构的工作人员讨论，别看现在的年轻人年轻，但他们经常很晚才睡，熬夜，不吃早餐等。是啊，\n年轻人更应该注意身体，尤其是IT行业的程序员。\n\n\n慢慢打造“个人品牌”#\n\n这一年，换了工作，在前端开发上有所成长，偶尔会在segmentFault社区答题，主要是10月份，一个月声望值增长976分。月度排行榜排名第六。现在声望值2.2\nK。虽然比较少，但基本是今年才涨的。全年只在segmentFault社区、掘金发布了两篇文章。\n\n5月份，开通了“前端视野”，知识星球（原“小密圈”），偶尔发一些前端开发相关的知识和感想，没怎么推广的情况下，没想到到年底有91人加入。\n\n很多人努力学习知识，参加各种沙龙，向前辈学习，参加开源项目，把自己的心得无私的分享出来，慢慢的，他们踏上了不一样的平台，快速成长。\n\n这样努力的人我朋友圈就有一位。毕业四年在北京，月薪早已超出同龄人的水平。但基本学习到2点左右睡，6:50起，午休睡一会，一般一天不少于6小时。还读着英文文档，玩\n转各种开发语言。想想我身边他这层次的人也没有这么拼啊，他解释道：个人追求也不同，追求也不一样。他都这样的努力确实让我敬佩不已。真是应了那句话：比你优秀的人不可怕\n，可怕的是比你优秀的人比你更努力。\n\n\n旅行#\n\n这一年，清明假期和同学去了江苏无锡鼋头渚、惠山古镇、三国城等。 太湖四月天，无锡鼋头渚。登上赏樱楼，樱花似白雪。\n惠山古镇，历史悠久，古迹众多，人文荟萃。宝界山林，远眺太湖。湖光山色，相映生辉。\n\n\n\n五一假期去了浙江舟山。人生中的第一次看海，海上日出日落。\n\n\n\n随便放了几张照片。 2017年初上写的旅行计划去黄山、上海、出境游通通没有实现，现实版的计划赶不上变化，是多么痛的领悟。\n\n\n危机感#\n\n5月13日，和课题组的两位同学，一起回学校参加课题组老师的婚礼，老师说：“到时你们婚礼的时候派代表参加”。一次和毕业几年的表哥聊天，聊到年轻的时候最重要的两件事\n就是结婚和买房。同事也会问准备一直在杭州吗。感觉这类话题，不管和谁聊天都会聊到。我就感慨到：现如今，大学毕业生靠自己在杭州买房，真是难于上青天。\n\n> 到底有多难，我大概算了下。假如杭州郊区算3万一平，那么一套房算300万，首付30%则需90万。假如一年存款能有10万，那么也要攒9年。你可能会说工资会涨，但\n> 可以肯定没有房价涨得快...而且只是付完首付而已，就要9年。9年后又到了人们常说的中年危机，面对各方面的压力，那么以后的日子更加艰难。照这样想想都后怕。\n\n但在大城市还是有一定机会的，虽然比较渺茫。\n\n退一步回老家买房，但小县城房价均价据说都6K+了。而且感觉在老家买房，自己在外漂泊也不是办法啊。\n\n写到这里，看到统计的字数是1818字，刚好2018年，很吉利。2017年度总结算是收尾了。","routePath":"/annual-summary/2017/","lang":"zh","toc":[{"text":"“丰富多彩的生活”","id":"丰富多彩的生活","depth":2,"charIndex":599},{"text":"身体健康","id":"身体健康","depth":2,"charIndex":967},{"text":"慢慢打造“个人品牌”","id":"慢慢打造个人品牌","depth":2,"charIndex":1177},{"text":"旅行","id":"旅行","depth":2,"charIndex":1639},{"text":"危机感","id":"危机感","depth":2,"charIndex":1840}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"2018年度总结，平淡无奇","content":"#\n\n> 写于2019-01-14 23:11:09\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n\n\n从2014年开始写年度总结至今已经五个年头了。正如孔子所说：逝者如斯夫，不舍昼夜。\n\n这一年，与2017年基本一样，平淡无奇，只是觉得时间过得更快了。\n人们往往容易高估自己一年能完成的事情，低估自己五年能完成的事情。记录下来，发现一年做不了很多事。\n\n使用teambition网站记录了不少任务，还有很多没有完成，不过我一般是记录任务。\n\n2016年学习了一门年度计划的课程，提到人生的8个方面，分别是身体健康、财务理财、人际社群、工作事业、家庭生活、学习成长、体验突破、休闲放松。觉得这8方面还是挺\n合理的，于是2016年度总结开始，都是按这8个方面用xmind画思维导图总结自己的一年。\n\n\n工具篇#\n\n有人可能会想，一年这么多事情，竟然记得那么清楚，是哪天发生的，都记得。 这时候就要说一说，这一年，主要使用的工具。\n\n其实很多事，我都会发微博记录。整理总结一年的开始会先先用xmind整理【2018年微博时间轴】\n\nGTD任务管理，目标管理之类的软件，很早之前（大学期间）用的是doit.im。后来用的是滴答清单，现在主要用的是teambition\n\n以前用24PI，后来不支持现在的手机，就弃用了。rescuetime 记录时间的软件\n\n\n\n发了年度总结的思维导图的朋友圈后，有人评价，一个极度自律的人。其实觉得自己自律和目标管理（之前写过一篇文章：如何制定有价值的目标）方面，还是做得挺不好的。没有达\n到良性循环。只是相比于一般人，写年度总结罢了。\n\n\n身体 · 健康#\n\n全年基本没有锻炼，虽然特意买了一个手环记录运动数据。骑车（20分钟左右）上下班都算是一种锻炼了，下雨或者天冷就坐公交。\n\n2月20日，大年初五换了第三副眼镜，据眼镜店记载上一副还是高三（2012年）配的，第一副是高一（2009年）配的。配完新眼镜感觉很清晰，现如今，已经又加深了，模\n糊了。（主要还是天天面对手机电脑且不注意休息的缘故）。\n\n正印证了那句话：真的要少玩手机电脑了，眼睛越来越不好了，打开支付宝都看不到钱了。\n\n有时问自己：按时好好吃饭，难吗？按时好好睡觉，难吗？确实难。\n\n这一年，工作日点外卖明显多了（往年基本不点外卖），下班后有时容易饿了先吃零食填肚子。年轻人容易得胃病，往往就是不按时好好吃饭的缘故。\n\n9月1日生日那天，把杭州的大学同学聚在一起聊天时，好几个同学提到累但睡不着，容易醒。醒来就睡不着了。感慨不年轻了，大学期间没课还可以睡到自然醒。那时心想看来不只\n是我一人如此。\n\n到了12点，身体就开始就感觉累了，要去休息了，很难熬夜了。有时又容易睡不着，就失眠到一两点，第二天照样去上班。周末一般都1点才入睡，想着第二天不用早起，再睡个懒\n觉，一上午就浪费了。\n\n但试想一下，好像没必要非得拖到那么晚才睡。听一朋友说TA 10点半前基本就会关闭电子设备，看书，11点准备入睡，容易睡着。我也试着照这样做，确实容易睡着。\n\n总之，2019年得管理好自己，按时吃饭、早睡早起。试着调整成11:30前睡，8:00前起。不区分工作日还是周末。\n\n\n财务 · 理财#\n\n所谓理财就是理清自己的财务，开源节流，基本没有乱花钱。\n\n虽然在网易云课堂上了花了几百元买了《简七理财》相关课程，但就看了几小节。\n有些人，买几千块钱的耳机，上万块的手机，几万块的电脑。不得不说这些人确实有钱。如果追求这些，把自己变成月光族，那我觉得没什么必要。毕竟跟理财理念是相违背的。\n\n\n人脉 · 社群#\n\n2016年工作后，那时就发现人脉圈子窄了。不像大学，因为社团和活动可以接触到很多同学和老师。原来大学认识的学弟学妹都来到杭州工作了，自己毕业快三年了。这一年，工\n作之外，算新认识的朋友少得可怜，好像不超过30个，女生就更少了。\n\n老朋友联系少了，但联系起来感情还在。\n\n而且即使同在杭州的朋友同学，一年都头，可能就聚过一两次，或者几年一次都没见过。再聚就不知道是什么时候了。所以每次和朋友同学若是去风景区玩，觉得都应该合个影留作纪\n念，毕竟真的是见一次少一次啊。\n\n2月12日，年前放假回家时，几个高中同学聚了一下，都发现是好几年没见了。 6月1日，和前端群里群主（在广州来杭州玩）召集了十来个在杭州的小伙伴一起欢度了六一。\n\n后续这些小伙伴，其中一人离开杭州，再去海底捞吃火锅聚了一次。这算是一次性认识的人最多的一次。\n\n\n家庭 · 生活#\n\n这一年，开始关注楼市消息，但也没有非常认真的关注。春节期间，亲戚坐在一起聊天时，提到房子要早点买，不然一年的钱就白赚了，那个谁在哪里买了房，诸如此类。2月春节期\n间，去看了县城周边的房子，连那么远都是5K起，太贵了，县城均价都6~7K了。要知道所在城市吉安都比自己小县城便宜。\n\n6月23日，我弟高考成绩出来，帮忙报考，后来还是录取到了计算机类专业，不知是喜是忧，毕竟自己从事计算机行业，时常感到焦虑。后续给我弟买了手机和电脑。\n\n10月1日-6日，国庆放假在家6天，国庆时给老妈买了一部新手机华为荣耀8X。给爸妈买个手机充个话费，他们都记得很清楚。其实相比他们对自己的爱来说，真的是微不足道\n。\n\n基本平均每两周会和我妈视频通话。很多次都会催着找女朋友，每次我也只好默不作声。他们也着急，也会找亲戚朋友帮忙看看哪里有合适的姑娘。\n自己比较佛系（随缘），新认识的人少，女生就更少了。\n\n从历史长河来看，好的伴侣真的很重要，应该努力去追寻，毕竟是陪伴一生的人。\n\n宁南山：多赚了一两千--深圳年龄30+中产状态，有兴趣的读者可以看看这篇文章。\n\n> 所以对于“学校出身”“学历出身”相似的人来说，\n> 虽然毕业后大家努力程度不同，行业的不同，公司的不同会导致收入有差距，但其实大多数人的收入区间是逐渐趋同的，少数人除外。\n> 年龄30岁+的我们，决定我们现在个人之间差距的， 是两个选择，一个是房子，一个是婚姻。\n\n简单说也就是单科（事业）再怎么好，一般都敌不过三科（包含房子、婚姻）好的同学。\n\n作者宁南山还在这篇文章提到婚姻这个问题。宁南山：(闲聊）高考二十年后的人生轨迹\n\n\n工作 · 事业#\n\n之前同事问：家里人知道你是做什么的嘛。\n这里解释下：说的高端一点是前端开发工程师，说的通俗一点则是：网站开发，比如朋友圈各种年度报告，或者百度、天猫网站、微信小程序就是我们这类人做的。\n\n慢慢打造个人品牌\n\n知识星球《前端视野》，依旧没怎么推广，共有318人加入，比去年（5月开通）增加了200余人，就是日常发些前端相关。\n\n建有微信群【前端视野交流群】，没怎么推广，暂时32人。 在SegmentFault、掘金、简书、知乎、博客，累计发了10余篇技术文章，最高产时是11月份3篇。\n\nSegmentFault、知乎上都开通了专栏《若川的前端视野》SegmentFault：若川的前端视野，\n\n知乎：若川的前端视野。\n\n机缘巧合，有偿给牛客网出了一些前端试题，得到了几百元的报酬。\n年初也有偿帮别人做了一份PPT，获得了几百元的报酬。不过帮被人做PPT太耗时了，好久不做，做得也没大学那么顺手了。\n\n\n学习 · 成长#\n\n1月27日，成为SegmentFault优秀问答作者，获得官方发的一些礼物，比如抱枕等。\n\n给2013年买的电脑，加了4G内存条，买了24寸的显示器，双屏显示器效率确实高了很多，看完了十余门视频课程，比去年看的多些。\n\n这一年，参加的技术分享活动不多，总共2场。\n\n4月21日，有赞前端技术开放日，写了一篇参与后感想参加有赞前端技术开放日所感所想\n\n5月20日，掘金杭州前端技术分享活动。\n\n这一年，加入到了freeCodeCamp杭州社区的活动组织中，和组织者一起举办了两场活动。\n\n3月19日，fCC与宋小菜联合举办线下分享活动。\n\n11月10日，全国联动，freeCodeConf杭州站技术分享活动。\n\n当时下班后写后续报道公众号文章首届freeCodeConf杭州站圆满结束，精彩回顾，写了三天。主持稿也是我写的。主持人是我请的大学同学。\n\n输出文章（在博客、掘金、思否、知乎、简书）11篇，其中技术文章9篇，技术文章比去年多写了7篇。（去年只写了2篇技术文章）。\n\n这一年，看技术书籍，主要看了几本《你不知道的JavaScript\n上中下卷》、《深入浅出webpack》等，非技术书籍，主要看了《刻意练习》，此书还是值得一看，推荐给大家。\n\n\n休闲 · 放松#\n\n这一年旅行，只去了苏州，体验了第一次一个人旅行的感觉，大学就想体验一下，但一直没实现。苏州虎丘、博物馆、狮子园、金鸡湖景区等。\n\n\n\n杭州周边，很多地方都去过，只是基本都是不同的人。\n\n上面洋洋洒洒写了三千多字，看过思维导图的同学，会发现基本是思维导图的扩充（或者说补充）版本。 跟以往的年度总结不太一样。以往年度总结，提出了好几个观点。\n2016年：2016年度总结，毕业工作 1. 未来的路在哪\n\n2. 打造个人品牌（知识型IP）\n\n3. 时间也是资源\n\n4. 世界发展太快，需要不断学习\n\n2017年：2017年度总结，一如既往\n\n1、慢慢打造个人品牌\n\n2、危机感。\n\n而现在觉得，这些都写过了，就不写了。\n至此，昨晚写了一晚和今晚配图，2018年度总结的文章算是结束了。后续会可能有些修改。以往都只发布在朋友圈和我的个人博客，觉得博客可能迁移，图片也有时缺失，有时打\n开也比较慢，所以这一次也发布到了简书。\n\n同时也发表在简书简书：2018年度总结，平淡无奇","routePath":"/annual-summary/2018/","lang":"zh","toc":[{"text":"工具篇","id":"工具篇","depth":2,"charIndex":469},{"text":"身体 · 健康","id":"身体--健康","depth":2,"charIndex":804},{"text":"财务 · 理财","id":"财务--理财","depth":2,"charIndex":1448},{"text":"人脉 · 社群","id":"人脉--社群","depth":2,"charIndex":1605},{"text":"家庭 · 生活","id":"家庭--生活","depth":2,"charIndex":1978},{"text":"工作 · 事业","id":"工作--事业","depth":2,"charIndex":2678},{"text":"学习 · 成长","id":"学习--成长","depth":2,"charIndex":3090},{"text":"休闲 · 放松","id":"休闲--放松","depth":2,"charIndex":3627}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"若川的2019年度总结，波澜不惊","content":"#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n从2014年开始写年度总结至今已经六个年头了。\n\n正如孔子所说：逝者如斯夫，不舍昼夜。\n\n2019年的年度总结写得比较晚，都快农历新年了，此刻在家里继续写完这篇文章。往年基本是元旦之后几天就写完了。我的年度总结尽量写得非技术人员也能看懂。\n\n回首六年以来，写的年度总结如下，感兴趣的读者可以看看。\n\n回顾2014，约定2015（QQ空间日志） 2015年总结，淡化旧标签，无惧未来（QQ空间日志） 2016年度总结，毕业工作 2017年度总结，一如既往\n2018年度总结，平淡无奇 2019年度总结，波澜不惊\n\n虽然包含比较多的个人信息，但读者朋友看到或许会觉得似乎认识我很久，当然一般人也不会都看。\n\n2014年写的标题是《回顾2014，约定2015》，2015年则是《2015年总结，淡化旧标签，无惧未来》。这两篇文章是在我QQ空间中置顶10篇文章的2篇。\n\n大学毕业后，把两个QQ的空间设为了仅所有好友（共计1400余人）可见。如今都是发朋友圈同步QQ说说，我还是算会发发动态的人。不过这一年动态也发的少了。\n\n大学期间常写空间日志，转发多阅读量还不错能有两三千人阅读。2019年开了微信公众号《若川视野》，文章阅读量很少，一般也就几百，上千都是少数。\n\n以一年为时间节点记录一年，以后再看自己写过的年度总结文章，或者与别人分享，也许是一种回忆。\n\n这一年的事，很多还记得。若时间再往前推，便记忆模糊。但翻看自己的年度总结还是能记起，这也许就是年度总结的一种作用吧。\n\n另外，年度总结其实也是一次对自我审视和复盘的机会。所以我是比较推荐读者朋友们都写年度总结的，不一定要写给大家看。整理写给自己看也是一种审视。\n\n2016~2018年标题分别是毕业工作、一如既往、平淡无奇。想2019年的标题时，和2018年相比，没什么变化，所以想到波澜不惊这个词语，也许2020年度总结时\n可能是水波不兴。\n\n这样算来，自己过了十分平凡普通的三年。有句话说：人们往往容易高估自己一年能完成的事情，低估自己五年能完成的事情。记录下来，发现一年做不了很多事。\n\n这一年，启用了新网名若川（取自上善若水，海纳百川中的两个字）、\n启用了公众号若川视野、只写了9篇文章、一些平台收获了若干粉丝和阅读量、只去了宁波等地、工具记录平均每天5个多小时在写代码。\n\n这一年很少用teambition记录任务了。\n\n2016年学习了一门年度计划的课程，提到人生的8个方面，分别是身体健康、财务理财、人际社群、工作事业、家庭生活、学习成长、体验突破、休闲放松。觉得这8方面还是挺\n合理的，于是2016年度总结开始，都是按这8个方面用xmind画思维导图总结自己的一年。\n\n\n\n写文章之前，想到了这些关键词，简单列举下。\n\n * 上帝视角\n * 格局视野\n * 投资自己\n * 跳出思维，思考本质\n * 人脉是隐形财富\n * 很多能力都是可以训练而成\n\n\n身体 · 健康#\n\n八个方面，其中身体健康是第一个。\n\n这一年，7月中旬，公司组织体检，体检过一次，体检报告显示正常。但感触比较深：放射性体检时，需要躺在仪器上，仪器启动推动时，那一刻感觉身体真的很重要，其他方面再强\n，赚钱能力再强，没有健康的身体都会大打折扣，甚至说等于零。\n\n这一年，只11月份开始跑了5次步，一次跑步花不了很多时间大约半小时，但跑步在于走出去和坚持下来。有人说真正觉得锻炼很重要了，那一定可以做到。\n\n这一年，自己记录的深夜失眠有12次，这里记录的深夜失眠指的是1点以后还思绪万千，久久不能入睡，然后把自己所思所想写下来，就容易睡着了。\n\n这一年，给自己定了晚上10:50，11:20，11:25三个闹钟，但基本没有11点半就睡觉的。早睡早起真的是重要，做到又是另外一回事了。2020年争取调整好的作\n息习惯。\n\n这一年，https://996.icu,\n996icu起初是一个github上的项目，印象中我star时才3k多star，发展后来到全民都在讨论996，如今是249k的star。\n\n> “996”工作制，即每天早 9 点到岗，一直工作到晚上 9 点，每周工作 6 天。\n\n另外阿里、网易、华为等互联网大厂都加班比较严重。\n\n按加班程度来算，程序员群体并不是幸福的群体，互联网从业者基本都属于比较高学历的群体，而且真的有中年危机。当然各行各业都辛苦，这是事实。\n\n国庆假期高中同学结婚，发现很多高中同学都走向了互联网开发这一条路，而且挺多都在知名企业。和在百度工作的高中同学聊天，他说了一句：用青春换钱。我觉得确实如此，都是\n用时间换钱。\n\n想起之前看到的一段文字，觉得写得挺好。\n\n> 我有一个伟大的愿望。我希望凭借自己的努力，净化程序员的环境，提升程序员的地位。愿 IT\n> 界再无黑心企业的剥削，无人自嘲“码农”、“码畜”，技术人员受到足够尊重，写程序重新成为一种创造性的劳动。软件行业，重新成为令人羡慕的行业。自由、开放、创新、\n> 包容。\n\n程序员这些高学历群体，真的是在做着改变世界的事情，为社会的互联网添砖加瓦。而他们 的社会地位却不是很高，或者说不是很幸福。\n\n\n财务 · 理财#\n\n所谓理财就是理清自己的财务，开源节流。钱生钱才是高境界。大都都是用时间换钱。\n\n\n人脉 · 社群#\n\n老同学老朋友来到杭州，基本是游西湖，再发条朋友圈有朋自远方来。\n\n老同学老朋友虽然许久没联系，联系起来也丝毫没有陌生感。\n\n世界很大，世界又很小。加了一些微信好友，就会发现朋友圈有共同好友。\n\n各行各业有时也没有我们想象的那么大，而且圈内相对顶尖的人物基本都是相互认识的。\n\n人脉其实是自己的隐形财富，当然前提是自己实力对等。这一年写技术文章，就开放了自己的微信号。\n\n一般加微信都会发一段关于我自己的简介（毕竟我还没有出名到妇孺皆知的情况），并且备注别人。\n\n毕竟微信好友是双向关系。如果是微博，单向关注，那就不用。\n\n但很多人加微信好友一般就是加一下，其实加了好友可以告知自己来意。只有极少部分人会自我介绍下，并且告知自己所处情况，再问问题。毕竟对于一般开放自己微信号的人，基本\n都是平易近人的，而且加的人也比较多。时间稍微久了一点，那么你就默默躺在好友列表里了。\n\n\n家庭 · 生活#\n\n这一年，2月1日-13日，春节在家13天，相比国家法定节假日7天，算是在家比较长。公司一般放假10天，但我总是希望春节假期多在家里待几天，所以一般会请年假几天。\n因为如今一年一般就回两次家，国庆假期和春节假期。\n\n国庆放假8天，9月30日-10月7日在家。\n\n2月15日，给老爸买了一台智能手机，2018年国庆时给老妈买了一台智能手机。现在智能手机很方便，在大都市没个手机都寸步难行。\n\n基本平均两周和家里视频通话，这一年，老爸都开始催我人生大事了，年纪确实也算大了。真的需要多投入时间到这方面了。\n\n\n工作 · 事业#\n\n我的年度总结基本不写工作方面。\n\n自己的工作，说的高端点就是前端开发工程师，用户看到的各种小程序、网站等都是我们这类人开发的。按照以前来说可能就是一个流水线工人，其实很容易被替代。这也就是为什么\n很多人焦虑的原因之一。\n\n这一年，使用了工具wakatime，统计自己编写代码的时间。\n\nProgramming Stats for 2019 by wakatime\n\n\n\n统计表明，全年总共编码1523小时，其中自己的博客花了107小时。平均每天编码5小时11分钟，其中6月10日编码11小时38分钟。这里的编码时间统计，是编辑器使\n用时间，不在用编辑器则不会算入，这样算起来还算多的。\n\n对比2018年，平均4小时47分钟。\n\n其中两个代码提交平台公司gitlab和个人github提交记录情况如下。\n\n\n\n\n\n\n慢慢打造个人品牌#\n\n2016~2018年网名都是轩辕Rowboat，觉得比较拗口。所以2019年1月5日启用新网名若川，取自上善若水，海纳百川，刚好是我曾用名谐音。\n\n知识星球，免费，【前端视野\n若川】，2017年开通至今，虽然还没有链接一千名铁杆粉丝。但相比去年年底318人，增长了600余人，现在958人。相对封闭，也没怎么推广，一般是通过关于我加入的\n。\n\n公众号【若川视野】，3月14日变更，比变更时增长了1000多名粉丝，目前粉丝2052个。同时公众号文章投稿到了【前端大全】等微信大号，获得了还不错的阅读量。\n\n微信群【前端视野交流群 若川】2018年年底是32人，至今是291人。\n\n在知乎、掘金、思否、博客等平台累计只发了9篇文章。\n\n其中知乎粉丝在【知友推荐计划】的助力下涨粉到6000余人。知乎我的回答和文章总共阅读量4万多一点。知乎文章也有投稿的一些关注度多的专栏，比如《颜海镜的博客》专栏\n。\n\n掘金终于突破了1000粉丝，这一年阅读量4万多一点。\n\n8月4日，用vuepress重构了博客 lxchuan12.gitee.io，相比以前，阅读体验更好些。\n\n纵向对比，这些对比于2018年，都是一些进步。\n\n> 而横向对比，相比我朋友圈一些公众号号主，我这点粉丝和阅读量简直不值一提。比如，很多都有十来个500人微信群。有的人一年写了67篇文章。甚至有的人写了几百篇文\n> 章。有的公众号粉丝数量超过好几万。\n\n微信公众号文章打开率极低，所以公众号号主一般都建有微信群，在群里交流讨论，并且发文章，不过长此以往，也不是很好的办法，微信公众号号主主要就是接相关广告变现。自己\n也在一月初接了一次广告（发公众号推文）。\n\n我在2016年，甚至更早就知道要打造个人品牌，而且运营社群，可是一直行动比较少，或者说能力跟不上思想。\n\n赚相对多的大钱的，一般都是前期积累比较多，而且能有源源不断的产出。换句话说，现在主流赚钱之道，大家都容易知道。但竞争那么大能不能赚到钱，就要各凭本事了。\n\n\n学习 · 成长#\n\n我们这类工作，经常面对的是电脑。所以对电脑要求一般比较高。\n2013年买的戴尔电脑，windows系统有些卡了。所以买了一个移动硬盘，安装了Ubuntu系统，8G内存，不卡，目测还可以再使用5年。自己写文章浏览网页等都是\n用Ubuntu系统了。\n\n\n参加了5场技术活动#\n\n> 1月5日，第二届蚂蚁金服体验科技大会 1月19日，网易前端技术大会。 5月25日，微医的第二届前端技术沙龙。 8月17日，蘑菇街技术分享日。\n> 10月14日，滨江前端技术沙龙。\n\n杭州前端类技术大会比较多，一般有空我都会去参加，虽然可能不能学到很多，但还是能开阔视野。\n为什么这么热衷这类大会？之前写过一篇文章。参加有赞前端技术开放日所感所想，摘抄里面的一段。\n\n> 可能拿之前D2填写的参会理由可以很好的解答这个问题。\n\n> D2报名填写的参会理由:\n> \n> 1、了解讲师碰到的问题，有哪些解决方案，是如何解决的，学习他们的解决思路和方案。 2、了解现在前端技术发展情况和未来发展趋势，把握学习方向。\n> 3、结交前端圈内朋友，让自己融入到更积极的技术氛围，促进自己的技术提升。\n\n\nfCC杭州社区举办了2场活动#\n\n> 可能挺多人不知道fCC，其实是freeCodeCamp的简称。\n> freeCodeCamp是github上star数最多的一个公益项目。助力全球人人皆可编程。国内各大城市一般都有社区，也有活动组织者。\n> 我是杭州社区活动组织者之一，有一群小伙伴一起组织线下技术分享活动。\n> 自己经常在博客等简介都是写的这个，并不是给自己找个头衔（毕竟也不是什么职位），让别人觉得自己很厉害的样子。\n> 而是希望更多人知道freeCodeCamp，另外自己找嘉宾大佬来技术分享时可能更方便些。\n\n> 4月14日，fCC杭州社区和个推等举办线下分享活动。 9月7日，个推Techday杭州站联合fCC杭州社区举办了一次活动。\n\n\n写了2篇非技术文章，7篇技术文章#\n\n非技术文章2篇，其中一篇是年度总结，还有一篇是： 高考七年后、工作三年后的感悟\n\n第一篇《面试官问：JS的继承》是年初回杭州后不久发布的。\n\n其中学习源码整体架构系列文章6篇。\n\n> 1.学习 jQuery 源码整体架构，打造属于自己的 js 类库 2.学习 underscore 源码整体架构，打造属于自己的函数式编程类库 3.学习\n> lodash 源码整体架构，打造属于自己的函数式编程类库 4.学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK 5.学习 vuex\n> 源码整体架构，打造属于自己的状态管理库 6.学习 axios 源码整体架构，打造属于自己的请求库\n\n每篇文章都写了挺久。一般跨度至少十多天才能写一篇，这里的十多天肯定不是以每天八小时来计算。甚至有的跨度一个月才写完。\n\n其实工作后，会发现属于自己的时间很少，加班多那就更少了。\n\n工作日，不加班的一天，每天9点上午，下班后吃完饭到住处，基本就晚上8点多了。基本通勤时间花在路上一天2个多小时。碎片化时间虽然也是可以利用起来的，但基本效果不好\n。\n\n除了以上这些，这一年基本没完整看完过一本书。看到朋友圈很多人都在得到等平台学习了很多课程。2020年要多看几本书了。\n\n\n体验 · 突破#\n\n和2018年一样，这一项可以说无。感觉好久没有体验突破，让自己非常开心的事情。\n\n\n休闲 · 放松#\n\n这一年，看的电影电视剧都比较少，只看过《流浪地球》、《琅琊榜2》、《无问西东》等。比如这一年比较火的电视剧《长安十二时辰》、《都挺好》、《庆余年》等都没看过。所\n以同事比较好奇问，平时时间怎么打发的，除了学习方面没有其他的了吗？其实空闲时间真不多。\n\n这一年只4月14日去了绍兴鲁迅故居，5月2-4日宁波老外滩、东钱湖、溪口、天一阁、博物馆等地。 放几张在宁波拍的照片。\n\n\n\n这一年，整理了一下大学期间2012年～2016年，发布在QQ空间，自己感觉写得还行的七首“诗词”。回答知乎问题：你写过什么自认为惊艳的诗？算是重拾这一兴趣爱好。\n\n每一年基本都会在杭州周边逛逛。再随便写写，也谈不上“诗词”，而且也写得不好，只是算是心情的一种记录方式吧。\n\n这一年，也写了四首。\n\n杭州西湖\n\n> 3月3日 《西湖》 细雨飘飘鱼儿散， 游船慢慢客人闲。 再登小山观宝塔， 回望白堤卧中间。\n\n\n\n杭州植物园\n\n> 3月10日 《植物园》 登山眺望西湖远， 转角误入植物园。 春风袭来梅花香， 花开烂漫迷人眼。\n\n\n\n中秋西湖边\n\n> 9月13日 《中秋》 中秋断桥前， 明月挂天边。 倚坐湖边椅， 闲谈尽开颜。\n\n\n\n西溪湿地河渚塔\n\n> 11月10日 《冬日夕阳》 独上渚塔望夕阳， 四面环山在异乡。 飞鸟归去人渐远， 月出东方夜微凉。\n\n\n\n\n总结#\n\n写完年度总结，站在一年一个节点的时间线上来看，基本就知道自己一年时间能做什么，做得到什么，未来还能做到什么。所以说开头前写了关键词上帝视角，就好比翻开一本书前看\n的目录，看了目录知道大概情况，能推算之后的事情。\n\n格局视野也很重要，如果把自己定位局限于某一个方面，对自己提升也不利。就好比井底之蛙，不知天之大。\n\n跳出思维，思考本质，1月份参加了2019永丰浙江商会暨老乡联谊会，那时觉得自己很渺小，毕竟只是公司的一名小员工，而参会的大都是各种公司老板等。同时觉得需要跳出互\n联网行业，看看别的行业，思考本质。技术实现只是很小的一部分，技术人经常容易沉浸在技术层面。\n\n文章统计竟然写了5000余字，就此收尾。\n\n最后农历新年即将到来，预祝各位读者朋友过一个快乐的春节。在新的一年，遇见更好的自己。\n\n> 2020年1月22日 若川于江西吉安\n\n--------------------------------------------------------------------------------\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 若川的博客，使用vuepress重构了，阅读体验可能更好些\n掘金专栏，欢迎关注~ segmentfault前端视野专栏，欢迎关注~ 知乎前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n欢迎加微信交流 微信公众号#\n\n可能比较有趣的微信公众号，长按扫码关注。欢迎加笔者微信ruochuan12（注明来源，基本来者不拒），拉您进【前端视野交流群】，长期交流学习~\n\n","routePath":"/annual-summary/2019/","lang":"zh","toc":[{"text":"身体 · 健康","id":"身体--健康","depth":2,"charIndex":1356},{"text":"财务 · 理财","id":"财务--理财","depth":2,"charIndex":2263},{"text":"人脉 · 社群","id":"人脉--社群","depth":2,"charIndex":2314},{"text":"家庭 · 生活","id":"家庭--生活","depth":2,"charIndex":2711},{"text":"工作 · 事业","id":"工作--事业","depth":2,"charIndex":2973},{"text":"慢慢打造个人品牌","id":"慢慢打造个人品牌","depth":3,"charIndex":3340},{"text":"学习 · 成长","id":"学习--成长","depth":2,"charIndex":4195},{"text":"参加了5场技术活动","id":"参加了5场技术活动","depth":3,"charIndex":4330},{"text":"`fCC`杭州社区举办了2场活动","id":"fcc杭州社区举办了2场活动","depth":3,"charIndex":-1},{"text":"写了2篇非技术文章，7篇技术文章","id":"写了2篇非技术文章7篇技术文章","depth":3,"charIndex":5016},{"text":"体验 · 突破","id":"体验--突破","depth":2,"charIndex":5567},{"text":"休闲 · 放松","id":"休闲--放松","depth":2,"charIndex":5619},{"text":"总结","id":"总结","depth":2,"charIndex":6200},{"text":"关于","id":"关于","depth":2,"charIndex":6661},{"text":"欢迎加微信交流 微信公众号","id":"欢迎加微信交流-微信公众号","depth":2,"charIndex":6826}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"若川的2020年度总结，水波不兴","content":"#\n\n\n前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n从2014年开始，每一年都会写年度总结，坚持了6个年头。\n回顾2014，约定2015（QQ空间日志）2015年总结，淡化旧标签，无惧未来（QQ空间日志）2016年度总结，毕业工作2017年度总结，一如既往2018年度总\n结，平淡无奇2019年度总结，波澜不惊2020年度总结，水波不兴（本文）\n如今第7年了，最近总是想着2020年度总结的点点滴滴，思考这一年要写点什么不一样的，可是思前想后觉得这一年好像也没有什么不一样啊。2019年度总结文章中就写了2\n020年度总结的标题可能取名为「水波不兴」。内心深处就感觉水波不兴不错。可能是内心深处有个湖，湖面平静，有时会激起水花和波浪，但终究会恢复平静，也就是说平平淡淡\n是常态。年度总结往年基本是元旦3天假期就动笔了。\n说起跨年和元旦，回忆起这几年的最后一天。把时间拨回到2016年12月31日，那时同行四人去了良渚博物馆。把时间拨回到2017年12月31日，那时几个在杭州的大学\n同学一起聚餐、K歌。把时间拨回到2018年12月31日，几个同事一起去西湖边跨年，最后同事开车把我们送回。之后听到朋友说他们去西湖边跨年，人太多打不到车，最后凌\n晨四五点才回去，说再也不去西湖边跨年了。时间再拨回到2019年12月31日，有了以往的“经验”，跨年的气息也没有那么浓厚，就自己在住处跨过了一年。第二天元旦，朋\n友开车带我去塘栖古镇逛了逛，开启了2020年。\n\n\n\n记得远在2019年12月份，那时我在微博上看到武汉发生不明肺炎。2020年，1月20日回家过春节时，看到各种群里有讨论要口罩，当时没想那么多也来不及买口罩，于是\n没有戴口罩回到了家。谁也不曾想，疫情会影响全世界。 而2020年12月31日，也是在住处跨过了一年。不平凡的一年过去了。\n\n回想这几年，感叹时光飞逝，每一年都过得普普通通。远不及朋友圈各种大佬的一年。\n\n个人是比较建议读者朋友们都写年度总结的，不一定要发布出来，给自己看也不错，或者给未来的自己看兴许也是一种回顾。非常欣慰有读者朋友特意到我的博客看有没有写年度总结\n，也有读者朋友在公众号留言说看完了我往年的年度总结，想看我的2020年的。可如今写出来了，怕是要对不住他们如此期待了。\n2016年学习了一门年度计划的课程，提到人生的8个方面，分别是身体健康、财务理财、人际社群、工作事业、家庭生活、学习成长、体验突破、休闲放松。觉得这8方面还是挺\n合理的，于是从2016年度总结开始，都是按这8个方面来写年度总结。另外作为读者朋友的你也可以搜索微信小程序：滴答目标九宫格，看到的就是这八方面。\n\n\n\n，也可以看邹小强老师的这篇文章《小工具：随时都可以看到漂亮的目标板》。\n\n\n身体 · 健康#\n\n这一年，基本是走路上下班，姑且算是一种锻炼吧。这一年，视力又下降了。在2018年度总结中写过的一句话引用过来同样适用。正印证了那句话：真的要少玩手机电脑了，眼睛\n越来越不好了，打开支付宝都看不到钱了。这一年，没有难以入睡的记录。而2019年记录有12次辗转反侧，难以入睡。身体健康重要性大家都知道，但往往是大部分作为年轻人\n的我们存在不良作息习惯和饮食习惯等，长此以往可能会导致身体一些问题。而身体健康、财务理财、人际社群可以看成是人生基石三要素。\n\n\n财务 · 理财#\n\n年度总结里一直说理财，实际上很少理财。看到朋友圈同龄人炒股副业一年都赚了30w+，实名羡慕啊。不过仔细一想，别人肯定也是积累了很久和付出了很大的努力。看似云淡风\n轻，但事实上背后的过程我们没有看到。看到别人年度总结中的一句话：投资不追求暴利，年化10%~20%即可，相信复利的力量，关键在于坚持，10年内投资只是副业，10\n年后希望可以靠投资实现财务自由。\n\n\n人际 · 社群#\n\n这一年，线下见过面的人屈指可数，总共见过两个大学校友，两个前端小伙伴（我微信群里的）。工作后除了公司同事，其他朋友线下见面，基本都是以一年为单位，一年到头线下见\n面的人真的很少。真正比较长期聊过天的人数也是很少。正所谓：越长大，越孤独。\n\n\n工作 · 事业#\n\n我的年度总结很少写公司工作方面。本职工作就是某不知名小公司的一名小前端开发工程师，负责小程序和网站开发等。这一年，在工作方面，由于公司变动，我担任了前端开发的面\n试官，负责给公司招人。记得2017年第一次面试别人时，自己都是很紧张的。当初刚毕业时求职面试，如今身份转换，时间真快。wakatime2020年使用Vscode\n编码时间统计，总共1572小时，和2019年相比基本持平。平均每天5个多小时在使用编辑器VSCode，其中2月13日最多，竟然11小时16分钟，记得这一天在家远\n程办公工作内容很多。花在自己博客的时间为45小时，相比2019年107小时有所下降。这里统计的是实际上聚焦使用VSCode的时间，应该还算是多的。在此放下统计地\n址https://wakatime.com/a-look-back-at-2020，方便不知道地址的读者朋友访问使用wakatime。\n\n\n\n按照以往的惯例，顺带贴下公司代码提交记录和个人github代码提交记录。\n\n\n\n\n\n\n技术自媒体，慢慢打造个人品牌#\n\n微信：再小的个体，也有自己的品牌。我从2016年度总结起，就一直写了「慢慢打造个人品牌」，真正有所收益时是2020年。\n\n公众号 8w+ 阅读#\n\n这一年，比较佛系的运营了公众号「若川视野」，有了工作之外的一些收益。清博大数据和新榜年度报告中都显示公众号全年累计8w+阅读，相比2019年增加2183.73%\n，虽然可能不是那么准确，但应该也相差不大。\n\n\n\n年初1月11日时，接了公众号第一次广告300元，但后续基本没有持续更新，比较佛系，接的广告也比较少。运营公众号其实是非常耗时耗力的。即使是转载文章，每天基本都要\n花上一小时左右选文章发文章。如果是自己写原创文章，基本每篇文章都需要10小时左右，甚至更多。作为一名互联网打工人，时间可是稀缺资源啊。\n\n真正醒悟打算不那么佛系，工作日都更新时，已经是11月份了。为什么醒悟了，当时考虑有两点：1、公众号对于内容创作者非常有利，同时变现能力非常强，2、相信复利的力量\n探寻更多可能。在微信公众号平台上，声明过原创的文章，别人在公众号发布必须取得授权才能转载发布，而其他平台随意转载抄袭现象很常见。也许在N年后，运营公众号的副业收\n入能超过主业。虽然我的公众号粉丝数还很少，但也能接上一些广告，有了一些收益，也可以给我的读者朋友们谋些福利。比如逢年过节发些红包或者送些书籍，不知不觉在2020\n年，两个微信号竟然分别发出了3306.30元、2469.30元，虽然分摊后读者朋友可能没收到多少，但我发现发了这么多红包时是惊讶的，因为相比2019年我发出的红\n包是1007.14元，而且我2020年的广告收入也很少，远不及一些大佬。在此特别感谢支持我的读者朋友们，感谢合作投放过广告的广告主（主要是开课吧、拉勾教育、珠峰\n教育）。\n\n说起运营公众号可以追溯到2013年，「若川视野」前身是我开通的社团的公众号，那时微信刚推出「微信公众号」一年左右。那时微信都很少使用，运营公众号，虽然关注人数少\n，但公众号也少，阅读量相对高。后来就业指导课上，老师要求我们每人写份简历，我写了一份「新媒体运营」的简历，竟然被老师表扬了，被老师流传至今，发给学弟学妹们参考，\n学弟学妹们不认识我，可能以为我在做「新媒体运营」相关工作。谁能想到多年以后的我，依旧会走上了新媒体（公众号）运营这条路。\n\n有时会想是不是我早点运营起公众号，成果会比现在好呢，也许会的。但反思一下，公众号运营是要长期持续给粉丝提供价值，才能够持续长久正向循环。而长期持续提供价值，是需\n要作者本身有价值可以提供，需要多输入提升自己才能有价值的多输出。我同时也清楚地意识到：过早频繁的接广告无异于杀鸡取卵涸泽而渔，我需要的是多创作出优质的内容，好好\n运营，先做增量，稳住粉丝增长和阅读量增长。粉丝对公众号作者的内容和作者认可后，不会因为公众号接些广告而取消关注，毕竟粉丝因公众号内容受益，也知道做公众号不容易，\n也就是人们常说的利他共赢。目前阶段接多了广告，感觉有点愧对读者朋友的关注。\n\n这一年，清明节假期，开通了第二个微信号，截止到目前有一千多微信好友。两个微信号累计3500+好友。也有6个微信交流群，共计一千多小伙伴，相比其他公众号号主来说算\n很少了。相比2019年，一个微信交流群来说有所进步。现如今是微信8.0了，支持一万个微信好友可看朋友圈，也不知道猴年马月会加满一万个微信好友，不过期待这一天早日\n到来。\n\n运营公众号以来，也连接到了一些非常优秀的公众号号主和许多非常优秀的人。偶尔有人加我微信或者在他们的文章中提到，说我的《学习源码整体架构系列》对TA帮助很大，写作\n最开心的莫过于有很多人肯定和支持。甚至有的人说找到了20K的前端开发工作，为了表示感谢，一定要寄来一箱家里种的猕猴桃。而我自己觉得并没有帮到他们什么忙，不过还是\n很欣慰能得到大家的肯定和支持。后来想想这样不对啊，以后都寄来东西给我，而我不能提供相应的帮助，那就不好了。一直以来私聊我答疑解惑时，读者朋友发给我的红包都不收，\n另外也不收读者朋友寄给我的东西。\n\n知乎 63w+ 阅读#\n\n这一年，知乎「若川」粉丝比去年多了2000+，现在是8377，阅读量比2019年增长了63w+，2019年时还是4w+阅读。主要有几篇回答被知乎推荐了。最高的一\n篇突破了31w+阅读量，如下图所示。虽然我觉得回答的也不是很好。也许是2019年写了《学习源码整体架构系列》的厚积薄发的表现。\n\n\n\n其中高赞的两篇回答，也同步发表在公众号，不过知乎上是最新版本。若川知乎问答：2年前端经验，做的项目没什么技术含量，怎么办？若川知乎高赞：有哪些必看的 JS\n库？顺便再放下我的《学习源码整体架构系列》链接，koa源码和redux源码是2020年写的。2019年下半年写了6篇，2020年只写了2篇，2021年会不会继续\n写下去是个谜。1.学习 jQuery 源码整体架构，打造属于自己的 js 类库2.学习 underscore 源码整体架构，打造属于自己的函数式编程类库3.学习\nlodash 源码整体架构，打造属于自己的函数式编程类库4.学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK5.学习 vuex\n源码整体架构，打造属于自己的状态管理库6.学习 axios 源码整体架构，打造属于自己的请求库7.学习 koa\n源码的整体架构，浅析koa洋葱模型原理和co原理8.学习 redux 源码整体架构，深入理解 redux 及其中间件原理\n\n其他#\n\n这一年，2017年时就开通了免费的知识星球「前端视野 ·\n若川」的人数也陆陆续续有增长，但更新少了，主要时间和精力放在了公众号更新上。这一年，在语雀平台发布的koa源码文章，被选为「语雀精选」，比较难得。\n\n\n\n这一年，在掘金平台上只发了3篇文章，相比2019年多了1000+关注，阅读量却多了近10w+，现在累计14w+。\n\n\n家庭 · 生活#\n\n这一年，在家待的时间是近年来最长。由于疫情，从1月20日放假到3月14日返杭，将近两个月的时间在家，远程办公。春节假期很长一段时间都是我妈做饭，我们不用操心。后\n来我妈上班去了，就是我们自己做饭了。这一年，国庆和中秋一起，放假在家八天，国庆归来工作时，总感觉像是做了一场梦，梦回到家里，在家里的时光总是那么短暂。这一年，给\n我弟买了一台新的笔记本电脑。这一年，清晰的记得父亲节那天，和老爸聊天。老爸提起身在体制内堂哥的种种好处，让我羡慕不已。这一年，「相亲相爱一家人」微信群用得相对多\n了起来。\n\n\n学习 · 成长#\n\n这一年，没有参加一场线下技术分享大会，而2019年参加了5场线下技术分享类大会。这一年，输入输出少了，只写了3篇文章。这一年，微信读书记录只看完了4本书。微信读\n书非常不错，很多书都有，如果喜欢读书的你还没用过微信读书，可以尝试使用。\n\n\n体验 · 突破#\n\n这一年，也没有什么特别的体验突破。\n\n\n休闲 · 放松#\n\n这一年，很长时间都陷入迷茫焦虑中，有个词语叫低欲望人群，说的可能就是我这种。周末经常看电视剧或电影打发时光，麻痹自己...最长的一天（8月16日周日）看了长达7\n小时。看过《庆余年》、抗疫剧《在一起》、《我在未来等你》、《花木兰》等。\n这一年，没有去旅行。刚毕业时2016-2017年，那时周末有空都会在杭州一些景点或大学逛逛。如今几乎不逛了。\n\n\n总结#\n\n站在一年的时间节点上来看全年所度过的光阴。不免又想起孔子在川上的感慨：逝者如斯夫，不舍昼夜。一年很短，列年度计划时满怀信心，写年度总结时却早已忘却当初的计划可能\n是多数人的状态。以前写过一篇《如何制定有价值的目标》，但真正目标管理很好的人是少数。以往年度总结中写过的一句话「人们往往容易高估自己一年能完成的事，低估自己五年\n内能完成的事」同样适用。\n\n写年度总结的作用在于每年都自我审视和复盘，多年以后能回顾那一年做成了什么、没做到什么，也许未来的自己会感谢当初努力的自己。通过一定的努力积累，平静的湖面，也许会\n激起水花。\n\n我的2020年，总结起来真的是很普通。只写了3篇文章，佛系运营了公众号「若川视野」，知乎平台积累了63w+阅读量，多年累计起来，全网也算是超过百万阅读。于是把公\n众号简介改为如下：\n\n> 我是若川，《学习源码整体架构系列》作者，知乎、掘金等平台的文章累计超过百万阅读。致力于前端开发经验分享。愿景：帮助5年内前端人开阔视野不断成长，走在互联网行\n> 业前列。\n\n从2018年起，年度总结文章里基本不列举年度计划...这篇文章发给我的群里小伙伴试读时，有人说写写2021年度计划呀。那就简单写下2点：第一点是：自媒体好好运营\n，特别是公众号「若川视野」，创作出更多优质的内容，适当招聘小助理分担部分工作，尝试更多可能。第二点则是：「好好工作，多赚点钱」。\n不知不觉写了5000+字，感谢作为读者朋友的你看到这里。最后农历新年即将到来，预祝各位读者朋友过一个快乐中国年。在新的一年，遇见更好的自己。\n\n> 若川 2021年2月4日","routePath":"/annual-summary/2020/","lang":"zh","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":3},{"text":"身体 · 健康","id":"身体--健康","depth":2,"charIndex":1273},{"text":"财务 · 理财","id":"财务--理财","depth":2,"charIndex":1510},{"text":"人际 · 社群","id":"人际--社群","depth":2,"charIndex":1701},{"text":"工作 · 事业","id":"工作--事业","depth":2,"charIndex":1832},{"text":"技术自媒体，慢慢打造个人品牌","id":"技术自媒体慢慢打造个人品牌","depth":3,"charIndex":2280},{"text":"公众号 8w+ 阅读","id":"公众号-8w-阅读","depth":4,"charIndex":2358},{"text":"知乎 63w+ 阅读","id":"知乎-63w-阅读","depth":4,"charIndex":3972},{"text":"其他","id":"其他","depth":4,"charIndex":4564},{"text":"家庭 · 生活","id":"家庭--生活","depth":2,"charIndex":4734},{"text":"学习 · 成长","id":"学习--成长","depth":2,"charIndex":4994},{"text":"体验 · 突破","id":"体验--突破","depth":2,"charIndex":5124},{"text":"休闲 · 放松","id":"休闲--放松","depth":2,"charIndex":5154},{"text":"总结","id":"总结","depth":2,"charIndex":5339}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"若川的 2021 年度总结，弹指之间","content":"#\n\n\n前言#\n\n从2014年开始，每一年都会写年度总结，已经坚持了7个年头。7年的光阴就是弹指之间，转瞬即逝。正如孔子所说：逝者如斯夫，不舍昼夜。\n回顾2014，约定2015（QQ空间日志）2015年总结，淡化旧标签，无惧未来（QQ空间日志）2016年度总结，毕业工作2017年度总结，一如既往2018年度总\n结，平淡无奇2019年度总结，波澜不惊2020年度总结，水波不兴\n\n如今第8年了，2021年的年度总结比往年晚很多。 本打算1月份，在回家前写完，无奈，工作比较忙，周末和工作日完全都提不起兴趣继续撰写。\n此刻，正在回家的高铁上，看着窗外的风景，继续完成2021年的年度总结。 此刻，正在江西老家继续把写完。回到家手机都很少拿起，电脑更是很少打开。\n此刻，正在返回的高铁上，看着窗外的风景，继续完成2021年的年度总结。 写了好多此刻，都被我删了又保留了。\n此刻还是回到工作地的电脑旁，继续完善2021年的年度总结。这也从侧面说明了写作难、写年度总结更难。\n\n就像我的2020年年度总结，在语雀平台显示竟然改了200多遍。2月4日才写完发布。\n\n朋友圈都有好友催年度总结了：你2021年是不是没写总结。元宵都过完了，现在才发布十分惭愧。\n因为根据以往经验每篇文章后续都可能会需要修改。所以写完了也要多留几天时间复核下，晚些时候再发。\n\n回想起过去的这一年，又是普通的一年。我只是作为一个创作者，用文字记录下这一年，方便以后回顾总结。\n\n以下几句话基本可以概括。\n\n这一年，去了沈阳和西安两个城市出差，分别出差约2个多月和10多天，坐了很多次飞机，体验过10多个小时的高铁。\n\n这一年，公众号持续运营了300+天，几乎每天不间断，涨粉1w+，微信好友增长 5000+\n。副业收入比2020年有比较大的进步，年收入大概就是5位数，但具体多少我也没有算过，副业离目标月入过万，还有很长的路要走。\n\n这一年，写了21篇文章，8月起，持续组织了5个月的源码共读，吸引了超4000人进群参与，帮助了很多人学会看源码，利他共赢。\n\n这一年，获得了掘金年度人气创作者第4名，获得了 InfoQ 签约作者，有幸入选了freeCodeCamp 全球社区 2021 贡献者」。\n\n这一年，我的文章在知乎阅读是 110w+，去年是 63w+，掘金阅读超过了 52w+，去年是 14w+。\n\n希望之后多写一些技术文。多拓宽一些视野，多拥抱技术社区。多帮助一些人学会看源码、不惧怕源码。\n\n这一年的关键词就是技术自媒体了，这一年几种状态。\n\n * 写文章，很多文章是周末和工作日写完的。\n * 忙于公众号、社群、答疑解惑等。\n * 刷视频，不想思考动脑时就会刷刷B站和视频号。\n * 看剧，找好看的电视剧看看。\n * 偶尔出去逛逛看看风景。\n\n\n身体 · 健康#\n\n身体健康，以往的年度总结说了很多，这次就少写些。\n\n睡眠不规律，很多时候都睡得很晚。好多时候都是1点左右才入睡的。偶尔有早起的时候就感觉一天很长。希望 2022年 有所改进。\n\n互联网关于身心健康的相关事件很多。而且都是很年轻的。我们应该多关注自己的身心健康，定期体检。身体有发出信号时就及时就医，不能不重视，以为能自愈。\n\n\n财务 · 理财#\n\n这一年基金我都很少买。不可否认理财是很重要的。\n\n\n人际 · 社群#\n\n这一年，工作之外算见过认识的人好像就没有。圈子真的挺窄的。虽然微信好友几千。\n\n不过运营自己的技术#公众号：若川视野，有机会认识很多技术圈的公众号号主。连接更多优秀的人。\n\n\n工作 · 事业#\n\n虽然是工作事业标题，但年度总结我都是很少写公司工作相关的。职业是前端开发工程师，工作内容是：大家常用的微信小程序、网站、健康码等都是我们这类人开发的。\n\n按照以往的惯例，放一下写代码的统计时间、公司代码提交记录和个人 github 代码提交记录。\n\nwakatime 2021年使用 Vscode\n编码时间统计，总共1308小时，和2020年相比1572小时相比少了一些，但有很多应该是没有统计到。平均每天4个多小时在使用编辑器VSCode，其中6月15日最\n多，竟然10小时23分钟。这里统计的是实际上聚焦使用 VSCode\n的时间，应该还算是多的。在此放下统计地址https://wakatime.com/a-look-back-at-2021，方便不知道地址的读者朋友访问使用wak\natime。\n\n\n\n\n\n\n\n\n出差两次，一次996两个月，一次十多天#\n\n2021年出差两次比较忙，基本是996的状态。有时凌晨还在酒店工作。\n\n4月份到6月份，在沈阳出差。这是我第二次踏上东北这片土地，上一次还是2015年去吉林大学参加互联网+创新创业大赛的时候。\n\n\n\n在吃方面，东北真是好，都是很大碗，分量很足，又很便宜。吃过蝉蛹、烤冷面，鸡架等特色。那段时光吃的挺好。同事一起吃，基本人均60+。\n\n7月底8月初，在西安出差，由于疫情关系大部分时间都是在酒店度过，就去了一次大雁塔。\n\n除去出差之后就相对不那么忙。这也为我业余时间写文章搞源码共读活动提供了时间保障。\n\n再回顾2020年，工作是相对比2021年更忙，而且整体来说，有一些消极。所以对我而言，并不喜欢一直很忙的工作。\n\n这一年，有一个词语叫\"新生代农民工\"，在互联网圈很火。简单来说，程序员群体基本都是高学历高智商的群体。但相对社会地位确实不是很高。一方面可能是相对来说老师医生等\n，这个职业历史不长，另外一方面是大家都不知道程序员是做什么的。事实上没有程序员群体就没有高速发展的互联网（反过来说好像也一样）。比如微信、支付宝、淘宝等大家常用\n的手机APP都是程序员群体开发的。\n\n我想很多人不想被工作占用太多的时间。好在2021年大环境很多公司陆续取消996。\n\n一个人的时间精力非常有限。被工作占据了很多时间，就容易对其他事提不起精神。\n\n\n赚钱的本质、认知、视野#\n\n解决了问题，提供了的价值。\n\n程序员赚钱的方式有很多种。在公司工作是最普遍的一种，也是最主要的一种。\n\n另外还有包括写书、知识付费（出课程等）、兼职做外包、自媒体接广告等。\n\n写作或者出课程等则是可以一次产出的价值多次售卖。\n\n2016年年度总结引用的一段话，放到现在也是同样适用。\n\n> 总结一下，对年轻人来说可操作性最强又能挣很多钱的方法，其实就三个步骤： 第一：找到自己的一个特长，把它培养得足够出色。\n> 第二：找到适合你的特长，又有足够用户注意的平台。 第三：在这个平台上深耕细作，打造品牌，获得收入。\n> 每个人都有自己的特长，只要长时间持续打磨，总有一天能到“可以卖钱”的水平。\n\n假设能有5000人购买你出的课程或者服务，单价是200元，不算平台扣税等那么就是100万。比在一般公司就职赚到的钱都多。\n\n我做公众号自媒体到变现就是这一个体现。但这一方法事实上很难。能赚到很多钱的还是少数。而且我是前面一两年基本是没有变现的。\n\n\n技术自媒体，慢慢打造个人品牌#\n\n公众号#\n\n做公众号自媒体其实也算是小型的创业，是一件很难的事情。可能大多数关注的人不知道，我的公众号取名为若川视野的原因。「若川」是我的网名，取自「上善若水，海纳百川」其\n中的两个字。没开通公众号前，知乎专栏和思否等专栏都是叫若川的前端视野。「视野」是我比较喜欢的一个词语。所以为了简短好记就取名「若川视野」了。视野谐音有很多，比如\n事业、实业等。也可以理解为我（若川）把运营公众号当做是自己的一份事业来对待。海纳百川，视野开阔。这样也许就好记了。\n\n这一年，公众号持续运营了300+天。几乎每天不间断，即使转载基本每天可能要花一小时左右选文发文，另外如果是写一篇原创文章一般都要耗费了10小时左右，甚至更多。有\n些广告收入赚得真的是辛苦钱，而且很多人不理解，甚至恶意举报。副业收入比2020年有比较大的进步，年收入大概就是5位数，但具体多少我也没有算过。总之目前投入的时间\n精力和广告收益回报不成正比。副业离目标月入过万，还有很长的路要走。记得有人说过：副业收入是主业收入的两倍甚至更多，才可以考虑把副业当主业。感觉说的很有道理。\n\n这一年公众号涨了一万粉左右，但远远不够。再涨一万粉很难，不一定能够实现。另外，广告投放基本减少了。都没什么广告可接了。而且公众号和朋友圈的广告，对于读者朋友的伤\n害值可能比较大，相比这点广告收入，投入的时间精力，可能不是那么划算。另外，广告投放多了会产生一定的\"耐药性\"，也就是说很难投放出效果，难投放出效果后投放单价几乎\n无法上涨。那为啥还在做，那是因为希望以后能更好，也是希望能为技术社区贡献一份自己的微薄之力，能帮到一些人成长。更多公众号相关在 《公众号运营策略》\n这篇文章中写了，感兴趣的小伙伴可以看。\n\n这一年，截止到目前两个微信号累计 8700+ 好友，相比去年多了 5000+\n微信好友。有12个微信交流群，18个源码共读大群，共计4000多小伙伴，相比其他公众号号主来说算很少了。相比2020年，两个微信号累计 3500+\n好友。也有6个微信交流群，共计 1000+ 小伙伴，有一些进步。现如今是微信8.0了，支持一万个微信好友可看朋友圈了。\n\n创作者、广告的投放方、读者三者之间，适当的商业化有助于创作者创作出更优质的内容，广告投放方也能吸引用户群体，另外读者也会有一定的成长。大多数号主都是良心博主，只\n是有时候投放广告的标题确实不是那么合适，很多时候也不是公众号号主能决定的。希望读者朋友也不要有那么多恶意。另外我也会给我的读者朋友们谋些福利，比如逢年过节发些红\n包或者送些书籍，不知不觉在2021年，两个微信号竟然分别发出的是29753.51元，13616.27元，有些应该是相互转账，还有一些是课程返现，另外还有是轻松筹\n、水滴筹等。虽然分摊后读者朋友可能没收到多少，但我发现发了这么多红包时是很惊讶的，因为相比2020年我发出的红包是3306.30元、2469.30元，而且我20\n21年广告收入好像也没赚到多少钱啊，远不及一些大佬。在此特别感谢支持我的读者朋友们，感谢合作投放过广告的广告主（主要是开课吧、极客时间、网易云课堂、珠峰教育等）\n。\n\n公众号技术圈内好些都离职做起了自由职业，很多收入到超过了本职工作，甚至是好几倍。也许在未来的某一天，我也可以达到这样的情况，也许永远无法达到。如果以我目前这种涨\n粉速度，几乎不可能做到自由职业。当然自由职业其实也没想象中那么自由。竞争其实很激烈。印象中 B站up主\n每年都会有百大up主活动，但能够一直维持百大up主的是很少数，这也说明了竞争激烈。比如：大多数人熟悉的何同学就是连续两年B站百大up之一。\n\n组织了5个月的源码共读#\n\n算到现在2月底，其实是7个月。源码共读活动每周一期，每周一起阅读200行左右的源码，目前进行到了24期。\n\n7月底，那时我还在西安出差，在酒店想着我读了那么多源码我历时3年才写了10余篇源码文章，但收获了100w+阅读\n，写了那么多文章，可惜看的人却是少数。是不是可以以某种形式帮助到大家学会看源码。看我的文章，我来答疑解惑。\n\n自己写微信机器人，同意加好友申请，拉群，节省了很多时间。后来被人连续举报两次，导致封禁不能邀请人加群。一周后解封了，但微信机器人就没敢用了，现在都是手动拉人进群\n。\n\n于是：为了能帮助到更多对源码感兴趣、想学会看源码、提升自己前端技术能力的同学。我组织了每周一期，一起学习200行左右的源码，从第1期开始不断迭代到目前第24期。\n源码共读活动也是在不断摸索中前进。竟然坚持到了现在7个月。\n\n确实真实有效的帮助到了很多人学会学习源码，不惧怕源码。截至目前：\n\n * 有超4000人报名进源码共读群了。\n * 在语雀讨论区 https://www.yuque.com/ruochuan12/topics，有400+笔记了。\n * 有个大三的小姐姐写了10期笔记。要知道超过5次及以上笔记的只有30人左右。\n * 也有在国外（比如：欧洲、澳大利亚）的小伙伴参与了源码共读。\n * 有人读完学以致用，做出了对公司有用的工具，公司奖励了他1000元。\n * 还有人持续学习，每天一期，学完了20多期。\n * 甚至有读者朋友跟面试官提到我的名字，面试官都知道读者朋友参加了源码共读。\n * 等等。\n\n总之后生可畏。正是由于大家的积极参与，看到大家学有所获，我也很开心能够帮到大家。我也有时能做到每周输出一篇新文章。可以说是读者和创作者相互成就。\n\n如果你也想参加，可以点此链接了解源码共读，扫码加我微信 ruochuan12，进微信群免费参与。\n\n掘金最受欢迎年度创作者#\n\n上了8月、10月、11月、12月掘金技术社区创作者榜单，每次上榜都能获得一些礼物和奖品。\n\n\n\n还有一次「掘力星计划」。奖励了800等价值的物品，自己挑选了蓝牙耳机。\n\n年底参加了掘金2021年度人气创作者榜单投票活动，活动持续7天，我在公众号、朋友圈、微信群里等拉票，很多人为我投票拉票，无比感谢，无比感动，最终获得了第4名的成\n绩，我也有抽价值2000+元奖回馈帮我投票的小伙伴。第4名的奖品是坚果J10投影仪，寄回家里了。春节期间，亲戚长辈们都说起现在科技发达，发展迅速，相当于都把电影\n院搬回家了，回忆起他们当年去看电影有趣的往事。\n\n\n\n学习源码整体架构系列\n\n这个源码专栏目前好像是掘金关注人数最多的专栏。\n\n每篇文章都花了很多时间撰写。有时候工作相对不忙，但写作任务相对比较多。也常有打算今天写完，事实上到明天、后天、大后天等才写完的情况。有时为了争取早一些写完发布，\n时常有熬夜到1、2点才写完的情况。\n\n比如有一次，还在沈阳出差。我和同事住酒店，同事早早的睡着了，我还在写文章（当然同事不知道我是写文章），写完到挺晚。感觉睡梦中都还想着文章的事情。想着第二天文章阅\n读量会不会比往常高一些。\n\n很多时候觉得时间不够用，另外也有的时候觉得浪费了很多时间。有时同事问我，你不玩游戏，无聊的时候是怎么打发时间的。我一时间不知道怎么回答。\n\n这里列举下2021年写的21篇文章。\n\n 1.  据说 99% 的人不知道 vue-devtools 还能直接打开对应组件文件？本文原理揭秘\n 2.  一文读懂vuex4源码，原来provide/inject就是妙用了原型链？\n 3.  面对 this 指向丢失，尤雨溪在 Vuex 源码中是怎么处理的\n 4.  尤雨溪开发的 vue-devtools 如何安装，为何打开文件的功能鲜有人知？\n 5.  初学者也能看懂的 Vue3 源码中那些实用的基础工具函数\n 6.  Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？\n 7.  50行代码串行Promise，koa洋葱模型原来是这么实现？\n 8.  为什么 Vue2 this 能够直接获取到 data 和 methods ? 源码揭秘！\n 9.  Vue 团队公开快如闪电的全新脚手架工具 create-vue，未来将替代 Vue-CLI，才300余行代码，学它！\n 10. 尤雨溪几年前开发的“玩具 vite”，才100多行代码，却十分有助于理解 vite 原理\n 11. 尤雨溪推荐神器 ni ，能替代 npm/yarn/pnpm ？简单好用！源码揭秘！\n 12. 初学者也能看懂的 Vue2 源码中那些实用的基础工具函数\n 13. 每次启动项目的服务时，电脑竟然乖乖的帮我打开了浏览器，100行源码揭秘！\n 14. 面试官：请实现一个通用函数把 callback 转成 promise\n 15. 新手向：前端程序员必学基本技能——调试JS代码\n 16. 每次新增页面复制粘贴？100多行源码的 element-ui 新增组件功能告诉你减少重复工作\n 17. 从 vue3 和 vite 源码中，我学到了一行代码统一规范团队包管理器的神器\n 18. 从 vue-cli 源码中，我发现了27行读取 json 文件有趣的 npm 包\n 19. Vue团队核心成员开发的39行小工具 install-pkg 安装包，值得一学！\n 20. 面试官：请手写一个带取消功能的延迟函数，axios 取消功能的原理是什么\n 21. 面试官：项目中常用的 .env 文件原理是什么？如何实现？\n\n拥抱社区#\n\n获得了 InfoQ\n签约作者，福利是大礼包还有大会免费参与的机会，没有你们想象中的一定稿费。其实并没有多么厉害。参加活动的条件把五篇文章整理成合集，报名了参赛，大多数报名参赛的都入\n选了。\n\n\n\n另外，由于好久之前在fCC杭州社区组织者的一些贡献，和一些文章输出。有幸入选了「freeCodeCamp 全球社区 2021 贡献者」。freeCodeCamp\n是一个免费学习编程的网站 https://www.freecodecamp.org/chinese/。\n\n这一年，我的文章在知乎阅读是 110w+，去年是 63w+，掘金阅读超过了 52w+，去年是 14w+。\n\n\n35岁焦虑#\n\n目前来说，互联网35岁焦虑还是确实存在的。\n\n * 初中级工程师很难一直工作到退休。\n * 成为行业专家，就不容易被年轻人取代。\n * 早做准备早规划，有句话叫做：早就是优势。\n\n有时候觉得，工作了好多年，真的就是把几年的工作重复了几年。\n有时候问问自己：自己的核心竞争力是什么？真的有那么热爱这份工作吗？而且这份工作是自己赖以生存（吃饭）的技能。吃饭的技能好像都没有那么努力和重视。为啥就还是那么菜\n呢。或者说成长感觉不是很大。\n\n有时候很忙就会想，是不是用战术上的勤奋掩盖战略上的懒惰。\n\n\n家庭 · 生活#\n\n很多读者看到家庭 ·\n生活这一部分以为我已经结婚了，事实上并没有。时间很快，转眼毕业好几年了，年龄也确实算大了，时常觉得自己一无所有、一事无成。也经常被家里人催婚。同龄的亲戚也基本都\n成家立业有房有车了。\n\n很多高中、大学同学也陆续结婚生娃。有时候都会觉得自己选择开发这条路是不是对的~一次和关系比较好的高中同学视频时我们都说自己是高中班上混的最差的。\n\n虽然回家说高铁3小时左右。但去高铁站的时间 + 高铁 +\n汽车，就很远了。大多数时候都是凌晨出发，晚上才到家。这时想起李白的一句诗：早辞白帝彩云间，千里江陵一日还。\n\n一年回家的次数屈指可数。不是好几天长假都懒得奔波，毕竟旅途劳累。\n\n一般就是国庆和春节假期回家。\n\n\n学习 · 成长#\n\n除了自己写文章，学习的很少。往往是买了，收藏了，或者简单看了就算看了。\n\n事实上高效学习方法，其实是以教为学。\n\n好在自己写文章就是一种比较高效的学习方法。\n\n如下图所示。\n\n\n\n很多人都有读书的习惯，而我一年下来好像没有完整看完过一本书。由于运营技术公众号，也经常有出版社和我合作宣传赠书。大多数时候也会送一本书给我，可是很多书我都没有拆\n封。更别说看完了。还是希望之后多看些书。\n\n\n\n\n体验 · 突破#\n\n这一年好像没有算体验突破的。如果要说有就是6月26日在同事家，吃了20斤小龙虾，实现了小龙虾自由。这时放两张图。\n\n\n\n\n\n\n休闲 · 放松#\n\n电视剧看了《赘婿》、《觉醒年代》、《扫黑风暴》、《琅琊榜之风起长林》等。\n\n爬了两次山。3月13日，爬了一次山，首次突破了2万步。第二次（4月2日）爬山再次突破两万步。后面好像就没突破过。\n\n\n\n公司团建，9月27日看了一次海。\n\n\n\n出差去了沈阳和西安。\n\n4月11日去了沈阳故宫。放几张图。\n\n\n\n\n\n\n\n7月24日去了西安大雁塔\n\n\n\n\n\n\n\n\n\n\n总结#\n\n弹指之间，不知不觉已经写了8年的年度总结。这8年是怎么度过的，回顾自己的年度总结就大概知道了。年度总结，大多是写时的所思所想和回忆本年度的事件，为自己一年的所得\n所失做一次简单的回顾。\n\n以往的年度总结都是看微博来整理时间线。而2021年几乎很少发布微博或者朋友圈，很多朋友圈都是搞自媒体后的一些送书或者获奖等，并不是很高的成就。2022年还是打算\n多记录，多发微博（因为微博没啥人看）。\n\n另外就不立目标了。毕竟年年岁岁小目标相似，岁岁年年没实现相同。\n\n从运营公众号来看，也证明了自己能持续坚持一件事，虽然很难，但坚持做正确且难的事情。\n\n从写文章来看，不忙的情况下，也是能够一周一篇相对高质量的文章。21年输出了21篇技术文章，好像是我写作这么多年写的最多的一年。另外也凭借着这些文章，拿到了一些成\n果。\n\n从组织源码共读了7个月来看，帮助到别人的心情是很开心，利他共赢。\n\n从工作忙碌状态来看，自己不喜欢一直很忙的工作。一个人的时间精力非常有限。被工作占据了很多时间，就容易对其他事提不起精神。\n\n等等。\n\n不知不觉写了7000+字，感谢作为读者朋友的你看到这里。\n\n希望下次2022年的年度总结能够早点写完。\n\n虽然农历新年已经过了元宵节，而且已经是正月廿七了，正月马上过完了，2022年都过去6分之一了。\n\n但依旧祝各位读者朋友：在新的一年，遇见更好的自己。工作顺利，平安喜乐。\n\n> 若川 2022年2月27日","routePath":"/annual-summary/2021/","lang":"zh","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":3},{"text":"身体 · 健康","id":"身体--健康","depth":2,"charIndex":1163},{"text":"财务 · 理财","id":"财务--理财","depth":2,"charIndex":1337},{"text":"人际 · 社群","id":"人际--社群","depth":2,"charIndex":1373},{"text":"工作 · 事业","id":"工作--事业","depth":2,"charIndex":1471},{"text":"出差两次，一次996两个月，一次十多天","id":"出差两次一次996两个月一次十多天","depth":3,"charIndex":1841},{"text":"赚钱的本质、认知、视野","id":"赚钱的本质认知视野","depth":3,"charIndex":2435},{"text":"技术自媒体，慢慢打造个人品牌","id":"技术自媒体慢慢打造个人品牌","depth":3,"charIndex":2872},{"text":"公众号","id":"公众号","depth":4,"charIndex":2889},{"text":"组织了5个月的源码共读","id":"组织了5个月的源码共读","depth":4,"charIndex":4401},{"text":"掘金最受欢迎年度创作者","id":"掘金最受欢迎年度创作者","depth":4,"charIndex":5199},{"text":"拥抱社区","id":"拥抱社区","depth":4,"charIndex":6716},{"text":"35岁焦虑","id":"35岁焦虑","depth":3,"charIndex":7010},{"text":"家庭 · 生活","id":"家庭--生活","depth":2,"charIndex":7266},{"text":"学习 · 成长","id":"学习--成长","depth":2,"charIndex":7589},{"text":"体验 · 突破","id":"体验--突破","depth":2,"charIndex":7795},{"text":"休闲 · 放松","id":"休闲--放松","depth":2,"charIndex":7868},{"text":"总结","id":"总结","depth":2,"charIndex":8056}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"若川的 2022 年度总结，回顾这十年","content":"#\n\n\n前言#\n\n从2014年开始，每一年都会写年度总结，已经坚持了8个年头。7年的光阴就是弹指之间，转瞬即逝。正如孔子所说：逝者如斯夫，不舍昼夜。\n\n2012年，\n\n2月，近期，去工商银行办理了换卡不换号。工商银行卡的有效期是十年。转眼十年过去了。\n\n这张银行卡2013年8月份办的。那是我大一暑假。花了4199元买了一台笔记本电脑。\n\n转眼间\n\n驾驶证，6年期，也换证了。 身份证十年过期，也快过期了。 种种迹象在提醒我，十年过去了。\n\n这几年\n\n这个公众号，留言功能\n\n我就是一个普通的前端开发程序员，不能像有些人一样说：最开心的时候是每个月拿着3000，现在手持几百万压力大一点也不开心。\n\n这5篇。\n\n\n回顾这十年#\n\n特意提前去市里取票，老练。 取票\n\n\n十年#\n\n高考 2012年，信息管理与信息系统 社团 免费修电脑 免费源码共读、点评 两个QQ 两个微信 秋叶PPT\n\n高考七年后、工作三年后的感悟\n\n\n高考#\n\n2012年坐在自己家乡的小县城考场里，写着语文试卷。前面花的时间比较多，留下写作文的时间不太多，有些紧张。后来考数学时，也时不时有想着语文可能没考好。现在想想那\n时有着40多分钟就能写出不少于800字的作文，放在现在这能力有所退化。\n\n高考出分后，语文111分。前面选择题36分都对了。后面的题目和作文没有高分。还记得高中有一次（也是仅此一次）语文考了120分（全年级第一），现在相对喜欢写作，也\n可能跟高中时比较喜欢语文有关。\n\n后来，自己研究和分析买的报考指南书籍。选择了一些专业和学校，凭着对这些专业和学校的简单认知，最后在网吧里报考了几所学校和专业。最后录取到了景德镇陶瓷大学信息管理\n与信息系统这个专业。\n\n那个暑假到处赴宴（升学宴），高中班上是重点班。当然，我是垫底级的，不然也不是考入双非普通二本院校。高考前，我没有出过小县城。我和考入同一所学校的校友两人，在网上\n买好了火车票。因为怕乘车的时候可能来不及取票，顺带出趟小县城去市里逛逛。所以特意约了一天坐出租车提前去市里火车站取票。\n\n\n大学是怎么过的#\n\n\n接触前端#\n\n大一时，由于新奇感，报名加入了4个社团，计算机协会、常青藤志愿者协会、环境保护协会、读者协会，基本很多活动有空基本都会去参与。认识了很多优秀的学长学姐。工作后就\n感觉社团也算是一个\"小公司\"（麻雀虽小，五脏俱全）。\n\n下学期（2013年），我所在的社团计算机协会（后文简称计协），当时教网页制作（嗯，那时不叫前端开发），当然我报名去参加了。比我们大一级的学长用着\nDreamweaver 软件 给我们教学，超链接，图片，音乐，视频，FLASH\n等。总之感觉很有趣。也要我们做出一些作品，交作业。但那时我并没有电脑。所以就没做。\n\n\n#\n\n于是大一的暑假（2013年7月），办了一张工商银行银行卡，就买了戴尔的电脑4199元。算是一直用到了22年，近十年，才买了现在的mac电脑。\n往后家里都是往这张银行卡存钱。毕业后我统计了，大二到大四三年累计25200元。\n\n\n参赛#\n\n转眼间，就到了2014年4月（大二下学期），我所在的信息学院，组织参加省级网页大赛（江西省网页制作与设计技能大赛），同时派老师给予培训指导。这时，老师N每周四（\n或五）给我们上了几周课，主要讲HTML和CSS，还给了我们他录制的视频，当时觉得老师好厉害。后来获得了一等奖。\n\n比如大二\n\n后来进入和同学A、同学B进入了课题组。没课时就在，补贴。\n\n\n江西省网页制作与设计技能大赛#\n\n\n毕业#\n\n2016年5月25日离校。6月1日入职。\n\n一年后，课题组L老师结婚邀请我们几个同学回去参加婚礼。2017年5月12日回过一趟大学。往后的几年里，再也没有回过学校了。\n\n高考后 毕业后 大学是怎么过的 工作后每天都是上班下班，期待周末。相对无趣。\n\n\n#","routePath":"/annual-summary/2022/","lang":"zh","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":3},{"text":"回顾这十年","id":"回顾这十年","depth":2,"charIndex":306},{"text":"十年","id":"十年","depth":2,"charIndex":333},{"text":"高考","id":"高考","depth":2,"charIndex":410},{"text":"大学是怎么过的","id":"大学是怎么过的","depth":2,"charIndex":867},{"text":"接触前端","id":"接触前端","depth":3,"charIndex":878},{"text":"","id":"","depth":2,"charIndex":1151},{"text":"参赛","id":"参赛","depth":3,"charIndex":1267},{"text":"江西省网页制作与设计技能大赛","id":"江西省网页制作与设计技能大赛","depth":3,"charIndex":1447},{"text":"毕业","id":"毕业","depth":3,"charIndex":1465},{"text":"","id":"-1","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"若川的 2023 年度总结","content":"#\n\n\n前言#","routePath":"/annual-summary/2023/","lang":"zh","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"","content":"1. 前言#\n\n大家好，我是若川，欢迎 follow 我的 github。我倾力持续组织了3年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.7k+人）第一的专栏，写有30余篇源码文章。\n\n我曾在 2019年 写过 axios 源码文章（570赞、758收藏、2.5w阅读），虽然之前文章写的版本是v0.19.x\n，但是相比现在的源码整体结构基本没有太大变化，感兴趣的可以看看。截至目前（2024-05-09）axios 版本已经更新到 v1.7.0-beta.0\n了。axios 源码值得每一个前端学习。转眼过去好多年了，真是逝者如斯夫，不舍昼夜。\n\n曾经也写过Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？，757赞、553收藏、3.7w阅读。\n\n本文主要讲述 axios，每次更新是如何打包发布更新版本的，学习如何打包发布工具库。\n\n学完本文，你将学到：\n\n\n\n看一个开源项目，第一步应该是先看 README.md 再看 贡献文档 和 package.json。\n\n\n\n\n2. package.json scripts#\n\n\n\npackage.json 中还有很多字段，比如 main、exports 等。推荐参考阮一峰老师的ES6 入门 —— Module 的加载实现\n\n我们可以看到发布主要对应的就是 release-it 。 我们来看 release-it 的配置。一般这类 nodejs 工具，都是可以设置在\npackage.json 中的单独属性xxx，或者单独文件配置，比如 xxxrc、xxx.json、xxx.config.js、xxx.config.ts\n等，内部实现了可以读取这些文件中的配置。算是一些通用规则。\n\nrelease-it 仓库 中的 gif 图如下：\n\n\n\n我们可以执行 npm run release:dry 空跑，查看下具体效果。当然也可以直接跑 npm run release，但可能没有那么顺利。\n\n执行效果如下图所示：\n\n\n\n\n\n\n3. release-it#\n\n\n\ngit、github、plugins 等很多属性都是字面意思。\n\nplugins 中这个插件 @release-it/conventional-changelog，是生成 CHANGELOG.md 文件的。\n\n值得一提的是这个插件有个配置 ignoreRecommendedBump 默认是 false。当然还有很多配置和其他插件。默认值 false 时，会根据提交的\ncommit 信息，比如 feat,fix 等推荐升级版本号，不能手动选择，如果为 true 则可以自行选择版本号。\n\n我们接着来看 hooks。\n\n\n3.1 hooks#\n\nhooks，这里我简单画了一个图。\n\n\n\n3.1.1 before:init#\n\n执行测试脚本\n\nnpm test\n\nnpm run test:eslint && npm run test:mocha && npm run test:karma && npm run\ntest:dtslint && npm run test:exports\n\n就不展开叙述了。\n\n3.1.2 after:bump#\n\n提升版本号后\n\ngulp version --bump ${version} && npm run build && npm run test:build:version &&\ngit add ./dist && git add ./package-lock.json\n\n可以拆分成四段\n\n * gulp version --bump ${version}\n\n提升版本号，执行 gulp 的 version 任务。\n\n * npm run build => gulp clear && cross-env NODE_ENV=production rollup -c -m\n   清理文件 执行 production rollup 编译\n\n * npm run test:build:version => node ./bin/check-build-version.js 检测源代码的 axios\n   版本和 axios 编译后的版本是否一致\n\n * git add ./dist && git add ./package-lock.json git 添加 ./dist 和\n   ./package-lock.json\n\n3.1.3 before:release#\n\n\n\n简单来说就是修改 CHANGELOG.md 文件，添加 PRs、Contributors 等。就不展开叙述了。\n\n3.1.3 after:release#\n\n执行 echo Successfully released ${name} v${version} to ${repo.repository}.\n\n替换相关变量，输出这句话。\n\n先来看这句：\n\n * gulp version --bump ${version}\n\n\n4. gulp version --bump ${version}#\n\ngulp 官方文档\n\n可以先在 gulpfile.js 文件打好断点，断点调试下。\n\n可参考我的文章新手向：前端程序员必学基本技能——调试JS代码，或者据说90%的人不知道可以用测试用例(Vitest)调试开源项目(Vue3) 源码\n\n\n\n或者新建 JavaScript调试终端 - 执行 npm run preversion 命令调试。\n\n\n\n\n\n\n4.1 引入 和 task deafult clear#\n\n\n\nprocess.argv.slice(2) process.argv 第一个参数是 node\n命令的完整路径。第二个参数是正被执行的文件的完整路径。所有其他的参数从第三个位置开始。\n\nminimist 解析命令行参数。这里主要是 gulp version --bump ${version} 获取 argv.bump 版本号。\n\n\n\n\n\n\n4.2 task bower#\n\n\n\n\n4.3 task package#\n\n\n\n\n4.4 task env#\n\n\n\n\n4.5 task version#\n\n\n\ngulp.series 串行\n\n将任务函数和/或组合操作组合成更大的操作，这些操作将按顺序依次执行。使用 series() 和 的组合操作的嵌套深度没有限制parallel()。\n\n我们继续来看 npm run build\n\n * gulp clear && cross-env NODE_ENV=production rollup -c -m\n\n\n5. gulp clear && cross-env NODE_ENV=production rollup -c -m#\n\n * gulp clear\n\n\n\n * cross-env NODE_ENV=production\n\ncross-env 跨平台\n\n也就是设置环境变量 process.env.NODE_ENV 为 production。\n\nrollupjs 中文文档\n\n命令行标志\n\n\n\n我们接着来看 rollup.config.js 文件。\n\n可以调试运行 build 命令，调试这个文件。\n\n\n\n\n5.1 引入各种 rollup 插件等#\n\n\n\n\n5.2 buildConfig#\n\n\n\n\n5.3 最终导出函数#\n\n打包后四种类型\n\n * browser ESM bundle for CDN\n * Browser UMD bundle for CDN\n * Browser CJS bundle\n * Node.js commonjs bundle\n\n打包后的文件如图所示：\n\n\n\n\n\n\n6. 总结#\n\n本文我们学习了 axios 是如何打包发布更新的，也就是说我们学会了打包工具库。\n\n我们通过学习 package.json 的脚本 scripts，release-it 的配置 git、github、npm、plugins、hooks 等。使用\n@release-it/conventional-changelog 生成 changelog。自动化发布 npm、生成 release、打 tag 等。\n\n在 hooks 中配置了一些命令，比如 npm test、gulp verison、npm run build 等，对应 gulpfile.js 和\nrollup.config.js。\n\n用 rollup 打包生成四种格式的文件。\n\n如图所示：\n\n\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n最后可以持续关注我@若川，欢迎 follow 我的\ngithub。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.7k+人）第一的专栏，写有30余篇源码文章。\n\n我倾力持续组织了3年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。","routePath":"/axios-build/README.juejin","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":-1},{"text":"2. package.json scripts","id":"2-packagejson-scripts","depth":2,"charIndex":518},{"text":"3. release-it","id":"3-release-it","depth":2,"charIndex":921},{"text":"3.1 hooks","id":"31-hooks","depth":3,"charIndex":1200},{"text":"3.1.1 before:init","id":"311-beforeinit","depth":4,"charIndex":1233},{"text":"3.1.2 after:bump","id":"312-afterbump","depth":4,"charIndex":1394},{"text":"3.1.3 before:release","id":"313-beforerelease","depth":4,"charIndex":1926},{"text":"3.1.3 after:release","id":"313-afterrelease","depth":4,"charIndex":2008},{"text":"4. gulp version --bump ${version}","id":"4-gulp-version---bump-version","depth":2,"charIndex":2163},{"text":"4.1 引入 和 task deafult clear","id":"41-引入-和-task-deafult-clear","depth":3,"charIndex":2375},{"text":"4.2 task bower","id":"42-task-bower","depth":3,"charIndex":2577},{"text":"4.3 task package","id":"43-task-package","depth":3,"charIndex":2597},{"text":"4.4 task env","id":"44-task-env","depth":3,"charIndex":2619},{"text":"4.5 task version","id":"45-task-version","depth":3,"charIndex":2637},{"text":"5. gulp clear && cross-env NODE_ENV=production rollup -c -m","id":"5-gulp-clear--cross-env-node_envproduction-rollup--c--m","depth":2,"charIndex":2833},{"text":"5.1 引入各种 rollup 插件等","id":"51-引入各种-rollup-插件等","depth":3,"charIndex":3088},{"text":"5.2 buildConfig","id":"52-buildconfig","depth":3,"charIndex":3113},{"text":"5.3 最终导出函数","id":"53-最终导出函数","depth":3,"charIndex":3134},{"text":"6. 总结","id":"6-总结","depth":2,"charIndex":3284}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":14,"title":"天天用的 axios 是如何打包发布更新的？学完等于学会了打包工具库","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎 follow 我的 github。我倾力持续组织了3年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.7k+人）第一的专栏，写有30余篇源码文章。\n\n我曾在 2019年 写过 axios 源码文章（570赞、758收藏、2.5w阅读），虽然之前文章写的版本是v0.19.x\n，但是相比现在的源码整体结构基本没有太大变化，感兴趣的可以看看。截至目前（2024-05-09）axios 版本已经更新到 v1.7.0-beta.0\n了。axios 源码值得每一个前端学习。转眼过去好多年了，真是逝者如斯夫，不舍昼夜。\n\n曾经也写过Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？，757赞、553收藏、3.7w阅读。\n\n本文主要讲述 axios，每次更新是如何打包发布更新版本的，学习如何打包发布工具库。\n\n学完本文，你将学到：\n\n\n\n看一个开源项目，第一步应该是先看 README.md 再看 贡献文档 和 package.json。\n\n\n\n\n2. package.json scripts#\n\n\n\npackage.json 中还有很多字段，比如 main、exports 等。推荐参考阮一峰老师的ES6 入门 —— Module 的加载实现\n\n我们可以看到发布主要对应的就是 release-it 。 我们来看 release-it 的配置。一般这类 nodejs 工具，都是可以设置在\npackage.json 中的单独属性xxx，或者单独文件配置，比如 xxxrc、xxx.json、xxx.config.js、xxx.config.ts\n等，内部实现了可以读取这些文件中的配置。算是一些通用规则。\n\nrelease-it 仓库 中的 gif 图如下：\n\n\n\n我们可以执行 npm run release:dry 空跑，查看下具体效果。当然也可以直接跑 npm run release，但可能没有那么顺利。\n\n执行效果如下图所示：\n\n\n\n\n\n\n3. release-it#\n\n\n\ngit、github、plugins 等很多属性都是字面意思。\n\nplugins 中这个插件 @release-it/conventional-changelog，是生成 CHANGELOG.md 文件的。\n\n值得一提的是这个插件有个配置 ignoreRecommendedBump 默认是 false。当然还有很多配置和其他插件。默认值 false 时，会根据提交的\ncommit 信息，比如 feat,fix 等推荐升级版本号，不能手动选择，如果为 true 则可以自行选择版本号。\n\n我们接着来看 hooks。\n\n\n3.1 hooks#\n\nhooks，这里我简单画了一个图。\n\n\n\n3.1.1 before:init#\n\n执行测试脚本\n\nnpm test\n\nnpm run test:eslint && npm run test:mocha && npm run test:karma && npm run\ntest:dtslint && npm run test:exports\n\n就不展开叙述了。\n\n3.1.2 after:bump#\n\n提升版本号后\n\ngulp version --bump ${version} && npm run build && npm run test:build:version &&\ngit add ./dist && git add ./package-lock.json\n\n可以拆分成四段\n\n * gulp version --bump ${version}\n\n提升版本号，执行 gulp 的 version 任务。\n\n * npm run build => gulp clear && cross-env NODE_ENV=production rollup -c -m\n   清理文件 执行 production rollup 编译\n\n * npm run test:build:version => node ./bin/check-build-version.js 检测源代码的 axios\n   版本和 axios 编译后的版本是否一致\n\n * git add ./dist && git add ./package-lock.json git 添加 ./dist 和\n   ./package-lock.json\n\n3.1.3 before:release#\n\n\n\n简单来说就是修改 CHANGELOG.md 文件，添加 PRs、Contributors 等。就不展开叙述了。\n\n3.1.3 after:release#\n\n执行 echo Successfully released ${name} v${version} to ${repo.repository}.\n\n替换相关变量，输出这句话。\n\n先来看这句：\n\n * gulp version --bump ${version}\n\n\n4. gulp version --bump ${version}#\n\ngulp 官方文档\n\n可以先在 gulpfile.js 文件打好断点，断点调试下。\n\n可参考我的文章新手向：前端程序员必学基本技能——调试JS代码，或者据说90%的人不知道可以用测试用例(Vitest)调试开源项目(Vue3) 源码\n\n\n\n或者新建 JavaScript调试终端 - 执行 npm run preversion 命令调试。\n\n\n\n\n\n\n4.1 引入 和 task deafult clear#\n\n\n\nprocess.argv.slice(2) process.argv 第一个参数是 node\n命令的完整路径。第二个参数是正被执行的文件的完整路径。所有其他的参数从第三个位置开始。\n\nminimist 解析命令行参数。这里主要是 gulp version --bump ${version} 获取 argv.bump 版本号。\n\n\n\n\n\n\n4.2 task bower#\n\n\n\n\n4.3 task package#\n\n\n\n\n4.4 task env#\n\n\n\n\n4.5 task version#\n\n\n\ngulp.series 串行\n\n将任务函数和/或组合操作组合成更大的操作，这些操作将按顺序依次执行。使用 series() 和 的组合操作的嵌套深度没有限制parallel()。\n\n我们继续来看 npm run build\n\n * gulp clear && cross-env NODE_ENV=production rollup -c -m\n\n\n5. gulp clear && cross-env NODE_ENV=production rollup -c -m#\n\n * gulp clear\n\n\n\n * cross-env NODE_ENV=production\n\ncross-env 跨平台\n\n也就是设置环境变量 process.env.NODE_ENV 为 production。\n\nrollupjs 中文文档\n\n命令行标志\n\n\n\n我们接着来看 rollup.config.js 文件。\n\n可以调试运行 build 命令，调试这个文件。\n\n\n\n\n5.1 引入各种 rollup 插件等#\n\n\n\n\n5.2 buildConfig#\n\n\n\n\n5.3 最终导出函数#\n\n打包后四种类型\n\n * browser ESM bundle for CDN\n * Browser UMD bundle for CDN\n * Browser CJS bundle\n * Node.js commonjs bundle\n\n打包后的文件如图所示：\n\n\n\n\n\n\n6. 总结#\n\n本文我们学习了 axios 是如何打包发布更新的，也就是说我们学会了打包工具库。\n\n我们通过学习 package.json 的脚本 scripts，release-it 的配置 git、github、npm、plugins、hooks 等。使用\n@release-it/conventional-changelog 生成 changelog。自动化发布 npm、生成 release、打 tag 等。\n\n在 hooks 中配置了一些命令，比如 npm test、gulp verison、npm run build 等，对应 gulpfile.js 和\nrollup.config.js。\n\n用 rollup 打包生成四种格式的文件。\n\n如图所示：\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n最后可以持续关注我@若川，欢迎 follow 我的\ngithub。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.7k+人）第一的专栏，写有30余篇源码文章。\n\n我倾力持续组织了3年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。","routePath":"/axios-build/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. package.json scripts","id":"2-packagejson-scripts","depth":2,"charIndex":522},{"text":"3. release-it","id":"3-release-it","depth":2,"charIndex":925},{"text":"3.1 hooks","id":"31-hooks","depth":3,"charIndex":1204},{"text":"3.1.1 before:init","id":"311-beforeinit","depth":4,"charIndex":1237},{"text":"3.1.2 after:bump","id":"312-afterbump","depth":4,"charIndex":1398},{"text":"3.1.3 before:release","id":"313-beforerelease","depth":4,"charIndex":1930},{"text":"3.1.3 after:release","id":"313-afterrelease","depth":4,"charIndex":2012},{"text":"4. gulp version --bump ${version}","id":"4-gulp-version---bump-version","depth":2,"charIndex":2167},{"text":"4.1 引入 和 task deafult clear","id":"41-引入-和-task-deafult-clear","depth":3,"charIndex":2379},{"text":"4.2 task bower","id":"42-task-bower","depth":3,"charIndex":2581},{"text":"4.3 task package","id":"43-task-package","depth":3,"charIndex":2601},{"text":"4.4 task env","id":"44-task-env","depth":3,"charIndex":2623},{"text":"4.5 task version","id":"45-task-version","depth":3,"charIndex":2641},{"text":"5. gulp clear && cross-env NODE_ENV=production rollup -c -m","id":"5-gulp-clear--cross-env-node_envproduction-rollup--c--m","depth":2,"charIndex":2837},{"text":"5.1 引入各种 rollup 插件等","id":"51-引入各种-rollup-插件等","depth":3,"charIndex":3092},{"text":"5.2 buildConfig","id":"52-buildconfig","depth":3,"charIndex":3117},{"text":"5.3 最终导出函数","id":"53-最终导出函数","depth":3,"charIndex":3138},{"text":"6. 总结","id":"6-总结","depth":2,"charIndex":3288}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":15,"title":"","content":"","routePath":"/axios/axios-v0.19.0","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"学习 axios 源码整体架构，打造属于自己的请求库","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 这是学习源码整体架构系列第六篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。本篇文章\n> 学习的是实际仓库的代码。\n\n> 本文仓库地址：git clone https://github.com/ruochuan12/axios-analysis.git\n\n> 要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了。\n\n学习源码整体架构系列文章如下：\n\n> 1.学习 jQuery 源码整体架构，打造属于自己的 js 类库 2.学习 underscore 源码整体架构，打造属于自己的函数式编程类库 3.学习\n> lodash 源码整体架构，打造属于自己的函数式编程类库 4.学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK 5.学习 vuex\n> 源码整体架构，打造属于自己的状态管理库 6.学习 axios 源码整体架构，打造属于自己的请求库 7.学习 koa\n> 源码的整体架构，浅析koa洋葱模型原理和co原理 8.学习 redux 源码整体架构，深入理解 redux 及其中间件原理\n\n感兴趣的读者可以点击阅读。 其他源码计划中的有：express、vue-rotuer、react-redux\n等源码，不知何时能写完（哭泣），欢迎持续关注我（若川）。\n\n源码类文章，一般阅读量不高。已经有能力看懂的，自己就看了。不想看，不敢看的就不会去看源码。 所以我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。\n\n本文比较长，手机上阅读，可以划到有图的地方直接看文中的几张图即可。建议点赞或收藏后在电脑上阅读，按照文中调试方式自己调试或许更容易吸收消化。\n\n导读 文章详细介绍了 axios 调试方法。详细介绍了 axios 构造函数，拦截器，取消等功能的实现。最后还对比了其他请求库。\n\n本文学习的版本是v0.19.0。克隆的官方仓库的master分支。 截至目前（2019年12月14日），最新一次commit是2019-12-09 15:52\nZhaoXC dc4bc49673943e352，fix: fix ignore set withCredentials false (#2582)。\n\n本文仓库在这里若川的 axios-analysis github 仓库。求个star呀。\n\n如果你是求职者，项目写了运用了axios，面试官可能会问你：\n\n> 1.为什么 axios 既可以当函数调用，也可以当对象使用，比如axios({})、axios.get。 2.简述 axios 调用流程。\n> 3.有用过拦截器吗？原理是怎样的？ 4.有使用axios的取消功能吗？是怎么实现的？ 5.为什么支持浏览器中发送请求也支持node发送请求？ 诸如这类问题。\n\n\n2. chrome 和 vscode 调试 axios 源码方法#\n\n前不久，笔者在知乎回答了一个问题一年内的前端看不懂前端框架源码怎么办？ 推荐了一些资料，阅读量还不错，大家有兴趣可以看看。主要有四点：\n\n> 1.借助调试 2.搜索查阅相关高赞文章 3.把不懂的地方记录下来，查阅相关文档 4.总结\n\n看源码，调试很重要，所以笔者详细写下 axios 源码调试方法，帮助一些可能不知道如何调试的读者。\n\n\n2.1 chrome 调试浏览器环境的 axios#\n\n调试方法\n\naxios打包后有sourcemap文件。\n\n\n\n本文就是通过上述的例子axios/sandbox/client.html来调试的。\n\n顺便简单提下调试example的例子，虽然文章最开始时写了这部分，后来又删了，最后想想还是写下。\n\n找到文件axios/examples/server.js，修改代码如下：\n\n\n\n\n\n打开http://localhost:5000，然后就可以开心的在Chrome浏览器中调试examples里的例子了。\n\naxios 是支持 node 环境发送请求的。接下来看如何用 vscode 调试 node 环境下的axios。\n\n\n2.2 vscode 调试 node 环境的 axios#\n\n在根目录下 axios-analysis/ 创建.vscode/launch.json文件如下：\n\n\n\n按F5开始调试即可，按照自己的情况，单步跳过（F10）、单步调试（F11）断点调试。\n\n其实开源项目一般都有贡献指南axios/CONTRIBUTING.md，笔者只是把这个指南的基础上修改为引用sourcemap的文件可调试。\n\n\n3. 先看 axios 结构是怎样的#\n\n\n\n按照上文说的调试方法， npm start 后，直接在 chrome 浏览器中调试。 打开\nhttp://localhost:3000，在控制台打印出axios，估计很多人都没打印出来看过。\n\n\n\n层层点开来看，axios 的结构是怎样的，先有一个大概印象。\n\n笔者画了一张比较详细的图表示。\n\n\n\n看完结构图，如果看过jQuery、underscore和lodash源码，会发现其实跟axios源码设计类似。\n\njQuery 别名 $，underscore loadsh 别名 _ 也既是函数，也是对象。比如jQuery使用方式。$('#id'), $.ajax。\n\n接下来看具体源码的实现。可以跟着断点调试一下。\n\n断点调试要领： 赋值语句可以一步跳过，看返回值即可，后续详细再看。 函数执行需要断点跟着看，也可以结合注释和上下文倒推这个函数做了什么。\n\n\n4. axios 源码 初始化#\n\n看源码第一步，先看package.json。一般都会申明 main 主入口文件。\n\n\n\n主入口文件\n\n\n\n\n4.1 lib/axios.js主文件#\n\naxios.js文件 代码相对比较多。分为三部分展开叙述。\n\n>  1. 第一部分：引入一些工具函数utils、Axios构造函数、默认配置defaults等。\n>  2. 第二部分：是生成实例对象 axios、axios.Axios、axios.create等。\n>  3. 第三部分取消相关API实现，还有all、spread、导出等实现。\n\n4.1.1 第一部分#\n\n引入一些工具函数utils、Axios构造函数、默认配置defaults等。\n\n\n\n4.1.2 第二部分#\n\n是生成实例对象 axios、axios.Axios、axios.create等。\n\n\n\n这里简述下工厂模式。axios.create，也就是用户不需要知道内部是怎么实现的。 举个生活的例子，我们买手机，不需要知道手机是怎么做的，就是工厂模式。\n看完第二部分，里面涉及几个工具函数，如bind、extend。接下来讲述这几个工具方法。\n\n4.1.3 工具方法之 bind#\n\naxios/lib/helpers/bind.js\n\n\n\n传递两个参数函数和thisArg指向。 把参数arguments生成数组，最后调用返回参数结构。 其实现在 apply 支持\narguments这样的类数组对象了，不需要手动转数组。\n那么为啥作者要转数组，为了性能？当时不支持？抑或是作者不知道？这就不得而知了。有读者知道欢迎评论区告诉笔者呀。\n\n关于apply、call和bind等不是很熟悉的读者，可以看笔者的另一个面试官问系列。 面试官问：能否模拟实现JS的bind方法\n\n举个例子\n\n\n\n4.1.4 工具方法之 utils.extend#\n\naxios/lib/utils.js\n\n\n\n其实就是遍历参数 b 对象，复制到 a 对象上，如果是函数就是则用 bind 调用。\n\n4.1.5 工具方法之 utils.forEach#\n\naxios/lib/utils.js\n\n遍历数组和对象。设计模式称之为迭代器模式。很多源码都有类似这样的遍历函数。比如大家熟知的jQuery $.each。\n\n\n\n如果对Object相关的API不熟悉，可以查看笔者之前写过的一篇文章。JavaScript 对象所有API解析\n\n4.1.6 第三部分#\n\n取消相关API实现，还有all、spread、导出等实现。\n\n\n\n这里介绍下 spread，取消的API暂时不做分析，后文再详细分析。\n\n假设你有这样的需求。\n\n\n\n那么可以用spread方法。用法：\n\n\n\n实现也比较简单。源码实现：\n\n\n\n上文var context = new Axios(defaultConfig);，接下来介绍核心构造函数Axios。\n\n\n4.2 核心构造函数 Axios#\n\naxios/lib/core/Axios.js\n\n构造函数Axios。\n\n\n\n\n\n接下来看拦截器部分。\n\n\n4.3 拦截器管理构造函数 InterceptorManager#\n\n请求前拦截，和请求后拦截。 在Axios.prototype.request函数里使用，具体怎么实现的拦截的，后文配合例子详细讲述。\n\naxios github 仓库 拦截器文档\n\n如何使用：\n\n\n\n如果想把拦截器移除，可以用eject方法。\n\n\n\n拦截器也可以添加自定义的实例上。\n\n\n\n源码实现：\n\n构造函数，handles 用于存储拦截器函数。\n\n\n\n接下来声明了三个方法：使用、移除、遍历。\n\n4.3.1 InterceptorManager.prototype.use 使用#\n\n传递两个函数作为参数，数组中的一项存储的是{fulfilled: function(){}, rejected: function(){}}。返回数字\nID，用于移除拦截器。\n\n\n\n4.3.2 InterceptorManager.prototype.eject 移除#\n\n根据 use 返回的 ID 移除 拦截器。\n\n\n\n有点类似定时器setTimeout 和 setInterval，返回值是id。用clearTimeout 和clearInterval来清除定时器。\n\n\n\n4.3.3 InterceptorManager.prototype.forEach 遍历#\n\n遍历执行所有拦截器，传递一个回调函数（每一个拦截器函数作为参数）调用，被移除的一项是null，所以不会执行，也就达到了移除的效果。\n\n\n\n\n5. 实例结合#\n\n上文叙述的调试时运行npm start 是用axios/sandbox/client.html路径的文件作为示例的，读者可以自行调试。\n\n以下是一段这个文件中的代码。\n\n\n\n\n5.1 先看调用栈流程#\n\n如果不想一步步调试，有个偷巧的方法。 知道 axios 使用了XMLHttpRequest。 可以在项目中搜索：new XMLHttpRequest。\n定位到文件 axios/lib/adapters/xhr.js 在这条语句 var request = new XMLHttpRequest(); chrome\n浏览器中 打个断点调试下，再根据调用栈来细看具体函数等实现。\n\nCall Stack\n\n\n\n简述下流程：\n\n 1. Send Request 按钮点击 submit.onclick\n 2. 调用 axios 函数实际上是调用 Axios.prototype.request 函数，而这个函数使用 bind 返回的一个名为wrap的函数。\n 3. 调用 Axios.prototype.request\n 4. （有请求拦截器的情况下执行请求拦截器），中间会执行 dispatchRequest方法\n 5. dispatchRequest 之后调用 adapter (xhrAdapter)\n 6. 最后调用 Promise 中的函数dispatchXhrRequest，（有响应拦截器的情况下最后会再调用响应拦截器）\n\n如果仔细看了文章开始的axios 结构关系图，其实对这个流程也有大概的了解。\n\n接下来看 Axios.prototype.request 具体实现。\n\n\n5.2 Axios.prototype.request 请求核心方法#\n\n这个函数是核心函数。 主要做了这几件事：\n\n> 1.判断第一个参数是字符串，则设置 url,也就是支持axios('example/url', [, config])，也支持axios({})。\n> 2.合并默认参数和用户传递的参数 3.设置请求的方法，默认是是get方法\n> 4.将用户设置的请求和响应拦截器、发送请求的dispatchRequest组成Promise链，最后返回还是Promise实例。\n> 也就是保证了请求前拦截器先执行，然后发送请求，再响应拦截器执行这样的顺序。 也就是为啥最后还是可以then，catch方法的缘故。\n\n\n\n5.2.1 组成Promise链，返回Promise实例#\n\n> 这部分：用户设置的请求和响应拦截器、发送请求的dispatchRequest组成Promise链。也就是保证了请求前拦截器先执行，然后发送请求，再响应拦截器\n> 执行这样的顺序 也就是保证了请求前拦截器先执行，然后发送请求，再响应拦截器执行这样的顺序 也就是为啥最后还是可以then，catch方法的缘故。\n\n如果读者对Promise不熟悉，建议读阮老师的书籍《ES6 标准入门》。 阮一峰老师 的 ES6 Promise-resolve 和 JavaScript\nPromise迷你书（中文版）\n\n\n\n\n\n解释下这句。作用是生成Promise实例。\n\n\n\n同样解释下后文会出现的Promise.reject(error);：\n\n\n\n\n\n接下来结合例子，来理解这段代码。\n很遗憾，在example文件夹没有拦截器的例子。笔者在example中在example/get的基础上添加了一个拦截器的示例。axios/examples/in\nterceptors，便于读者调试。\n\n\n\npromise = promise.then(chain.shift(), chain.shift());这段代码打个断点。\n\n会得到这样的这张图。\n\n特别关注下，右侧，local中的chain数组。也就是这样的结构。\n\n\n\n这段代码相对比较绕。也就是会生成如下类似的代码，中间会调用dispatchRequest方法。\n\n\n\n这里提下promise then和catch知识：\nPromise.prototype.then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。所以是成对出现\n的。 Promise.prototype.catch方法是.then(null, rejection)或.then(undefined,\nrejection)的别名，用于指定发生错误时的回调函数。\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n\n结合上述的例子更详细一点，代码则是这样的。\n\n\n\n仔细看这段Promise链式调用，代码都类似。then方法最后返回的参数，就是下一个then方法第一个参数。\ncatch错误捕获，都返回Promise.reject(error)，这是为了便于用户catch时能捕获到错误。\n\n举个例子：\n\n\n\nerr2不会捕获到，也就是不会执行，但如果都返回了return Promise.reject(err)，则可以捕获到。\n\n最后画个图总结下 Promise 链式调用。\n\n\n\n> 小结：1. 请求和响应的拦截器可以写Promise。 2. 如果设置了多个请求响应器，后设置的先执行。 3. 如果设置了多个响应拦截器，先设置的先执行。\n\ndispatchRequest(config) 这里的config是请求成功拦截器返回的。接下来看dispatchRequest函数。\n\n\n5.3 dispatchRequest 最终派发请求#\n\n这个函数主要做了如下几件事情：\n\n> 1.如果已经取消，则 throw 原因报错，使Promise走向rejected。 2.确保 config.header 存在。\n> 3.利用用户设置的和默认的请求转换器转换数据。 4.拍平 config.header。 5.删除一些 config.header。\n> 6.返回适配器adapter（Promise实例）执行后 then执行后的 Promise实例。返回结果传递给响应拦截器处理。\n\n\n\n5.3.1 dispatchRequest 之 transformData 转换数据#\n\n上文的代码里有个函数 transformData ，这里解释下。其实就是遍历传递的函数数组 对数据操作，最后返回数据。\n\naxios.defaults.transformResponse 数组中默认就有一个函数，所以使用concat链接自定义的函数。\n\n使用：\n\n文件路径 axios/examples/transform-response/index.html\n\n这段代码其实就是对时间格式的字符串转换成时间对象，可以直接调用getMonth等方法。\n\n\n\n源码：\n\n就是遍历数组，调用数组里的传递 data 和 headers 参数调用函数。\n\n\n\n5.3.2 dispatchRequest 之 adapter 适配器执行部分#\n\n适配器，在设计模式中称之为适配器模式。讲个生活中简单的例子，大家就容易理解。\n\n我们常用以前手机耳机孔都是圆孔，而现在基本是耳机孔和充电接口合二为一。统一为typec。\n\n这时我们需要需要一个typec转圆孔的转接口，这就是适配器。\n\n\n\n接下来看具体的 adapter。\n\n\n5.4 adapter 适配器 真正发送请求#\n\n\n\n看了上文的 adapter，可以知道支持用户自定义。比如可以通过微信小程序 wx.request 按照要求也写一个 adapter。 接着来看下\ndefaults.ddapter。 文件路径：axios/lib/defaults.js\n\n根据当前环境引入，如果是浏览器环境引入xhr，是node环境则引入http。 类似判断node环境，也在sentry-javascript源码中有看到。\n\n\n\nxhr\n\n接下来就是我们熟悉的 XMLHttpRequest 对象。\n\n可能读者不了解可以参考XMLHttpRequest MDN 文档。\n\n主要提醒下：onabort是请求取消事件，withCredentials是一个布尔值，用来指定跨域 Access-Control 请求是否应带有授权信息，如\ncookie 或授权 header 头。\n\n这块代码有删减，具体可以看若川的axios-analysis仓库，也可以克隆笔者的axios-analysis仓库调试时再具体分析。\n\n\n\n而实际上现在 fetch 支持的很好了，阿里开源的 umi-request 请求库，就是用fetch封装的，而不是用XMLHttpRequest。\n文章末尾，大概讲述下 umi-request 和 axios 的区别。\n\nhttp\n\nhttp这里就不详细叙述了，感兴趣的读者可以自行查看，若川的axios-analysis仓库。\n\n\n\n上文 dispatchRequest 有取消模块，我觉得是重点，所以放在最后来细讲：\n\n\n5.5 dispatchRequest 之 取消模块#\n\n可以使用cancel token取消请求。\n\naxios cancel token API 是基于撤销的 promise 取消提议。\n\nThe axios cancel token API is based on the withdrawn cancelable promises\nproposal.\n\naxios 文档 cancellation\n\n文档上详细描述了两种使用方式。\n\n很遗憾，在example文件夹也没有取消的例子。笔者在example中在example/get的基础上添加了一个取消的示例。axios/examples/can\ncel，便于读者调试。\n\n\n\nrequest中的拦截器和dispatch中的取消这两个模块相对复杂，可以多调试调试，吸收消化。\n\n\n\n5.5.1 取消请求模块代码示例#\n\n结合源码取消流程大概是这样的。这段放在代码在axios/examples/cancel-token/index.html。\n\n参数的 config.cancelToken 是触发了source.cancel('哎呀，我被若川取消了');才生成的。\n\n\n\n5.5.2 接下来看取消模块的源码#\n\n看如何通过生成config.cancelToken。\n\n文件路径：\n\naxios/lib/cancel/CancelToken.js\n\n\n\n由示例看 CancelToken.source的实现，\n\n\n\n执行后source的大概结构是这样的。\n\n\n\n接着看 new CancelToken\n\n\n\n发送请求的适配器里是这样使用的。\n\n\n\ndispatchRequest 中的throwIfCancellationRequested具体实现：throw 抛出异常。\n\n\n\n取消流程调用栈\n\n> 1.source.cancel() 2.resolvePromise(token.reason);\n> 3.config.cancelToken.promise.then(function onCanceled(cancel) {})\n\n最后进入request.abort();``reject(cancel);\n\n到这里取消的流程就介绍完毕了。主要就是通过传递配置参数cancelToken，取消时才会生成cancelToken，判断有，则抛出错误，使Promise\n走向rejected，让用户捕获到消息{message: '用户设置的取消信息'}。\n\n文章写到这里就基本到接近尾声了。\n\n能读到最后，说明你已经超过很多人啦^_^\n\naxios是非常优秀的请求库，但肯定也不能满足所有开发者的需求，接下来对比下其他库，看看其他开发者有什么具体需求。\n\n\n6. 对比其他请求库#\n\n\n6.1 KoAjax#\n\nfCC成都社区负责人水歌开源的KoAJAX。\n\n如何用开源软件办一场技术大会？ 以下这篇文章中摘抄的一段。\n\n> 前端请求库 —— KoAJAX 国内前端同学最常用的 HTTP 请求库应该是 axios 了吧？虽然它的 Interceptor（拦截器）API 是\n> .use()，但和 Node.js 的 Express、Koa 等框架的中间件模式完全不同，相比 jQuery\n> .ajaxPrefilter()、dataFilter() 并没什么实质改进；上传、下载进度比 jQuery.Deferred()\n> 还简陋，只是两个专门的回调选项。所以，它还是要对特定的需求记忆特定的 API，不够简洁。\n\n> 幸运的是，水歌在研究如何用 ES 2018 异步迭代器实现一个类 Koa 中间件引擎的过程中，做出了一个更有实际价值的上层应用 ——\n> KoAJAX。它的整个执行过程基于 Koa 式的中间件，而且它自己就是一个中间件调用栈。除了 RESTful API 常用的\n> .get()、.post()、.put()、.delete() 等快捷方法外，开发者就只需记住 .use() 和 next()，其它都是 ES 标准语法和\n> TS 类型推导。\n\n\n6.2 umi-request 阿里开源的请求库#\n\numi-request github 仓库\n\numi-request 与 fetch, axios 异同。\n\n\n\n不得不说，umi-request 确实强大，有兴趣的读者可以阅读下其源码。\n\n看懂axios的基础上，看懂umi-request源码应该不难。\n\n比如 umi-request 取消模块代码几乎与axios一模一样。\n\n\n7. 总结#\n\n文章详细介绍了 axios 调试方法。详细介绍了 axios 构造函数，拦截器，取消等功能的实现。最后还对比了其他请求库。\n\n最后画个图总结一下axios的总体大致流程。\n\n\n\n解答下文章开头提的问题：\n\n如果你是求职者，项目写了运用了axios，面试官可能会问你：\n\n> 1.为什么 axios 既可以当函数调用，也可以当对象使用，比如axios({})、axios.get。\n> 答：axios本质是函数，赋值了一些别名方法，比如get、post方法，可被调用，最终调用的还是Axios.prototype.request函数。\n> 2.简述 axios 调用流程。\n> 答：实际是调用的Axios.prototype.request方法，最终返回的是promise链式调用，实际请求是在dispatchRequest中派发的。\n> 3.有用过拦截器吗？原理是怎样的？\n> 答：用过，用axios.interceptors.request.use添加请求成功和失败拦截器函数，用axios.interceptors.respons\n> e.use添加响应成功和失败拦截器函数。在Axios.prototype.request函数组成promise链式调用时，Interceptors.prot\n> ype.forEach遍历请求和响应拦截器添加到真正发送请求dispatchRequest的两端，从而做到请求前拦截和响应后拦截。拦截器也支持用Interc\n> eptors.protype.eject方法移除。 4.有使用axios的取消功能吗？是怎么实现的？\n> 答：用过，通过传递config配置cancelToken的形式，来取消的。判断有传cancelToken，在promise链式调用的dispatchRequ\n> est抛出错误，在adapter中request.abort()取消请求，使promise走向rejected，被用户捕获取消信息。\n> 5.为什么支持浏览器中发送请求也支持node发送请求？\n> 答：axios.defaults.adapter默认配置中根据环境判断是浏览器还是node环境，使用对应的适配器。适配器支持自定义。\n\n回答面试官的问题，读者也可以根据自己的理解，组织语言，笔者的回答只是做一个参考。\n\naxios 源码相对不多，打包后一千多行，比较容易看完，非常值得学习。\n\n建议 clone 若川的 axios-analysis github 仓库，按照文中方法自己调试，印象更深刻。\n\n基于Promise，构成Promise链，巧妙的设置请求拦截，发送请求，再试试响应拦截器。\n\nrequest中的拦截器和dispatch中的取消这两个模块相对复杂，可以多调试调试，吸收消化。\n\naxios\n既是函数，是函数时调用的是Axios.prototype.request函数，又是对象，其上面有get、post等请求方法，最终也是调用Axios.protot\nype.request函数。\n\naxios\n源码中使用了挺多设计模式。比如工厂模式、迭代器模式、适配器模式等。如果想系统学习设计模式，一般比较推荐豆瓣评分9.1的JavaScript设计模式与开发实践\n\n如果读者发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出。另外觉得写得不错，对您有些许帮助，可以点赞、评论、转发分享，也是对笔者的一种支持，非常感\n谢呀。\n\n\n推荐阅读#\n\n官方axios github 仓库\n\n写文章前，搜索了以下几篇文章泛读了一下。有兴趣再对比看看以下这几篇，有代码调试的基础上，看起来也快。\n\n一直觉得多搜索几篇文章看，对自己学习知识更有用。有个词语叫主题阅读。大概意思就是一个主题一系列阅读。\n\n@叫我小明呀：Axios 源码解析 @尼库尼库桑：深入浅出 axios 源码 @小贼先生_ronffy：Axios源码深度剖析 - AJAX新王者\n逐行解析Axios源码 [译]axios 是如何封装 HTTP 请求的 知乎@Lee : TypeScript 重构 Axios 经验分享\n\n\n笔者另一个系列#\n\n面试官问：JS的继承 面试官问：JS的this指向 面试官问：能否模拟实现JS的call和apply方法 面试官问：能否模拟实现JS的bind方法\n面试官问：能否模拟实现JS的new操作符\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 若川的博客，使用vuepress重构了，阅读体验可能更好些\n掘金专栏，欢迎关注~ segmentfault前端视野专栏，欢迎关注~ 知乎前端视野专栏，欢迎关注~ 语雀前端视野专栏，新增语雀专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n欢迎加微信交流 微信公众号#\n\n可能比较有趣的微信公众号，长按扫码关注（回复pdf获取前端优质书籍pdf）。欢迎加笔者微信ruochuan12（注明来源，基本来者不拒），拉您进【前端视野交流群\n】，长期交流学习~\n\n","routePath":"/axios/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. chrome 和 vscode 调试 axios 源码方法","id":"2-chrome-和-vscode-调试-axios-源码方法","depth":2,"charIndex":1349},{"text":"2.1 chrome 调试浏览器环境的 axios","id":"21-chrome-调试浏览器环境的-axios","depth":3,"charIndex":1553},{"text":"2.2 vscode 调试 node 环境的 axios","id":"22-vscode-调试-node-环境的-axios","depth":3,"charIndex":1867},{"text":"3. 先看 axios 结构是怎样的","id":"3-先看-axios-结构是怎样的","depth":2,"charIndex":2067},{"text":"4. axios 源码 初始化","id":"4-axios-源码-初始化","depth":2,"charIndex":2471},{"text":"4.1 `lib/axios.js`主文件","id":"41-libaxiosjs主文件","depth":3,"charIndex":-1},{"text":"4.1.1 第一部分","id":"411-第一部分","depth":4,"charIndex":2739},{"text":"4.1.2 第二部分","id":"412-第二部分","depth":4,"charIndex":2794},{"text":"4.1.3 工具方法之 bind","id":"413-工具方法之-bind","depth":4,"charIndex":2975},{"text":"4.1.4 工具方法之 utils.extend","id":"414-工具方法之-utilsextend","depth":4,"charIndex":3246},{"text":"4.1.5 工具方法之 utils.forEach","id":"415-工具方法之-utilsforeach","depth":4,"charIndex":3339},{"text":"4.1.6 第三部分","id":"416-第三部分","depth":4,"charIndex":3506},{"text":"4.2 核心构造函数 Axios","id":"42-核心构造函数-axios","depth":3,"charIndex":3702},{"text":"4.3 拦截器管理构造函数 InterceptorManager","id":"43-拦截器管理构造函数-interceptormanager","depth":3,"charIndex":3775},{"text":"4.3.1 InterceptorManager.prototype.use 使用","id":"431-interceptormanagerprototypeuse-使用","depth":4,"charIndex":4011},{"text":"4.3.2 InterceptorManager.prototype.eject 移除","id":"432-interceptormanagerprototypeeject-移除","depth":4,"charIndex":4146},{"text":"4.3.3 InterceptorManager.prototype.forEach 遍历","id":"433-interceptormanagerprototypeforeach-遍历","depth":4,"charIndex":4295},{"text":"5. 实例结合","id":"5-实例结合","depth":2,"charIndex":4413},{"text":"5.1 先看调用栈流程","id":"51-先看调用栈流程","depth":3,"charIndex":4511},{"text":"5.2 Axios.prototype.request 请求核心方法","id":"52-axiosprototyperequest-请求核心方法","depth":3,"charIndex":5118},{"text":"5.2.1 组成`Promise`链，返回`Promise`实例","id":"521-组成promise链返回promise实例","depth":4,"charIndex":-1},{"text":"5.3 dispatchRequest 最终派发请求","id":"53-dispatchrequest-最终派发请求","depth":3,"charIndex":6735},{"text":"5.3.1 dispatchRequest 之 transformData 转换数据","id":"531-dispatchrequest-之-transformdata-转换数据","depth":4,"charIndex":6985},{"text":"5.3.2 dispatchRequest 之 adapter 适配器执行部分","id":"532-dispatchrequest-之-adapter-适配器执行部分","depth":4,"charIndex":7307},{"text":"5.4 adapter 适配器 真正发送请求","id":"54-adapter-适配器-真正发送请求","depth":3,"charIndex":7488},{"text":"5.5 dispatchRequest 之 取消模块","id":"55-dispatchrequest-之-取消模块","depth":3,"charIndex":8169},{"text":"5.5.1 取消请求模块代码示例","id":"551-取消请求模块代码示例","depth":4,"charIndex":8538},{"text":"5.5.2 接下来看取消模块的源码","id":"552-接下来看取消模块的源码","depth":4,"charIndex":8684},{"text":"6. 对比其他请求库","id":"6-对比其他请求库","depth":2,"charIndex":9327},{"text":"6.1 KoAjax","id":"61-koajax","depth":3,"charIndex":9341},{"text":"6.2 umi-request 阿里开源的请求库","id":"62-umi-request-阿里开源的请求库","depth":3,"charIndex":9887},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":10081},{"text":"推荐阅读","id":"推荐阅读","depth":2,"charIndex":11531},{"text":"笔者另一个系列","id":"笔者另一个系列","depth":2,"charIndex":11807},{"text":"关于","id":"关于","depth":2,"charIndex":11914},{"text":"欢迎加微信交流 微信公众号","id":"欢迎加微信交流-微信公众号","depth":2,"charIndex":12101}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"bugsnag","content":"#\n\n\n推荐阅读#\n\nbugsnag-js\n\nbugsnag-js 文档","routePath":"/bugsnag/","lang":"zh","toc":[{"text":"推荐阅读","id":"推荐阅读","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"","content":"","routePath":"/bugsnag/src/bugsnag","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"vite 3.0 都发布了，经常初始化 vite 项目，却不知 create-vite 原理？揭秘！","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。为了能帮助到更多对源码感兴趣、想学会看源码、提升自己前端技术能力的同学。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感\n> 兴趣的可以点此扫码加我微信 ruochuan02 参与。\n\n想学源码，极力推荐关注我写的专栏（目前是掘金专栏关注人数第一，3.6K+人）《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等20余篇源码文章。\n\n> 本文项目，欢迎 star 和克隆调试学习。git clone https://github.com/ruochuan12/vite-analysis.git\n\n早在2021年10月，我写了Vue 团队公开快如闪电的全新脚手架工具 create-vue，未来将替代 Vue-CLI，才300余行代码，学它！，备受好评。当时\ncreate-vue 还没有配置 eslint 等，现在已经比较完善了。\n\n这是源码共读中第九期。有读者写了最新 create-vue 的源码解读。\n\n我们知道 vite 3.0 发布了。什么？你不知道？想起有好友问：如何关注前端新技术、新热点等，我的回答是关注相关的 Github 和\nTwitter，或者关注我的【公众号@若川视野】也可以啊。\n\n你一般会很开心的 npm create vite@latest 初始化一个 vite 项目。\n\n那么你知道它的原理是什么吗？\n\n今天这篇文章就来带领大家一起学习其原理，源码400行不到。\n\n\n2. npm init && npm create#\n\nnpm init 文档有写。create 其实就是 init 的一个别名。\n\n也就是说 npm create vite@latest 相当于 => npx create-vite@latest，latest\n是版本号，目前最新版本可以通过以下命令查看。\n\n\n\n接着我们克隆 vite 项目，调试 packages/create-vite，分析其源码实现。\n\n\n3. 克隆项目 && 调试源码#\n\n之前文章写过，新手向：前端程序员必学基本技能——调试JS代码，这里就不赘述。\n\n可以直接克隆我的项目调试。同时欢迎 star 一下。 看开源项目，一般先看 README.md 和相应的 CONTRIBUTING.md。\n\n\n\n贡献文档中也详细写了如何调试。\n\n调试截图：\n\n控制台输出：\n\n最终生成的文件：\n\n顺便提下我是如何保持 vite 记录的，其实用的git subtree。\n\n\n\n找到路径，packages/create-vite 看 package.json\n\n\n\ntype 类型指定为 module 说明是 ES Module。 bin 可执行命令为 create-vite 或 别名 cva。 我们可以知道主文件\nindex.js。 代码限制了较高版本的Nodejs。\n\n接着我们调试来看这个 index.js 文件。\n\n\n4. 主流程 init 函数拆分#\n\n\n\n\n4.1 输出的目标路径#\n\n\n\n4.1.1 延伸函数 formatTargetDir#\n\n替换反斜杠 / 为空字符串。\n\n\n\n\n4.2 prompts 询问项目名、选择框架，选择框架变体等#\n\nprompts 根据用户输入选择，代码有删减。\n\n\n\n\n4.3 重写已有目录/或者创建不存在的目录#\n\n\n\n4.3.1 延伸函数 emptyDir#\n\n递归删除文件夹，相当于 rm -rf xxx。\n\n\n\n\n4.4 获取模板路径#\n\n\n\n从模板里可以看出，目前还算是相对简陋的。比如没有配置 eslint prettier 等。如果你想为多个的 vite 项目，自动添加 eslint\nprettier。这里推荐vite-pretty-lint，为这个库我出了的源码共读第35期，还有别人参与后写的不错的文章如何为前端项目一键自动添加eslint\n和prettier的支持。\n\n\n\n\n4.5 写入文件函数#\n\n\n\n这里的 renameFiles，是因为在某些编辑器或者电脑上不支持.gitignore。\n\n\n\n4.5.1 延伸函数 copy && copyDir#\n\n如果是文件夹用 copyDir 拷贝\n\n\n\n\n4.6 根据模板路径的文件写入目标路径#\n\npackage.json 文件单独处理。 它的名字为输入的 packageName 或者获取。\n\n\n\n\n4.7 打印安装完成后的信息#\n\n\n\n4.7.1 延伸的 pkgFromUserAgent 函数#\n\n\n\n第一句 pkgFromUserAgent函数，是从使用了什么包管理器创建项目，那么就输出 npm/yarn/pnpm 相应的命令。\n\n\n\n\n5. 总结#\n\n再来回顾下控制台输出：\n\n到此我们就分析完了整体的流程。总体代码行数不多，不到400行。\n\n\n\n从 package.json 中看到，代码限制了较高版本的Nodejs，采用 ES Module，目前未涉及打包编译。\n\n为了保证轻量快速，源码中很多函数都是自己写的。比如校验项目名，有比较出名的\nvalidate-npm-package-name，vue-cli、create-react-app 中就是用的它。比如删除文件和文件夹，也是自己实现。\n\n依赖包很少。只依赖了三个包。 解析命令行的参数 minimist、 询问选择之类的 prompts、 终端颜色输出的库 kolorist\n\n测试用例本文未涉及，感兴趣的小伙伴可以看，路径：vite/packages/create-vite/tests/cli.spec.ts，采用的是 vitest。\n\n读完本文，你会发现日常使用 npm create vite 初始化 vite 项目，create-vite 才不到400行源码。\n\n我们也可以根据公司相关业务，开发属于自己的脚手架工具。\n\n如果觉得 Vite 项目模板不够，还可以自行修改添加，比如vite-pretty-lint这个库，就是一键为多个 vite 项目自动添加\neslint、prettier。\n\n有时我们容易局限于公司项目无法自拔，不曾看看开源世界，而且开源项目源码就在那里，如果真的有心愿意学，是能学会很多的。\n\n很多源码不是我们想象中的那么高深莫测。源码不应该成为我们的拦路虎，而应该是我们的良师益友。这也可以说是我持续组织源码共读活动的原因之一。\n\n> 本文项目，欢迎 star 和克隆调试学习。git clone https://github.com/ruochuan12/vite-analysis.git\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力~\n\n最后可以持续关注我@若川。关注我的公众号@若川视野。欢迎点此扫码加我微信 ruochuan02\n交流，参加由公众号@若川视野发起的，每周大家一起学习200行左右的源码共读活动，共同进步。\n\n我正在参与掘金技术社区创作者签约计划招募活动，点击链接报名投稿。","routePath":"/create-vite/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. npm init && npm create","id":"2-npm-init--npm-create","depth":2,"charIndex":745},{"text":"3. 克隆项目 && 调试源码","id":"3-克隆项目--调试源码","depth":2,"charIndex":953},{"text":"4. 主流程 init 函数拆分","id":"4-主流程-init-函数拆分","depth":2,"charIndex":1341},{"text":"4.1 输出的目标路径","id":"41-输出的目标路径","depth":3,"charIndex":1363},{"text":"4.1.1 延伸函数 formatTargetDir","id":"411-延伸函数-formattargetdir","depth":4,"charIndex":1379},{"text":"4.2 prompts 询问项目名、选择框架，选择框架变体等","id":"42-prompts-询问项目名选择框架选择框架变体等","depth":3,"charIndex":1427},{"text":"4.3 重写已有目录/或者创建不存在的目录","id":"43-重写已有目录或者创建不存在的目录","depth":3,"charIndex":1488},{"text":"4.3.1 延伸函数 emptyDir","id":"431-延伸函数-emptydir","depth":4,"charIndex":1514},{"text":"4.4 获取模板路径","id":"44-获取模板路径","depth":3,"charIndex":1564},{"text":"4.5 写入文件函数","id":"45-写入文件函数","depth":3,"charIndex":1752},{"text":"4.5.1 延伸函数 copy && copyDir","id":"451-延伸函数-copy--copydir","depth":4,"charIndex":1815},{"text":"4.6 根据模板路径的文件写入目标路径","id":"46-根据模板路径的文件写入目标路径","depth":3,"charIndex":1867},{"text":"4.7 打印安装完成后的信息","id":"47-打印安装完成后的信息","depth":3,"charIndex":1941},{"text":"4.7.1 延伸的 pkgFromUserAgent 函数","id":"471-延伸的-pkgfromuseragent-函数","depth":4,"charIndex":1960},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":2064}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":20,"title":"","content":"","routePath":"/create-vue/examples/__dirname","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"Vue 团队公开快如闪电的全新脚手架工具 create-vue，未来将替代 Vue-CLI，才300余行代码，学它！","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动，感兴趣的可以加我微信 ruochuan12\n> 参与，已进行两个多月，大家一起交流学习，共同进步。\n\n想学源码，极力推荐之前我写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue-next-release、vue-this等十余篇源码文章。\n\n> 美国时间 2021 年 10 月 7 日早晨，Vue 团队等主要贡献者举办了一个 Vue Contributor Days\n> 在线会议，蒋豪群（知乎胖茶，Vue.js 官方团队成员，Vue-CLI 核心开发），在会上公开了create-vue，一个全新的脚手架工具。\n\ncreate-vue使用npm init vue@next一行命令，就能快如闪电般初始化好基于vite的Vue3项目。\n\n本文就是通过调试和大家一起学习这个300余行的源码。\n\n阅读本文，你将学到：\n\n\n\n\n2. 使用 npm init vue@next 初始化 vue3 项目#\n\ncreate-vue github README上写着，An easy way to start a Vue project。一种简单的初始化vue项目的方式。\n\n\n\n估计大多数读者，第一反应是这样竟然也可以，这么简单快捷？\n\n忍不住想动手在控制台输出命令，我在终端试过，见下图。\n\n\n\n最终cd vue3-project、npm install 、npm run dev打开页面http://localhost:3000。\n\n\n\n\n2.1 npm init && npx#\n\n为啥 npm init 也可以直接初始化一个项目，带着疑问，我们翻看 npm 文档。\n\nnpm init\n\nnpm init 用法：\n\n\n\nnpm init 时转换成npx命令：\n\n * npm init foo -> npx create-foo\n * npm init @usr/foo -> npx @usr/create-foo\n * npm init @usr -> npx @usr/create\n\n看完文档，我们也就理解了：\n\n\n\n我们可以在这里create-vue，找到一些信息。或者在npm create-vue找到版本等信息。\n\n其中@next是指定版本，通过npm dist-tag ls create-vue命令可以看出，next版本目前对应的是3.0.0-beta.6。\n\n\n\n发布时 npm publish --tag next 这种写法指定 tag。默认标签是latest。\n\n可能有读者对 npx 不熟悉，这时找到阮一峰老师博客 npx 介绍、nodejs.cn npx\n\nnpx 是一个非常强大的命令，从 npm 的 5.2 版本（发布于 2017 年 7 月）开始可用。\n\n简单说下容易忽略且常用的场景，npx有点类似小程序提出的随用随走。\n\n轻松地运行本地命令\n\n\n\n使用不同的 Node.js 版本运行代码 某些场景下可以临时切换 node 版本，有时比 nvm 包管理方便些。\n\n\n\n无需安装的命令执行\n\n\n\n\n\n\n\nnpm init vue@next （npx create-vue@next）\n快的原因，主要在于依赖少（能不依赖包就不依赖），源码行数少，目前index.js只有300余行。\n\n\n3. 配置环境调试源码#\n\n\n3.1 克隆 create-vue 项目#\n\n本文仓库地址 create-vue-analysis，求个star~\n\n\n\n当然不克隆也可以直接用 VSCode 打开我的仓库\n\n顺带说下：我是怎么保留 create-vue 仓库的 git 记录的。\n\n\n\n关于更多 git subtree，可以看Git Subtree 简明使用手册\n\n\n3.2 package.json 分析#\n\n\n\nbin指定可执行脚本。也就是我们可以使用 npx create-vue 的原因。\n\noutfile.cjs 是打包输出的JS文件\n\n\n\n执行 npm run test 时，会先执行钩子函数 pretest。run-s 是 npm-run-all 提供的命令。run-s build\nsnapshot 命令相当于 npm run build && npm run snapshot。\n\n根据脚本提示，我们来看 snapshot.js 文件。\n\n\n3.3 生成快照 snapshot.js#\n\n这个文件主要作用是根据const featureFlags = ['typescript', 'jsx', 'router', 'vuex',\n'with-tests'] 组合生成31种加上 default 共计 32种 组合，生成快照在 playground目录。\n\n因为打包生成的 outfile.cjs 代码有做一些处理，不方便调试，我们可以修改为index.js便于调试。\n\n\n\n我们可以在for和 createProjectWithFeatureFlags 打上断点。\n\ncreateProjectWithFeatureFlags其实类似在终端输入如下执行这样的命令\n\n\n\n\n\n> 调试：VSCode打开项目，VSCode高版本(1.50+)可以在 create-vue/package.json => scripts =>\n> \"test\": \"node\n> test.js\"。鼠标悬停在test上会有调试脚本提示，选择调试脚本。如果对调试不熟悉，可以看我之前的文章koa-compose，写的很详细。\n\n调试时，大概率你会遇到：create-vue/index.js 文件中，__dirname 报错问题。可以按照如下方法解决。在 import\n的语句后，添加如下语句，就能愉快的调试了。\n\n\n\n接着我们调试 index.js 文件，来学习。\n\n\n4. 调试 index.js 主流程#\n\n回顾下上文 npm init vue@next 初始化项目的。\n\n\n\n单从初始化项目输出图来看。主要是三个步骤。\n\n\n\n\n\n\n4.1 解析命令行参数#\n\n\n\nminimist\n\n简单说，这个库，就是解析命令行参数的。看例子，我们比较容易看懂传参和解析结果。\n\n\n\n比如\n\n\n\n\n4.2 如果设置了 feature flags 跳过 prompts 询问#\n\n这种写法方便代码测试等。直接跳过交互式询问，同时也可以省时间。\n\n\n\n\n4.3 交互式询问一些配置#\n\n如上文npm init vue@next 初始化的图示\n\n * 输入项目名称\n * 还有是否删除已经存在的同名目录\n * 询问使用需要 JSX Router vuex cypress 等。\n\n\n\n\n4.4 初始化询问用户给到的参数，同时也会给到默认值#\n\n\n\n\n4.5 根据模板文件生成初始化项目所需文件#\n\n\n\n\n4.6 渲染生成代码模板#\n\n\n\n\n4.7 如果配置了需要 ts#\n\n重命名所有的 .js 文件改成 .ts。 重命名 jsconfig.json 文件为 tsconfig.json 文件。\n\njsconfig.json 是VSCode的配置文件，可用于配置跳转等。\n\n把index.html 文件里的 main.js 重命名为 main.ts。\n\n\n\n\n4.8 配置了不需要测试#\n\n因为所有的模板都有测试文件，所以不需要测试时，执行删除 cypress、/__tests__/ 文件夹\n\n\n\n\n4.9 根据使用的 npm / yarn / pnpm 生成README.md 文件，给出运行项目的提示#\n\n\n\n\n5. npm run test => node test.js 测试#\n\n\n\n主要对生成快照时生成的在 playground 32个文件夹，进行如下测试。\n\n\n\n\n6. 总结#\n\n我们使用了快如闪电般的npm init vue@next，学习npx命令了。学会了其原理。\n\n\n\n快如闪电的原因在于依赖的很少。很多都是自己来实现。如：Vue-CLI中 vue create vue-project\n命令是用官方的npm包validate-npm-package-name，删除文件夹一般都是使用 rimraf。而 create-vue\n是自己实现emptyDir和isValidPackageName。\n\n非常建议读者朋友按照文中方法使用VSCode调试 create-vue 源码。源码中还有很多细节文中由于篇幅有限，未全面展开讲述。\n\n学完本文，可以为自己或者公司创建类似初始化脚手架。\n\n目前版本是3.0.0-beta.6。我们持续关注学习它。除了create-vue 之外，我们还可以看看create-vite、create-umi 的源码实现。\n\n最后欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。\n\n\n7. 参考资料#\n\n发现 create-vue 时打算写文章加入到源码共读计划中，大家一起学习。而源码共读群里小伙伴upupming比我先写完文章。\n\n@upupming vue-cli 将被 create-vue 替代？初始化基于 vite 的 vue3 项目为何如此简单？","routePath":"/create-vue/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 使用 npm init vue@next 初始化 vue3 项目","id":"2-使用-npm-init-vuenext-初始化-vue3-项目","depth":2,"charIndex":491},{"text":"2.1 npm init && npx","id":"21-npm-init--npx","depth":3,"charIndex":746},{"text":"3. 配置环境调试源码","id":"3-配置环境调试源码","depth":2,"charIndex":1489},{"text":"3.1 克隆 create-vue 项目","id":"31-克隆-create-vue-项目","depth":3,"charIndex":1504},{"text":"3.2 package.json 分析","id":"32-packagejson-分析","depth":3,"charIndex":1672},{"text":"3.3 生成快照 snapshot.js","id":"33-生成快照-snapshotjs","depth":3,"charIndex":1918},{"text":"4. 调试 index.js 主流程","id":"4-调试-indexjs-主流程","depth":2,"charIndex":2522},{"text":"4.1 解析命令行参数","id":"41-解析命令行参数","depth":3,"charIndex":2606},{"text":"4.2 如果设置了 feature flags 跳过 prompts 询问","id":"42-如果设置了-feature-flags-跳过-prompts-询问","depth":3,"charIndex":2682},{"text":"4.3 交互式询问一些配置","id":"43-交互式询问一些配置","depth":3,"charIndex":2758},{"text":"4.4 初始化询问用户给到的参数，同时也会给到默认值","id":"44-初始化询问用户给到的参数同时也会给到默认值","depth":3,"charIndex":2873},{"text":"4.5 根据模板文件生成初始化项目所需文件","id":"45-根据模板文件生成初始化项目所需文件","depth":3,"charIndex":2905},{"text":"4.6 渲染生成代码模板","id":"46-渲染生成代码模板","depth":3,"charIndex":2932},{"text":"4.7 如果配置了需要 ts","id":"47-如果配置了需要-ts","depth":3,"charIndex":2950},{"text":"4.8 配置了不需要测试","id":"48-配置了不需要测试","depth":3,"charIndex":3110},{"text":"4.9 根据使用的 npm / yarn / pnpm 生成README.md 文件，给出运行项目的提示","id":"49-根据使用的-npm--yarn--pnpm-生成readmemd-文件给出运行项目的提示","depth":3,"charIndex":3181},{"text":"5. npm run test => node test.js 测试","id":"5-npm-run-test--node-testjs-测试","depth":2,"charIndex":3239},{"text":"6. 总结","id":"6-总结","depth":2,"charIndex":3321},{"text":"7. 参考资料","id":"7-参考资料","depth":2,"charIndex":3768}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":22,"title":"","content":"","routePath":"/debounce/debounce-underscore","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"","content":"从lodash源码学习节流与防抖 志遥：详解Lodash中的debounce和throttle JavaScript 函数节流和函数去抖应用场景辨析\nunderscore 函数去抖的实现 underscore 函数节流的实现 聊聊lodash的debounce实现 一图秒懂函数防抖和函数节流\n冴羽：JavaScript专题之跟着underscore学防抖 司徒正美：函数防抖与函数节流 修言：事件的节流（throttle）与防抖（debounce）","routePath":"/debounce/","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"","content":"","routePath":"/debounce/lodash/debounce","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"","content":"","routePath":"/debounce/lodash/freeGlobal","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"","content":"","routePath":"/debounce/lodash/","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":27,"title":"","content":"","routePath":"/debounce/lodash/isObject","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"","content":"","routePath":"/debounce/lodash/root","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"","content":"","routePath":"/debounce/lodash/throttle","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"","content":"","routePath":"/debounce/tempCodeRunnerFile","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"新手向：前端程序员必学基本技能——调试JS代码","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动，感兴趣的可以加我微信 ruochuan12\n> 参与，如今已进行三个月，大家一起交流学习，共同进步，很多人都表示收获颇丰。\n\n想学源码，极力推荐之前我写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等10余篇源码文章。\n\n最近组织了源码共读活动，公众号：若川视野，回复\"源码\"参与，每周大家一起学习200行左右的源码，共同进步。常有小伙伴在微信群里提关于如何调试的问题，而我写的调试\n方法基本分散在其他文章中。所以特此写一篇关于调试的文章。此外，之后写文章也可以少写些调试相关的，只需持续更新这篇文章。\n\n本文仓库地址，求个star\n\n阅读本文，你将学到：\n\n\n\n\n2. 推荐安装或者更新到最新版 VSCode#\n\n官网下载安装 VSCode。\n\n> 如果你的VSCode不是中文（不习惯英文），可以安装简体中文插件。 如果 VSCode 没有这个调试功能。建议更新到最新版的 VSCode（目前最新版本\n> v1.62.2）。\n\n\n3. 配置 auto-attach#\n\nVSCode 调试 JS 的方法有很多，目前比较推荐的就是无需配置的 auto-attach。\n\n默认无需配置，超级好用\n\n按 ctrl + shift + p，打开输入 >auto attach。默认是智能（smart）。如果不是，可以查看设置成智能，或者根据场景自行设置成其他的。\n\n\n\n\n\n更多可以查看官方文档：nodejs-debugging\n\n\n4. 调试 Node.js 代码#\n\n我特意新建了一个仓库。供读者动手实践。\n\n\n\n一般来说，从 package.json 文件查看入口，其中 main 字段会说明入口文件是什么。同时查看 scripts 脚本文件。\n\n一般提前在入口文件打好断点。\n\n\n4.1 调试操作方式#\n\n操作方式一：package.json\n\n在 package.json 找到相应的 scripts。鼠标悬浮在相应的命令上，会出现运行命令和调试命令两个选项，选择 调试命令 即可进入调试模式。或者点击\nscripts 上方的 调试，再选择相应的命令。也可以进入调试模式。\n\n\n\n操作方式二：终端命令\n\n通过快捷键 ctrl + 反引号 打开终端。或者通过 查看 —— 终端 打开 VSCode` 终端。\n\n在终端进入到目录。执行相应的脚本。\n\nVSCode 则会自动进入到调试模式。如下图所示：\n\n\n\n接着我们看按钮介绍。\n\n\n4.2 调试按钮介绍#\n\n详细解释下几个调试相关按钮。\n\n * 1. 继续（F5）: 点击后代码会直接执行到下一个断点所在位置，如果没有下一个断点，则认为本次代码执行完成。\n * 2. 单步跳过（F10）：点击后会跳到当前代码下一行继续执行，不会进入到函数内部。\n * 3. 单步调试（F11）：点击后进入到当前函数的内部调试，比如在 fn 这一行中执行单步调试，会进入到 fn 函数内部进行调试。\n * 4. 单步跳出（Shift + F11）：点击后跳出当前调试的函数，与单步调试对应。\n * 5. 重启（Ctrl + Shift + F5）：顾名思义。\n * 6. 断开链接（Shift + F5）：顾名思义。\n\n\n\n调试走到不是想看的文件时（或者完全不是这个目录下的文件时），可以选择单步退出按钮或者重新调试。\n\n\n5. 其他调试#\n\n由于很多项目都配置了代码压缩，难于调试。所以开发环境下，一般通过配置生成 sourcemap\n来调试代码。大部分开源项目（比如vue、vue-next源码）也会在贡献指南中说明如何开启 sourcemap。\n\n普通 webpack 配置\n\n\n\n调试 vue-cli 3+ 生成的项目。\n\nVuejs 官方文档调试\n\n\n\nchrome 调试代码其实也类似。在 chrome devtools 的 source 面板找到相应文件，去打断点再调试。\n\n\n6. 其他参考链接#\n\n如何调试代码看以下这些参考链接，动手练习可以学会，Node.js 也类似。\n\n前端容易忽略的 debugger 调试技巧\n\n慕课网调试课程\n\n掘金 chrome 免费小册\n\n慕课网 nodejs 调试入门\n\n\n7. 总结#\n\n文章比较详细的介绍了 VSCode 调试 Node.js 调试代码的基本技能，Chrome\n调试代码其实也是类似。调试代码是前端程序员基本技能，必须掌握。组织了源码共读活动发现很多人都不会，或者说不熟悉。让我感到十分诧异。所以写下这篇文章分享给读者。\n\n建议大家可以克隆我的项目，动手实践，多操作几次就熟悉了。\n\n\n\n最后可以持续关注我@若川。欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。","routePath":"/debug/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 推荐安装或者更新到最新版 VSCode","id":"2-推荐安装或者更新到最新版-vscode","depth":2,"charIndex":446},{"text":"3. 配置 auto-attach","id":"3-配置-auto-attach","depth":2,"charIndex":580},{"text":"4. 调试 Node.js 代码","id":"4-调试-nodejs-代码","depth":2,"charIndex":778},{"text":"4.1 调试操作方式","id":"41-调试操作方式","depth":3,"charIndex":905},{"text":"4.2 调试按钮介绍","id":"42-调试按钮介绍","depth":3,"charIndex":1181},{"text":"5. 其他调试","id":"5-其他调试","depth":2,"charIndex":1543},{"text":"6. 其他参考链接","id":"6-其他参考链接","depth":2,"charIndex":1777},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":1894}],"domain":"","frontmatter":{},"version":""},{"id":32,"title":"面试官：请手写一个带取消功能的延迟函数，axios 取消功能的原理是什么","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。为了能帮助到更多对源码感兴趣、想学会看源码、提升自己前端技术能力的同学。我倾力组织了源码共读活动，感兴趣的可以加我微信\n> ruochuan12 参与。每周大家一起学习200行左右的源码，共同进步，已进行4个月，很多人都表示收获颇丰。\n\n想学源码，极力推荐关注我写的专栏（目前1.9K人关注）《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等20余篇源码文章。\n\n本文仓库 https://github.com/ruochuan12/delay-analysis.git，求个star^_^\n\n源码共读活动 每周一期，已进行到17期。于是搜寻各种值得我们学习，且代码行数不多的源码。delay 主文件仅70多行，非常值得我们学习。\n\n阅读本文，你将学到：\n\n\n\n\n2. 环境准备#\n\n\n\n\n3. delay#\n\n我们从零开始来实现一个比较完善的 delay 函数。\n\n\n3.1 第一版 简版延迟#\n\n要完成这样一个延迟函数。\n\n3.1.1 使用#\n\n\n\n3.1.2 实现#\n\n用 Promise 和 setTimeout 结合实现，我们都很容易实现以下代码。\n\n\n\n我们要传递结果。\n\n\n3.2 第二版 传递 value 参数作为结果#\n\n3.2.1 使用#\n\n\n\n我们也很容易实现如下代码。传递 value 最后作为结果返回。\n\n3.2.2 实现#\n\n因此我们实现也很容易实现如下第二版。\n\n\n\n这样写，Promise 永远是成功。我们也需要失败。这时我们定义个参数 willResolve 来定义。\n\n\n3.3 第三版 willResolve 参数决定成功还是失败。#\n\n3.3.1 使用#\n\n\n\n3.3.2 实现#\n\n加个 willResolve 参数决定成功还是失败。于是我们有了如下实现。\n\n\n\n\n3.4 第四版 一定时间范围内随机获得结果#\n\n延时器的毫秒数是写死的。我们希望能够在一定时间范围内随机获取到结果。\n\n3.4.1 使用#\n\n\n\n3.4.2 实现#\n\n我们把成功 delay 和失败 reject 封装成一个函数，随机 range 单独封装成一个函数。\n\n\n\n实现到这里，相对比较完善了。但我们可能有需要提前结束。\n\n\n3.5 第五版 提前清除#\n\n3.5.1 使用#\n\n\n\n3.5.2 实现#\n\n声明 settle变量，封装 settle 函数，在调用 delayPromise.clear 时清除定时器。于是我们可以得到如下第五版的代码。\n\n\n\n\n3.6 第六版 取消功能#\n\n我们查阅资料可以知道有 AbortController 可以实现取消功能。\n\ncaniuse AbortController\n\nnpm abort-controller\n\nmdn AbortController\n\nfetch-abort\n\nfetch#aborting-requests\n\nyet-another-abortcontroller-polyfill\n\n3.6.1 使用#\n\n\n\n3.6.2 实现#\n\n\n\n\n3.7 第七版 自定义 clearTimeout 和 setTimeout 函数#\n\n3.7.1 使用#\n\n\n\n3.7.2 实现#\n\n传递 clearTimeout, setTimeout\n两个参数替代上一版本的clearTimeout，setTimeout。于是有了第七版。这也就是delay的最终实现。\n\n\n\n\n4. axios 取消请求#\n\naxios取消原理是：通过传递 config 配置 cancelToken 的形式，来取消的。判断有传cancelToken，在 promise 链式调用的\ndispatchRequest 抛出错误，在 adapter 中 request.abort() 取消请求，使 promise 走向\nrejected，被用户捕获取消信息。\n\n更多查看我的 axios 源码文章取消模块 学习 axios 源码整体架构，取消模块\n\n\n5. 总结#\n\n我们从零开始实现了一个带取消功能比较完善的延迟函数。也就是 delay 70多行源码的实现。\n\n包含支持随机时间结束、提前清除、取消、自定义 clearTimeout、setTimeout等功能。\n\n取消使用了 mdn AbortController ，由于兼容性不太好，社区也有了相应的 npm abort-controller 实现 polyfill。\n\nyet-another-abortcontroller-polyfill\n\n建议克隆项目启动服务调试例子，印象会更加深刻。\n\n\n\n最后可以持续关注我@若川。欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，每周大家一起学习200行左右的源码，共同进步。","routePath":"/delay/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 环境准备","id":"2-环境准备","depth":2,"charIndex":467},{"text":"3. delay","id":"3-delay","depth":2,"charIndex":480},{"text":"3.1 第一版 简版延迟","id":"31-第一版-简版延迟","depth":3,"charIndex":520},{"text":"3.1.1 使用","id":"311-使用","depth":4,"charIndex":549},{"text":"3.1.2 实现","id":"312-实现","depth":4,"charIndex":562},{"text":"3.2 第二版 传递 value 参数作为结果","id":"32-第二版-传递-value-参数作为结果","depth":3,"charIndex":629},{"text":"3.2.1 使用","id":"321-使用","depth":4,"charIndex":655},{"text":"3.2.2 实现","id":"322-实现","depth":4,"charIndex":701},{"text":"3.3 第三版 willResolve 参数决定成功还是失败。","id":"33-第三版-willresolve-参数决定成功还是失败","depth":3,"charIndex":789},{"text":"3.3.1 使用","id":"331-使用","depth":4,"charIndex":823},{"text":"3.3.2 实现","id":"332-实现","depth":4,"charIndex":836},{"text":"3.4 第四版 一定时间范围内随机获得结果","id":"34-第四版-一定时间范围内随机获得结果","depth":3,"charIndex":889},{"text":"3.4.1 使用","id":"341-使用","depth":4,"charIndex":949},{"text":"3.4.2 实现","id":"342-实现","depth":4,"charIndex":962},{"text":"3.5 第五版 提前清除","id":"35-第五版-提前清除","depth":3,"charIndex":1057},{"text":"3.5.1 使用","id":"351-使用","depth":4,"charIndex":1072},{"text":"3.5.2 实现","id":"352-实现","depth":4,"charIndex":1085},{"text":"3.6 第六版 取消功能","id":"36-第六版-取消功能","depth":3,"charIndex":1173},{"text":"3.6.1 使用","id":"361-使用","depth":4,"charIndex":1371},{"text":"3.6.2 实现","id":"362-实现","depth":4,"charIndex":1384},{"text":"3.7 第七版 自定义 clearTimeout 和 setTimeout 函数","id":"37-第七版-自定义-cleartimeout-和-settimeout-函数","depth":3,"charIndex":1398},{"text":"3.7.1 使用","id":"371-使用","depth":4,"charIndex":1441},{"text":"3.7.2 实现","id":"372-实现","depth":4,"charIndex":1454},{"text":"4. axios 取消请求","id":"4-axios-取消请求","depth":2,"charIndex":1556},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":1784}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":33,"title":"面试官：项目中常用的 .env 文件原理是什么？如何实现？","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。正在参加掘金年度人气作者活动，可以点此帮我投票。为了能帮助到更多对源码感兴趣、想学会看源码、提升自己前端技术能力的同学。我倾力组织了源码共\n> 读活动，感兴趣的可以加我微信 ruochuan12 参与。每周大家一起学习200行左右的源码，已进行5个月。\n\n想学源码，极力推荐关注我写的专栏（目前2K人关注）《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等20余篇源码文章。\n\n本文仓库 https://github.com/ruochuan12/dotenv-analysis.git，求个star^_^\n\n源码共读活动 每周一期，已进行到18期。于是搜寻各种值得我们学习，且代码行数不多的源码。dotenv 主文件仅118行，非常值得我们学习。\n\n阅读本文，你将学到：\n\n\n\n\n2. 环境准备#\n\n\n\n如果需要对源码进行调试，可以看我的这篇文章：新手向：前端程序员必学基本技能——调试JS代码，这里就不再赘述了。\n\n\n3. dotenv 的作用#\n\ndotenv\n\nDotenv 是一个零依赖模块，可将 .env 文件中的环境变量加载到 process.env 中。\n\n如果需要使用变量，则配合如下扩展包使用。\n\ndotenv-expand\n\n众所周知，.env 文件在我们项目中非常常见，在 vue-cli 和 create-react-app 中都有使用。\n\nvue-cli .env\n\ncreate-react-app .env\n\n\n4. .env 文件使用#\n\n我们项目中经常会用到.env 文件写法：\n\n\n\n单从这个文件来看，我们可以知道有如下功能需要实现：\n\n 1. 读取 .env 文件\n 2. 解析 .env 文件拆成键值对的对象形式\n 3. 赋值到 process.env 上\n 4. 最后返回解析后得到的对象\n\n\n5. 简单实现#\n\n根据分析问题，我们最终可以简单把代码实现如下：\n\n\n\n\n6. 继续完善 config 函数#\n\n简版的 config 函数还缺失挺多功能，比如：\n\n\n\n根据功能，我们很容易实现以下代码：\n\n\n\ndotenv 源码中，parse 函数主要是一些正则和单双引号、跨平台等细致处理。这里就暂时不阐述，读者朋友可以查看dotenv 源码。\n\n\n7. 总结#\n\n鉴于文章不宜过长，文章只比较深入的分析了 config 函数。parse 函数目前没有深入分析。\n\n一句话总结 dotenv 库的原理。用 fs.readFileSync 读取 .env 文件，并解析文件为键值对形式的对象，将最终结果对象遍历赋值到\nprocess.env 上。\n\n我们也可以不看 dotenv 源码，根据 api 倒推，自己来实现这样的功能。最终看看和 dotenv 源码本身有什么差别。这样也许更能锻炼自己。或者用 ts\n重构它。\n\n本文同时也给我们启发：围绕工作常用的技术包和库值得深入学习，做到知其然，知其所以然。\n\n值得一提的是：dotenv 源码使用的是 flow 类型。vue2 源码也是用的 flow。vue3 源码改用 ts了。\n\n最后可以持续关注我@若川。欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，每周大家一起学习200行左右的源码，共同进步。","routePath":"/dotenv/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 环境准备","id":"2-环境准备","depth":2,"charIndex":476},{"text":"3. dotenv 的作用","id":"3-dotenv-的作用","depth":2,"charIndex":546},{"text":"4. .env 文件使用","id":"4-env-文件使用","depth":2,"charIndex":757},{"text":"5. 简单实现","id":"5-简单实现","depth":2,"charIndex":904},{"text":"6. 继续完善 config 函数","id":"6-继续完善-config-函数","depth":2,"charIndex":942},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":1082}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":34,"title":"每次新增页面复制粘贴？100多行源码的 element-ui 新增组件功能告诉你减少重复工作","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。最近组织了源码共读活动，感兴趣的可以加我微信 ruochuan12\n> 参与，或者关注我的公众号若川视野，回复“源码”参与。已进行三个月，大家一起交流学习，共同进步，很多人都表示收获颇丰。\n\n想学源码，极力推荐之前我写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等10余篇源码文章。\n\n本文仓库 element-analysis，求个star^_^\n\n最近组织了源码共读活动，大家一起学习源码，每周学习200行左右的源码，已进行到13期。于是搜寻各种值得我们学习，且代码行数不多的源码。\n\n其中 element-ui 新建组件的源码 仅 100多行，非常值得我们学习。\n\n> 可以通过 github1s.com 在线 VSCode\n> 打开：https://github1s.com/ElemeFE/element/blob/dev/build/bin/new.js\n\n阅读本文，你将学到：\n\n\n\n\n2. 环境准备#\n\n\n2.1 克隆#\n\n\n\n\n2.2 看开源项目的 README 和贡献文档等#\n\n看开源项目，我们一般先看README，README.md 中一般有贡献指南。\n\n开发环境搭建\n\n> 首先你需要 Node.js 4+，yarn 和 npm 3+。注意：我们使用 yarn 进行依赖版本的锁定，所以请不要使用 npm install\n> 安装依赖。\n\n\n\npackage.json\n\n\n\n在 npm run dev 时是先执行了 npm run bootstrap => yarn || npm i 命令，安装好了依赖。\n\nnpm run build:file 应该留着下一篇文章讲述。\n\n组件开发规范\n\n> 通过 make new 创建组件目录结构，包含测试代码、入口文件、文档 如果包含父子组件，需要更改目录结构，参考 Button\n> 组件内如果依赖了其他组件，需要在当前组件内引入，参考 Select\n\nmake 命令的配置对应根目录 Makefile。\n\n\n\n通过查看 Makefile 文件我们知道了make new命令对应的是： node build/bin.new.js。\n\n接着我们来调试源码。\n\n\n2.3 调试源码#\n\n在最新版的 VSCode 中，auto attach 功能，默认支持智能调试，如果发现不支持，可以通过快捷键 ctrl + shift + p 查看是否启用。\n\nctrl + 快捷键打开终端。输入如下命令，即可调试 build/bin/new.js`。\n\n\n\n\n\n更多调试细节可以看我的这篇文章：新手向：前端程序员必学基本技能——调试JS代码\n\n接着我们按调试来看主流程。\n\n\n3. 主流程#\n\n我看完 build/bin/new.js 源码画了一张流程图。毕竟俗话说得好，一图胜千言。\n\n\n\n同时执行完命令后也新增和修改了若干文件，git diff 如下图所示。\n\n\n\n接着我们来看 build/bin/new.js 文件。\n\n\n3.1 文件开头判断#\n\n\n\n关于 process 对象可以查看 阮一峰老师 process 对象\n\n> process.argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是\n> node，第二个成员是脚本文件名，其余成员是脚本文件的参数。\n\n接着我们来看，引用的依赖等。\n\n\n3.2 引用依赖等#\n\n\n\n其中 file-save 依赖，顾名思义，且非常关键。我们可以在 node_module/file-save 查看一些信息。 也可以在\nhttps://npmjs.com 搜索其信息。\n\n接着，我们来看文件模板。定义了若干文件模板，方便写入到项目中。\n\n\n3.3 文件模板 Files#\n\n\n\n接着我们继续看添加对应的路径到组件 json 配置中。\n\n\n3.4 把 componentname 添加到 components.json#\n\n\n\n\n\n\n3.5 把 componentname.scss 添加到 index.scss#\n\n\n\n\n3.6 把 componentname.d.ts 添加到 element-ui.d.ts#\n\n\n\n\n3.7 创建 package#\n\n\n\n\n\n\n3.8 把新增的组件添加到 nav.config.json#\n\n\n\n\n\nnav.config.json 的修改，新增的组件显示在导航这里。其中有四次修改是对应四种语言。\n\n\n\n\n4. 总结#\n\n再次放出开头的流程图。\n\n通过看 element-ui 新建组件的源码 流程，我们学到了 file-save 这么方便的写入文件的库等。\n\n同时给我们启发：公司项目新建页面时，或者组件库新增组件时，是不是可以类似做到的，一条命令省去一些繁杂重复的操作。\n\n建议读者克隆我的仓库动手实践调试源码学习。\n\n后续也可以查看 file-save 源码实现等。\n\n最后可以持续关注我@若川。欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。","routePath":"/element-new/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 环境准备","id":"2-环境准备","depth":2,"charIndex":538},{"text":"2.1 克隆","id":"21-克隆","depth":3,"charIndex":549},{"text":"2.2 看开源项目的 README 和贡献文档等","id":"22-看开源项目的-readme-和贡献文档等","depth":3,"charIndex":561},{"text":"2.3 调试源码","id":"23-调试源码","depth":3,"charIndex":1054},{"text":"3. 主流程","id":"3-主流程","depth":2,"charIndex":1254},{"text":"3.1 文件开头判断","id":"31-文件开头判断","depth":3,"charIndex":1381},{"text":"3.2 引用依赖等","id":"32-引用依赖等","depth":3,"charIndex":1534},{"text":"3.3 文件模板 Files","id":"33-文件模板-files","depth":3,"charIndex":1676},{"text":"3.4 把 componentname 添加到 components.json","id":"34-把-componentname-添加到-componentsjson","depth":3,"charIndex":1725},{"text":"3.5 把 componentname.scss 添加到 index.scss","id":"35-把-componentnamescss-添加到-indexscss","depth":3,"charIndex":1772},{"text":"3.6 把 componentname.d.ts 添加到 element-ui.d.ts","id":"36-把-componentnamedts-添加到-element-uidts","depth":3,"charIndex":1817},{"text":"3.7 创建 package","id":"37-创建-package","depth":3,"charIndex":1867},{"text":"3.8 把新增的组件添加到 nav.config.json","id":"38-把新增的组件添加到-navconfigjson","depth":3,"charIndex":1889},{"text":"4. 总结","id":"4-总结","depth":2,"charIndex":1978}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":35,"title":"如何制定有价值的目标","content":"#\n\n> 写于2017年07月09日23:29\n\n> 公司会制定一系列目标，个人也可以制定一些目标，有利于自我学习成长。那么看我这篇文章可以告诉你如何制定有价值的目标。会制定有价值的目标，绝对超越很多人。\n\n\nSMART原则#\n\n王健林之前说定个小目标，先赚它一个亿。然后就火了一把，各种推文，主要是关于定计划的。我清晰得记得有一天早上，去上班时路过一所学校，广播里校长引用了王健林这句话。\n其实目标管理要量身定做，且有一定原则。这时召唤下同级校友做的一页PPT，SMART原则。\n\n\n\n如果转换成简单好记一点就是：什么时间内，做什么事情，做到什么程度。\n\n\n记录时间#\n\n不过定目标不是那么容易，可以试着记录自己一周的时间或者说一个月的时间都做了什么。关于如何记录可以利用艾力老师的 “34枚金币时间管理法”\n，通俗点讲就是一天17小时醒着，每半小时算一枚金币。记录了一个周时间后，就能发现自己什么时间在做什么。有一定针对性。\n\n比如你随便定了个计划，一个月内，把年中618买的四本书看完，并记笔记。你可能就会发现一个月内，一天只能抽出一小时看书，一小时最多能看50页。而一本书平均300页\n。这样粗略一算，6天才能看完一本，还不包括记笔记。所以一个月看不完四本。\n\n\n戴明环（PDCA）#\n\n有人说，计划赶不上变化，所以不做计划。有一种东西叫做戴明环（PDCA）。拆开来就是：计划(Plan)、实施(Do)、检查(Check)、行动(Action)。\n\n比如上面的例子，一个月看四本书。计划可能会被打断，去实施及时检查，再行动。也就是说原计划一个月看完4本书，每天看50页，发现看的这类书籍一小时完全看不完50页，\n就及时修正计划。看完就给自己一个小奖励（正反馈），比如吃一包麻辣冷静一下，这时再召唤一下我很早以前做的一张PPT（从修电脑中学到的万能学习模式）。\n\n\n\n这样虽然可能会延期到一个半月才看完，但这是有效的循环。定目标——定计划——执行计划——检查回顾——巩固循环——定目标。\n\n\n工具推荐#\n\n前面说了这么多，那么有没有工具来帮助我们定目标呢。答案是肯定的。\n\n非常推荐teambition，网站：https://www.teambition.com/\n\n推荐滴答清单，网站：https://www.dida365.com/\n\n最后推荐doit.im，网站：http://doitim.com/cn/\n\n这三款软件，都有APP，各大应用商店可供下载。\n\n这三款我都使用过，其中doit.im、滴答清单在大学期间用的比较多。现在用的比较多的是teambition，免费版也支持日历功能。大家可以根据自己实际情况选择适\n合自己的。\n\n\n总结#\n\n总结一下：【目标管理】如何制定有价值的目标。 主要写了四点：\n\n * ①SMART原则\n * ②记录时间（34枚金币时间管理法）\n * ③戴明环（PDCA）\n * ④工具推荐\n   * teambition\n   * 滴答清单\n   * doit.im\n\n希望对大家有所启发。\n\n这是我2017年在知识星球写的推文。\n\n> 知识星球前端视野\n> 若川简介：主要发表一些前端所见所想，Vue、React、构建工具(比如：gulp、webpack)、Nodejs、设计模式等。一个人走得快，一群人走得远。\n> 公众号文章不常更新，知识星球更新相对多一些。2017年开通至今，一直没怎么宣传，目前有960余人加入了我的知识星球，欢迎识别二维码免费加入。","routePath":"/goal/","lang":"zh","toc":[{"text":"SMART原则","id":"smart原则","depth":2,"charIndex":104},{"text":"记录时间","id":"记录时间","depth":2,"charIndex":279},{"text":"戴明环（PDCA）","id":"戴明环pdca","depth":2,"charIndex":535},{"text":"工具推荐","id":"工具推荐","depth":2,"charIndex":848},{"text":"总结","id":"总结","depth":2,"charIndex":1124}],"domain":"","frontmatter":{},"version":""},{"id":36,"title":"若川诚邀你加前端源码共读群，长期交流学习","content":"#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n微信扫码或搜索「若川视野」关注我，专注前端技术分享。江西人，某不那么知名的陶瓷大学毕业生，目前在杭州从事前端开发工作。常以若川为名混迹于江湖。更详细的可以点击关\n于我\n我历时很久写了《学习源码整体架构系列》20余篇文章，包含jQuery、underscore、lodash、sentry、vuex、axios、koa、redux\n、vue-devtools、vuex4、vue3 工具函数、vue3 发布、koa-compose、vue-this、create-vue、玩具 vite、神器\nni、vue-utils、open、promisify、element 初始化组件\n等源码，详细的写了我是如何看源码的，并且绘制了大量的关系图和原理图，应该算是比较好的学习源码的文章。更多可参考我的这篇知乎回答：有哪些必看的js库？\n\n> 我的博客地址：https://ruochuan12.github.io，建议加个书签，也可以百度搜索若川，找到我。\n\n另外，你可以在以下网站（点击图片跳转）关注我（你的关注是对我的肯定）：\n\n\n\n我运营了公众号「若川视野」，关注回复「pdf」限时获取前端优质书籍pdf。公众号经常更新，值得你关注学习，每天进步一点点。\n\n\n知乎高赞问答#\n\n若川知乎回答：做了两年前端开发，平时就是拿 Vue 写写页面和组件，简历的项目经历应该怎么写得好看？ 若川知乎问答：有哪些必看的js库？\n若川知乎回答：一年内的前端看不懂前端框架源码怎么办？ 若川知乎回答：怎么才能学好前端？ 如果觉得不错，可以点个赞^_^\n\n\n文章列表#\n\n * Taro 源码揭秘 - 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密\n * Taro 源码揭秘 - 2. 揭开整个架构的插件系统的秘密\n * Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么\n * Taro 4.0 已正式发布 - 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？\n * Taro 4.0 已发布 - 5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？\n * Taro 源码揭秘 - 6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?\n\nvant 组件库源码分析系列：\n\n * 分析 vant4 组件库源码，写一个常用的 highlight 高亮文本的组件\n\n * vant4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n * 分析 vant4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n\n * 分析 vant4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n\n * 跟着 vant4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n\n * vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n\n学习源码整体架构系列：\n\n * 48.开发小程序又一新选择 vue-mini，据说性能是 Taro 的 10 倍，遥遥领先\n\n * 47.神器啊，从未想过 VSCode 还能这样直接打开仓库URL，原理揭秘~\n\n * 46.自从学了 react-use 源码，我写自定义 React Hooks 越来越顺了~\n\n * 45.据说90%的人不知道可以用测试用例(Vitest)调试开源项目(Vue3) 源码\n\n * 44.经常用 vant-weapp 开发小程序，却不知道如何开发一个组件？学！\n\n * 43.vite 3.0 都发布了，经常初始化 vite 项目，却不知 create-vite 原理？揭秘！\n\n * 42.还在用开发者工具上传小程序? 快来试试 miniprogram-ci 提效摸鱼\n\n * 41.面试官：项目中常用的 .env 文件原理是什么？如何实现？\n\n * 40.面试官：请手写一个带取消功能的延迟函数，axios 取消功能的原理是什么\n\n * 39.Vue团队核心成员开发的39行小工具 install-pkg 安装包，值得一学！\n\n * 38.从 vue-cli 源码中，我发现了27行读取 json 文件有趣的 npm 包\n\n * 37.从 vue3 和 vite 源码中，我学到了一行代码统一规范团队包管理器的神器\n\n * 36.每次新增页面复制粘贴？100多行源码的 element-ui 新增组件功能告诉你减少重复工作\n\n * 35.新手向：前端程序员必学基本技能——调试JS代码\n\n * 34.从22行有趣的源码库中，我学到了 callback promisify 化的 Node.js 源码实现\n\n * 33.每次启动项目的服务，电脑竟然乖乖的帮我打开了浏览器，100行源码揭秘！\n\n * 32.初学者也能看懂的 Vue2 源码中那些实用的基础工具函数\n\n * 31.尤雨溪推荐神器 ni ，能替代 npm/yarn/pnpm ？简单好用！源码揭秘！\n\n * 30.尤雨溪几年前开发的“玩具 vite”，才100多行代码，却十分有助于理解 vite 原理\n\n * 29.Vue 团队公开快如闪电的全新脚手架工具 create-vue，未来将替代 Vue-CLI，才300余行代码，学它！\n\n * 28.为什么 Vue2 this 能够直接获取到 data 和 methods\n\n * 27.50行代码串行Promise，koa洋葱模型原来是这么实现？\n\n * 26.Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？\n\n * 25.初学者也能看懂的 Vue3 源码中那些实用的基础工具函数\n\n * 24.尤雨溪开发的 vue-devtools 如何安装，为何打开文件的功能鲜有人知？\n\n * 23.面对 this 指向丢失，尤雨溪在 Vuex 源码中是怎么处理的\n\n * 22.一文读懂vuex4源码，原来provide/inject就是妙用了原型链？\n\n * 21.据说 99% 的人不知道 vue-devtools 还能直接打开对应组件文件？本文原理揭秘\n\n * 20.学习 redux 源码整体架构，深入理解 redux 及其中间件原理\n\n * 19.学习 koa 源码的整体架构，浅析koa洋葱模型原理和co原理\n\n * 18.学习 axios 源码整体架构，打造属于自己的请求库\n\n * 17.学习 vuex 源码整体架构，打造属于自己的状态管理库\n\n * 16.学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK\n\n * 15.学习 lodash 源码整体架构，打造属于自己的函数式编程类库\n\n * 14.学习 underscore 源码整体架构，打造属于自己的函数式编程类库\n\n * 13.学习 jQuery 源码整体架构，打造属于自己的 js 类库\n\n面试官问系列：\n\n * 12.面试官问：JS的继承\n\n * 11.面试官问：JS的this指向\n\n * 10.面试官问：能否模拟实现JS的call和apply方法\n\n * 9.面试官问：能否模拟实现JS的bind方法\n\n * 8.面试官问：能否模拟实现JS的new操作符\n\n其他：\n\n * 7.前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并\n\n * 6.分析vue-cli@2.9.3 搭建的webpack项目工程\n\n * 5.oh my zsh 和 windows git bash 设置别名提高效率\n\n * 4.vue 2.x项目 vue-qriously 生成二维码并下载、cliploard复制粘贴\n\n * 3.参加有赞前端技术开放日所感所想\n\n * 2.JavaScript 对象所有API解析\n\n * 1.《JavaScript语言精粹 修订版》 读书笔记\n\n\n免费的知识星球 前端视野#\n\n主要发表一些前端所见所想，Vue、React、构建工具(比如：gulp、webpack)、设计模式等。一个人走得快，一群人走得远。","routePath":"/","lang":"zh","toc":[{"text":"知乎高赞问答","id":"知乎高赞问答","depth":2,"charIndex":672},{"text":"文章列表","id":"文章列表","depth":2,"charIndex":812},{"text":"免费的知识星球 前端视野","id":"免费的知识星球-前端视野","depth":2,"charIndex":3451}],"domain":"","frontmatter":{},"version":""},{"id":37,"title":"Vue团队核心成员开发的39行小工具 install-pkg 安装包，值得一学！","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。为了能帮助到更多对源码感兴趣、想学会看源码、提升自己前端技术能力的同学。我倾力组织了源码共读活动，感兴趣的可以加我微信\n> ruochuan12 参与，欢迎关注我的公众号若川视野。每周大家一起学习200行左右的源码，共同进步，已进行4个月，很多人都表示收获颇丰。\n\n想学源码，极力推荐关注我写的专栏（目前1.9K人关注）《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等20余篇源码文章。\n\n本文仓库 https://github.com/ruochuan12/install-pkg-analysis.git，求个star^_^\n\n源码共读活动 每周一期，已进行到16期。Vue团队核心成员 Anthony Fu 开发的 install-pkg 小工具，主文件源码仅39行，非常值得我们学习。\n\n阅读本文，你将学到：\n\n\n\n\n2. install-pkg 是什么#\n\nInstall package programmatically. Detect package managers automatically (npm,\nyarn and pnpm).\n\n以编程方式安装包。自动检测包管理器（npm、yarn 和 pnpm）。\n\n\n\n\n\n我们看看npmjs.com @antfu/install-pkg 有哪些包依赖的这个包。\n\n我们可以发现目前只有以下这两个项目使用了。\n\nunplugin-icons @chenyueban/lint\n\n我们克隆项目来看源码。\n\n\n3 克隆项目#\n\n\n\n看源码一般先看 package.json，再看 script。\n\n\n\n关于调试可以看我的这篇文章：新手向：前端程序员必学基本技能——调试JS代码，这里就不再赘述了。\n\n我们可以得知入口文件是 src/index.ts\n\nsrc文件夹下有三个文件\n\n\n\n接着我们看这些文件源码。\n\n\n4. 源码#\n\n\n4.1 index.js#\n\n导出所有\n\n\n\n我们来看 install.ts 文件，installPackage 方法。\n\n\n4.2 installPackage 安装包#\n\n\n\n支持安装多个，也支持指定包管理器，支持额外的参数。\n\n其中 github execa 是执行脚本\n\n> Process execution for humans\n\n也就是说：最终执行类似以下的脚本。\n\n\n\n我们接着来看 detect.ts文件 探测包管理器 detectPackageManager 函数如何实现的。\n\n\n4.3 detectPackageManager 探测包管理器#\n\n根据当前目录锁文件，探测包管理器。\n\n\n\n其中 find-up 查找路径。\n\n\n\n\n\npath.basename('/Users/install-pkg/pnpm-lock.yaml') 则是 pnpm-lock.yaml。\n\n所以在有pnpm-lock.yaml文件的项目中，detectPackageManager 函数最终返回的是 pnpm。\n\n至此我们可以用一句话总结原理就是：通过锁文件自动检测使用何种包管理器（npm、yarn、pnpm），最终用 execa 执行类似如下的命令。\n\n\n\n看完源码，我们接着来解释下 package.json 中的 scripts 命令。\n\n\n5. package.json script 命令解析#\n\n\n\n\n5.1 ni 神器#\n\ngithub ni\n\n我之前写过源码文章。\n\n尤雨溪推荐神器 ni ，能替代 npm/yarn/pnpm ？简单好用！源码揭秘！\n\n自动根据锁文件 yarn.lock / pnpm-lock.yaml / package-lock.json 检测使用 yarn / pnpm / npm\n的包管理器。\n\n\n\n\n\nnci - clean install\n\n\n\npnpm install --frozen-lockfile\n\n\n5.2 esno 运行 ts#\n\nesno\n\nTypeScript / ESNext node runtime powered by esbuild\n\n源码也不是很多。\n\n\n\nesbuild-register 简单说：使用 esbuild 即时传输 JSX、TypeScript 和 esnext 功能\n\n\n5.3 tsup 打包 ts#\n\n打包 TypeScript 库的最简单、最快的方法。\n\ntsup\n\n\n5.4 bumpp 交互式提升版本号#\n\nbumpp\n\nversion-bump-prompt\n\n交互式 CLI 可增加您的版本号等\n\n\n5.5 eslint 预设#\n\neslint 预设\n\n\n\n添加 .eslintrc 文件\n\n\n\n之前看其他源码发现的也很好用的 eslint 工具 xo\n\nxo\n\n> JavaScript/TypeScript linter (ESLint wrapper) with great defaults\n> JavaScript/TypeScript linter（ESLint 包装器）具有很好的默认值\n\n看完 scripts 命令解析，我们来看看 github action 配置。\n\n\n6. github action workflows#\n\n对于github action 不熟悉的读者，可以看阮一峰老师 GitHub Actions 入门教程\n\n配置文件workflows/release\n\n构建历史github action workflow\n\n\n\n根据每次 tags 推送，执行。\n\n\n\n\n\nnci - clean install\n\n\n\n最后 npx conventional-github-releaser -p angular conventional-github-releaser\n\n生成 changelog。\n\n至此我们就学习完了 install-pkg 包。\n\n\n7. 总结#\n\n整体代码比较简单。原理就是通过锁文件自动检测使用何种包管理器（npm、yarn、pnpm），最终用 execa 执行类似如下的命令。\n\n\n\n我们学到了：\n\n\n\n还有各种依赖工具。\n\n建议读者克隆 我的仓库 动手实践调试源码学习。\n\n最后可以持续关注我@若川。欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，每周大家一起学习200行左右的源码，共同进步。","routePath":"/install-pkg/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. install-pkg 是什么","id":"2-install-pkg-是什么","depth":2,"charIndex":499},{"text":"3 克隆项目","id":"3-克隆项目","depth":2,"charIndex":772},{"text":"4. 源码","id":"4-源码","depth":2,"charIndex":924},{"text":"4.1 index.js","id":"41-indexjs","depth":3,"charIndex":933},{"text":"4.2 installPackage 安装包","id":"42-installpackage-安装包","depth":3,"charIndex":996},{"text":"4.3 detectPackageManager 探测包管理器","id":"43-detectpackagemanager-探测包管理器","depth":3,"charIndex":1184},{"text":"5. package.json script 命令解析","id":"5-packagejson-script-命令解析","depth":2,"charIndex":1512},{"text":"5.1 ni 神器","id":"51-ni-神器","depth":3,"charIndex":1545},{"text":"5.2 esno 运行 ts","id":"52-esno-运行-ts","depth":3,"charIndex":1769},{"text":"5.3 tsup 打包 ts","id":"53-tsup-打包-ts","depth":3,"charIndex":1923},{"text":"5.4 bumpp 交互式提升版本号","id":"54-bumpp-交互式提升版本号","depth":3,"charIndex":1975},{"text":"5.5 eslint 预设","id":"55-eslint-预设","depth":3,"charIndex":2044},{"text":"6. github action workflows","id":"6-github-action-workflows","depth":2,"charIndex":2288},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":2587}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":38,"title":"《JavaScript语言精粹 修订版》 读书笔记","content":"#\n\n> 写于2017年07月23日\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 之前看到这篇文章，前端网老姚浅谈：怎么学JavaScript？，说到怎么学习JavaScript，那就是看书、分析源码。\n> 10本书读2遍的好处，应该大于一本书读20遍。 看书主动学习，看视频是被动学习。\n> 看书和分析源码的时机。但已经工作一年半载时，正是提高的好时候，此时可以去看书了。全面系统的梳理知识点，扫清自己的盲区。如果只是靠项目经验是不够的，通过项目来\n> 学习，那>肯定是必须的，工作本身就是一个学习的过程。 **怎么把一本书看完呢？**很简单，敲。文字加代码都敲。\n> 比较认同老姚的说法。去年毕业到现在，我也算是工作一年了，是时候看书查缺补漏了。\n\n于是我就先把这本薄的经典书《JavaScript语言精粹\n修订版》豆瓣读书本书简介（总共10章，除去附录，才100页），读完并记录了一些笔记。基本算是摘抄书本的，自己联想到了一些知识和资料也扩展了一下。总体写下来近一万\n字。读书笔记还可以分享给别人看。回顾时，书不在身边还可以看看自己的笔记。想想这类经典书记一遍动手敲一遍也是很值得的。不过这读书笔记中可能会有一些错别字，阅读时如\n果发现欢迎指正。\n\n\n第1章 精华#\n\n大多数语言都有精华和糟粕。JavaScript令人诡异的事情是，在对这门语言没有的太多了解，甚至对编程都没有太多了解的情况下，你也能用它来完成工作。\n看到这里不禁想起：\n\n> 张鑫旭大牛在《我对知乎前端相关问题的十问十答》 非计算机专业背景学习JS要点有这一条：\n> 所有继承和原型相关内容跳过，注意，是跳过，不要看！没有这些JS一样可以活得很好，你的日常工作一样玩得飞起，当然，你没忍住看了相关知识也没关系，因为你会发现自\n> 己看不懂的；\n\nJavaScript的函数是（主要）基于词法作用域的顶级对象。\n\n> 译注：JavaScript中的函数是根据词法来划分作用域的，而不是动态划分作用域的。具体内容参见《JavaScript权威指南》中译第5版相关章节“8.8.\n> 1 词法作用域”。 JavaScript有非常强大的对象字面量表示法。这种表示法是JSON的灵感来源。 原型继承是JavaScript中一个有争议的特性。\n\n《ECMAScript编程语言》第3版定义了JavaScript的标准。 ES3标准 扩展：颜海镜大牛整理的ES3中文版 颜海镜大牛整理的ES5中文版 W3c\nES5中文版 阮一峰大牛的书籍《ES6标准入门2》 更多内容可参见这篇文章：ECMAScript 2018 标准导读\n\n一个简单的例子：\n\n\n\n书中贯彻始终都会用到这个method方案，作者将会在第4章解释它。\n\n\n第2章 语法#\n\n本章主要用铁路图（语法图）表示语法。 主要有：空白、标识符、数字、字符串、语句、表达式、字面量、函数。 typeof 运算符产生的值有'number',\n'string','boolean','u\nndefined','function','object'。如果运算数是一个数组或者是null,那么结果是'object',这其实是不对的。\n\n\n第3章 对象#\n\nJavaScript简单数据类型包括数字、字符串、布尔值，null值和undefined值。其他所有值都是对象。\n数组、字符串和布尔值“貌似”对象，因为它们拥有方法（包装对象），但它们是不可变的。\n对象是属性的容器，其中每个属性都拥有名字和值。属性名可以是包括空字符串在内的所有字符串，属性值可以是除了undefined值之外的任何值。\n\nJavaScript包含一种原型链的特性，允许对象继承到另一个对象的属性。正确地使用它能减少对象初始化时的消耗的时间和内存。 检索\n.,[]两种检索方式，推荐点.表示法。 尝试重undefined的成员属性中取值将会导致TypeError异常，这时可以通过&&来避免错误。 更新\n如果属性名已经存在对象里。那么属性的值会被替换。如果之前没有拥有那个属性名，那么该属性将被扩充到对象中。 引用 对象通过引用来传递。它们永远不会被复制。 原型\n所有通过对象字面量创建的对象都链接到Object.prototype。 创建新对象时，可以选择某个对象作为它的原型。\n\n\n\n原型连接只有在检索值的时候才被用到。如果尝试去获取对象的某个属性值，但对象没有此属性名，那么JavaScript会试着从原型对象中获取属性值。如果那个原型对象也\n没有该属性，那么再从它的原型中寻找，依此类推，直到该过程最后达到终点Object.prototype。如果想要的属性完全不存在原型链中，那么结果就是\nundefined值。这个过程称为委托。 原型关系是一种动态的关系。 反射 原型链上的所有属性都会产生值。有两种方案可以处理掉对象上不需要的属性。\n①程序检查时丢弃值为函数的属性。但有可能有些值确实是函数，所以该方法不可靠。\n②使用hasOwnProperty方法，如果是对象拥有独有的属性，则返回true。该方法不会检查原型链。 枚举 ① for\nin可以遍历一个对象中所有的属性名。但包含函数和一些不关心的原型中属性。而且顺序不确定，可以用 hasOwnProperty方法和typeof排除函数。\n②for 循环不会出现for in那些情况。 删除 delete运算符可以用来删除对象的属性。 减少全局变量的污染\n可以把全局性的资源纳入一个名称空间之下。这样做能减少冲突。\n\n\n第4章 函数#\n\n函数用于①代码复用②信息隐藏③组合调用。一般来说，所谓编程，就是将一组需求分节成一组函数与数据结构的技能。 JavaScript的函数就是对象。\n函数对象连接到Function.prototype(该原型对象本身连接到Object.prototype)。\n每个函数在创建时会附加两个隐藏属性，函数的上下文和实现函数行为的代码。\n每个函数对象在创建时也随配有一个prototype属性。它的值是一个拥有constructor属性且值为该函数的对象。 函数字面量\n函数字面量包括4个部分。①保留字function②函数名，可以省略，③一组参数④一组语句。\n函数字面量可以出现在任何允许表达式出现的地方。一个内部函数除了可以访问自己的参数和变量，同时也可以自由访问把它嵌套在其中的父函数的参数和变量。通过函数字面量创建\n的函数对象包含一个连接到外部上下文的连接。这被称为闭包。 调用\n除了声明时定义的形式参数，每一个函数还接收两个附加的参数：this和argument。在JavaScript中一共有四种调用模式。①方法调用模式，②函数调用模式\n③构造器调用模式④apply调用模式。\n\n（this指向问题一直困扰很多人。我一般是这样记的，谁调用this就指向谁。）\n\n方法调用模式 对象的方法执行,this指向该对象。比如：\n\n\n\n函数调用模式\n\n\n\n有种简单的办法就是var that = this;把this存储下。 例：\n\n\n\n构造器调用模式 JavaScript是一门基于原型继承的语言。 如果在一个函数前面带上new\n来调用。那么背地利将会创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到那个新对象上。 new 前缀也会改变return 语句的行为。\n例：\n\n\n\n一个函数，如果创建的目的就是希望结合new\n前缀来调用。那么它就被称为构造器函数。按照约定，它们保存在以大写函数命名的变量里。如果调用构造器函数时没有在前面加上new,可能会发生非常糟糕的事情，既没有编译\n时的警告，也没有运行时广告，所以大写约定非常重要。 作者不推荐这种形式的构造器函数。有更好的替代方式。 Apply调用模式\nJavaScript是一门函数式的面向对象编程语言，所以对象可以拥有方法。 apply方法让我们构建一个参数数组传递给调用函数，它也允许我们选择this的值。\n参数 arguments，虽然拥有length属性，但不是真正的数组。而是类似数组（array-like）的对象。 返回 return\n可用来是函数提前返回。当return 被执行时，函数立即返回而不再执行余下的语句。 一个函数总会返回一个值，如果没指定，那就是返回undefined值。\n如果函数调用时在前面加上了new 前缀，且返回值不是一个对象，则返回this（该新对象）。 异常 JavaScript提供了一套异常处理机制。\nthrow语句和try catch,try catch中finally是可选的。 扩展类型的功能\nJavaScript允许给语言的基本类型扩充功能。在第3章中我们已经看到，可以通过Object.prototype添加方法，可以让该方法对所有对象都可用。这样的\n方式对函数、数组、字符串、数字、正则表达式和布尔值同样适用。\n\n例如：\n\n\n\n基本类型的原型是公用结构，所以在类库混用时务必小心。一个保险的做法就是只在确认没有该方法时才添加它。\n\n\n\n递归\n递归函数就是会直接或间接地调用自身的一种函数。递归是一种强大的编程技术，递归是用一般的方式去解决每一个子问题。书中举了一个汉诺塔的例子，是程序设计中经典递归问题\n。详细说明可以参见 百度百科“汉诺塔”词条。 一些语言提供了尾递归优化。尾递归是一种在函数的最后执行调用语句的特殊形式的递归。参见Tail call。\nES6版本扩展了尾递归。参见阮一峰老师的《ES6标准入门》中的尾调用优化 作用域 在编程语言中，作用域控制着变量与参数的可见性和声明周期。\n书中指出当前JavaScript没有块级作用域。因为没有块级作用域，所以最好的做法是在函数体的顶部声明函数中可能用到的所有变量。不过ES6扩展了有块级作用域。\n闭包 作用域的好处是内部函数可以访问定义它们的外部函数的参数和变量（除了this和arguments）。 例子：\n\n\n\n\n\n回调 发起异步请求，提供一个当服务器响应到达时随即出发的回调函数。异步函数立即返回，这样客户端就不会被阻塞。 模块\n我们可以使用函数和闭包来构造模块。模块是一个提供接口却隐藏状态与实现的函数或对象。\n举例：给String添加一个deentityify方法。它的任务是寻找字符串中的HTML字符实体并把它们替换成对应的字符。\n\n\n\n模块模式利用了函数作用域和闭包来创建被绑定对象与私有成员的关联，在上面例子中，只有deentityify方法有权访问字符实体表这个数据对象。\n模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可以访问的地方。\n使用模块模式就可以摒弃全局变量的使用。它促进了信息隐藏和其他优秀的设计实践。对于应用程序的封装，或者构造其他单例对象，模块模式非常有效。\n\n> 单例译注\n> 模块模式通常结合单例模式使用。JavaScript的单例就是用对象字面量表示法创建的对象，对象的属性值可以是数值或函数，并且属性值在该对象的生命周期中不会发\n> 生变化。更多内容参见：单例模式\n\n级联 有一些方法没有返回值。如果我们让这些方法返回this而不是undefined，就可以启用级联。\n在一个级联中，我们可以在单独一条语句中依次调用同一个对象的很多方法。比如jQuery获取元素、操作样式、添加事件、添加动画等。 柯里化\n柯里化，是把多参数函数转换为一系列单参数函数并进行调用的技术。更多详情可参见：柯里化 函数也是值。柯里化允许我们把函数与传递给它的参数相结合，产生一个新的函数。\n\n\n\nJavaScript并没有curry方法，但可以扩展该功能。 arguments不是真正的数组，所以使用了Array.prototype.slice方法。\n\n\n\n记忆 函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。这种优化称作记忆。\n比如说，我们想要一个递归函数来计算Fibonacci(斐波那契)数列，它的特点是，前面相邻两项之和等于后一项的值。更多参考：斐波那契。最前面两个数字是0和1。\n\n\n\n这样虽然能完成工作，但它做了很多无谓的工作。 构造一个带有记忆功能的函数：\n\n\n\n再用这个memoizer函数来定义fibonacci函数，提供其初始的memo数组和formula函数。\n\n\n\n极大的减少了我们的工作量。例如要产生一个记忆的阶乘函数，只需要提供基本的阶乘公式即可：\n\n\n\n\n第5章 继承#\n\n伪类 JavaScript的原型存在诸多矛盾。它不直接让对象从其他对象继承，反而插入了一个多余的间接层：通过构造器函数产生对象。\nFunction构造器产生的函数对象会运行类似这样的一些代码：\n\n\n\n新函数对象被赋予一个prototype属性，这个prototype对象是存放继承特征的地方。\n\n当采用构造器调用模式，即用new前缀去调用一个函数时，函数执行的方式会被修改。如果new 运算符是一个方法而不是一个运算符，它可能像这样执行：\n\n\n\n所有构造器函数都约定命名成大写字母。一种更好的备选方案就是根本不使用new。 对象说明符 就是指传多个参数时，可以直接传递一个对象。 原型\n可以用Object.create方法构造出更多实例来。 函数化\n迄今为止，我们所看到的继承模式的一个弱点就是没法保护隐私。对象的所有属性都是可见的。我们无法得到私有变量和私有函数。\n幸运的是，我们有一个更好的选择，那就是应用模块模式。 我们从构造一个生成对象的函数开始。我们以小写字母开头来命名。 该函数包括以下四个步骤 1、创建一个新对象。\n2、有选择地私有实例变量和方法。 3、给这个新对象扩充方法。 4、返回那个新对象。 以下是一个函数化构造器的伪代码模板\n\n\n\n函数化模式有很大的灵活性。它相比伪类模式不仅带来的工作更少，还让我们更好的封装和信息隐藏，以及访问父类方法的能力。 部件 我们可以从一套部件中把对象组装出来。\n\n\n第6章 数组#\n\n数组是一段线性分配的内存，它通过整数计算偏移并访问其中的元素。 数组是一种性能出色的数据结构。不幸的是，JavaScript没有像此类数组一样的数据结构。\n数组字面量 对象字面量 数组继承了Array.prototype大量有用的方法。而对象字面量是继承自Object.prototype。\n数组有length属性，而对象没有。 长度 每个数组都有一个length属性。\n可以直接设置length的值。设置更大的length不会给数组分配更多的空间，而设小导致所有下标大于等于新length的属性被删除。\n\n\n\n也可以通过length来通过添加值\n\n\n\n有时用push方法更方便。 删除\n由于JavaScript的数组也是对象，所以delete运算符可以用来从数组中移出元素。移除后，长度不变，原位置上变成了undefined。\n可以使用Array.prototype.splice方法删除数组。 枚举 JS数组就是对象，所以for in语句可以用来遍历数据的所有属性。 不过，for\nin无法保证属性顺序。并且可能从原型链中得到意外的属性。 for循环可以避免以上问题。 容易混淆的地方\n\n\n\n识别是否是数组。\n\n\n\n但它在识别从不同窗口（window）或帧（frame）里的构造的数组时会失败。 有一个更好的方式：\n\n\n\n扩展： ES5 提供了Array.isArray()的方法。不过兼容性是IE9+。 要做到兼容，可以用如下方法。MDN上提供的。MDN\nArray.isArray\n\n\n\n\n\n方法四、instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。 方法五、isPrototypeOf()\n方法用于测试一个对象是否存在于另一个对象的原型链上。 方法六、Object.getPrototypeOf() 方法返回指定对象的原型（即,\n内部[[Prototype]]属性的值）。 小结：除了方法二、三外，面对复杂的环境，其他的都不能准确的判断是否是数组。 方法\nJavaScript提供了一套数组可用的方法，这些方法是被存储在Array.prototype中的函数。 Object.prototype是可以扩充的。\nArray.prototype也是可以扩充的。\nES5中提供的Object.create方法。这方法用在数组是没有意义的，因为它产生的是一个对象，而不是一个数组，产生的对象将继承这个数组的值和方法，但它没有l\nength特殊属性。 指定初始值 JavaScript的数组通常不会预设值。书中写了一个循环来扩展，生成初始值。 扩展：ES6中提供了fill来填充。比如：\n\n\n\n\n第7章 正则表达式#\n\n正则表达式对字符串中的信息实现查找、替换和提取操作。\n可处理正则表达式的方法有regexp.exec、regexp.test、string.match、string.search和string.split。通常来说\n，正则相较于等效的字符串处理有着显著的性能优势。\n\n一个例子\n\n\n\n依次匹配到的是：\n\n\n\n个人扩展：这里推荐 在线测试正则表达式的网站regex101，默认是PHP语言，选择JavaScript语言。 在线图形化RegExp工具 MDN\nRegExp.prototype.exec() 大概解释下这个正则， 这里的^ 起始位置，$结束位置 () 分组捕获 ?:不捕获\n.表示除换行以外的任意单个字符，对于码点大于0xFFFF的Unicode字符，点(.)不能识别（ES6中加u修饰符才可识别），+表示一个或多个，*表示零个或多个\n，?表示0个或一个。[]表示或者，里面符合一个即可。 \\d表示数字0-9。\n不严谨的正则表达式是一个常见的安全漏洞的发源地。在执行某些匹配时，嵌套的正则表达式也能导致极其恶劣的性能问题。因此简单是最好的策略。\n\n再看一个 匹配数字的例子。\n\n\n\n结构 有两个方法来创建一个RegExp对象。优先考虑的是正则表达式字面量，还有一种方式是new RegExp('','g')。\n正则表达式标识：g全局(匹配多次，不同的方法对g标识的处理防范各不相同)，i忽略大小写。m多行 元素 正则表达式分支 |表示或，也表示分支 比如：\n\n\n\n正则表达式序列\n一个正则表达式序列饱和一个或多个正则表达式因子。每一个因子能选择是否跟随一个量词，这个量词决定着这个因子被允许出现的次数，若没指定，这个因子则只匹配一次。\n正则表达式因子\n\n\n\n正则表达式转义 \\ 表转义 \\f 分页 \\n 换行 \\r回车 \\t 制表 \\u 允许制定一个 Unicode 字符来表示一个十六进制的常量。 \\d\n等同于[0-9] \\D 取反等同于 [^0-9] \\s Unicode 空白符一个不完全子集。 \\S 与\\s相反 \\w [0-9A-Z_a-z] \\W 与其相反\n[^0-9A-Z_a-z] \\b 表示 字边界 \\1 表示 分组1所捕获的文本的一个引用，所以它能被再次匹配。 \\2 表示 指向分组2的引用，\\3\n是表示分组3的引用，以此类推。 正则表达式分组 捕获型 () 非捕获型?: 向前正向匹配?=\n有一个(?=前缀。它类似于非捕获类型分组，但在这个组匹配后，文本会倒回到它它开始的地方，实际上并不匹配任何东西。也可以理解为匹配位置。 向后负向匹配\n有一个(?!前缀。它类似于向前正向匹配分组，但只有当它匹配失败时它才继续向前进行匹配。这不是一个好的特性。 正则表达式字符集\n正则表达式字符集是一种指定一组字符的便利方式。例如，要匹配一个元音字母，(?:a|e|i|o|u),可以方便的写成[aeiou]。\n类提供另外两个便利：①指定字符范围 所以，一组由32个ASCII的特殊组合，可以写成[!-\\/:-@\\[-{-~]` ②类的取反 取反\n\n\n\n正则表达式字符转义 字符类内部的转义规则和正则表达式因子的相比稍有不同。下面是在字符类中需要被转义的特殊字符。\n\n\n\n正则表达式量词 量词后缀决定正则表达式因子应该被匹配的次数。 {3}三次 {3,6} 3、4、5、6次 {3,}3次或更多次\n?等同于{0,1}，*等同于{0,}，+等同于{1,}。\n\n\n第8章 方法#\n\n\nArray#\n\narray.concat(item...) concat\n方法产生一个新数组，它包含一份array的浅复制并把一个或多个参数item附加在其后。如果item是数组，那么每个元素分别被添加。后面有和它功能类似的array\n.push(item...)方法。\n\n\n\n扩展： ES6 有更便捷的扩展运算符...\n\n\n\narray.join(separator) join方法把一个array构造成一个字符串。 separator 默认值就是逗号','。\n如果你想把大量的字符串片段组装成一个字符串，把这些片段放在一个数组中，并用join方法连接起来通常比用+元素运算符连接起来要快。\n\n> 译注：对于IE6/7，使用join连接大量字符串效率确实优于加号运算符。但目前主流浏览器，包括IE8以后的版本，都对+元素运算符连接字符串做了优化，性能已经\n> 显著高于Array.join()。所以目前大多数情况下，建议首选使用+ 连接字符串。更多参看《高性能网站建设进阶指南》中字符串优化相关章节。\n\narray.pop() pop方法移除array中的最后一个元素，并返回这个元素。如果array为空，则返回undefined。\n\n\n\narray.push(item...)\n与concat不同的是，它会修改array，如果参数item是数组，它会把参数数组作为单个元素整个添加到数组中。并返回这个array的新长度值。\n\n\n\npush可以像这样实现：\n\n\n\narray.reverse() reverse反转array元素顺序，并返回array本身。\n\n\n\narray.shift() shift移除array的第一个元素并返回这个元素。如果array为空，则返回undefined。shift通常比pop慢的多。\n\n\n\nshift可以这样实现：\n\n\n\narray.slice(start[, end])\nslice是对array中的一段做浅复制。end是可选的。默认是array.length,如果两个参数任何一个是负数，array.length会和相加。如果st\nart大于array.length,获得一个[],字符串也有Sting.slice这个同名方法。\n\narray.sort 默认不能给一组数字排序。默认把要被排序的元素都视为字符串。 幸运的是，可以使用自己的比较函数替换默认的比较函数。\n比较函数应该接受两个参数，并且如果这两个参数相等则返回0，如果第1个参数应该排列在前面，则返回一个负数，如果第二个参数应该排列在前面，则返回一个正数。\nsort方法是不稳定的。JavaScript的sort方法的稳定性根据不同浏览器的实现而不一致。 可参见MDN sort\n\narray.splice(start, deleteCount,item...) splice方法从array中移除一个或多个元素，并用新的item替换它们。\n\n\n\narray.unshift(item...) unshift 方法像push方法一样，不过是用于把元素添加到数组的开始部分，返回新array的length。\n\n\n\n\nFunction#\n\nfunction.apply(thisArg,argArray)\napply方法调用function,传递一个会被绑定到this上的对象和一个可选的数组作为参数。\n\n\nNumber#\n\nnumber.toExponential(fractionDigits) toExponential方法\n把这个number转换成一个指数形式的字符串。可选参数控制其小数点后的数字位数。它的值必须在0~20。\n\nnumber.toFixed(fractionDigits)\ntoFixed方法把这个number转换成一个十进制数形式的字符串。可选参数控制其小数点后的数字位数。它的值必须在0~20。\n\nnumber.toPrecision(precision)\ntoPrecision方法把这个number转换成一个十进制数形式的字符串。可选参数控制数字的精度。它的值必须在0~21。\n\nnumber.toString(radix)\n把number转换成字符串。可选参数控制基数。它的值必须是2~36。默认的radix是以10为基数的。radix参数最常用的是整数，但是它可以用任意的数字。\n\n\nObject#\n\nobject.hasOwnProperty(name)\n如果这个object包含名为name的属性，那么返回true。原型链中的同名方法不会被检测。这个方法对name就是“hasOwnProperty”时不起作用。\n\n\nRegExp#\n\nregexp.exec(string) exec是正则中最强大(和最慢）的方法。 如果成功匹配，它会返回一个数组。下标为0\n的元素包含正则匹配的子字符串。下标为1的则是分组1捕获的文本。下标为2的则是分组2捕获的文本。以此类推。如果匹配失败则返回null。\nregexp.test(string) test是最简单(和最快)的方法。匹配成功，返回true,否则返回false。不要对这个方法使用g标识。 比如：\n\n\n\ntest可以像这样实现：\n\n\n\n\nString#\n\nstring.charAt(pos) 返回在string中的pos位置处的字符。\n\nstring.charCodeAt(pos) 与charAt一样，不过返回整数形式表示字符码位。\n\nstring.concat(string) 很少用，用+号运算符更方便。\n\nstring.indexOf(searchString,position)\n在string中查找第一个参数，如果被找到返回该字符的位置，否则返回-1。position可设置指定位置开始查找。\n\nstring.lastIndexOf(searchString,position) lastIndexOf\n方法和indexOf方法类似，不过它是从末尾开始查找，不是从头开始。\n\nstring.localeCompare(that) 比较两个字符串。类似于array.sort。\n\nstring.match(regexp)\n如果没有g标识，那么调用string.match(regexp)和调用regexp.exec(string)结果相同。如果带有g标识，那么它生成一个包含所有匹配\n（除捕获分组之外）的数组。\n\nstring.replace(searchValue,replaceValue)\n对string进行查找和替换操作，并返回一个新的字符串。参数searchvalue可以是一个字符串也可以是一个正则表达式对象。参数replaceValue可以是\n一个字符串或一个函数。\n\nstring.search(regexp) 和indexOf类似，不过它接收正则为参数。\n\nstring.slice(start, end)\nslice方法复制string的一部分来构造一个新的字符串。如果start参数是负数，它将与string.length相加。end参数是可选的。\n\nstring.split(separator,limit)\n把string分割成片段来创建一个字符串数组。可选参数limit可以限制分割的片段数量。separator参数可以是字符串或者正则。\n\nstring.substring(start,end) 与slice方法一样，不过它不能处理负数参数。\n\nstring.toLocaleLowerCase() 它使用本地化的规则把这个string中的字母转换成小写格式。这个方法主要用在土耳其语上。\n\nstring.toLocaleUpperCase() 它使用本地化的规则把这个string中的字母转换成大写格式。这个方法主要用在土耳其语上。\n\nstring.toLowerCase() 返回新字符串，所有字母转成小写格式。\n\nstring.toUpperCase() 返回新字符串，所有字母转成大写格式。\n\nString.fromCharCode(char...) 根据一串数字编码返回一个字符串。\n\n\n\n\n第9章 代码风格#\n\n这一章中，简短的说了一些代码风格。事实证明代码风格在编程中是很重要的。\n\n\n第10章 优美的特性#\n\n精简的JavaScript里都是好东西。 包括：1、函数是顶级对象；2、基于原型继承的动态作用域；3、对象字面量和数组字面量。\n\n到此，读书笔记已完结。文章有什么不妥之处，欢迎指出~\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客 掘金专栏，欢迎关注~\nsegmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/js-book/","lang":"zh","toc":[{"text":"第1章 精华","id":"第1章-精华","depth":2,"charIndex":651},{"text":"第2章 语法","id":"第2章-语法","depth":2,"charIndex":1266},{"text":"第3章 对象","id":"第3章-对象","depth":2,"charIndex":1447},{"text":"第4章 函数","id":"第4章-函数","depth":2,"charIndex":2406},{"text":"第5章 继承","id":"第5章-继承","depth":2,"charIndex":5272},{"text":"第6章 数组","id":"第6章-数组","depth":2,"charIndex":5891},{"text":"第7章 正则表达式","id":"第7章-正则表达式","depth":2,"charIndex":7026},{"text":"第8章 方法","id":"第8章-方法","depth":2,"charIndex":8477},{"text":"Array","id":"array","depth":3,"charIndex":8487},{"text":"Function","id":"function","depth":3,"charIndex":9797},{"text":"Number","id":"number","depth":3,"charIndex":9892},{"text":"Object","id":"object","depth":3,"charIndex":10299},{"text":"RegExp","id":"regexp","depth":3,"charIndex":10418},{"text":"String","id":"string","depth":3,"charIndex":10653},{"text":"第9章 代码风格","id":"第9章-代码风格","depth":2,"charIndex":11856},{"text":"第10章 优美的特性","id":"第10章-优美的特性","depth":2,"charIndex":11905},{"text":"关于","id":"关于","depth":2,"charIndex":12012},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":39,"title":"","content":"","routePath":"/js-extend/es5-extends","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":40,"title":"","content":"","routePath":"/js-extend/es6-extends-babel-es5","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":41,"title":"","content":"","routePath":"/js-extend/es6-extends","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":42,"title":"面试官问：JS的继承","content":"#\n\n> 写于2019年2月20日\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 这是面试官问系列的第五篇，旨在帮助读者提升JS基础知识，包含new、call、apply、this、继承相关知识。\n> 面试官问系列文章如下：感兴趣的读者可以点击阅读。 1.面试官问：能否模拟实现JS的new操作符 2.面试官问：能否模拟实现JS的bind方法\n> 3.面试官问：能否模拟实现JS的call和apply方法 4.面试官问：JS的this指向 5.面试官问：JS的继承\n\n用过React的读者知道，经常用extends继承React.Component。\n\n\n\n点击这里查看 React github源码\n\n面试官可以顺着这个问JS继承的相关问题，比如：ES6的class继承用ES5如何实现。据说很多人答得不好。\n\n\n构造函数、原型对象和实例之间的关系#\n\n要弄懂extends继承之前，先来复习一下构造函数、原型对象和实例之间的关系。 代码表示：\n\n\n\n笔者画了一张图表示：\n\n\nES6 extends 继承做了什么操作#\n\n我们先看看这段包含静态方法的ES6继承代码：\n\n\n\n其中这段代码里有两条原型链，不信看具体代码。\n\n\n\n一图胜千言，笔者也画了一张图表示，如图所示：\n\n结合代码和图可以知道。 ES6 extends 继承，主要就是：\n\n * 1. 把子类构造函数(Child)的原型(__proto__)指向了父类构造函数(Parent)，\n * 2. 把子类实例child的原型对象(Child.prototype)\n      的原型(__proto__)指向了父类parent的原型对象(Parent.prototype)。\n\n这两点也就是图中用不同颜色标记的两条线。\n\n * 3. 子类构造函数Child继承了父类构造函数Parent的里的属性。使用super调用的(ES5则用call或者apply调用传参)。\n      也就是图中用不同颜色标记的两条线。\n\n看过《JavaScript高级程序设计-第3版》 章节6.3继承的读者应该知道，这2和3小点，正是寄生组合式继承，书中例子没有第1小点。\n1和2小点都是相对于设置了__proto__链接。那问题来了，什么可以设置了__proto__链接呢。\n\n\nnew、Object.create和Object.setPrototypeOf可以设置__proto__#\n\n说明一下，__proto__这种写法是浏览器厂商自己的实现。\n再结合一下图和代码看一下的new，new出来的实例的__proto__指向构造函数的prototype，这就是new做的事情。\n摘抄一下之前写过文章的一段。面试官问：能否模拟实现JS的new操作符，有兴趣的读者可以点击查看。\n\n\nnew做了什么：#\n\n>  1. 创建了一个全新的对象。\n>  2. 这个对象会被执行[[Prototype]]（也就是__proto__）链接。\n>  3. 生成的新对象会绑定到函数调用的this。\n>  4. 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。\n>  5. 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg,\n>     Error)，那么new表达式中的函数调用会自动返回这个新的对象。\n\n\nObject.create ES5提供的#\n\nObject.create(proto, [propertiesObject]) 方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是undefined）。对于不支持ES5的浏览器，MDN上提供了ployfill方案。 MDN\nObject.create()\n\n\n\n\nObject.setPrototypeOf ES6提供的#\n\nObject.setPrototypeOf MDN\n\nObject.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 null。\nObject.setPrototypeOf(obj, prototype)\n\n\n\nnodejs源码就是利用这个实现继承的工具函数的。 nodejs utils inherits\n\n\n\n\nES6的extends的ES5版本实现#\n\n知道了ES6\nextends继承做了什么操作和设置__proto__的知识点后，把上面ES6例子的用ES5就比较容易实现了，也就是说实现寄生组合式继承，简版代码就是：\n\n\n\n我们完全可以把上述ES6的例子通过babeljs转码成ES5来查看，更严谨的实现。\n\n\n\n如果对JS继承相关还是不太明白的读者，推荐阅读以下书籍的相关章节，可以自行找到相应的pdf版本。\n\n\n推荐阅读JS继承相关的书籍章节#\n\n《JavaScript高级程序设计第3版》-第6章\n面向对象的程序设计，6种继承的方案，分别是原型链继承、借用构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承。图灵社区本书地址，后文放出github\n链接，里面包含这几种继承的代码demo。\n\n《JavaScript面向对象编程第2版》-第6章\n继承，12种继承的方案。1.原型链法（仿传统）、2.仅从原型继承法、3.临时构造器法、4.原型属性拷贝法、5.全属性拷贝法（即浅拷贝法）、6.深拷贝法、7.原型\n继承法、8.扩展与增强模式、9.多重继承法、10.寄生继承法、11.构造器借用法、12.构造器借用与属性拷贝法。\n\nES6标准入门-第21章class的继承\n\n《深入理解ES6》-第9章 JavaScript中的类\n\n《你不知道的JavaScript-上卷》第6章 行为委托和附录A ES6中的class\n\n\n总结#\n\n继承对于JS来说就是父类拥有的方法和属性、静态方法等，子类也要拥有。子类中可以利用原型链查找，也可以在子类调用父类，或者从父类拷贝一份到子类等方案。\n继承方法可以有很多，重点在于必须理解并熟 悉这些对象、原型以及构造器的工作方式，剩下的就简单了。寄生组合式继承是开发者使用比较多的。\n回顾寄生组合式继承。主要就是三点：\n\n * 1. 子类构造函数的__proto__指向父类构造器，继承父类的静态方法。\n * 2. 子类构造函数的prototype的__proto__指向父类构造器的prototype，继承父类的方法。\n * 3. 子类构造器里调用父类构造器，继承父类的属性。 行文到此，文章就基本写完了。文章代码和图片等资源放在这里github\n      inhert和demo展示es6-extends，结合console、source面板查看更佳。\n\n读者发现有不妥或可改善之处，欢迎评论指出。另外觉得写得不错，可以点赞、评论、转发，也是对笔者的一种支持。\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客 segmentfault前端视野专栏，开通了前端视野专栏，欢迎关注\n掘金专栏，欢迎关注 知乎前端视野专栏，开通了前端视野专栏，欢迎关注 github blog，相关资源和文件都放在这里，求个star~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/js-extend/","lang":"zh","toc":[{"text":"构造函数、原型对象和实例之间的关系","id":"构造函数原型对象和实例之间的关系","depth":2,"charIndex":479},{"text":"`ES6 extends` 继承做了什么操作","id":"es6-extends-继承做了什么操作","depth":2,"charIndex":-1},{"text":"`new`、`Object.create`和`Object.setPrototypeOf`可以设置`__proto__`","id":"newobjectcreate和objectsetprototypeof可以设置__proto__","depth":2,"charIndex":-1},{"text":"****","id":"","depth":3,"charIndex":-1},{"text":"`Object.create` `ES5提供的`","id":"objectcreate-es5提供的","depth":3,"charIndex":-1},{"text":"`Object.setPrototypeOf` `ES6提供的`","id":"objectsetprototypeof-es6提供的","depth":3,"charIndex":-1},{"text":"`ES6`的`extends`的`ES5`版本实现","id":"es6的extends的es5版本实现","depth":2,"charIndex":-1},{"text":"推荐阅读JS继承相关的书籍章节","id":"推荐阅读js继承相关的书籍章节","depth":2,"charIndex":2176},{"text":"总结","id":"总结","depth":2,"charIndex":2585},{"text":"关于","id":"关于","depth":2,"charIndex":3026},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":43,"title":"面试官问：能否模拟实现JS的bind方法","content":"#\n\n> 写于2018年11月21日\n\n\n前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 这是面试官问系列的第二篇，旨在帮助读者提升JS基础知识，包含new、call、apply、this、继承相关知识。\n> 面试官问系列文章如下：感兴趣的读者可以点击阅读。 1.面试官问：能否模拟实现JS的new操作符 2.面试官问：能否模拟实现JS的bind方法\n> 3.面试官问：能否模拟实现JS的call和apply方法 4.面试官问：JS的this指向 5.面试官问：JS的继承\n\n用过React的同学都知道，经常会使用bind来绑定this。\n\n\n\n那么面试官可能会问是否想过bind到底做了什么，怎么模拟实现呢。\n\n> 附上之前写文章写过的一段话：已经有很多模拟实现bind的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一\n> 定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。\n\n先看一下bind是什么。从上面的React代码中，可以看出bind执行后是函数，并且每个函数都可以执行调用它。\n眼见为实，耳听为虚。读者可以在控制台一步步点开例子1中的obj:\n\n\n\n\n\n\n因此可以得出结论1：#\n\n1、bind是Functoin原型链中Function.prototype的一个属性，每个函数都可以调用它。\n2、bind本身是一个函数名为bind的函数，返回值也是函数，函数名是bound 。（打出来就是bound加上一个空格）。\n知道了bind是函数，就可以传参，而且返回值'bound '也是函数，也可以传参，就很容易写出例子2： 后文统一 bound 指原函数original\nbind之后返回的函数，便于说明。\n\n\n\n\n由此可以得出结论2：#\n\n1、调用bind的函数中的this指向bind()函数的第一个参数。\n\n2、传给bind()的其他参数接收处理了，bind()之后返回的函数的参数也接收处理了，也就是说合并处理了。\n\n3、并且bind()后的name为bound + 空格 + 调用bind的函数名。如果是匿名函数则是bound + 空格。\n\n4、bind后的返回值函数，执行后返回值是原函数（original）的返回值。\n\n5、bind函数形参（即函数的length）是1。bind后返回的bound函数形参不定，根据绑定的函数原函数（original）形参个数确定。\n\n根据结论2：我们就可以简单模拟实现一个简版bindFn\n\n\n\n如果面试官看到你答到这里，估计对你的印象60、70分应该是会有的。 但我们知道函数是可以用new来实例化的。那么bind()返回值函数会是什么表现呢。\n接下来看例子3：\n\n\n\n从例子3种可以看出this指向了new bound()生成的新对象。\n\n\n可以分析得出结论3：#\n\n1、bind原先指向obj的失效了，其他参数有效。\n\n2、new bound的返回值是以original原函数构造器生成的新对象。original原函数的this指向的就是这个新对象。\n另外前不久写过一篇文章：面试官问：能否模拟实现JS的new操作符。简单摘要： new做了什么：\n\n> 1.创建了一个全新的对象。 2.这个对象会被执行[[Prototype]]（也就是__proto__）链接。 3.生成的新对象会绑定到函数调用的this。\n> 4.通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。\n> 5.如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg,\n> Error)，那么new表达式中的函数调用会自动返回这个新的对象。\n\n所以相当于new调用时，bind的返回值函数bound内部要模拟实现new实现的操作。 话不多说，直接上代码。\n\n\n\n面试官看到这样的实现代码，基本就是满分了，心里独白：这小伙子/小姑娘不错啊。不过可能还会问this instanceof bound不准确问题。\n上文注释中提到this instanceof bound也不是很准确，ES6 new.target很好的解决这一问题，我们举个例子4:\n\n\ninstanceof 不准确，ES6 new.target很好的解决这一问题#\n\n\n\n细心的同学可能会发现了这版本的代码没有实现bind后的bound函数的nameMDN Function.name和lengthMDN\nFunction.length。面试官可能也发现了这一点继续追问，如何实现，或者问是否看过es5-shim的源码实现L201-L335。如果不限ES版本。其实可\n以用ES5的Object.defineProperties来实现。\n\n\n\n\nes5-shim的源码实现bind#\n\n直接附上源码（有删减注释和部分修改等）\n\n\n\n你说出es5-shim源码bind实现，感慨这代码真是高效、严谨。面试官心里独白可能是：你就是我要找的人，薪酬福利你可以和HR去谈下。\n\n\n最后总结一下#\n\n1、bind是Function原型链中的Function.prototype的一个属性，它是一个函数，修改this指向，合并参数传递给原函数，返回值是一个新的函\n数。 2、bind返回的函数可以通过new调用，这时提供的this的参数被忽略，指向了new生成的全新对象。内部模拟实现了new操作符。\n3、es5-shim源码模拟实现bind时用Function实现了length。\n事实上，平时其实很少需要使用自己实现的投入到生成环境中。但面试官通过这个面试题能考察很多知识。比如this指向，原型链，闭包，函数等知识，可以扩展很多。\n读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。\n\n文章中的例子和测试代码放在github中bind模拟实现 github。bind模拟实现 预览地址 F12看控制台输出，结合source面板查看效果更佳。\n\n\n\n\n参考#\n\nOshotOkill翻译的 深入理解ES6 简体中文版 - 第三章 函数（虽然笔者是看的纸质书籍，但推荐下这本在线的书） MDN\nFunction.prototype.bind 冴羽: JavaScript深入之bind的模拟实现\n《react状态管理与同构实战》侯策：从一道面试题，到“我可能看了假源码”\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客 掘金专栏，欢迎关注~\nsegmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/js-implement-bind/","lang":"zh","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":20},{"text":"因此可以得出结论1：","id":"因此可以得出结论1","depth":3,"charIndex":659},{"text":"由此可以得出结论2：","id":"由此可以得出结论2","depth":3,"charIndex":887},{"text":"可以分析得出结论3：","id":"可以分析得出结论3","depth":3,"charIndex":1326},{"text":"`instanceof` 不准确，`ES6 new.target`很好的解决这一问题","id":"instanceof-不准确es6-newtarget很好的解决这一问题","depth":3,"charIndex":-1},{"text":"`es5-shim`的源码实现`bind`","id":"es5-shim的源码实现bind","depth":3,"charIndex":-1},{"text":"最后总结一下","id":"最后总结一下","depth":2,"charIndex":2253},{"text":"参考","id":"参考","depth":2,"charIndex":2659},{"text":"关于","id":"关于","depth":2,"charIndex":2820},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":44,"title":"面试官问：能否模拟实现JS的call和apply方法","content":"#\n\n> 写于2018年11月30日\n\n\n前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 这是面试官问系列的第三篇，旨在帮助读者提升JS基础知识，包含new、call、apply、this、继承相关知识。\n> 面试官问系列文章如下：感兴趣的读者可以点击阅读。 1.面试官问：能否模拟实现JS的new操作符 2.面试官问：能否模拟实现JS的bind方法\n> 3.面试官问：能否模拟实现JS的call和apply方法 4.面试官问：JS的this指向 5.面试官问：JS的继承\n\n之前写过两篇《面试官问：能否模拟实现JS的new操作符》和《面试官问：能否模拟实现JS的bind方法》\n\n其中模拟bind方法时是使用的call和apply修改this指向。但面试官可能问：能否不用call和apply来实现呢。意思也就是需要模拟实现call和app\nly的了。\n\n> 附上之前写文章写过的一段话：已经有很多模拟实现call和apply的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的\n> 风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。\n\n\n先通过MDN认识下call和apply#\n\nMDN 文档：Function.prototype.call() 语法\n\n\n\nthisArg\n在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和und\nefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。\narg1, arg2, ... 指定的参数列表 返回值 返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。\n\nMDN 文档：Function.prototype.apply()\n\n\n\nthisArg 可选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为\nnull 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 argsArray\n可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或\nundefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 返回值 调用有指定this值和参数的函数的结果。\n直接先看例子1\n\n\ncall 和 apply 的异同#\n\n相同点：\n1、call和apply的第一个参数thisArg，都是func运行时指定的this。而且，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则\n指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 2、都可以只传递一个参数。\n不同点：apply只接收两个参数，第二个参数可以是数组也可以是类数组，其实也可以是对象，后续的参数忽略不计。call接收第二个及以后一系列的参数。\n看两个简单例子1和2**：\n\n\n\n\n\ntypeof 有7种类型（undefined number string boolean symbol object\nfunction），笔者都验证了一遍：更加验证了相同点第一点，严格模式下，函数的this值就是call和apply的第一个参数thisArg，非严格模式下，th\nisArg值被指定为 null 或 undefined 时this值会自动替换为指向全局对象，原始值则会被自动包装，也就是new Object()。\n\n重新认识了call和apply会发现：它们作用都是一样的，改变函数里的this指向为第一个参数thisArg，如果明确有多少参数，那可以用call，不明确则可以\n使用apply。也就是说完全可以不使用call，而使用apply代替。\n也就是说，我们只需要模拟实现apply，call可以根据参数个数都放在一个数组中，给到apply即可。\n\n\n模拟实现 apply#\n\n既然准备模拟实现apply，那先得看看ES5规范。ES5规范 英文版，ES5规范\n中文版。apply的规范下一个就是call的规范，可以点击打开新标签页去查看，这里摘抄一部分。\n\n> Function.prototype.apply (thisArg, argArray) 当以 thisArg 和 argArray 为参数在一个 func\n> 对象上调用 apply 方法，采用如下步骤：\n\n> 1.如果 IsCallable(func) 是 false, 则抛出一个 TypeError 异常。 2.如果 argArray 是 null 或\n> undefined, 则返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。 3.返回提供\n> thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。 4.如果 Type(argArray) 不是\n> Object, 则抛出一个 TypeError 异常。 5~8 略 9.提供 thisArg 作为 this 值并以 argList 作为参数列表，调用\n> func 的 [[Call]] 内部方法，返回结果。 apply 方法的 length 属性是 2。\n\n> 在外面传入的 thisArg 值会修改并成为 this 值。thisArg 是 undefined 或 null 时它会被替换成全局对象，所有其他值会被应用\n> ToObject 并将结果作为 this 值，这是第三版引入的更改。\n\n结合上文和规范，如何将函数里的this指向第一个参数thisArg呢，这是一个问题。 这时候请出例子3：\n\n\n\n可以得出结论1：在对象student上加一个函数doSth，再执行这个函数，这个函数里的this就指向了这个对象。那也就是可以在thisArg上新增调用函数，执\n行后删除这个函数即可。 知道这些后，我们试着容易实现第一版本：\n\n\n\n\n实现第一版后，很容易找出两个问题：#\n\n * 1.__fn 同名覆盖问题，thisArg对象上有__fn，那就被覆盖了然后被删除了。\n\n针对问题1 解决方案一：采用ES6 Sybmol() 独一无二的。可以本来就是模拟ES3的方法。如果面试官不允许用呢。\n解决方案二：自己用Math.random()模拟实现独一无二的key。面试时可以直接用生成时间戳即可。\n\n\n\n如果这个key万一这对象中还是有，为了保险起见，可以做一次缓存操作。比如如下代码：\n\n\n\n * 2.使用了ES6扩展符... 解决方案一：采用eval来执行函数。\n\n> eval把字符串解析成代码执行。 MDN 文档：eval 语法\n\n\n\n参数 string 表示JavaScript表达式，语句或一系列语句的字符串。表达式可以包含变量以及已存在对象的属性。 返回值\n执行指定代码之后的返回值。如果返回值为空，返回undefined 解决方案二：但万一面试官不允许用eval呢，毕竟eval是魔鬼。可以采用new\nFunction()来生成执行函数。 MDN 文档：Function 语法\n\n\n\n参数 arg1, arg2, ... argN\n被函数使用的参数的名称必须是合法命名的。参数名称是一个有效的JavaScript标识符的字符串，或者一个用逗号分隔的有效字符串的列表;例如“×”，“theVal\nue”，或“A，B”。 functionBody 一个含有包括函数定义的JavaScript语句的字符串。 接下来看两个例子：\n\n\n\n\n\n\n你可能不知道在ES3、ES5中 undefined 是能修改的#\n\n可能大部分人不知道。ES5中虽然在全局作用域下不能修改，但在局部作用域中也是能修改的，不信可以复制以下测试代码在控制台执行下。虽然一般情况下是不会的去修改它。\n\n\n\n所以判断一个变量a是不是undefined，更严谨的方案是typeof a === 'undefined'或者a === void 0;\n这里面用的是void，void的作用是计算表达式，始终返回undefined，也可以这样写void(0)。 更多可以查看韩子迟的这篇文章：为什么用「void\n0」代替「undefined」 解决了这几个问题，比较容易实现如下代码。\n\n\n使用 new Function() 模拟实现的apply#\n\n\n\n\n利用模拟实现的apply模拟实现call#\n\n\n\n细心的你会发现注释了这一句argsArray.push(arguments[i +\n1]);，事实上push方法，内部也有一层循环。所以理论上不使用push性能会更好些。面试官也可能根据这点来问时间复杂度和空间复杂度的问题。\n\n\n\n行文至此，就基本结束了，你可能还发现就是写的非严格模式下，thisArg原始值会包装成对象，添加函数并执行，再删除。而严格模式下还是原始值这个没有实现，而且万一\n这个对象是冻结对象呢，Object.freeze({})，是无法在这个对象上添加属性的。所以这个方法只能算是非严格模式下的简版实现。最后来总结一下。\n\n\n总结#\n\n通过MDN认识call和apply，阅读ES5规范，到模拟实现apply，再实现call。\n就是使用在对象上添加调用apply的函数执行，这时的调用函数的this就指向了这个thisArg，再返回结果。引出了ES6\nSymbol，ES6的扩展符...、eval、new Function()，严格模式等。\n事实上，现实业务场景不需要去模拟实现call和apply,毕竟是ES3就提供的方法。但面试官可以通过这个面试题考察候选人很多基础知识。如：call、apply的\n使用。ES6 Symbol，ES6的扩展符...，eval，new Function()，严格模式，甚至时间复杂度和空间复杂度等。\n读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。\n\n\n\n\n扩展阅读#\n\n《JavaScript设计模式与开发实践》- 第二章 第 2 章　this、call和apply\nJS魔法堂：再次认识Function.prototype.call 不用call和apply方法模拟实现ES5的bind方法\nJavaScript深入之call和apply的模拟实现\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客 掘金专栏，欢迎关注~\nsegmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/js-implement-call-apply/","lang":"zh","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":20},{"text":"先通过`MDN`认识下`call`和`apply`","id":"先通过mdn认识下call和apply","depth":2,"charIndex":-1},{"text":"`call` 和 `apply` 的异同","id":"call-和-apply-的异同","depth":2,"charIndex":-1},{"text":"模拟实现 `apply`","id":"模拟实现-apply","depth":2,"charIndex":-1},{"text":"实现第一版后，很容易找出两个问题：","id":"实现第一版后很容易找出两个问题","depth":2,"charIndex":2755},{"text":"你可能不知道在`ES3、ES5`中 `undefined` 是能修改的","id":"你可能不知道在es3es5中-undefined-是能修改的","depth":2,"charIndex":-1},{"text":"使用 `new Function()` 模拟实现的`apply`","id":"使用-new-function-模拟实现的apply","depth":2,"charIndex":-1},{"text":"利用模拟实现的`apply`模拟实现`call`","id":"利用模拟实现的apply模拟实现call","depth":2,"charIndex":-1},{"text":"总结","id":"总结","depth":2,"charIndex":4048},{"text":"扩展阅读","id":"扩展阅读","depth":2,"charIndex":4403},{"text":"关于","id":"关于","depth":2,"charIndex":4553},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":45,"title":"面试官问：能否模拟实现JS的new操作符","content":"#\n\n> 写于2018年11月05日\n\n\n1. 前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 这是面试官问系列的第一篇，旨在帮助读者提升JS基础知识，包含new、call、apply、this、继承相关知识。\n> 面试官问系列文章如下：感兴趣的读者可以点击阅读。 1.面试官问：能否模拟实现JS的new操作符 2.面试官问：能否模拟实现JS的bind方法\n> 3.面试官问：能否模拟实现JS的call和apply方法 4.面试官问：JS的this指向 5.面试官问：JS的继承\n\n用过Vuejs的同学都知道，需要用new操作符来实例化。\n\n\n\n那么面试官可能会问是否想过new到底做了什么，怎么模拟实现呢。\n\n> 附上之前写文章写过的一段话：已经有很多模拟实现new操作符的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你\n> 不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。\n\n\n2. new 做了什么#\n\n先看简单例子1：\n\n\n\n从这里例子中，我们可以看出：一个函数用new操作符来调用后，生成了一个全新的对象。而且Student和Object都是函数，只不过Student是我们自定义的，\nObject是JS本身就内置的。 再来看下控制台输出图，感兴趣的读者可以在控制台试试。\n\n\n\n与new Object() 生成的对象不同的是new\nStudent()生成的对象中间还嵌套了一层__proto__，它的constructor是Student这个函数。\n\n\n\n\n2.1 小结1：从这个简单例子来看，new操作符做了两件事：#\n\n 1. 创建了一个全新的对象。\n 2. 这个对象会被执行[[Prototype]]（也就是__proto__）链接。\n\n接下来我们再来看升级版的例子2：\n\n\n\n由此可以看出：这里Student函数中的this指向new Student()生成的对象student。\n\n\n2.2 小结2：从这个例子来看，new操作符又做了一件事：#\n\n 1. 生成的新对象会绑定到函数调用的this。\n\n接下来继续看升级版例子3：\n\n\n\n\n\n关于JS的原型关系我之前看到这张图，觉得很不错，分享给大家。\n\n\n\n\n2.3 小结3：这个例子3再一次验证了小结1中的第2点。也就是这个对象会被执行[[Prototype]]（也就是__proto__）链接。并且通过new\nStudent()创建的每个对象将最终被[[Prototype]]链接到这个Student.protytype对象上。#\n\n细心的同学可能会发现这三个例子中的函数都没有返回值。那么有返回值会是怎样的情形呢。 那么接下来请看例子4\n\n\n\n我测试这七种类型后MDN JavaScript类型，得出的结果是：前面六种基本类型都会正常返回{name:\n'若川'}，后面的Object(包含Functoin, Array, Date, RegExg, Error)都会直接返回这些值。\n\n\n2.4 由此得出 小结4：#\n\n 1. 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg,\n    Error)，那么new表达式中的函数调用会自动返回这个新的对象。\n\n结合这些小结，整理在一起就是：\n\n 1. 创建了一个全新的对象。\n 2. 这个对象会被执行[[Prototype]]（也就是__proto__）链接。\n 3. 生成的新对象会绑定到函数调用的this。\n 4. 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。\n 5. 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg,\n    Error)，那么new表达式中的函数调用会自动返回这个新的对象。\n\n\n3. new 模拟实现#\n\n知道了这些现象，我们就可以模拟实现new操作符。直接贴出代码和注释\n\n\n\n最后用模拟实现的newOperator函数验证下之前的例子3：\n\n\n\n可以看出，很符合new操作符。读者发现有不妥或可改善之处，欢迎指出。\n回顾这个模拟new函数newOperator实现，最大的功臣当属于Object.create()这个ES5提供的API。\n\n\n4. Object.create() 用法举例#\n\n我之前整理的一篇文章中也有讲过，可以翻看JavaScript 对象所有API解析\n\nMDN Object.create()\n\nObject.create(proto, [propertiesObject]) 方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是undefined）。\n\n\n\n对于不支持ES5的浏览器，MDN上提供了ployfill方案。\n\n\n\n到此，文章就基本写完了。感谢读者看到这里。\n\n\n5. 最后总结一下：#\n\n 1. new做了什么：\n\n>  1. 创建了一个全新的对象。\n>  2. 这个对象会被执行[[Prototype]]（也就是__proto__）链接。\n>  3. 生成的新对象会绑定到函数调用的this。\n>  4. 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。\n>  5. 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg,\n>     Error)，那么new表达式中的函数调用会自动返回这个新的对象。\n\n 2. 怎么模拟实现\n\n\n\n读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对我的一种支持。\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客 掘金专栏，欢迎关注~\nsegmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/js-implement-new/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":20},{"text":"2. new 做了什么","id":"2-new-做了什么","depth":2,"charIndex":566},{"text":"2.1 小结1：从这个简单例子来看，`new`操作符做了两件事：","id":"21-小结1从这个简单例子来看new操作符做了两件事","depth":3,"charIndex":-1},{"text":"2.2 小结2：从这个例子来看，`new`操作符又做了一件事：","id":"22-小结2从这个例子来看new操作符又做了一件事","depth":3,"charIndex":-1},{"text":"2.3 小结3：这个例子3再一次验证了**小结1**中的**第2点**。也就是这个对象会被执行`[[Prototype]]`（也就是`__proto__`）链接。并且通过`new Student()`创建的每个对象将最终被`[[Prototype]]`链接到这个`Student.protytype`对象上。","id":"23-小结3这个例子3再一次验证了小结1中的第2点也就是这个对象会被执行prototype也就是__proto__链接并且通过new-student创建的每个对象将最终被prototype链接到这个studentprotytype对象上","depth":3,"charIndex":-1},{"text":"2.4 由此得出 小结4：","id":"24-由此得出-小结4","depth":3,"charIndex":1407},{"text":"3. new 模拟实现","id":"3-new-模拟实现","depth":2,"charIndex":1770},{"text":"4. Object.create() 用法举例","id":"4-objectcreate-用法举例","depth":2,"charIndex":1954},{"text":"5. 最后总结一下：","id":"5-最后总结一下","depth":2,"charIndex":2227},{"text":"关于","id":"关于","depth":2,"charIndex":2561},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":46,"title":"JavaScript 对象所有API解析【2020版】","content":"#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 写于 2017年08月20日，虽然是2017年写的文章，但现在即将2020年依旧不过时，现在补充了2019年新增的ES10\n> Object.fromEntries()。\n\n近日发现有挺多人对对象基础API不熟悉，举个开发中常见的需求，经常会有类似的封装http到原型Vue.prototype，一般人是这样封装的，但容易被篡改。\n\n\n\n熟悉Object.defineProperty或者说熟悉对象API的人，一般是如下代码写的，则不会出现被修改的问题。\n\n\n\nvue-router 源码里就是类似这样写的，this.$router，this.$route无法修改。\n\n\n\n以下是正文~\n\n> 之前看到【深度长文】JavaScript数组所有API全解密和JavaScript字符串所有API全解密这两篇高质量的文章。发现没写对象API解析（估计是博\n> 主觉得简单，就没写）。刚好我看到《JavaScript面向对象编程指南（第2版）》，觉得有必要写（或者说chao）一下，也好熟悉下对象的所有API用法。\n\n创建对象的两种方式：\n\n\n\n该构造器可以接受任何类型的参数，并且会自动识别参数的类型，并选择更合适的构造器来完成相关操作。比如：\n\n\n\n\n一、Object构造器的成员#\n\n\nObject.prototype#\n\n该属性是所有对象的原型（包括 Object对象本身），语言中的其他对象正是通过对该属性上添加东西来实现它们之间的继承关系的。所以要小心使用。 比如：\n\n\n\n\n二、Object.prototype 的成员#\n\n\nObject.prototype.constructor#\n\n该属性指向用来构造该函数对象的构造器，在这里为Object()\n\n\n\n\nObject.prototype.toString(radix)#\n\n该方法返回的是一个用于描述目标对象的字符串。特别地，当目标是一个Number对象时，可以传递一个用于进制数的参数radix，该参数radix，该参数的默认值为1\n0。\n\n\n\n\nObject.prototype.toLocaleString()#\n\n该方法的作用与toString()基本相同，只不过它做一些本地化处理。该方法会根据当前对象的不同而被重写，例如Date(),Number(),Array(),它\n们的值都会以本地化的形式输出。当然，对于包括Object()在内的其他大多数对象来说，该方法与toString()是基本相同的。\n在浏览器环境下，可以通过BOM对象Navigator的language属性（在IE中则是userLanguage）来了解当前所使用的语言：\n\n\n\n\nObject.prototype.valueOf()#\n\n该方法返回的是用基本类型所表示的this值，如果它可以用基本类型表示的话。如果Number对象返回的是它的基本数值，而Date对象返回的是一个时间戳（times\ntamp）。如果无法用基本数据类型表示，该方法会返回this本身。\n\n\n\n\nObject.prototype.hasOwnProperty(prop)#\n\n该方法仅在目标属性为对象自身属性时返回true,而当该属性是从原型链中继承而来或根本不存在时，返回false。\n\n\n\n\nObject.prototype.isPrototypeOf(obj)#\n\n如果目标对象是当前对象的原型，该方法就会返回true，而且，当前对象所在原型上的所有对象都能通过该测试，并不局限与它的直系关系。\n\n\n\n\nObject.prototype.propertyIsEnumerable(prop)#\n\n如果目标属性能在for in循环中被显示出来，该方法就返回true\n\n\n\n\n三、在ES5中附加的Object属性#\n\n在ES3中，除了一些内置属性（如：Math.PI），对象的所有的属性在任何时候都可以被修改、插入、删除。在ES5中，我们可以设置属性是否可以被改变或是被删除——\n在这之前，它是内置属性的特权。ES5中引入了属性描述符的概念，我们可以通过它对所定义的属性有更大的控制权。这些属性描述符（特性）包括：\n\n> value——当试图获取属性时所返回的值。 writable——该属性是否可写。 enumerable——该属性在for in循环中是否会被枚举\n> configurable——该属性是否可被删除。 set()——该属性的更新操作所调用的函数。 get()——获取属性值时所调用的函数。\n> 另外，数据描述符（其中属性为：enumerable，configurable，value，writable）与存取描述符（其中属性为enumerable，c\n> onfigurable，set()，get()）之间是有互斥关系的。在定义了set()和get()之后，描述符会认为存取操作已被\n> 定义了，其中再定义value和writable会引起错误。 以下是ES3风格的属性定义方式：\n\n\n\n以下是等价的ES5通过数据描述符定义属性的方式：\n\n\n\n其中，\n除了value的默认值为undefined以外，其他的默认值都为false。这就意味着，如果想要通过这一方式定义一个可写的属性，必须显示将它们设为true。\n或者，我们也可以通过ES5的存储描述符来定义：\n\n\n\n这样一来，多了许多可以用来描述属性的代码，如果想要防止别人篡改我们的属性，就必须要用到它们。此外，也不要忘了浏览器向后兼容ES3方面所做的考虑。例如，跟添加Ar\nray.prototype属性不一样，我们不能再旧版的浏览器中使用shim这一特性。\n另外，我们还可以（通过定义nonmalleable属性），在具体行为中运用这些描述符：\n\n\n\n\nObject.defineProperty(obj, prop, descriptor) (ES5)#\n\n具体用法可参见上文，或者查看MDN。 MDN Object.defineProperty(obj, descriptor)\n\n> Vue.js文档：如何追踪变化 把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用\n> Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5\n> 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。\n\n\nObject.defineProperties(obj, props) (ES5)#\n\n该方法的作用与defineProperty()基本相同，只不过它可以用来一次定义多个属性。 比如：\n\n\n\n\nObject.getPrototypeOf(obj) (ES5)#\n\n之前在ES3中，我们往往需要通过Object.prototype.isPrototypeOf()去猜测某个给定的对象的原型是什么，如今在ES5中，我们可以直接询\n问该对象“你的原型是什么？”\n\n\n\n\nObject.create(obj, descr) (ES5)#\n\n该方法主要用于创建一个新对象，并为其设置原型，用（上述）属性描述符来定义对象的原型属性。\n\n\n\n现在，我们甚至可以用它来创建一个完全空白的对象，这样的事情在ES3中可是做不到的。\n\n\n\n\nObject.getOwnPropertyDesciptor(obj, property) (ES5)#\n\n该方法可以让我们详细查看一个属性的定义。甚至可以通过它一窥那些内置的，之前不可见的隐藏属性。\n\n\n\n\nObject.getOwnPropertyNames(obj) (ES5)#\n\n该方法返回一个数组，其中包含了当前对象所有属性的名称（字符串），不论它们是否可枚举。当然，也可以用Object.keys()来单独返回可枚举的属性。\n\n\n\n\nObject.preventExtensions(obj) (ES5)#\n\n\nObject.isExtensible(obj) (ES5)#\n\npreventExtensions()方法用于禁止向某一对象添加更多属性，而isExtensible()方法则用于检查某对象是否还可以被添加属性。\n\n\n\n\nObject.seal(obj) (ES5)#\n\n\nObject.isSeal(obj) (ES5)#\n\nseal()方法可以让一个对象密封，并返回被密封后的对象。 seal()方法的作用与preventExtensions()基本相同，但除此之外，它还会将现有属性\n设置成不可配置。也就是说，在这种情况下，我们只能变更现有属性的值，但不能删除或（用defineProperty()）重新配置这些属性，例如不能将一个可枚举的属性\n改成不可枚举。\n\n\n\n\nObject.freeze(obj) (ES5)#\n\n\nObject.isFrozen(obj) (ES5)#\n\nfreeze()方法用于执行一切不受seal()方法限制的属性值变更。Object.freeze()\n方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也\n就是说，这个对象永远是不可变的。该方法返回被冻结的对象。\n\n\n\n\nObject.keys(obj) (ES5)#\n\n该方法是一种特殊的for-in循环。它只返回当前对象的属性（不像for-in），而且这些属性也必须是可枚举的（这点和Object.getOwnPropertyN\names()不同，不论是否可以枚举）。返回值是一个字符串数组。\n\n\n\n\n四、在ES6中附加的Object属性#\n\n\nObject.is(value1, value2) (ES6)#\n\n该方法用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致。 不同之处只有两个：一是+0不等于-0，而是NaN等于自身。\n\n\n\nES5可以通过以下代码部署Object.is\n\n\n\n\nObject.assign(target, ...sources) (ES6)#\n\n该方法用来源对象（source）的所有可枚举的属性复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象target，后面的参数都是源\n对象（source）。只有一个参数不是对象，就会抛出TypeError错误。\n\n\n\nObject.assign只复制自身属性，不可枚举的属性（enumerable为false）和继承的属性不会被复制。\n\n\n\n属性名为Symbol值的属性，也会被Object.assign()复制。\n\n\n\n对于嵌套的对象，Object.assign()的处理方法是替换，而不是添加。\n\n\n\n对于数组，Object.assign()把数组视为属性名为0、1、2的对象。\n\n\n\n\nObject.getOwnPropertySymbols(obj) (ES6)#\n\n该方法会返回一个数组，该数组包含了指定对象自身的（非继承的）所有 symbol 属性键。 该方法和 Object.getOwnPropertyNames()\n类似，但后者返回的结果只会包含字符串类型的属性键，也就是传统的属性名。\n\n\n\n\nObject.setPrototypeOf(obj, prototype) (ES6)#\n\n该方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 null。\n__proto__属性用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括IE11）都部署了这个属性。\n\n\n\n该属性没有写入ES6的正文，而是写入了附录。__proto__前后的双下划线说明它本质上是一个内部属性，而不是正式对外的一个API。无论从语义的角度，还是从兼容\n性的角度，都不要使用这个属性。而是使用Object.setPrototypeOf()（写操作），Object.getPrototypeOf()（读操作），或Ob\nject.create()（生成操作）代替。 在实现上，__proto__调用的Object.prototype.__proto__。\nObject.setPrototypeOf()方法的作用与__proto__作用相同，用于设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象\n的方法。\n\n\n五、在ES8中附加的Object属性#\n\n\nObject.getOwnPropertyDescriptors(obj) (ES8)#\n\n该方法基本与Object.getOwnPropertyDescriptor(obj,\nproperty)用法一致，只不过它可以用来获取一个对象的所有自身属性的描述符。\n\n\n\n\nObject.values(obj) (ES8)#\n\nObject.values() 方法与Object.keys类似。返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 (\n区别在于for-in循环枚举原型链中的属性 )。\n\n\n\n\nObject.entries(obj) (ES8)#\n\nObject.entries() 方法返回一个给定对象自己的可枚举属性[key，value]对的数组，数组中键值对的排列顺序和使用 for...in\n循环遍历该对象时返回的顺序一致（区别在于一个for-in循环也枚举原型链中的属性）。\n\n\n\n\n六、在ES10中附加的Object属性#\n\n\nObject.fromEntries(iterable) (ES10)#\n\nObject.fromEntries()方法返回一个给定可迭代对象（类似Array、Map或其他可迭代对象）对应属性的新对象。\n\nObject.fromEntries() 是 Object.entries()的逆操作。\n\n\n\n\n小结#\n\n细心的读者可能会发现MDN上还有一些API，本文没有列举到。因为那些是非标准的API。熟悉对象的API对理解原型和原型链相关知识会有一定帮助。常用的API主要有\nObject.prototype.toString()，Object.prototype.hasOwnProperty()，\nObject.getPrototypeOf(obj)，Object.create()，Object.defineProperty，Object.keys(obj\n)，Object.assign()。\n\n\n参考资料#\n\nMDN Object API JavaScript面向对象编程指南（第2版）（豆瓣读书链接） 阮一峰 ES6标准入门2\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客 掘金专栏，欢迎关注~\nsegmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/js-object-api/","lang":"zh","toc":[{"text":"一、Object构造器的成员","id":"一object构造器的成员","depth":2,"charIndex":671},{"text":"Object.prototype","id":"objectprototype","depth":3,"charIndex":689},{"text":"二、Object.prototype 的成员","id":"二objectprototype-的成员","depth":2,"charIndex":787},{"text":"Object.prototype.constructor","id":"objectprototypeconstructor","depth":3,"charIndex":813},{"text":"Object.prototype.toString(radix)","id":"objectprototypetostringradix","depth":3,"charIndex":880},{"text":"Object.prototype.toLocaleString()","id":"objectprototypetolocalestring","depth":3,"charIndex":1003},{"text":"Object.prototype.valueOf()","id":"objectprototypevalueof","depth":3,"charIndex":1259},{"text":"Object.prototype.hasOwnProperty(prop)","id":"objectprototypehasownpropertyprop","depth":3,"charIndex":1407},{"text":"Object.prototype.isPrototypeOf(obj)","id":"objectprototypeisprototypeofobj","depth":3,"charIndex":1507},{"text":"Object.prototype.propertyIsEnumerable(prop)","id":"objectprototypepropertyisenumerableprop","depth":3,"charIndex":1614},{"text":"三、在`ES5`中附加的`Object`属性","id":"三在es5中附加的object属性","depth":2,"charIndex":-1},{"text":"Object.defineProperty(obj, prop, descriptor) (ES5)","id":"objectdefinepropertyobj-prop-descriptor-es5","depth":3,"charIndex":2525},{"text":"Object.defineProperties(obj, props) (ES5)","id":"objectdefinepropertiesobj-props-es5","depth":3,"charIndex":2848},{"text":"Object.getPrototypeOf(obj) (ES5)","id":"objectgetprototypeofobj-es5","depth":3,"charIndex":2946},{"text":"Object.create(obj, descr) (ES5)","id":"objectcreateobj-descr-es5","depth":3,"charIndex":3081},{"text":"Object.getOwnPropertyDesciptor(obj, property) (ES5)","id":"objectgetownpropertydesciptorobj-property-es5","depth":3,"charIndex":3209},{"text":"Object.getOwnPropertyNames(obj) (ES5)","id":"objectgetownpropertynamesobj-es5","depth":3,"charIndex":3314},{"text":"Object.preventExtensions(obj) (ES5)","id":"objectpreventextensionsobj-es5","depth":3,"charIndex":3433},{"text":"Object.isExtensible(obj) (ES5)","id":"objectisextensibleobj-es5","depth":3,"charIndex":3472},{"text":"Object.seal(obj) (ES5)","id":"objectsealobj-es5","depth":3,"charIndex":3583},{"text":"Object.isSeal(obj) (ES5)","id":"objectissealobj-es5","depth":3,"charIndex":3609},{"text":"Object.freeze(obj) (ES5)","id":"objectfreezeobj-es5","depth":3,"charIndex":3810},{"text":"Object.isFrozen(obj) (ES5)","id":"objectisfrozenobj-es5","depth":3,"charIndex":3838},{"text":"Object.keys(obj) (ES5)","id":"objectkeysobj-es5","depth":3,"charIndex":4032},{"text":"四、在`ES6`中附加的`Object`属性","id":"四在es6中附加的object属性","depth":2,"charIndex":-1},{"text":"Object.is(value1, value2) (ES6)","id":"objectisvalue1-value2-es6","depth":3,"charIndex":4196},{"text":"Object.assign(target, ...sources) (ES6)","id":"objectassigntarget-sources-es6","depth":3,"charIndex":4330},{"text":"Object.getOwnPropertySymbols(obj) (ES6)","id":"objectgetownpropertysymbolsobj-es6","depth":3,"charIndex":4682},{"text":"Object.setPrototypeOf(obj, prototype) (ES6)","id":"objectsetprototypeofobj-prototype-es6","depth":3,"charIndex":4843},{"text":"五、在`ES8`中附加的`Object`属性","id":"五在es8中附加的object属性","depth":2,"charIndex":-1},{"text":"Object.getOwnPropertyDescriptors(obj) (ES8)","id":"objectgetownpropertydescriptorsobj-es8","depth":3,"charIndex":5346},{"text":"Object.values(obj) (ES8)","id":"objectvaluesobj-es8","depth":3,"charIndex":5480},{"text":"Object.entries(obj) (ES8)","id":"objectentriesobj-es8","depth":3,"charIndex":5617},{"text":"六、在`ES10`中附加的`Object`属性","id":"六在es10中附加的object属性","depth":2,"charIndex":-1},{"text":"Object.fromEntries(iterable) (ES10)","id":"objectfromentriesiterable-es10","depth":3,"charIndex":5790},{"text":"小结","id":"小结","depth":2,"charIndex":5942},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":6193},{"text":"关于","id":"关于","depth":2,"charIndex":6262},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":47,"title":"面试官问：JS的this指向","content":"#\n\n> 写于2018年12月25日\n\n\n前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 这是面试官问系列的第四篇，旨在帮助读者提升JS基础知识，包含new、call、apply、this、继承相关知识。\n> 面试官问系列文章如下：感兴趣的读者可以点击阅读。 1.面试官问：能否模拟实现JS的new操作符 2.面试官问：能否模拟实现JS的bind方法\n> 3.面试官问：能否模拟实现JS的call和apply方法 4.面试官问：JS的this指向 5.面试官问：JS的继承\n\n面试官出很多考题，基本都会变着方式来考察this指向，看候选人对JS基础知识是否扎实。\n读者可以先拉到底部看总结，再谷歌（或各技术平台）搜索几篇类似文章，看笔者写的文章和别人有什么不同（欢迎在评论区评论不同之处），对比来看，验证与自己现有知识是否有\n盲点，多看几篇，自然就会完善自身知识。\n\n> 附上之前写文章写过的一段话：已经有很多关于this的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能\n> 看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。\n\n函数的this在调用时绑定的，完全取决于函数的调用位置（也就是函数的调用方法）。为了搞清楚this的指向是什么，必须知道相关函数是如何调用的。\n\n\n全局上下文#\n\n非严格模式和严格模式中this都是指向顶层对象（浏览器中是window）。\n\n\n\n\n函数上下文#\n\n\n普通函数调用模式#\n\n\n\n你可能会误以为window.doSth()是调用的，所以是指向window。虽然本例中window.doSth确实等于doSth。name等于window.na\nme。上面代码中这是因为在ES5中，全局变量是挂载在顶层对象（浏览器是window）中。 事实上，并不是如此。\n\n\n\n这个例子中let没有给顶层对象中（浏览器是window）添加属性，window.name2和window.doSth都是undefined。\n\n严格模式中，普通函数中的this则表现不同，表现为undefined。\n\n\n\n看过的《你不知道的JavaScript》上卷的读者，应该知道书上将这种叫做默认绑定。 对call，apply熟悉的读者会类比为：\n\n\n\n效果是一样的，call，apply作用之一就是用来修改函数中的this指向为第一个参数的。\n第一个参数是undefined或者null，非严格模式下，是指向window。严格模式下，就是指向第一个参数。后文详细解释。\n经常有这类代码（回调函数），其实也是普通函数调用模式。\n\n\n\n\n对象中的函数（方法）调用模式#\n\n\n\n但往往会有以下场景，把对象中的函数赋值成一个变量了。 这样其实又变成普通函数了，所以使用普通函数的规则（默认绑定）。\n\n\n\n\ncall、apply、bind 调用模式#\n\n上文提到call、apply，这里详细解读一下。先通过MDN认识下call和apply MDN 文档：Function.prototype.call() 语法\n\n\n\nthisArg\n在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和und\nefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。\narg1, arg2, ... 指定的参数列表 返回值 返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。\napply和call类似。只是参数不一样。它的参数是数组（或者类数组）。\n\n根据参数thisArg的描述，可以知道，call就是改变函数中的this指向为thisArg，并且执行这个函数，这也就使JS灵活很多。严格模式下，thisArg\n是原始值是值类型，也就是原始值。不会被包装成对象。举个例子：\n\n\n\n虽然一般不会把thisArg参数写成值类型。但还是需要知道这个知识。 之前写过一篇文章：面试官问：能否模拟实现JS的call和apply方法\n就是利用对象上的函数this指向这个对象，来模拟实现call和apply的。感兴趣的读者思考如何实现，再去看看笔者的实现。\n\nbind和call和apply类似，第一个参数也是修改this指向，只不过返回值是新函数，新函数也能当做构造函数（new）调用。 MDN\nFunction.prototype.bind\n\n> bind()方法创建一个新的函数， 当这个新函数被调用时this键值为其提供的值，其参数列表前几项值为创建时指定的参数序列。 语法：\n> fun.bind(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 调用绑定函数时作为this参数传递给目标函数的值。\n> 如果使用new运算符构造绑定函数，则忽略该值。当使用bind在setTimeout中创建一个函数（作为回调提供）时，作为thisArg传递的任何原始值都将转\n> 换为object。如果没有提供绑定的参数，则执行作用域的this被视为新函数的thisArg。 arg1, arg2, ...\n> 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回值 返回由指定的this值和初始化参数改造的原函数拷贝。\n\n之前也写过一篇文章：面试官问：能否模拟实现JS的bind方法\n就是利用call和apply指向这个thisArg参数，来模拟实现bind的。感兴趣的读者思考如何实现，再去看看笔者的实现。\n\n\n构造函数调用模式#\n\n\n\n使用new操作符调用函数，会自动执行以下步骤。\n\n>  1. 创建了一个全新的对象。\n>  2. 这个对象会被执行[[Prototype]]（也就是__proto__）链接。\n>  3. 生成的新对象会绑定到函数调用的this。\n>  4. 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。\n>  5. 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg,\n>     Error)，那么new表达式中的函数调用会自动返回这个新的对象。\n\n由此可以知道：new操作符调用时，this指向生成的新对象。 特别提醒一下，new调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象。\n\n\n\n很多人或者文章都忽略了这一点，直接简单用typeof判断对象。虽然实际使用时不会显示返回，但面试官会问到。\n\n之前也写了一篇文章面试官问：能否模拟实现JS的new操作符，是使用apply来把this指向到生成的新生成的对象上。感兴趣的读者思考如何实现，再去看看笔者的实现\n。\n\n\n原型链中的调用模式#\n\n\n\n会发现这个似曾相识。这就是对象上的方法调用模式。自然是指向生成的新对象。 如果该对象继承自其它对象。同样会通过原型链查找。 上面代码使用\nES6中class写法则是：\n\n\n\nbabel es6转换成es5的结果，可以去babeljs网站转换测试自行试试。\n\n\n\n由此看出，ES6的class也是通过构造函数模拟实现的，是一种语法糖。\n\n\n箭头函数调用模式#\n\n先看箭头函数和普通函数的重要区别：\n\n> 1、没有自己的this、super、arguments和new.target绑定。 2、不能使用new来调用。 3、没有原型对象。\n> 4、不可以改变this的绑定。 5、形参名称不能重复。\n\n箭头函数中没有this绑定，必须通过查找作用域链来决定其值。\n如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this，否则this的值则被设置为全局对象。 比如：\n\n\n\n其实就是相当于箭头函数外的this是缓存的该箭头函数上层的普通函数的this。如果没有普通函数，则是全局对象（浏览器中则是window）。\n也就是说无法通过call、apply、bind绑定箭头函数的this(它自身没有this)。而call、apply、bind可以绑定缓存箭头函数上层的普通函数的\nthis。 比如：\n\n\n\n\nDOM事件处理函数调用#\n\naddEventerListener、attachEvent、onclick#\n\n\n\nonclick和addEventerListener是指向绑定事件的元素。\n一些浏览器，比如IE6~IE8下使用attachEvent，this指向是window。\n顺便提下：面试官也经常考察ev.currentTarget和ev.target的区别。\nev.currentTarget是绑定事件的元素，而ev.target是当前触发事件的元素。比如这里的分别是ul和li。\n但也可能点击的是ul，这时ev.currentTarget和ev.target就相等了。\n\n内联事件处理函数调用#\n\n\n\n第一个是button本身，所以是true，第二个是window。这里跟严格模式没有关系。 当然我们现在不会这样用了，但有时不小心写成了这样，也需要了解。\n\n其实this的使用场景还有挺多，比如对象object中的getter、setter的this，new Function()、eval。\n但掌握以上几种，去分析其他的，就自然迎刃而解了。 使用比较多的还是普通函数调用、对象的函数调用、new调用、call、apply、bind调用、箭头函数调用。\n那么他们的优先级是怎样的呢。\n\n\n优先级#\n\n而箭头函数的this是上层普通函数的this或者是全局对象（浏览器中是window），所以排除，不算优先级。\n\n\n\n试想一下，如果是Student.doSth.call(person)先执行的情况下，那new执行一个函数。是没有问题的。\n然而事实上，这代码是报错的。运算符优先级是new比点号低，所以是执行new (Student.doSth.call)(person)\n而Function.prototype.call，虽然是一个函数（apply、bind也是函数），跟箭头函数一样，不能用new调用。所以报错了。\n\n\n\n这是因为函数内部有两个不同的方法：[[Call]]和[[Constructor]]。\n当使用普通函数调用时，[[Call]]会被执行。当使用构造函数调用时，[[Constructor]]会被执行。call、apply、bind和箭头函数内部没有[\n[Constructor]]方法。\n\n从上面的例子可以看出普通函数调用优先级最低，其次是对象上的函数。\ncall（apply、bind）调用方式和new调用方式的优先级，在《你不知道的JavaScript》是对比bind和new，引用了mdn的bind的ployf\nill实现，new调用时bind之后的函数，会忽略bind绑定的第一个参数，(mdn的实现其实还有一些问题，感兴趣的读者，可以看我之前的文章：面试官问：能否模拟\n实现JS的bind方法)，说明new的调用的优先级最高。 所以它们的优先级是new 调用 > call、apply、bind 调用 > 对象上的函数调用 >\n普通函数调用。\n\n\n总结#\n\n如果要判断一个运行中函数的 this 绑定， 就需要找到这个函数的直接调用位置。 找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。\n\n 1. new 调用：绑定到新创建的对象，注意：显示return函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。\n 2. call 或者 apply（ 或者 bind）\n    调用：严格模式下，绑定到指定的第一个参数。非严格模式下，null和undefined，指向全局对象（浏览器中是window），其余值指向被new\n    Object()包装的对象。\n 3. 对象上的函数调用：绑定到那个对象。\n 4. 普通函数调用： 在严格模式下绑定到 undefined，否则绑定到全局对象。\n\nES6 中的箭头函数：不会使用上文的四条标准的绑定规则， 而是根据当前的词法作用域来决定this， 具体来说， 箭头函数会继承外层函数，调用的 this 绑定（\n无论 this 绑定到什么），没有外层函数，则是绑定到全局对象（浏览器中是window）。 这其实和 ES6 之前代码中的 self = this 机制一样。\n\nDOM事件函数：一般指向绑定事件的DOM元素，但有些情况绑定到全局对象（比如IE6~IE8的attachEvent）。\n\n一定要注意，有些调用可能在无意中使用普通函数绑定规则。 如果想“ 更安全” 地忽略 this 绑 定， 你可以使用一个对象， 比如 ø =\nObject.create(null)， 以保护全局对象。\n\n面试官考察this指向就可以考察new、call、apply、bind，箭头函数等用法。从而扩展到作用域、闭包、原型链、继承、严格模式等。这就是面试官乐此不疲的\n原因。\n\n读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。\n\n\n考题#\n\nthis指向考题经常结合一些运算符等来考察。看完本文，不妨通过以下两篇面试题测试一下。 小小沧海：一道常被人轻视的前端JS面试题\n从这两套题，重新认识JS的this、作用域、闭包、对象\n\n\n扩展阅读#\n\n你不知道的JavaScript 上卷 冴羽：JavaScript深入之从ECMAScript规范解读this 这波能反杀：前端基础进阶（五）：全方位解读this\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客 掘金专栏，欢迎关注~\nsegmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/js-this/","lang":"zh","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":20},{"text":"全局上下文","id":"全局上下文","depth":2,"charIndex":713},{"text":"函数上下文","id":"函数上下文","depth":2,"charIndex":763},{"text":"普通函数调用模式","id":"普通函数调用模式","depth":3,"charIndex":772},{"text":"对象中的函数（方法）调用模式","id":"对象中的函数方法调用模式","depth":3,"charIndex":1245},{"text":"`call、apply、bind` 调用模式","id":"callapplybind-调用模式","depth":3,"charIndex":-1},{"text":"构造函数调用模式","id":"构造函数调用模式","depth":3,"charIndex":2507},{"text":"原型链中的调用模式","id":"原型链中的调用模式","depth":3,"charIndex":3010},{"text":"箭头函数调用模式","id":"箭头函数调用模式","depth":3,"charIndex":3193},{"text":"`DOM`事件处理函数调用","id":"dom事件处理函数调用","depth":3,"charIndex":-1},{"text":"addEventerListener、attachEvent、onclick","id":"addeventerlistenerattacheventonclick","depth":4,"charIndex":3597},{"text":"内联事件处理函数调用","id":"内联事件处理函数调用","depth":4,"charIndex":3874},{"text":"优先级","id":"优先级","depth":3,"charIndex":4132},{"text":"总结","id":"总结","depth":2,"charIndex":4827},{"text":"考题","id":"考题","depth":2,"charIndex":5621},{"text":"扩展阅读","id":"扩展阅读","depth":2,"charIndex":5721},{"text":"关于","id":"关于","depth":2,"charIndex":5811},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":48,"title":"50行代码串行Promise，koa洋葱模型原来是这么实现？","content":"#\n\n\n1. 前言#\n\n大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动《1个月，200+人，一起读了4周源码》，感兴趣的可以加我微信 ruochuan12\n参与，长期交流学习。\n\n之前写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4十余篇源码文章\n。其中最新的两篇是：\n\nVue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？\n\n初学者也能看懂的 Vue3 源码中那些实用的基础工具函数\n\n写相对很难的源码，耗费了自己的时间和精力，也没收获多少阅读点赞，其实是一件挺受打击的事情。从阅读量和读者受益方面来看，不能促进作者持续输出文章。\n\n所以转变思路，写一些相对通俗易懂的文章。其实源码也不是想象的那么难，至少有很多看得懂。\n\n之前写过 koa 源码文章学习 koa\n源码的整体架构，浅析koa洋葱模型原理和co原理比较长，读者朋友大概率看不完，所以本文从koa-compose50行源码讲述。\n\n本文涉及到的 koa-compose 仓库 文件，整个index.js文件代码行数虽然不到 50 行，而且测试用例test/test.js文件 300\n余行，但非常值得我们学习。\n\n歌德曾说：读一本好书，就是在和高尚的人谈话。 同理可得：读源码，也算是和作者的一种学习交流的方式。\n\n阅读本文，你将学到：\n\n\n\n\n2. 环境准备#\n\n\n2.1 克隆 koa-compose 项目#\n\n本文仓库地址 koa-compose-analysis，求个star~\n\n\n\n顺带说下：我是怎么保留 compose 仓库的 git 记录的。\n\n\n\n关于更多 git subtree，可以看这篇文章用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册\n\n接着我们来看怎么根据开源项目中提供的测试用例调试源码。\n\n\n2.2 根据测试用例调试 compose 源码#\n\n用VSCode（我的版本是 1.60 ）打开项目，找到 compose/package.json，找到 scripts 和 test 命令。\n\n\n\n在scripts上方应该会有debug或者调试字样。点击debug(调试)，选择 test。\n\n\n\n接着会执行测试用例test/test.js文件。终端输出如下图所示。\n\n\n\n接着我们调试 compose/test/test.js 文件。 我们可以在 45行 打上断点，重新点击 package.json => srcipts =>\ntest 进入调试模式。 如下图所示。\n\n\n\n接着按上方的按钮，继续调试。在compose/index.js文件中关键的地方打上断点，调试学习源码事半功倍。\n\n更多 nodejs 调试相关 可以查看官方文档\n\n顺便详细解释下几个调试相关按钮。\n\n * 1. 继续（F5）: 点击后代码会直接执行到下一个断点所在位置，如果没有下一个断点，则认为本次代码执行完成。\n * 2. 单步跳过（F10）：点击后会跳到当前代码下一行继续执行，不会进入到函数内部。\n * 3. 单步调试（F11）：点击后进入到当前函数的内部调试，比如在 compose 这一行中执行单步调试，会进入到 compose 函数内部进行调试。\n * 4. 单步跳出（Shift + F11）：点击后跳出当前调试的函数，与单步调试对应。\n * 5. 重启（Ctrl + Shift + F5）：顾名思义。\n * 6. 断开链接（Shift + F5）：顾名思义。\n\n接下来，我们跟着测试用例学源码。\n\n\n3. 跟着测试用例学源码#\n\n分享一个测试用例小技巧：我们可以在测试用例处加上only修饰。\n\n\n\n这样我们就可以只执行当前的测试用例，不关心其他的，不会干扰调试。\n\n\n3.1 正常流程#\n\n打开 compose/test/test.js 文件，看第一个测试用例。\n\n\n\n大概看完这段测试用例，context是什么，next又是什么。\n\n在koa的文档上有个非常代表性的中间件 gif 图。\n\n\n\n而compose函数作用就是把添加进中间件数组的函数按照上面 gif 图的顺序执行。\n\n3.1.1 compose 函数#\n\n简单来说，compose 函数主要做了两件事情。\n\n * 1. 接收一个参数，校验参数是数组，且校验数组中的每一项是函数。\n * 2. 返回一个函数，这个函数接收两个参数，分别是context和next，这个函数最后返回Promise。\n\n\n\n接着我们来看 dispatch 函数。\n\n3.1.2 dispatch 函数#\n\n\n\n值得一提的是：bind函数是返回一个新的函数。第一个参数是函数里的this指向（如果函数不需要使用this，一般会写成null）。 这句fn(context,\ndispatch.bind(null, i + 1)，i + 1 是为了 let fn = middleware[i] 取middleware中的下一个函数。\n也就是 next 是下一个中间件里的函数。也就能解释上文中的 gif图函数执行顺序。 测试用例中数组的最终顺序是[1,2,3,4,5,6]。\n\n3.1.3 简化 compose 便于理解#\n\n自己动手调试之后，你会发现 compose 执行后就是类似这样的结构（省略 try catch 判断）。\n\n\n\n> 也就是说koa-compose返回的是一个Promise，从中间件（传入的数组）中取出第一个函数，传入context和第一个next函数来执行。\n> 第一个next函数里也是返回的是一个Promise，从中间件（传入的数组）中取出第二个函数，传入context和第二个next函数来执行。\n> 第二个next函数里也是返回的是一个Promise，从中间件（传入的数组）中取出第三个函数，传入context和第三个next函数来执行。 第三个...\n> 以此类推。最后一个中间件中有调用next函数，则返回Promise.resolve。如果没有，则不执行next函数。\n> 这样就把所有中间件串联起来了。这也就是我们常说的洋葱模型。\n\n\n\n不得不说非常惊艳，“玩还是大神会玩”。\n\n\n3.2 错误捕获#\n\n\n\n相信理解了第一个测试用例和 compose 函数，也是比较好理解这个测试用例了。这一部分其实就是对应的代码在这里。\n\n\n\n\n3.3 next 函数不能调用多次#\n\n\n\n这一块对应的则是：\n\n\n\n调用两次后 i 和 index 都为 1，所以会报错。\n\ncompose/test/test.js文件中总共 300余行，还有很多测试用例可以按照文中方法自行调试。\n\n\n4. 总结#\n\n虽然koa-compose源码 50行 不到，但如果是第一次看源码调试源码，还是会有难度的。其中混杂着高阶函数、闭包、Promise、bind等基础知识。\n\n通过本文，我们熟悉了 koa-compose 中间件常说的洋葱模型，学会了部分 jest 用法，同时也学会了如何使用现成的测试用例去调试源码。\n\n相信学会了通过测试用例调试源码后，会觉得源码也没有想象中的那么难。\n\n开源项目，一般都会有很全面的测试用例。除了可以给我们学习源码调试源码带来方便的同时，也可以给我们带来的启发：自己工作中的项目，也可以逐步引入测试工具，比如\njest。\n\n此外，读开源项目源码是我们学习业界大牛设计思想和源码实现等比较好的方式。\n\n看完本文，非常希望能自己动手实践调试源码去学习，容易吸收消化。另外，如果你有余力，可以继续看我的 koa-compose 源码文章：学习 koa\n源码的整体架构，浅析koa洋葱模型原理和co原理","routePath":"/koa-compose/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 环境准备","id":"2-环境准备","depth":2,"charIndex":634},{"text":"2.1 克隆 koa-compose 项目","id":"21-克隆-koa-compose-项目","depth":3,"charIndex":645},{"text":"2.2 根据测试用例调试 compose 源码","id":"22-根据测试用例调试-compose-源码","depth":3,"charIndex":840},{"text":"3. 跟着测试用例学源码","id":"3-跟着测试用例学源码","depth":2,"charIndex":1540},{"text":"3.1 正常流程","id":"31-正常流程","depth":3,"charIndex":1625},{"text":"3.1.1 compose 函数","id":"311-compose-函数","depth":4,"charIndex":1783},{"text":"3.1.2 dispatch 函数","id":"312-dispatch-函数","depth":4,"charIndex":1945},{"text":"3.1.3 简化 compose 便于理解","id":"313-简化-compose-便于理解","depth":4,"charIndex":2199},{"text":"3.2 错误捕获","id":"32-错误捕获","depth":3,"charIndex":2623},{"text":"3.3 next 函数不能调用多次","id":"33-next-函数不能调用多次","depth":3,"charIndex":2698},{"text":"4. 总结","id":"4-总结","depth":2,"charIndex":2818}],"domain":"","frontmatter":{},"version":""},{"id":49,"title":"学习 koa 源码的整体架构，浅析koa洋葱模型原理和co原理","content":"#\n\n\n1. 前言#\n\n> 你好，我是若川，微信搜索「若川视野」关注我，专注前端技术分享。欢迎加我微信ruochuan12，加群交流学习。\n\n> 这是学习源码整体架构系列第七篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。本篇文章\n> 学习的是实际仓库的代码。\n\n> 本文仓库地址：git clone https://github.com/ruochuan12/koa-analysis.git\n\n> 要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了。\n\n学习源码整体架构系列文章如下：\n\n> 1.学习 jQuery 源码整体架构，打造属于自己的 js 类库 2.学习 underscore 源码整体架构，打造属于自己的函数式编程类库 3.学习\n> lodash 源码整体架构，打造属于自己的函数式编程类库 4.学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK 5.学习 vuex\n> 源码整体架构，打造属于自己的状态管理库 6.学习 axios 源码整体架构，打造属于自己的请求库 7.学习 koa\n> 源码的整体架构，浅析koa洋葱模型原理和co原理 8.学习 redux 源码整体架构，深入理解 redux 及其中间件原理\n\n感兴趣的读者可以点击阅读。 其他源码计划中的有：express、vue-rotuer、react-redux\n等源码，不知何时能写完（哭泣），欢迎持续关注我（若川）。\n\n源码类文章，一般阅读量不高。已经有能力看懂的，自己就看了。不想看，不敢看的就不会去看源码。 所以我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。\n\n如果你简历上一不小心写了熟悉koa，面试官大概率会问：\n\n> 1、koa洋葱模型怎么实现的。 2、如果中间件中的next()方法报错了怎么办。 3、co的原理是怎样的。 等等问题\n\n导读 文章通过例子调试koa，梳理koa的主流程，来理解koa-compose洋葱模型原理和co库的原理，相信看完一定会有所收获。\n\n\n\n本文学习的koa版本是v2.11.0。克隆的官方仓库的master分支。 截至目前（2020年3月11日），最新一次commit是2020-01-04\n07:41 Olle Jonsson eda27608，build: Drop unused Travis sudo: false directive\n(#1416)。\n\n本文仓库在这里若川的 koa-analysis github 仓库\nhttps://github.com/ruochuan12/koa-analysis。求个star呀。\n\n\n2. 本文阅读最佳方式#\n\n先star一下我的仓库，再把它git clone\nhttps://github.com/ruochuan12/koa-analysis.git克隆下来。不用管你是否用过nodejs。会一点点promise、ge\nnerator、async、await等知识即可看懂。如果一点点也不会，可以边看阮一峰老师的《ES6标准入门》相关章节。跟着文章节奏调试和示例代码调试，动手调试\n（用vscode或者chrome）印象更加深刻。文章长段代码不用细看，可以调试时再细看。看这类源码文章百遍，可能不如自己多调试几遍。也欢迎加我微信交流ruoch\nuan12。\n\n\n\n这里把这个examples文件夹做个简单介绍。\n\n * middleware文件夹是用来vscode调试整体流程的。\n * simpleKoa 文件夹是koa简化版，为了调试koa-compose洋葱模型如何串联起来各个中间件的。\n * koa-convert文件夹是用来调试koa-convert和co源码的。\n * co-generator文件夹是模拟实现co的示例代码。\n\n\n3. vscode 调试 koa 源码方法#\n\n之前，我在知乎回答了一个问题一年内的前端看不懂前端框架源码怎么办？ 推荐了一些资料，阅读量还不错，大家有兴趣可以看看。主要有四点：\n\n> 1.借助调试 2.搜索查阅相关高赞文章 3.把不懂的地方记录下来，查阅相关文档 4.总结\n\n看源码，调试很重要，所以我详细写下 koa 源码调试方法，帮助一些可能不知道如何调试的读者。\n\n\n\n\n\n克隆源码后，看package.json找到main，就知道入口文件是lib/application.js了。\n\n大概看完项目结构后发现没有examples文件夹（一般项目都会有这个文件夹，告知用户如何使用该项目），这时仔细看README.md。\n如果看英文README.md有些吃力，会发现在Community标题下有一个中文文档 v2.x。同时也有一个examples仓库。\n\n\n\n这时再开心的把examples克隆到自己电脑。可以安装好依赖，逐个研究学习下这里的例子，然后可能就一不小心掌握了koa的基本用法。当然，我这里不详细写这一块了，\n我是自己手写一些例子来调试。\n\n继续看文档会发现使用指南讲述编写中间件。\n\n\n3.1 使用文档中的中间件koa-compose例子来调试#\n\n学习 koa-compose 前，先看两张图。\n\n\n\n\n\n在koa中，请求响应都放在中间件的第一个参数context对象中了。\n\n再引用Koa中文文档中的一段：\n\n如果您是前端开发人员，您可以将 next(); 之前的任意代码视为“捕获”阶段，这个简易的 gif 说明了 async\n函数如何使我们能够恰当地利用堆栈流来实现请求和响应流：\n\n\n\n>  1.  创建一个跟踪响应时间的日期\n>  2.  等待下一个中间件的控制\n>  3.  创建另一个日期跟踪持续时间\n>  4.  等待下一个中间件的控制\n>  5.  将响应主体设置为“Hello World”\n>  6.  计算持续时间\n>  7.  输出日志行\n>  8.  计算响应时间\n>  9.  设置 X-Response-Time 头字段\n>  10. 交给 Koa 处理响应\n\n读者们看完这个gif图，也可以思考下如何实现的。根据表现，可以猜测是next是一个函数，而且返回的可能是一个promise，被await调用。\n\n看到这个gif图，我把之前写的examples/koa-compose的调试方法含泪删除了。默默写上gif图上的这些代码，想着这个读者们更容易读懂。\n我把这段代码写在这里 koa/examples/middleware/app.js便于调试。\n\n在项目路径下配置新建.vscode/launch.json文件，program配置为自己写的koa/examples/middleware/app.js文件。\n\n\n\n按F5键开始调试，调试时先走主流程，必要的地方打上断点，不用一开始就关心细枝末节。\n\n> 断点调试要领： 赋值语句可以一步跳过，看返回值即可，后续详细再看。 函数执行需要断点跟着看，也可以结合注释和上下文倒推这个函数做了什么。\n\n上述比较啰嗦的写了一堆调试方法。主要是想着授人予鱼不如授人予渔，这样换成其他源码也会调试了。\n\n简单说下chrome调试nodejs，chrome浏览器打开chrome://inspect，点击配置**configure...**配置127.0.0.1:端\n口号(端口号在Vscode 调试控制台显示了)。 更多可以查看English Debugging Guide 中文调试指南\n喜欢看视频的读者也可以看慕课网这个视频node.js调试入门，讲得还是比较详细的。\n不过我感觉在chrome调试nodejs项目体验不是很好（可能是我方式不对），所以我大部分具体的代码时都放在html文件script形式，在chrome调试了。\n\n\n4. 先看看 new Koa() 结果app是什么#\n\n看源码我习惯性看它的实例对象结构，一般所有属性和方法都放在实例对象上了，而且会通过原型链查找形式查找最顶端的属性和方法。\n\n用koa/examples/middleware/app.js文件调试时，先看下执行new Koa()之后，app是什么，有个初步印象。\n\n\n\n在调试控制台ctrl + 反引号键（一般在Tab上方的按键）唤起，输入app，按enter键打印app。会有一张这样的图。\n\n\n\nVScode也有一个代码调试神器插件Debug Visualizer。\n\n安装好后插件后，按ctrl + shift + p，输入Open a new Debug Visualizer View，来使用，输入app，显示是这样的。\n\n\n\n不过目前体验来看，相对还比较鸡肋，只能显示一级，而且只能显示对象，相信以后会更好。更多玩法可以查看它的文档。\n\n我把koa实例对象比较完整的用xmind画出来了，大概看看就好，有个初步印象。\n\n\n\n接着，我们可以看下app 实例、context、request、request的官方文档。\n\n\n4.1 app 实例、context、request、request 官方API文档#\n\n * index API | context API | request API | response API\n\n可以真正使用的时候再去仔细看文档。\n\n\n5. koa 主流程梳理简化#\n\n通过F5启动调试（直接跳到下一个断点处）、F10单步跳过、F11单步调试等，配合重要的地方断点，调试完整体代码，其实比较容易整理出如下主流程的代码。\n\n\n\n重点就在listen函数里的compose这个函数，接下来我们就详细来欣赏下这个函数。\n\n\n6. koa-compose 源码（洋葱模型实现）#\n\n通过app.use() 添加了若干函数，但是要把它们串起来执行呀。像上文的gif图一样。\n\ncompose函数，传入一个数组，返回一个函数。对入参是不是数组和校验数组每一项是不是函数。\n\n\n\n把简化的代码和koa-compose代码写在了一个文件中。koa/examples/simpleKoa/koa-compose.js\n\n\n\n不过这样好像还是有点麻烦，我还把这些代码放在codepen\nhttps://codepen.io/lxchuan12/pen/wvarPEb中，直接可以在线调试啦。是不是觉得很贴心^_^，自己多调试几遍便于消化理解。\n\n你会发现compose就是类似这样的结构（移除一些判断）。\n\n\n\n> 也就是说koa-compose返回的是一个Promise，Promise中取出第一个函数（app.use添加的中间件），传入context和第一个next函\n> 数来执行。\n> 第一个next函数里也是返回的是一个Promise，Promise中取出第二个函数（app.use添加的中间件），传入context和第二个next函数来执\n> 行。\n> 第二个next函数里也是返回的是一个Promise，Promise中取出第三个函数（app.use添加的中间件），传入context和第三个next函数来执\n> 行。 第三个... 以此类推。最后一个中间件中有调用next函数，则返回Promise.resolve。如果没有，则不执行next函数。\n> 这样就把所有中间件串联起来了。这也就是我们常说的洋葱模型。\n\n不得不说非常惊艳，“玩还是大神会玩”。\n\n这种把函数存储下来的方式，在很多源码中都有看到。比如lodash源码的惰性求值，vuex也是把action等函数存储下，最后才去调用。\n\n搞懂了koa-compose 洋葱模型实现的代码，其他代码就不在话下了。\n\n\n7. 错误处理#\n\n中文文档 错误处理\n\n仔细看文档，文档中写了三种捕获错误的方式。\n\n * ctx.onerror 中间件中的错误捕获\n * app.on('error', (err) => {}) 最外层实例事件监听形式 也可以看看例子koajs/examples/errors/app.js\n   文件\n * app.onerror = (err) => {} 重写onerror自定义形式 也可以看测试用例 onerror\n\n\n\nctx.onerror\n\nlib/context.js文件中，有一个函数onerror，而且有这么一行代码this.app.emit('error', err, this)。\n\n\n\n\n\ntry catch\n错误或被fnMiddleware(ctx).then(handleResponse).catch(onerror);，这里的onerror是ctx.onerro\nr 而ctx.onerror函数中又调用了this.app.emit('error', err, this)，所以在最外围app.on('error'，err\n=> {})可以捕获中间件链中的错误。 因为koa继承自events模块，所以有'emit'和on等方法）\n\n\n8. koa2 和 koa1 的简单对比#\n\n中文文档中描述了 koa2 和 koa1 的区别\n\nkoa1中主要是generator函数。koa2中会自动转换generator函数。\n\n\n\n\n8.1 koa-convert 源码#\n\n在vscode/launch.json文件，找到这个program字段，修改为\"program\":\n\"${workspaceFolder}/koa/examples/koa-convert/app.js\"。\n\n通过F5启动调试（直接跳到下一个断点处）、F10单步跳过、F11单步调试调试走一遍流程。重要地方断点调试。\n\napp.use时有一层判断，是否是generator函数，如果是则用koa-convert暴露的方法convert来转换重新赋值，再存入middleware，后\n续再使用。\n\n\n\nkoa-convert源码挺多，核心代码其实是这样的。\n\n\n\n最后还是通过co来转换的。所以接下来看co的源码。\n\n\n8.2 co 源码#\n\ntj大神写的co 仓库\n\n本小节的示例代码都在这个文件夹koa/examples/co-generator中，hs\nkoa/example，可以自行打开https://localhost:8080/co-generator调试查看。\n\n看co源码前，先看几段简单代码。\n\n\n\n\n\n简单来说co，就是把generator自动执行，再返回一个promise。\ngenerator函数这玩意它不自动执行呀，还要一步步调用next()，也就是叫它走一步才走一步。\n\n所以有了async、await函数。\n\n\n\n也就是说co需要做的事情，是让generator向async、await函数一样自动执行。\n\n\n8.3 模拟实现简版 co（第一版）#\n\n这时，我们来模拟实现第一版的co。根据generator的特性，其实容易写出如下代码。\n\n\n\n\n8.4 模拟实现简版 co（第二版）#\n\n但是实际上，不会上面那么简单的。有可能是多个yield和传参数的情况。 传参可以通过这如下两行代码来解决。\n\n\n\n两个yield，我大不了重新调用一下promise.then，搞定。\n\n\n\n\n8.5 模拟实现简版 co（第三版）#\n\n问题是肯定不止两次，无限次的yield的呢，这时肯定要把重复的封装起来。而且返回是promise，这就实现了如下版本的代码。\n\n\n\n但第三版的模拟实现简版co中，还没有考虑报错和一些参数合法的情况。\n\n\n8.6 最终来看下co源码#\n\n这时来看看co的源码，报错和错误的情况，错误时调用reject，是不是就好理解了一些呢。\n\n\n\n\n9. koa 和 express 简单对比#\n\n中文文档 koa 和 express 对比\n\n文档里写的挺全面的。简单来说koa2语法更先进，更容易深度定制（egg.js、think.js、底层框架都是koa）。\n\n\n10. 总结#\n\n文章通过授人予鱼不如授人予鱼的方式，告知如何调试源码，看完了koa-compose洋葱模型实现，koa-convert和co等源码。\n\nkoa-compose是将app.use添加到middleware数组中的中间件（函数），通过使用Promise串联起来，next()返回的是一个promise\n。\n\nkoa-convert 判断app.use传入的函数是否是generator函数，如果是则用koa-convert来转换，最终还是调用的co来转换。\n\nco源码实现原理：其实就是通过不断的调用generator函数的next()函数，来达到自动执行generator函数的效果（类似async、await函数的自\n动自行）。\n\nkoa框架总结：主要就是四个核心概念，洋葱模型（把中间件串联起来），http请求上下文（context）、http请求对象、http响应对象。\n\n本文仓库在这里若川的 koa-analysis github 仓库\nhttps://github.com/ruochuan12/koa-analysis。求个star呀。\n\n\n\n再强烈建议下按照本文阅读最佳方式，克隆代码下来，动手调试代码学习更加深刻。\n\n> 如果读者发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出，也欢迎加我微信交流ruochuan12。另外觉得写得不错，对您有些许帮助，可以点赞、\n> 评论、转发分享，也是对笔者的一种支持，万分感谢。\n\n\n10.1 解答下开头的提问#\n\n仅供参考\n\n> 1、koa洋葱模型怎么实现的。\n\n可以参考上文整理的简版koa-compose作答。\n\n\n\n答：app.use()\n把中间件函数存储在middleware数组中，最终会调用koa-compose导出的函数compose返回一个promise，中间函数的第一个参数ctx是包含响\n应和请求的一个对象，会不断传递给下一个中间件。next是一个函数，返回的是一个promise。\n\n> 2、如果中间件中的next()方法报错了怎么办。\n\n可参考上文整理的错误处理作答。\n\n\n\n答：中间件链错误会由ctx.onerror捕获，该函数中会调用this.app.emit('error', err,\nthis)（因为koa继承自events模块，所以有'emit'和on等方法），可以使用app.on('error', (err) =>\n{})，或者app.onerror = (err) => {}进行捕获。\n\n> 3、co的原理是怎样的。\n> 答：co的原理是通过不断调用generator函数的next方法来达到自动执行generator函数的，类似async、await函数自动执行。\n\n答完，面试官可能觉得小伙子还是蛮懂koa的啊。当然也可能继续追问，直到答不出...\n\n\n10.2 还能做些什么 ？#\n\n学完了整体流程，koa-compose、koa-convert和co的源码。\n\n还能仔细看看看http请求上下文（context）、http请求对象、http响应对象的具体实现。\n\n还能根据我文章说的调试方式调试koa 组织中的各种中间件，比如koa-bodyparser,\nkoa-router，koa-jwt，koa-session、koa-cors等等。\n\n还能把examples仓库克隆下来，我的这个仓库已经克隆了，挨个调试学习下源码。\n\nweb框架有很多，比如Express.js，Koa.js、Egg.js、Nest.js、Next.js、Fastify.js、Hapi.js、Restify.j\ns、Loopback.io、Sails.js、Midway.js等等。\n\n还能把这些框架的优势劣势、设计思想等学习下。\n\n还能继续学习HTTP协议、TCP/IP协议网络相关，虽然不属于koa的知识，但需深入学习掌握。\n\n学无止境~~~\n\n\n11. 推荐阅读#\n\nkoa 官网 | koa 仓库 | koa 组织 | koa2 中文文档 | co 仓库 知乎@姚大帅：可能是目前市面上比较有诚意的Koa2源码解读\n知乎@零小白：十分钟带你看完 KOA 源码 微信开放社区@小丹の：可能是目前最全的koa源码解析指南 IVWEB官方账号: KOA2框架原理解析和实现\n深入浅出vue.js 作者 berwin: 深入浅出 Koa2 原理 阮一峰老师：co 函数库的含义和用法\n\n\n另一个系列#\n\n面试官问：JS的继承 面试官问：JS的this指向 面试官问：能否模拟实现JS的call和apply方法 面试官问：能否模拟实现JS的bind方法\n面试官问：能否模拟实现JS的new操作符\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 若川的博客，使用vuepress重构了，阅读体验可能更好些\n掘金专栏，欢迎关注~ segmentfault前端视野专栏，欢迎关注~ 知乎前端视野专栏，欢迎关注~ 语雀前端视野专栏，新增语雀专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n欢迎加微信交流 微信公众号#\n\n可能比较有趣的微信公众号，长按扫码关注（回复pdf获取前端优质书籍pdf）。欢迎加我微信ruochuan12（注明来源，基本来者不拒），拉您进【前端视野交流群】\n，长期交流学习~\n\n","routePath":"/koa/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 本文阅读最佳方式","id":"2-本文阅读最佳方式","depth":2,"charIndex":1146},{"text":"3. vscode 调试 koa 源码方法","id":"3-vscode-调试-koa-源码方法","depth":2,"charIndex":1629},{"text":"3.1 使用文档中的中间件`koa-compose`例子来调试","id":"31-使用文档中的中间件koa-compose例子来调试","depth":3,"charIndex":-1},{"text":"4. 先看看 `new Koa()` 结果`app`是什么","id":"4-先看看-new-koa-结果app是什么","depth":2,"charIndex":-1},{"text":"4.1 app 实例、context、request、request 官方API文档","id":"41-app-实例contextrequestrequest-官方api文档","depth":3,"charIndex":3740},{"text":"5. koa 主流程梳理简化","id":"5-koa-主流程梳理简化","depth":2,"charIndex":3862},{"text":"6. koa-compose 源码（洋葱模型实现）","id":"6-koa-compose-源码洋葱模型实现","depth":2,"charIndex":4003},{"text":"7. 错误处理","id":"7-错误处理","depth":2,"charIndex":4829},{"text":"8. koa2 和 koa1 的简单对比","id":"8-koa2-和-koa1-的简单对比","depth":2,"charIndex":5368},{"text":"8.1 koa-convert 源码","id":"81-koa-convert-源码","depth":3,"charIndex":5464},{"text":"8.2 co 源码","id":"82-co-源码","depth":3,"charIndex":5794},{"text":"8.3 模拟实现简版 co（第一版）","id":"83-模拟实现简版-co第一版","depth":3,"charIndex":6105},{"text":"8.4 模拟实现简版 co（第二版）","id":"84-模拟实现简版-co第二版","depth":3,"charIndex":6174},{"text":"8.5 模拟实现简版 co（第三版）","id":"85-模拟实现简版-co第三版","depth":3,"charIndex":6291},{"text":"8.6 最终来看下`co`源码","id":"86-最终来看下co源码","depth":3,"charIndex":-1},{"text":"9. koa 和 express 简单对比","id":"9-koa-和-express-简单对比","depth":2,"charIndex":6479},{"text":"10. 总结","id":"10-总结","depth":2,"charIndex":6588},{"text":"10.1 解答下开头的提问","id":"101-解答下开头的提问","depth":3,"charIndex":7224},{"text":"10.2 还能做些什么 ？","id":"102-还能做些什么-","depth":3,"charIndex":7784},{"text":"11. 推荐阅读","id":"11-推荐阅读","depth":2,"charIndex":8225},{"text":"另一个系列","id":"另一个系列","depth":2,"charIndex":8443},{"text":"关于","id":"关于","depth":2,"charIndex":8548},{"text":"欢迎加微信交流 微信公众号","id":"欢迎加微信交流-微信公众号","depth":2,"charIndex":8735}],"domain":"","frontmatter":{},"version":""},{"id":50,"title":"学习 lodash  源码整体架构，打造属于自己的函数式编程类库","content":"学习 lodash 源码整体架构，打造属于自己的函数式编程类库#\n\n\n前言#\n\n这是学习源码整体架构系列第三篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。文章学习的是\n打包整合后的代码，不是实际仓库中的拆分的代码。\n\n上上篇文章写了jQuery源码整体架构，学习 jQuery 源码整体架构，打造属于自己的 js 类库\n\n上一篇文章写了underscore源码整体架构，学习 underscore 源码整体架构，打造属于自己的函数式编程类库\n\n感兴趣的读者可以点击阅读。\n\nunderscore源码分析的文章比较多，而lodash源码分析的文章比较少。原因之一可能是由于lodash源码行数太多。注释加起来一万多行。\n\n分析lodash整体代码结构的文章比较少，笔者利用谷歌、必应、github等搜索都没有找到，可能是找的方式不对。于是打算自己写一篇。平常开发大多数人都会使用lo\ndash，而且都或多或少知道，lodash比underscore性能好，性能好的主要原因是使用了惰性求值这一特性。\n\n本文章学习的lodash的版本是：v4.17.15。unpkg.com地址 https://unpkg.com/lodash@4.17.15/lodash.js\n\n文章篇幅可能比较长，可以先收藏再看。\n\n导读：\n\n> 文章主要学习了runInContext() 导出_\n> lodash函数使用baseCreate方法原型继承LodashWrapper和LazyWrapper，mixin挂载方法到lodash.prototype\n> 、后文用结合例子解释lodash.prototype.value(wrapperValue)和Lazy.prototype.value(lazyValue)\n> 惰性求值的源码具体实现。\n\n\n匿名函数执行#\n\n\n\n暴露 lodash\n\n\n\n\nrunInContext 函数#\n\n这里的简版源码，只关注函数入口和返回值。\n\n\n\n可以看到申明了一个runInContext函数。里面有一个lodash函数，最后处理返回这个lodash函数。\n\n再看lodash函数中的返回值 new LodashWrapper(value)。\n\n\nLodashWrapper 函数#\n\n\n\n设置了这些属性：\n\n__wrapped__：存放参数value。\n\n__actions__：存放待执行的函数体func， 函数参数 args，函数执行的this 指向 thisArg。\n\n__chain__、undefined两次取反转成布尔值false，不支持链式调用。和underscore一样，默认是不支持链式调用的。\n\n__index__：索引值 默认 0。\n\n__values__：主要clone时使用。\n\n接着往下搜索源码，LodashWrapper， 会发现这两行代码。\n\n\n\n接着往上找baseCreate、baseLodash这两个函数。\n\n\nbaseCreate 原型继承#\n\n\n\n笔者画了一张图，表示这个关系。\n\n衍生的 isObject 函数#\n\n判断typeof value不等于null，并且是object或者function。\n\n\n\n\nObject.create() 用法举例#\n\n面试官问：能否模拟实现JS的new操作符 之前这篇文章写过的一段。\n\n笔者之前整理的一篇文章中也有讲过，可以翻看JavaScript 对象所有API解析\n\nMDN Object.create()\n\nObject.create(proto, [propertiesObject]) 方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是undefined）。\n\n\n\n对于不支持ES5的浏览器，MDN上提供了ployfill方案。\n\n\n\nlodash上有很多方法和属性，但在lodash.prototype也有很多与lodash上相同的方法。肯定不是在lodash.prototype上重新写一遍。\n而是通过mixin挂载的。\n\n\nmixin#\n\n\nmixin 具体用法#\n\n\n\n> 添加来源对象自身的所有可枚举函数属性到目标对象。 如果 object 是个函数，那么函数方法将被添加到原型链上。\n\n> 注意: 使用 _.runInContext 来创建原始的 lodash 函数来避免修改造成的冲突。\n\n添加版本\n\n> 0.1.0\n\n参数\n\n> [object=lodash] (Function|Object): 目标对象。\n\n> source (Object): 来源对象。\n\n> [options={}] (Object): 选项对象。\n\n> [options.chain=true] (boolean): 是否开启链式操作。\n\n返回\n\n> (*): 返回 object.\n\n\nmixin 源码#\n\nmixin源码，后文注释解析\n\n\n\n接下来先看衍生的函数。\n\n其实看到具体定义的函数代码就大概知道这个函数的功能。为了不影响主线，导致文章篇幅过长。具体源码在这里就不展开。\n\n感兴趣的读者可以自行看这些函数衍生的其他函数的源码。\n\n\nmixin 衍生的函数 keys#\n\n在 mixin 函数中 其实最终调用的就是 Object.keys\n\n\n\n\nmixin 衍生的函数 baseFunctions#\n\n返回函数数组集合\n\n\n\n\nmixin 衍生的函数 isFunction#\n\n判断参数是否是函数\n\n\n\n\nmixin 衍生的函数 arrayEach#\n\n类似 [].forEarch\n\n\n\n\nmixin 衍生的函数 arrayPush#\n\n类似 [].push\n\n\n\n\nmixin 衍生的函数 copyArray#\n\n拷贝数组\n\n\n\n\nmixin 源码解析#\n\nlodash 源码中两次调用 mixin\n\n\n\n结合两次调用mixin 代入到源码解析如下 mixin源码及注释\n\n\n\n小结：简单说就是把lodash上的静态方法赋值到lodash.prototype上。分两次第一次是支持链式调用（lodash.after等 153\n个支持链式调用的方法），第二次是不支持链式调用的方法（lodash.add等152个不支持链式调用的方法）。\n\n\nlodash 究竟在_和_.prototype挂载了多少方法和属性#\n\n再来看下lodash究竟挂载在_函数对象上有多少静态方法和属性，和挂载_.prototype上有多少方法和属性。\n\n使用for in循环一试便知。看如下代码：\n\n\n\n其实就是上文提及的 lodash.after 等153个支持链式调用的函数 、lodash.add 等 152不支持链式调用的函数赋值而来。\n\n\n\n相比lodash上的静态方法多了12个，说明除了 mixin 外，还有12个其他形式赋值而来。\n\n支持链式调用的方法最后返回是实例对象，获取最后的处理的结果值，最后需要调用value方法。\n\n笔者画了一张表示lodash的方法和属性挂载关系图。\n\n\n\n\n请出贯穿下文的简单的例子#\n\n\n\n也就是说这里lodash聪明的知道了最后需要几个值，就执行几次map循环，对于很大的数组，提升性能很有帮助。\n而underscore执行这段代码其中map执行了5次。 如果是平常实现该功能也简单。\n\n\n\n而相比lodash这里的map执行了5次。\n\n\n\n简单说这里的map方法，添加 LazyWrapper 的方法到 lodash.prototype存储下来，最后调用 value时再调用。 具体看下文源码实现。\n\n\n添加 LazyWrapper 的方法到 lodash.prototype#\n\n主要是如下方法添加到到 lodash.prototype 原型上。\n\n\n\n具体源码及注释\n\n\n\n小结一下，写了这么多注释，简单说：其实就是用LazyWrapper.prototype\n改写原先在lodash.prototype的函数，判断函数是否需要使用惰性求值，需要时再调用。\n\n读者可以断点调试一下，善用断点进入函数功能，对着注释看，可能会更加清晰。\n\n断点调试的部分截图\n\n\n\n链式调用最后都是返回实例对象，实际的处理数据的函数都没有调用，而是被存储存储下来了，最后调用value方法，才执行这些函数。\n\n\nlodash.prototype.value 即 wrapperValue#\n\n\n\n如果是惰性求值，则调用的是 LazyWrapper.prototype.value 即 lazyValue。\n\n\nLazyWrapper.prototype.value 即 lazyValue 惰性求值#\n\nlazyValue源码及注释\n\n\n\n笔者画了一张 lodash和LazyWrapper的关系图来表示。\n\n小结：lazyValue简单说实现的功能就是把之前记录的需要执行几次，把记录存储的函数执行几次，不会有多少项数据就执行多少次，而是根据需要几项，执行几项。\n也就是说以下这个例子中，map函数只会执行3次。如果没有用惰性求值，那么map函数会执行5次。\n\n\n\n\n总结#\n\n行文至此，基本接近尾声，最后总结一下。\n\n> 文章主要学习了runInContext() 导出_\n> lodash函数使用baseCreate方法原型继承LodashWrapper和LazyWrapper，mixin挂载方法到lodash.prototype\n> 、后文用结合例子解释lodash.prototype.value(wrapperValue)和Lazy.prototype.value(lazyValue)\n> 惰性求值的源码具体实现。\n\n分享一个只知道函数名找源码定位函数申明位置的VSCode 技巧：Ctrl + p。输入 @functionName\n定位函数functionName在源码文件中的具体位置。如果知道调用位置，那直接按alt+鼠标左键即可跳转到函数申明的位置。\n\n如果读者发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出。另外觉得写得不错，对您有些许帮助，可以点赞、评论、转发分享，也是对笔者的一种支持。万分感\n谢。\n\n\n推荐阅读#\n\nlodash github仓库 lodash 官方文档 lodash 中文文档 打造一个类似于lodash的前端工具库 惰性求值——lodash源码解读\nluobo tang：lazy.js 惰性求值实现分析 lazy.js github 仓库 本文章学习的lodash的版本v4.17.15\nunpkg.com链接\n\n\n笔者往期文章#\n\n学习 underscore 源码整体架构，打造属于自己的函数式编程类库 学习 jQuery 源码整体架构，打造属于自己的 js 类库 面试官问：JS的继承\n面试官问：JS的this指向 面试官问：能否模拟实现JS的call和apply方法 面试官问：能否模拟实现JS的bind方法\n面试官问：能否模拟实现JS的new操作符 前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客-若川，使用vuepress重构了，阅读体验可能更好些\n掘金专栏，欢迎关注~ segmentfault前端视野专栏，欢迎关注~ 知乎前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/lodash/README.all","lang":"zh","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":34},{"text":"匿名函数执行","id":"匿名函数执行","depth":2,"charIndex":800},{"text":"runInContext 函数","id":"runincontext-函数","depth":2,"charIndex":825},{"text":"LodashWrapper 函数","id":"lodashwrapper-函数","depth":3,"charIndex":968},{"text":"baseCreate 原型继承","id":"basecreate-原型继承","depth":3,"charIndex":1270},{"text":"衍生的 isObject 函数","id":"衍生的-isobject-函数","depth":4,"charIndex":1307},{"text":"Object.create() 用法举例","id":"objectcreate-用法举例","depth":3,"charIndex":1372},{"text":"mixin","id":"mixin","depth":2,"charIndex":1751},{"text":"mixin 具体用法","id":"mixin-具体用法","depth":3,"charIndex":1760},{"text":"mixin 源码","id":"mixin-源码","depth":3,"charIndex":2078},{"text":"mixin 衍生的函数 keys","id":"mixin-衍生的函数-keys","depth":3,"charIndex":2206},{"text":"mixin 衍生的函数 baseFunctions","id":"mixin-衍生的函数-basefunctions","depth":3,"charIndex":2263},{"text":"mixin 衍生的函数 isFunction","id":"mixin-衍生的函数-isfunction","depth":3,"charIndex":2304},{"text":"mixin 衍生的函数 arrayEach","id":"mixin-衍生的函数-arrayeach","depth":3,"charIndex":2343},{"text":"mixin 衍生的函数 arrayPush","id":"mixin-衍生的函数-arraypush","depth":3,"charIndex":2386},{"text":"mixin 衍生的函数 copyArray","id":"mixin-衍生的函数-copyarray","depth":3,"charIndex":2425},{"text":"mixin 源码解析","id":"mixin-源码解析","depth":3,"charIndex":2458},{"text":"lodash 究竟在_和_.prototype挂载了多少方法和属性","id":"lodash-究竟在_和_prototype挂载了多少方法和属性","depth":2,"charIndex":2662},{"text":"请出贯穿下文的简单的例子","id":"请出贯穿下文的简单的例子","depth":2,"charIndex":2982},{"text":"添加 `LazyWrapper` 的方法到 `lodash.prototype`","id":"添加-lazywrapper-的方法到-lodashprototype","depth":2,"charIndex":-1},{"text":"lodash.prototype.value 即 wrapperValue","id":"lodashprototypevalue-即-wrappervalue","depth":2,"charIndex":3504},{"text":"LazyWrapper.prototype.value 即 lazyValue 惰性求值","id":"lazywrapperprototypevalue-即-lazyvalue-惰性求值","depth":2,"charIndex":3603},{"text":"总结","id":"总结","depth":2,"charIndex":3833},{"text":"推荐阅读","id":"推荐阅读","depth":2,"charIndex":4273},{"text":"笔者往期文章","id":"笔者往期文章","depth":2,"charIndex":4441},{"text":"关于","id":"关于","depth":2,"charIndex":4652},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":51,"title":"学习 lodash  源码整体架构，打造属于自己的函数式编程类库","content":"学习 lodash 源码整体架构，打造属于自己的函数式编程类库#\n\n\n1. 前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 这是学习源码整体架构系列第三篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。文章学习\n> 的是打包整合后的代码，不是实际仓库中的拆分的代码。\n\n> 本文仓库地址：git clone https://github.com/ruochuan12/lodash-analysis.git\n\n> 要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了。\n\n学习源码整体架构系列文章如下：\n\n> 1.学习 jQuery 源码整体架构，打造属于自己的 js 类库 2.学习 underscore 源码整体架构，打造属于自己的函数式编程类库 3.学习\n> lodash 源码整体架构，打造属于自己的函数式编程类库 4.学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK 5.学习 vuex\n> 源码整体架构，打造属于自己的状态管理库 6.学习 axios 源码整体架构，打造属于自己的请求库 7.学习 koa\n> 源码的整体架构，浅析koa洋葱模型原理和co原理 8.学习 redux 源码整体架构，深入理解 redux 及其中间件原理\n\n感兴趣的读者可以点击阅读。 其他源码计划中的有：express、vue-rotuer、react-redux\n等源码，不知何时能写完（哭泣），欢迎持续关注我（若川）。\n\n源码类文章，一般阅读量不高。已经有能力看懂的，自己就看了。不想看，不敢看的就不会去看源码。 所以我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。\n\nunderscore源码分析的文章比较多，而lodash源码分析的文章比较少。原因之一可能是由于lodash源码行数太多。注释加起来一万多行。\n\n分析lodash整体代码结构的文章比较少，笔者利用谷歌、必应、github等搜索都没有找到，可能是找的方式不对。于是打算自己写一篇。平常开发大多数人都会使用lo\ndash，而且都或多或少知道，lodash比underscore性能好，性能好的主要原因是使用了惰性求值这一特性。\n\n本文章学习的lodash的版本是：v4.17.15。unpkg.com地址 https://unpkg.com/lodash@4.17.15/lodash.js\n\n文章篇幅可能比较长，可以先收藏再看，所以笔者使用了展开收缩的形式。\n\n导读：\n\n> 文章主要学习了runInContext() 导出_\n> lodash函数使用baseCreate方法原型继承LodashWrapper和LazyWrapper，mixin挂载方法到lodash.prototype\n> 、后文用结合例子解释lodash.prototype.value(wrapperValue)和Lazy.prototype.value(lazyValue)\n> 惰性求值的源码具体实现。\n\n\n2. 匿名函数执行#\n\n\n\n暴露 lodash\n\n\n\n\n3. runInContext 函数#\n\n这里的简版源码，只关注函数入口和返回值。\n\n\n\n可以看到申明了一个runInContext函数。里面有一个lodash函数，最后处理返回这个lodash函数。\n\n再看lodash函数中的返回值 new LodashWrapper(value)。\n\n\n3.1 LodashWrapper 函数#\n\n\n\n设置了这些属性：\n\n__wrapped__：存放参数value。\n\n__actions__：存放待执行的函数体func， 函数参数 args，函数执行的this 指向 thisArg。\n\n__chain__、undefined两次取反转成布尔值false，不支持链式调用。和underscore一样，默认是不支持链式调用的。\n\n__index__：索引值 默认 0。\n\n__values__：主要clone时使用。\n\n接着往下搜索源码，LodashWrapper， 会发现这两行代码。\n\n\n\n接着往上找baseCreate、baseLodash这两个函数。\n\n\n3.2 baseCreate 原型继承#\n\n\n\n笔者画了一张图，表示这个关系。\n\n3.2.1 衍生的 isObject 函数#\n\n判断typeof value不等于null，并且是object或者function。\n\n\n\n\n3.3 Object.create() 用法举例#\n\n面试官问：能否模拟实现JS的new操作符 之前这篇文章写过的一段，所以这里收缩起来了。\n\n笔者之前整理的一篇文章中也有讲过，可以翻看JavaScript 对象所有API解析\n\nMDN Object.create()\n\nObject.create(proto, [propertiesObject]) 方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是undefined）。\n\n\n\n对于不支持ES5的浏览器，MDN上提供了ployfill方案。\n\n\n\nlodash上有很多方法和属性，但在lodash.prototype也有很多与lodash上相同的方法。肯定不是在lodash.prototype上重新写一遍。\n而是通过mixin挂载的。\n\n\n4. mixin#\n\n\n4.1 mixin 具体用法#\n\n\n\n> 添加来源对象自身的所有可枚举函数属性到目标对象。 如果 object 是个函数，那么函数方法将被添加到原型链上。\n\n> 注意: 使用 _.runInContext 来创建原始的 lodash 函数来避免修改造成的冲突。\n\n添加版本\n\n> 0.1.0\n\n参数\n\n> [object=lodash] (Function|Object): 目标对象。\n\n> source (Object): 来源对象。\n\n> [options={}] (Object): 选项对象。\n\n> [options.chain=true] (boolean): 是否开启链式操作。\n\n返回\n\n> (*): 返回 object.\n\n\n4.2 mixin 源码#\n\n\n\n其实看到具体定义的函数代码就大概知道这个函数的功能。为了不影响主线，导致文章篇幅过长。具体源码在这里就不展开。\n\n感兴趣的读者可以自行看这些函数衍生的其他函数的源码。\n\n\n4.3 mixin 衍生的函数 keys#\n\n在 mixin 函数中 其实最终调用的就是 Object.keys\n\n\n\n\n4.4 mixin 衍生的函数 baseFunctions#\n\n返回函数数组集合\n\n\n\n\n4.5 mixin 衍生的函数 isFunction#\n\n判断参数是否是函数\n\n\n\n\n4.6 mixin 衍生的函数 arrayEach#\n\n类似 [].forEarch\n\n\n\n\n4.7 mixin 衍生的函数 arrayPush#\n\n类似 [].push\n\n\n\n\n4.8 mixin 衍生的函数 copyArray#\n\n拷贝数组\n\n\n\n\n4.9 mixin 源码解析#\n\nlodash 源码中两次调用 mixin\n\n\n\n结合两次调用mixin 代入到源码解析如下\n\n\n\n小结：简单说就是把lodash上的静态方法赋值到lodash.prototype上。分两次第一次是支持链式调用（lodash.after等 153\n个支持链式调用的方法），第二次是不支持链式调用的方法（lodash.add等152个不支持链式调用的方法）。\n\n\n5. lodash 究竟在_和_.prototype挂载了多少方法和属性#\n\n再来看下lodash究竟挂载在_函数对象上有多少静态方法和属性，和挂载_.prototype上有多少方法和属性。\n\n使用for in循环一试便知。看如下代码：\n\n\n\n其实就是上文提及的 lodash.after 等153个支持链式调用的函数 、lodash.add 等 152不支持链式调用的函数赋值而来。\n\n\n\n相比lodash上的静态方法多了12个，说明除了 mixin 外，还有12个其他形式赋值而来。\n\n支持链式调用的方法最后返回是实例对象，获取最后的处理的结果值，最后需要调用value方法。\n\n笔者画了一张表示lodash的方法和属性挂载关系图。\n\n\n\n\n6. 请出贯穿下文的简单的例子#\n\n\n\n也就是说这里lodash聪明的知道了最后需要几个值，就执行几次map循环，对于很大的数组，提升性能很有帮助。\n而underscore执行这段代码其中map执行了5次。 如果是平常实现该功能也简单。\n\n\n\n而相比lodash这里的map执行了5次。\n\n\n\n简单说这里的map方法，添加 LazyWrapper 的方法到 lodash.prototype存储下来，最后调用 value时再调用。 具体看下文源码实现。\n\n\n7. 添加 LazyWrapper 的方法到 lodash.prototype#\n\n主要是如下方法添加到到 lodash.prototype 原型上。\n\n\n\n\n\n小结一下，写了这么多注释，简单说：其实就是用LazyWrapper.prototype\n改写原先在lodash.prototype的函数，判断函数是否需要使用惰性求值，需要时再调用。\n\n读者可以断点调试一下，善用断点进入函数功能，对着注释看，可能会更加清晰。\n\n\n\n链式调用最后都是返回实例对象，实际的处理数据的函数都没有调用，而是被存储存储下来了，最后调用value方法，才执行这些函数。\n\n\n8. lodash.prototype.value 即 wrapperValue#\n\n\n\n如果是惰性求值，则调用的是 LazyWrapper.prototype.value 即 lazyValue。\n\n\n9. LazyWrapper.prototype.value 即 lazyValue 惰性求值#\n\n\n\n笔者画了一张 lodash和LazyWrapper的关系图来表示。\n\n小结：lazyValue简单说实现的功能就是把之前记录的需要执行几次，把记录存储的函数执行几次，不会有多少项数据就执行多少次，而是根据需要几项，执行几项。\n也就是说以下这个例子中，map函数只会执行3次。如果没有用惰性求值，那么map函数会执行5次。\n\n\n\n\n10. 总结#\n\n行文至此，基本接近尾声，最后总结一下。\n\n> 文章主要学习了runInContext() 导出_\n> lodash函数使用baseCreate方法原型继承LodashWrapper和LazyWrapper，mixin挂载方法到lodash.prototype\n> 、后文用结合例子解释lodash.prototype.value(wrapperValue)和Lazy.prototype.value(lazyValue)\n> 惰性求值的源码具体实现。\n\n分享一个只知道函数名找源码定位函数申明位置的VSCode 技巧：Ctrl + p。输入 @functionName\n定位函数functionName在源码文件中的具体位置。如果知道调用位置，那直接按alt+鼠标左键即可跳转到函数申明的位置。\n\n如果读者发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出。另外觉得写得不错，对您有些许帮助，可以点赞、评论、转发分享，也是对笔者的一种支持。万分感\n谢。\n\n\n11. 推荐阅读#\n\nlodash github仓库 lodash 官方文档 lodash 中文文档 打造一个类似于lodash的前端工具库 惰性求值——lodash源码解读\nluobo tang：lazy.js 惰性求值实现分析 lazy.js github 仓库 本文章学习的lodash的版本v4.17.15\nunpkg.com链接\n\n\n笔者往期文章#\n\n面试官问：JS的继承 面试官问：JS的this指向 面试官问：能否模拟实现JS的call和apply方法 面试官问：能否模拟实现JS的bind方法\n面试官问：能否模拟实现JS的new操作符 前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 若川的博客，使用vuepress重构了，阅读体验可能更好些\n掘金专栏，欢迎关注~ segmentfault前端视野专栏，欢迎关注~ 知乎前端视野专栏，欢迎关注~ 语雀前端视野专栏，新增语雀专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注（回复pdf获取前端优质书籍pdf）。欢迎加笔者微信ruochuan12（注明来源，基本来者不拒），拉您进【前端视野交流群\n】，长期交流学习~\n\n","routePath":"/lodash/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":34},{"text":"2. 匿名函数执行","id":"2-匿名函数执行","depth":2,"charIndex":1408},{"text":"3. runInContext 函数","id":"3-runincontext-函数","depth":2,"charIndex":1436},{"text":"3.1 LodashWrapper 函数","id":"31-lodashwrapper-函数","depth":3,"charIndex":1582},{"text":"3.2 baseCreate 原型继承","id":"32-basecreate-原型继承","depth":3,"charIndex":1888},{"text":"3.2.1 衍生的 isObject 函数","id":"321-衍生的-isobject-函数","depth":4,"charIndex":1929},{"text":"3.3 Object.create() 用法举例","id":"33-objectcreate-用法举例","depth":3,"charIndex":2000},{"text":"4. mixin","id":"4-mixin","depth":2,"charIndex":2393},{"text":"4.1 mixin 具体用法","id":"41-mixin-具体用法","depth":3,"charIndex":2405},{"text":"4.2 mixin 源码","id":"42-mixin-源码","depth":3,"charIndex":2727},{"text":"4.3 mixin 衍生的函数 keys","id":"43-mixin-衍生的函数-keys","depth":3,"charIndex":2830},{"text":"4.4 mixin 衍生的函数 baseFunctions","id":"44-mixin-衍生的函数-basefunctions","depth":3,"charIndex":2891},{"text":"4.5 mixin 衍生的函数 isFunction","id":"45-mixin-衍生的函数-isfunction","depth":3,"charIndex":2936},{"text":"4.6 mixin 衍生的函数 arrayEach","id":"46-mixin-衍生的函数-arrayeach","depth":3,"charIndex":2979},{"text":"4.7 mixin 衍生的函数 arrayPush","id":"47-mixin-衍生的函数-arraypush","depth":3,"charIndex":3026},{"text":"4.8 mixin 衍生的函数 copyArray","id":"48-mixin-衍生的函数-copyarray","depth":3,"charIndex":3069},{"text":"4.9 mixin 源码解析","id":"49-mixin-源码解析","depth":3,"charIndex":3106},{"text":"5. lodash 究竟在_和_.prototype挂载了多少方法和属性","id":"5-lodash-究竟在_和_prototype挂载了多少方法和属性","depth":2,"charIndex":3303},{"text":"6. 请出贯穿下文的简单的例子","id":"6-请出贯穿下文的简单的例子","depth":2,"charIndex":3626},{"text":"7. 添加 `LazyWrapper` 的方法到 `lodash.prototype`","id":"7-添加-lazywrapper-的方法到-lodashprototype","depth":2,"charIndex":-1},{"text":"8. lodash.prototype.value 即 wrapperValue","id":"8-lodashprototypevalue-即-wrappervalue","depth":2,"charIndex":4134},{"text":"9. LazyWrapper.prototype.value 即 lazyValue 惰性求值","id":"9-lazywrapperprototypevalue-即-lazyvalue-惰性求值","depth":2,"charIndex":4236},{"text":"10. 总结","id":"10-总结","depth":2,"charIndex":4453},{"text":"11. 推荐阅读","id":"11-推荐阅读","depth":2,"charIndex":4897},{"text":"笔者往期文章","id":"笔者往期文章","depth":2,"charIndex":5069},{"text":"关于","id":"关于","depth":2,"charIndex":5213},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":52,"title":"","content":"","routePath":"/lodash/lodash-v0.1","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":53,"title":"","content":"","routePath":"/lodash/lodash-v4.17.15","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":54,"title":"还在用开发者工具上传小程序? 快来试试 miniprogram-ci 提效摸鱼","content":"#\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.3k+人）第一的专栏，写有20余篇源码文章。\n\n\n2. 前情回顾#\n\n注意：文章是基于 tag v0.7.0 撰写。目前工具是 0.12.0 版本，后续 mini-ci 会持续更新，文章应该暂时不会更新。\n\n本文提到的工具 mini-ci 已开源，求个 star^_^\n\n\n\n估计有很多开发小程序的同学，还在使用微信开发者工具上传小程序。如果你是，那么这篇文章非常适合你。如果不是，同样也很适合你。\n\n早在 2021 年 08 月，我写过一篇文章 Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？\n\nVue 2.7 如何发布跟Vue 3.2这篇文章类似，所以就不赘述了。\n\n> vuejs发布的文件很多代码我们可以直接复制粘贴修改，优化我们自己发布的流程。比如写小程序，相对可能发布频繁，完全可以使用这套代码，配合miniprogra\n> m-ci，再加上一些自定义，加以优化。\n\n于是今天我们来开发这样的脚手架工具。\n\n看完本文，你将学到：\n\n\n\n先看看最终开发的效果。\n\n支持的功能\n\n\n\n显示帮助信息\n\n\n\n上传效果\n\n\n\n\n3. 关于为啥要开发这样的工具#\n\n> 关于小程序 ci 上传，再分享两篇文章。\n\n> 基于 CI 实现微信小程序的持续构建\n\n> 小打卡小程序自动化构建及发布的工程化实践 虽然文章里不是最新的 miniprogram-ci，但这篇场景写得比较全面。\n\n接着，我们先来看看 miniprogram-ci 官方文档。\n\n\n4. miniprogram-ci 官方文档#\n\nminiprogram-ci 文档\n\n\n4.1 上传#\n\n\n\n\n4.2 预览#\n\n\n\n\n5. Taro 小程序插件 @tarojs/plugin-mini-ci#\n\n如果使用 Taro 开发的小程序，可以直接使用。\n\n具体如何使用参考文档，我在本文中就不赘述了。\n\n小程序持续集成 @tarojs/plugin-mini-ci\n\n我组织的源码共读第 30 期读的就是这个插件，非常值得学习。@tarojs/plugin-mini-ci 源码解读可以参考 @NewName 的源码文章\n\n我体验下来的感觉有以下几点可以优化。\n\n * 不支持指定机器人\n * 不支持不打包时上传\n * 不支持官方提供的更多配置\n * 不支持选择多个小程序批量上传等等\n\n如果有时间我可能给 Taro 提 PR，当然不一定会被合并。\n\n\n6. uni-app 好像没有提供类似的插件#\n\nuni-app 好像没有提供类似的插件。需要自己动手，丰衣足食。\n\n\n7. release-it 自动提升版本、打 tag、生成 changelog 等#\n\n于是我们自己动手，丰衣足食，写一个工具解决上面提到的问题，支持 Taro 打包后的小程序和 uni-app 打包后的，还有原生小程序上传和预览。\n\n开发小工具之前，先介绍一些好用的工具。\n\n据说很多小伙伴的项目，没有打 tag、没有版本的概念，没有生成 changelog，没有配置 eslint、prettier，没有 commit 等规范。\n\n这些其实不难，commit 规范一般简单做法是安装 npm i git-cz -D， 在package.json 中加入如下脚本。\n\n\n\ngit 提交时使用 npm run commit 即可，其他就不赘述了。\n\nrelease-it，自动提升版本号，自动打 tag，生成 changelog 等\n\nrelease-it 官网仓库\n\n\n\n\n\n这样配置后，可以 npm run release 执行 release-it 版本。 还支持 hooks 钩子，比如提升版本号后\"after:bump\":\n\"echo 更新版本成功\"，更多功能可以查看release-it 官网仓库。\n\n\n7.1 npm init release-it 原理#\n\n为啥 npm init 也可以直接初始化一个项目，带着疑问，我们翻看 npm 文档。\n\nnpm init\n\nnpm init 用法：\n\n\n\nnpm init 时转换成 npx 命令：\n\n\n\n看完文档，我们也就理解了：\n\n运行 npm init release-it => 相当于 npx create-release-it\n\ncreate-release-it\n\nnpm init release-it 原理其实就是 npx create-release-it 选择一些配置，生成 .release-it.json 或者\npackage.json 的 release-it 配置。\n\n再写入命令release 配置到 package.json。\n\n\n\n最后执行 npm install release-it --save-dev 也就是源码里的 await execa('npm', ['install',\n'release-it', '--save-dev'], { stdio: 'inherit' });。\n\n这行源码位置\n\n\n8. 小程序上传工具实现主流程#\n\n需要支持多选，那肯定得遍历数组。\n\n\n\nmain 函数\n\n\n\n\n8.1 添加功能支持指定参数#\n\n使用 minimist 解析命令行参数。\n\n\n\n\n8.2 支持读取项目的 package.json 的 version，也支持读取自定义version#\n\nkolorist 颜色输出。\n\n\n\n\n8.3 版本描述 支持指定 git commit hash 和作者#\n\ngit rev-parse --short HEAD 读取 git 仓库最近一次的 commit hash。\n\nparse-git-config 可以读取 .git/config 配置。\n\n\n\n\n8.4 读取配置 wx.config.js 配置（更推荐）#\n\n当前也支持读取 .env 配置。读取 .env 配置，可以采用 dotenv。关于 dotenv 的原理，可以看我之前写过的文章面试官：项目中常用的 .env\n文件原理是什么？如何实现？\n\n但 wx.config.js 可以配置更多东西而且更灵活。所以更推荐。\n\n感兴趣的可以研究 vue-cli 是如何读取 vue.config.js 配置的。围绕工作相关的学习，往往收益更大。\n\n\n\n\n8.5 支持选择多个小程序#\n\n我们可以用 enquirer 来实现单选或者多选的功能。以下只是关键代码。 完整代码可以查看 mini-ci/src/utils/getConfig.js\n文件。\n\n\n\n\n8.6 支持多个批量上传#\n\n\n\n后续可能接入 CI/CD、接入邮件提醒、接入钉钉、支持可视化操作等等\n\n\n8.7 更多如何使用可以参考文档#\n\n\n\n可以克隆我的另外一个小程序（腾讯开源的电商小程序）。比如 projects 中。\n\n按照微信小程序文档配置小程序密钥等，这样就能上传和预览了。如果没有微信小程序，可以自行免费开通个人的微信小程序。\n\n\n9. 总结#\n\n通过本文的学习，我们知道了以下知识。\n\n\n\n我相信大家也能够自己动手实现公司类似要求的脚手架工具，减少发版时间，降本提效。\n\n本文提到的工具 mini-ci 已开源，求个 star^_^\n\n\n\n注意：文章是基于 tag v0.7.0 撰写。目前工具是 0.12.0 版本，后续 mini-ci 会持续更新，文章应该暂时不会更新。\n\n--------------------------------------------------------------------------------\n\n最后可以持续关注我@若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。\n\n另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.2k+人）第一的专栏，写有20余篇源码文章。包含jQuery、under\nscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-compose、vue 3.2\n发布、vue-this、create-vue、玩具vite、create-vite 等20余篇源码文章。","routePath":"/mini-ci/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 前情回顾","id":"2-前情回顾","depth":2,"charIndex":150},{"text":"3. 关于为啥要开发这样的工具","id":"3-关于为啥要开发这样的工具","depth":2,"charIndex":598},{"text":"4. miniprogram-ci 官方文档","id":"4-miniprogram-ci-官方文档","depth":2,"charIndex":758},{"text":"4.1 上传","id":"41-上传","depth":3,"charIndex":803},{"text":"4.2 预览","id":"42-预览","depth":3,"charIndex":815},{"text":"5. Taro 小程序插件 @tarojs/plugin-mini-ci","id":"5-taro-小程序插件-tarojsplugin-mini-ci","depth":2,"charIndex":827},{"text":"6. uni-app 好像没有提供类似的插件","id":"6-uni-app-好像没有提供类似的插件","depth":2,"charIndex":1141},{"text":"7. release-it 自动提升版本、打 tag、生成 changelog 等","id":"7-release-it-自动提升版本打-tag生成-changelog-等","depth":2,"charIndex":1201},{"text":"7.1 npm init release-it 原理","id":"71-npm-init-release-it-原理","depth":3,"charIndex":1709},{"text":"8. 小程序上传工具实现主流程","id":"8-小程序上传工具实现主流程","depth":2,"charIndex":2205},{"text":"8.1 添加功能支持指定参数","id":"81-添加功能支持指定参数","depth":3,"charIndex":2255},{"text":"8.2 支持读取项目的 `package.json` 的 `version`，也支持读取自定义`version`","id":"82-支持读取项目的-packagejson-的-version也支持读取自定义version","depth":3,"charIndex":-1},{"text":"8.3 版本描述 支持指定 git commit hash 和作者","id":"83-版本描述-支持指定-git-commit-hash-和作者","depth":3,"charIndex":2369},{"text":"8.4 读取配置 wx.config.js 配置（更推荐）","id":"84-读取配置-wxconfigjs-配置更推荐","depth":3,"charIndex":2503},{"text":"8.5 支持选择多个小程序","id":"85-支持选择多个小程序","depth":3,"charIndex":2730},{"text":"8.6 支持多个批量上传","id":"86-支持多个批量上传","depth":3,"charIndex":2832},{"text":"8.7 更多如何使用可以参考文档","id":"87-更多如何使用可以参考文档","depth":3,"charIndex":2886},{"text":"9. 总结","id":"9-总结","depth":2,"charIndex":3008}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":55,"title":"尤雨溪推荐神器 ni ，能替代 npm/yarn/pnpm ？简单好用！源码揭秘！","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动，感兴趣的可以加我微信 ruochuan12\n> 参与，已进行两个多月，大家一起交流学习，共同进步，很多人都表示收获颇丰。\n\n想学源码，极力推荐之前我写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue-next-release、vue-this、create-vue、玩具vite等10余篇源码文章。\n\n本文仓库 ni-analysis，求个star^_^\n\n最近组织了源码共读活动，大家一起学习源码。于是搜寻各种值得我们学习，且代码行数不多的源码。\n\n之前写了 Vue3 相关的两篇文章。\n\n * 初学者也能看懂的 Vue3 源码中那些实用的基础工具函数\n * Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？\n\n文章里都是写的使用 yarn 。参加源码共读的小伙伴按照我的文章，却拉取的最新仓库代码，发现 yarn install 安装不了依赖，向我反馈报错。于是我去\ngithub仓库 一看，发现尤雨溪把 Vue3仓库 从 yarn 换成了 pnpm。贡献文档中有一句话。\n\n> We also recommend installing ni to help switching between repos using\n> different package managers. ni also provides the handy nr command which\n> running npm scripts easier.\n\n> 我们还建议安装 ni 以帮助使用不同的包管理器在 repos 之间切换。 ni 还提供了方便的 nr 命令，可以更轻松地运行 npm 脚本。\n\n这个 ni 项目源码虽然是 ts，没用过 ts 小伙伴也是很好理解的，而且主文件其实不到 100行，非常适合我们学习。\n\n阅读本文，你将学到：\n\n\n\n\n2. 原理#\n\ngithub 仓库 ni#how\n\nni 假设您使用锁文件（并且您应该）\n\n在它运行之前，它会检测你的 yarn.lock / pnpm-lock.yaml / package-lock.json\n以了解当前的包管理器，并运行相应的命令。\n\n单从这句话中可能有些不好理解，还是不知道它是个什么。我解释一下。\n\n\n\n我看源码发现：ni相关的命令，都可以在末尾追加\\?，表示只打印，不是真正执行。\n\n所以全局安装 ni 后，可以尽情测试，比如 ni \\?，nr dev --port=3000 \\?，因为打印，所以可以在各种目录下执行，有助于理解 ni\n源码。我测试了如下图所示：\n\n\n\n假设项目目录下没有锁文件，默认就会让用户从npm、yarn、pnpm选择，然后执行相应的命令。\n但如果在~/.nirc文件中，设置了全局默认的配置，则使用默认配置执行对应命令。\n\nConfig\n\n\n\n因此，我们可以得知这个工具必然要做三件事：\n\n\n\n接着继续看看 README 其他命令的使用，就会好理解。\n\n\n3. 使用#\n\n看 ni github文档。\n\n> npm i in a yarn project, again? F**k!\n> \n> ni - use the right package manager\n\n全局安装。\n\n\n\n如果全局安装遭遇冲突，我们可以加上 --force 参数强制安装。\n\n举几个常用的例子。\n\n\n3.1 ni - install#\n\n\n\n\n\n\n3.2 nr - run#\n\n\n\n\n\n\n\n\n3.3 nx - execute#\n\n\n\n\n4. 阅读源码前的准备工作#\n\n\n4.1 克隆#\n\n\n\n众所周知，看一个开源项目，先从 package.json 文件开始看起。\n\n\n4.2 package.json 文件#\n\n\n\n根据 dev 命令，我们找到主入口文件 src/ni.ts。\n\n\n4.3 从源码主入口开始调试#\n\n\n\n找到 ni/package.json 的 scripts，把鼠标移动到 dev 命令上，会出现运行脚本和调试脚本命令。如下图所示，选择调试脚本。\n\n\n\n\n\n\n5. 主流程 runner - runCli 函数#\n\n这个函数就是对终端传入的命令行参数做一次解析。最终还是执行的 run 函数。\n\n对于 process 不了解的读者，可以看阮一峰老师写的 process 对象\n\n\n\n我们接着来看，run 函数。\n\n\n6. 主流程 runner - run 主函数#\n\n这个函数主要做了三件事：\n\n\n\n\n\n我们学习完主流程，接着来看两个重要的函数：detect 函数、parseNi 函数。\n\n根据入口我们可以知道。\n\n\n\n\n6.1 根据锁文件猜测用哪个包管理器（npm/yarn/pnpm） - detect 函数#\n\n代码相对不多，我就全部放出来了。\n\n\n\n\n\n\n\n接着我们来看 parseNi 函数。\n\n\n6.2 抹平不同的包管理器的命令差异 - parseNi 函数#\n\n\n\n通过 getCommand 获取命令。\n\n\n\n\n\n\n6.3 最终运行相应的脚本#\n\n得到相应的命令，比如是 npm i，最终用这个工具 execa 执行最终得到的相应的脚本。\n\n\n\n\n7. 总结#\n\n我们看完源码，可以知道这个神器 ni 主要做了三件事：\n\n\n\n我们日常开发中，可能容易 npm、yarn、pnpm 混用。有了 ni 后，可以用于日常开发使用。Vue 核心成员 Anthony Fu\n发现问题，最终开发了一个工具 ni 解决问题。而这种发现问题、解决问题的能力正是我们前端开发工程师所需要的。\n\n另外，我发现 Vue 生态很多基本都切换成了使用 pnpm。\n\n因为文章不宜过长，所以未全面展开讲述源码中所有细节。非常建议读者朋友按照文中方法使用VSCode调试 ni 源码。学会调试源码后，源码并没有想象中的那么难。\n\n最后可以持续关注我@若川。欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。","routePath":"/ni/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 原理","id":"2-原理","depth":2,"charIndex":902},{"text":"3. 使用","id":"3-使用","depth":2,"charIndex":1358},{"text":"3.1 ni - install","id":"31-ni---install","depth":3,"charIndex":1519},{"text":"3.2 nr - run","id":"32-nr---run","depth":3,"charIndex":1543},{"text":"3.3 nx - execute","id":"33-nx---execute","depth":3,"charIndex":1565},{"text":"4. 阅读源码前的准备工作","id":"4-阅读源码前的准备工作","depth":2,"charIndex":1587},{"text":"4.1 克隆","id":"41-克隆","depth":3,"charIndex":1604},{"text":"4.2 package.json 文件","id":"42-packagejson-文件","depth":3,"charIndex":1654},{"text":"4.3 从源码主入口开始调试","id":"43-从源码主入口开始调试","depth":3,"charIndex":1711},{"text":"5. 主流程 runner - runCli 函数","id":"5-主流程-runner---runcli-函数","depth":2,"charIndex":1809},{"text":"6. 主流程 runner - run 主函数","id":"6-主流程-runner---run-主函数","depth":2,"charIndex":1937},{"text":"6.1 根据锁文件猜测用哪个包管理器（npm/yarn/pnpm） - detect 函数","id":"61-根据锁文件猜测用哪个包管理器npmyarnpnpm---detect-函数","depth":3,"charIndex":2041},{"text":"6.2 抹平不同的包管理器的命令差异 - parseNi 函数","id":"62-抹平不同的包管理器的命令差异---parseni-函数","depth":3,"charIndex":2134},{"text":"6.3 最终运行相应的脚本","id":"63-最终运行相应的脚本","depth":3,"charIndex":2196},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":2262}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":56,"title":"使用 ohmyzsh 打造 windows、ubuntu、mac 系统高效终端命令行工具","content":"#\n\n> 原标题名： oh my zsh 和 windows git bash 设置别名提高效率\n\n> 写于2018年06月03日\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 在我的微信交流群中听闻很多前端开发比较贫穷，没有买mac电脑（比如我），也没有用过ohmyzsh。于是就有了这篇写于2018年文章的更新。这篇文章没啥难度，\n> 很快就能看完，主要还是希望读者你看完后可以安装开始使用高效终端工具。有了这么强大的终端工具后我发现Windows很好用呀，瞬间感觉都不需要买mac了。\n\n主要就是：\n\n * 利用Windows的linux子系统功能\n * 安装Ubuntu系统，安装ohmyzsh和一些插件\n * 安装windows Terminal工具\n * 安装vscode remote-wsl插件\n * 安装 tig 查看 git 记录\n\n先看下效果。反正我是用了ohmyzsh后，离不开了。\n\n\n\n\nwindows 安装 Ubuntu 子系统 安装 windows Terminal#\n\n搜索启用或关闭 windows 功能，勾选适用于 Linux 的 Windows 子系统，确定后重启电脑。\n\n搜索 Ubuntu 和 windows Terminal 并安装（windows Terminal 可能要求win10系统比较高的版本，一般更新到最新版本即可）\n\nUbuntu安装好后会要求设置用户名和密码。\n\n\n\n\n\n建议安装最新版 Ubuntu 20.04\n\n\n\nwin10安装了ubuntu子系统和oh my zsh后，则可以通过/mnt/f/访问win10下的f盘，或者其他盘。 也就有上面的pwd效果图。\n\n\n安装 vscode remote-wsl 插件#\n\n下载安装vscode，并且安装remote-wsl插件。\n\n\n\n\n安装 oh my zsh#\n\n简述下oh my zshoh my zsh官网的安装方法。 github ohmyzsh\n\n安装oh my zsh部分适用于Ubuntu和mac系统。\n\n\n\n\n\n如果以上三种方式还装不了，可以来找我(若川 微信ruochuan12)。也可以查看oh my zsh文档\n\n安装成功后，配置信息会在~/.zshrc。可以通过code ~/.zshrc(如果没安装vscode，可以用vim\n~/.zshrc)打开编辑zsh配置信息，可以看到默认配置了git 插件Plugin:git。 也就是说，可以更加简便的使用git 相关的一些别名。\n\n\n\n是因为配置里有这些简写，还有更多可以查看这里oh my zsh plugin git.plugin.zsh文档配置，github oh my zsh\nplugin git.plugin.zsh文件地址。 安装成功后，同时会创建~/.oh-my-zsh的文件夹，其实就是.oh-my-zsh 的 git\n仓库master分支。 可以发现文件夹中有一个plugins文件夹，内置了很多插件。可以自定义主题theme，具体可以看example.zsh-theme。\ncustom自定义相关。 插件相关会安装在这里，更多可以查看example.plugin.zsh\n\n我暂时安装了这几个插件。\n\n\n\n顺带讲下后面两个插件的安装方法 安装 zsh-autosuggestions\n\n\n\n安装zsh-syntax-highlighting\n\n\n\n$ZSH_CUSTOM 其实是个变量，代表这个路径~/.oh-my-zsh/custom， 也就是安装到了这个目录下。还有很多高效插件，等您发掘~oh my\nzsh官网 不过插件安装多了，感觉会有些卡顿~\n\n\n\n也可以在这个配置文件中配置更多alias。\n\n\n\n这也就是开头的效果图了。\n\n\n\n那不是win10，也想通过设置别名来提高效率，是不是就没有办法了呢，可以使用git bash设置alias，安装git，自带git bash。\n\n\nwindows git bash 设置别名提高效率#\n\nwindows 桌面或任意资源管理器位置，右击，选择Git Bash Here，即打开了git bash命令行。 先设置下主题，右击选择options,\nLooks > theme > dracula 我选择的是dracula主题，看起来比较舒适。还可以设置字体等。\n\n\n\n可以根据修改设置一些别名。 比如我们常用的git status命令，可以封装成gst。清屏clear命令封装成cls。\n\n\n\n每次修改这个文件需要输入source ~/.bash_profile重载这个文件，才会生效。 code\n~/.bash_profile，用vscode编辑这个配置文件，封装成一个命令。 比如：\n\n\n\n这样每次修改保存后就只需要输入rl，即可重载生效了。 还可以把一些工作目录封装，我的一些项目是放在/f/git-source/github文件下。\n\n\n\n每次进入项目，就直接dgg，即可跳转到这个目录，然后选择相应的目录即可。 比如dgg进入工作目录，cd\nanalyse-vue-cli进入项目目录,（输入anal按tab键智能提示）\n\n\n\ngit 相关的， 例举一些平时用的比较多的。\n\n\n\n更多可以把oh my zsh的插件一些命令拷贝过来，留alias相关的即可，oh my zsh plugin git.plugin.zsh Plugin:git\nwiki 相当于解锁了oh my zsh 的git插件。还有很多插件，比如npm点击查看, node 等，都可以研究下。\n\ngit bash，有没有类似oh my zsh的插件呢，我暂时没发现，如果您知道，欢迎告诉我。 目录相关的操作，也可以设置一些别名。比如：\n\n\n\n更多别名可以自定义～ windows上命令行工具还可以使用cmder点击查看cmder官网命令行工具。虽然我几年前就安装了，但发现还是git\nbash用的顺畅些，可能是我还不太习惯cmder。 关于cmder配置相关，这里推荐晚晴幽草轩轩主的一篇文章： 《Win下必备神器之Cmder》\n\n也有cygwin，也是windows命令行工具，也可以安装on my zsh。\n\n当然，git也是可以设置别名的。\n\n\ngit设置别名，使用tig神器#\n\n\n\n更多可以查看廖雪峰老师的这篇文章git\n配置别名。不过可能大多数人不知道，他们可能用着可视化工具。我觉得可视化工具也是对git的一些封装，具体背后是什么命令，我们还是需要去了解熟悉的。命令行使用git\n，我推荐使用tig。git log增强版，性能很好。Ubuntu、linux、mac可以直接安装，windows稍微麻烦些。具体安装方法查看tig\ngithub仓库中的官方安装文档，或者查看这篇文章：颠覆 Git 命令使用体验的神器 -- tig\n\n\n小结#\n\n磨刀不误砍柴工，花时间折腾研究工具，有利于提高开发效率。\n\n最新更新于 2020-06-21 23:32:08\n\n文章首发于segmentfault win10 安装 oh my zsh 和 windows git bash 设置别名提高效率\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 若川的博客 掘金专栏，欢迎关注~\nsegmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/oh-my-zsh/","lang":"zh","toc":[{"text":"windows 安装 Ubuntu 子系统 安装 windows Terminal","id":"windows-安装-ubuntu-子系统-安装-windows-terminal","depth":2,"charIndex":529},{"text":"安装 vscode remote-wsl 插件","id":"安装-vscode-remote-wsl-插件","depth":2,"charIndex":838},{"text":"安装 `oh my zsh`","id":"安装-oh-my-zsh","depth":2,"charIndex":-1},{"text":"`windows` `git bash` 设置别名提高效率","id":"windows-git-bash-设置别名提高效率","depth":2,"charIndex":-1},{"text":"`git`设置别名，使用`tig`神器","id":"git设置别名使用tig神器","depth":2,"charIndex":-1},{"text":"小结","id":"小结","depth":2,"charIndex":2965},{"text":"关于","id":"关于","depth":2,"charIndex":3094},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":57,"title":"从 vue3 和 vite 源码中，我学到了一行代码统一规范团队包管理器的神器","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。最近组织了源码共读活动，感兴趣的可以加我微信 ruochuan12\n> 参与，或者关注我的公众号若川视野，回复“源码”参与。已进行三个月，大家一起交流学习，共同进步，很多人都表示收获颇丰。\n\n想学源码，极力推荐之前我写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等10余篇源码文章。\n\n本文仓库 only-allow-analysis，求个star^_^\n\n最近组织了源码共读活动，每周大家一起学习200行左右的源码。每周一期，已进行到14期。于是搜寻各种值得我们学习，且代码行数不多的源码。\n\n阅读本文，你将学到：\n\n\n\n\n2. 场景#\n\n我们项目开发时，常需要安装依赖，虽说一般用文档可以说明。但不是比较强制的约束。是人就容易犯错或者疏忽，假如规定是用的npm，而团队里有人某一天不小心使用了其他包\n管理器安装了的其他依赖，上传了代码，严重时可能导致线上问题。所以我们需要借助工具（代码）来强制约束。\n\n在源码共读第12期中，我们学习了尤雨溪推荐神器 ni ，能替代 npm/yarn/pnpm ？简单好用！源码揭秘！\n根据锁文件自动匹配相应的包管理器，运行相应的命令。\n\n在源码共读第3期中，我们学习了Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？\n\n其中 Vue3 源码用了 npm 的 preinstall 钩子 约束，只能使用 pnpm 安装依赖。我们接着来看其实现。\n\n\n3. Vue3 源码 && npm 命令钩子#\n\n\n\n\n\n当然也支持自定义的命令。\n\n更多可以查看官方文档钩子。\n\n接着我们来看 preinstall 源码。\n\n\n\n这段代码也相对简单，校验如果不是 pnpm 执行脚本则报错，退出进程。\n\n关于 process 对象可以查看 阮一峰老师 process 对象\n\n> process.argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是\n> node，第二个成员是脚本文件名，其余成员是脚本文件的参数。\n\n这段代码能解决文章开头场景提出的问题，但是总不能每个项目都复制粘贴这段代码吧。我们是不是可以封装成 npm 包使用。 当时我也没想太多，也没有封装 npm\n包。直到我翻看 vite 源码发现了 only-allow 这个包。一行代码统一规范包管理器。\n\n\n\n当时看到这段代码时，我就在想：他们咋知道这个的。 当时依旧也没想太多。直到有一天，发现 pnpm 文档 Only allow pnpm 文档\n上就有这个。好吧，吃了没看文档的亏。那时我打算分析下这个only-allow 包的源码，打开一看惊喜万分，才 36 行，写它，于是写了这篇文章。\n\n按照惯例，看源码前先准备环境。\n\n\n4. 环境准备#\n\n先克隆代码。\n\n\n4.1 克隆代码#\n\n\n\n开源项目一般先看README.md。\n\n> Force a specific package manager to be used on a project\n\n强制在项目上使用特定的包管理器\n\nUsage\n\n> Add a preinstall script to your project's package.json.\n\nIf you want to force yarn, add:\n\n\n\n同理可得：强制使用 npm、pnpm也是类似设置。\n\n\n4.2 调试源码#\n\n我们通过查看 package.json 文件。\n\n\n\n确定主入口文件为 only-allow/bin.js。\n\n在最新版的 VSCode 中，auto attach 功能，默认支持智能调试，如果发现不支持，可以通过快捷键 ctrl + shift + p 查看是否启用。\n\n于是我们在 only-allow/package.json 文件中，添加如下命令。\n\n\n\n可以提前在 only-allow/bin.js 文件打上断点 const usedPM = whichPMRuns()\n\n按快捷键 ctrl + ` 快捷键打开终端。输入如下 yarn add release-it -D 命令，即可调试 only-allow/bin.js。\n\n\n\n最终调试完会在终端报错提示使用 pnpm install。\n\n如下图所示：\n\n\n\n更多调试细节可以看我的这篇文章：新手向：前端程序员必学基本技能——调试JS代码\n\n接着我们按调试来看源码主流程。\n\n\n5. only-allow 源码#\n\n\n\n跟着断点，我们可以查看到 which-pm-runs。\n\n\n6. which-pm-runs 当前运行的是哪一个包管理器#\n\n最终返回包管理器和版本号。\n\n根据调试可知，process.env.npm_config_user_agent 是类似这样的字符串。\n\n\"yarn/1.22.10 npm/? node/v14.16.0 linux x64\"\n\n\n\n\n6.1 String.prototype.substr 截取字符串#\n\n顺带提下。我之前在 vue-next 源码看到的 pull request => chore: remove deprecated\nString.prototype.substr\n\n> String.prototype.substr is deprecated.\n\n也就是说不推荐使用 substr。推荐使用 slice。\n\necma 规范\n\n\n7. 总结#\n\n我们通过从团队需要规范统一包管理器的实际场景出发，讲了 vue3 源码中 preinstall 钩子 约束只能使用 pnpm 。同时通过查看 vite 源码和\npnpm 文档，了解到 only-allow 这个包。可以做到一行代码统一规范包管理器\"preinstall\": \"npx only-allow pnpm\"。\n\n也学习了其原理。only-allow 期待的包管理器和运行的包管理器对比。匹配失败，则报错。而which-pm-runs 通过获取\nprocess.env.npm_config_user_agent 变量获取到当前运行脚本的包管理器和版本号。\n\n我们通过文档和沟通约束，不如用工具（代码）约束。\n\n文章写到这里，让我想起我2018年写的文章参加有赞前端技术开放日所感所想\n\n当时演讲的大佬说过一句话。无比赞同。\n\n> 技术（开源）项目本质上是：理念、套路、规范的工具化。\n\n同时给我们的启发也是要多看官方文档和规范。\n\n建议读者克隆我的仓库动手实践调试源码学习。\n\n最后可以持续关注我@若川。欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，每周大家一起学习200行左右的源码，共同进步。","routePath":"/only-allow/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 场景","id":"2-场景","depth":2,"charIndex":401},{"text":"3. Vue3 源码 && npm 命令钩子","id":"3-vue3-源码--npm-命令钩子","depth":2,"charIndex":739},{"text":"4. 环境准备","id":"4-环境准备","depth":2,"charIndex":1272},{"text":"4.1 克隆代码","id":"41-克隆代码","depth":3,"charIndex":1291},{"text":"4.2 调试源码","id":"42-调试源码","depth":3,"charIndex":1530},{"text":"5. only-allow 源码","id":"5-only-allow-源码","depth":2,"charIndex":1964},{"text":"6. which-pm-runs 当前运行的是哪一个包管理器","id":"6-which-pm-runs-当前运行的是哪一个包管理器","depth":2,"charIndex":2015},{"text":"6.1 String.prototype.substr 截取字符串","id":"61-stringprototypesubstr-截取字符串","depth":3,"charIndex":2165},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":2374}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":58,"title":"据说 99% 的人不知道 vue-devtools 还能直接打开对应组件文件？本文原理揭秘","content":"#\n\n\n1. 前言#\n\n> 你好，我是若川，微信搜索「若川视野」关注我，专注前端技术分享，一个愿景是帮助5年内前端开阔视野走向前列的公众号。欢迎加我微信ruochuan12，长期交流学\n> 习。\n\n> 这是学习源码整体架构系列 之 launch-editor\n> 源码（第九篇）。学习源码整体架构系列文章(有哪些必看的JS库)：jQuery、underscore、lodash、sentry、vuex、axios、koa\n> 、redux。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。本篇文章学习的是实际仓库的\n> 代码。下一篇应该是《学习 Vuex 4 源码整体架构，深入理解其原理及provide/inject原理》。\n\n> 本文仓库地址：git clone\n> https://github.com/ruochuan12/open-in-editor.git，本文最佳阅读方式，克隆仓库自己动手调试，容易吸收消化。\n\n> 要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是无以为报啊。\n\n我的文章尽量写得让想看源码又不知道怎么看的读者能看懂。我都是推荐使用搭建环境断点调试源码学习，哪里不会点哪里，边调试边看，而不是硬看。正所谓：授人与鱼不如授人予\n渔。\n\n阅读本文后你将学到：\n\n 1. 如何解决该功能报错问题\n 2. 如何调试学习源码\n 3. launch-editor-middleware、launch-editor 等实现原理\n\n\n1.1 短时间找不到页面对应源文件的场景#\n\n不知道你们有没有碰到这样的场景，打开你自己（或者你同事）开发的页面，却短时间难以找到对应的源文件。\n\n这时你可能会想要是能有点击页面按钮自动用编辑器打开对应文件的功能，那该多好啊。\n\n而vue-devtools提供了这样的功能，也许你不知道。我觉得很大一部分人都不知道，因为感觉很多人都不常用vue-devtools。\n\n\n\n你也许会问，我不用vue，我用react有没有类似功能啊，有啊，请看react-dev-inspector。你可能还会问，支持哪些编辑器呀，主流的\nvscode、webstorm、atom、sublime 等都支持，更多可以看这个列表 Supported editors。\n\n本文就是根据学习尤大写的 launch-editor 源码，本着知其然，知其所以然的宗旨，探究 vue-devtools「在编辑器中打开组件」功能实现原理。\n\n\n1.2 一句话简述其原理#\n\n\n\n一句话简述原理：利用nodejs中的child_process，执行了类似code\npath/to/file命令，于是对应编辑器就打开了相应的文件，而对应的编辑器则是通过在进程中执行ps\nx（Window则用Get-Process）命令来查找的，当然也可以自己指定编辑器。\n\n\n1.3 打开编辑器无法打开组件的报错解决方法#\n\n而你真正用这个功能时，你可能碰到报错，说不能打开这个文件。\n\n\n\n\n\n> 这里说明下写这篇文章时用的是 Windows 电脑，VSCode 编辑器，在Ubuntu子系统下使用的终端工具。同时推荐我的文章使用 ohmyzsh 打造\n> windows、ubuntu、mac 系统高效终端命令行工具，用过的都说好。\n\n解决办法也简单，就是这句英文的意思。\n\n1.3.1 方法一：先确保在终端能用命令打开你使用的编辑器，文中以VSCode为例#\n\n如果你的命令行本身就不能运行code等命令打开编辑器，那肯定是报错的。这时需要把VSCode注入到命令行终端中。\n注入方法也简单。我的交流群里有小伙伴提供了mac电脑的截图。windows 用户安装VSCode后，终端默认支持 code 命令无需此操作。\n\nmac 电脑在 VSCode command + shift + p，Windows 则是 ctrl + shift +\np。然后输入shell，选择安装code。如下图：\n\nInstall 'code' command in PATH\n\n这样就能在终端中打开VSCode的了。\n\n如果能在终端打开使用命令编辑器能打开，但实际上还是报错，那么大概率是没有识别到你的编辑器。 那么可以通过方法二设置指定编辑器。\n\n1.3.2 方法二：具体说明编辑器，在环境变量中说明指定编辑器#\n\n在vue项目的根目录下，对应本文则是：vue3-project，添加.env.development文件，其内容是EDITOR=code。这里重点说明下，我的\nvue-cli 版本是4.5.12，好像在vue-cli 3.5及以上版本才支持自定义EDITOR这样的环境变量。\n\n\n\n> 不用指定编辑器的对应路径（c/Users/lxchu/AppData/Local/Programs/Microsoft VS\n> Code/bin/code），因为会报错。为什么会报错，因为我看了源码且试过。因为会被根据空格截断，变成c/Users/lxchu/AppData/Loca\n> l/Programs/Microsoft，当然就报错了。\n\n也有可能你的编辑器路径有中文路径导致报错，可以在环境变量中添加你的编辑器路径。\n\n如果你通过以上方法，还没解决报错问题。欢迎留言，或者加我微信 ruochuan12\n交流。毕竟电脑环境不一，很难保证所有人都能正常执行，但我们知道了其原理，就很容易解决问题。\n\n接下来我们从源码角度探究「在编辑器中打开组件」功能的实现原理。\n\n\n2. vue-devtools Open component in editor 文档#\n\n探究原理之前，先来看看vue-devtools官方文档。\n\nvuejs/vue-devtools 文档\n\n> Open component in editor To enable this feature, follow this guide.\n\n这篇指南中写了在Vue CLI 3中是开箱即用。\n\n\n\n也详细写了如何在Webpack下使用。\n\n\n\n同时也写了如何在Node.js中使用等。\n\n> Node.js You can use the launch-editor package to setup an HTTP route with the\n> /__open-in-editor path. It will receive file as an URL variable.\n\n查看更多可以看这篇指南。\n\n\n3. 环境准备工作#\n\n熟悉我的读者，都知道我都是推荐调试看源码的，正所谓：哪里不会点哪里。而且调试一般都写得很详细，是希望能帮助到一部分人知道如何看源码。于是我特意新建一个仓库ope\nn-in-editor git clone https://github.com/ruochuan12/open-in-editor.git，便于大家克隆学习。\n\n安装vue-cli\n\n\n\n\n\n这里同时说明下我的vscode版本。\n\n\n\n前文提到的Vue CLI 3中开箱即用和Webpack使用方法。\n\nvue3-project/package.json中有一个debug按钮。\n\n\n\n选择第一项，serve vue-cli-service serve。\n\n我们来搜索下'launch-editor-middleware'这个中间件，一般来说搜索不到node_modules下的文件，需要设置下。当然也有个简单做法。就\n是「排除的文件」右侧旁边有个设置图标「使用“排查设置”与“忽略文件”」，点击下。\n\n其他的就不赘述了。可以看这篇知乎回答：vscode怎么设置可以搜索包含node_modules中的文件?\n\n这时就搜到了vue3-project/node_modules/@vue/cli-service/lib/commands/serve.js中有使用这个中间件。\n\n如下图所示：\n\n\n\n\n4. vue-devtools 开箱即用具体源码实现#\n\n接着我们来看Vue CLI 3中开箱即用具体源码实现。\n\n\n\n本文项目使用的是Vue3，如果无法访问谷歌应用商店，如果未安装 vue3 对应的\nvue-devtools，可以点此下载安装Vue3对应版本的vue-devtools\n\n若平时项目开发使用的是vue2，可以点此下载安装vue2版本的vue-devtools\n\n点击vue-devtools中的图中 open in editor\n按钮时，会有一个请求，http://localhost:8080/__open-in-editor?file=src/App.vue，不出意外就会打开该组件啦。\n\n\n\n接着我们在launchEditorMiddleware的具体实现。\n\n\n5. launch-editor-middleware#\n\n看源码时，先看调试截图。\n\n\n\n在launch-editor-middleware中间件中作用在于最终是调用 launch-editor 打开文件。\n\n\n\n上一段中，这种切换参数的写法，在很多源码中都很常见。为的是方便用户调用时传参。虽然是多个参数，但可以传一个或者两个。\n\n可以根据情况打上断点。比如这里我会在launch(path.resolve(srcRoot, file), specifiedEditor,\nonErrorCallback)打断点。\n\n\n\n\n6. launch-editor#\n\n跟着断点来看，走到了launchEditor函数。\n\n\n\n\n6.1 wrapErrorCallback 包裹错误函数回调#\n\n\n\n这段的代码，就是传递错误回调函数，wrapErrorCallback 返回给一个新的函数，wrapErrorCallback 执行时，再去执行\nonErrorCallback(cb)。\n\n我相信读者朋友能看懂，我单独拿出来讲述，主要是因为这种包裹函数的形式在很多源码里都很常见。\n\n这里也就是文章开头终端错误图Could not open App.vue in the editor.输出的代码位置。\n\n\n\n\n6.2 guessEditor 猜测当前正在使用的编辑器#\n\n这个函数主要做了如下四件事情：\n\n 1. 如果具体指明了编辑器，则解析下返回。\n 2. 找出当前进程中哪一个编辑器正在运行。macOS 和 Linux 用 ps x 命令windows 则用 Get-Process 命令\n 3. 如果都没找到就用 process.env.VISUAL或者process.env.EDITOR。这就是为啥开头错误提示可以使用环境变量指定编辑器的原因。\n 4. 最后还是没有找到就返回[null]，则会报错。\n\n\n\n\n\n看完了 guessEditor 函数，我们接着来看 launch-editor 剩余部分。\n\n\n6.3 launch-editor 剩余部分#\n\n以下这段代码不用细看，调试的时候细看就行。\n\n\n\n这一大段中，主要的就是以下代码，用子进程模块。简单来说子进程模块有着执行命令的能力。\n\n\n\n行文至此，就基本接近尾声了。原理其实就是利用nodejs中的child_process，执行了类似code path/to/file命令。\n\n\n7. 总结#\n\n这里总结一下：首先文章开头通过提出「短时间找不到页面对应源文件的场景」，并针对容易碰到的报错情况给出了解决方案。\n其次，配置了环境跟着调试学习了vue-devtools中使用的尤大写的 yyx990803/launch-editor。\n\n\n7.1 一句话简述其原理#\n\n我们回顾下开头的原理内容。\n\n\n\n一句话简述原理：利用nodejs中的child_process，执行了类似code\npath/to/file命令，于是对应编辑器就打开了相应的文件，而对应的编辑器则是通过在进程中执行ps\nx（Window则用Get-Process）命令来查找的，当然也可以自己指定编辑器。\n\n最后还能做什么呢。\n\n可以再看看 umijs/launch-editor 和 react-dev-utils/launchEditor.js 。他们的代码几乎类似。\n\n也可以利用Node.js做一些提高开发效率等工作，同时可以学习child_process等模块。\n\n也不要禁锢自己的思维，把前端禁锢在页面中，应该把视野拓宽。\n\nNode.js是我们前端人探索操作文件、操作网络等的好工具。\n\n> 如果读者朋友发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出。另外觉得写得不错，对您有些许帮助，可以点赞、评论、转发分享，也是对我的一种支持，\n> 万分感谢。如果能关注我的前端公众号：「若川视野」，就更好啦。\n\n\n关于#\n\n> 你好，我是若川，微信搜索「若川视野」关注我，专注前端技术分享，一个愿景是帮助5年内前端开阔视野走向前列的公众号。欢迎加我微信ruochuan12，长期交流学\n> 习。 主要有以下系列文章：学习源码整体架构系列、年度总结、JS基础系列\n\n\n参考链接#\n\nyyx990803/launch-editor umijs/launch-editor vuejs/vue-devtools vue-devtools\nopen-in-editor.md \"Open in editor\" button doesn't work in Win 10 with VSCode if\ninstallation path contains spaces react-dev-utils/launchEditor.js","routePath":"/open-in-editor/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"1.1 短时间找不到页面对应源文件的场景","id":"11-短时间找不到页面对应源文件的场景","depth":3,"charIndex":668},{"text":"1.2 一句话简述其原理","id":"12-一句话简述其原理","depth":3,"charIndex":1073},{"text":"1.3 打开编辑器无法打开组件的报错解决方法","id":"13-打开编辑器无法打开组件的报错解决方法","depth":3,"charIndex":1229},{"text":"1.3.1 方法一：先确保在终端能用命令打开你使用的编辑器，文中以`VSCode`为例","id":"131-方法一先确保在终端能用命令打开你使用的编辑器文中以vscode为例","depth":4,"charIndex":-1},{"text":"1.3.2 方法二：具体说明编辑器，在环境变量中说明指定编辑器","id":"132-方法二具体说明编辑器在环境变量中说明指定编辑器","depth":4,"charIndex":1810},{"text":"2. vue-devtools Open component in editor 文档","id":"2-vue-devtools-open-component-in-editor-文档","depth":2,"charIndex":2327},{"text":"3. 环境准备工作","id":"3-环境准备工作","depth":2,"charIndex":2733},{"text":"4. vue-devtools 开箱即用具体源码实现","id":"4-vue-devtools-开箱即用具体源码实现","depth":2,"charIndex":3326},{"text":"5. launch-editor-middleware","id":"5-launch-editor-middleware","depth":2,"charIndex":3670},{"text":"6. launch-editor","id":"6-launch-editor","depth":2,"charIndex":3934},{"text":"6.1 wrapErrorCallback 包裹错误函数回调","id":"61-wraperrorcallback-包裹错误函数回调","depth":3,"charIndex":3983},{"text":"6.2 guessEditor 猜测当前正在使用的编辑器","id":"62-guesseditor-猜测当前正在使用的编辑器","depth":3,"charIndex":4223},{"text":"6.3 launch-editor 剩余部分","id":"63-launch-editor-剩余部分","depth":3,"charIndex":4527},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":4695},{"text":"7.1 一句话简述其原理","id":"71-一句话简述其原理","depth":3,"charIndex":4823},{"text":"关于","id":"关于","depth":2,"charIndex":5306},{"text":"参考链接","id":"参考链接","depth":2,"charIndex":5432}],"domain":"","frontmatter":{"theme":"smartblue","highlight":"dracula"},"version":""},{"id":59,"title":"","content":"","routePath":"/open-in-editor/mdnice","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":60,"title":"神器啊，从未想过 VSCode 还能这样直接打开仓库URL，原理揭秘~","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎 follow 我的 github。我倾力持续组织了一年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.7k+人）第一的专栏，写有20余篇源码文章。\n\n最近 antfu 在 Twitter 上发推开发了一个 VSCode 插件。\n\n\n\n你应该有碰到这样的场景。自己公司项目 gitlab 或者 github\n项目。想快速打开网页去做一些操作，但耗时很久。那么有了这个插件后就方便快速很多，直接在状态栏点击一下图标即可打开。\n\n安装插件 open in github button，github repo 后，会安装上依赖的另外一个插件 Open in GitHub，github\nrepo。\n\nOpen in GitHub 插件也提供了一些用户自定义配置。支持配置为自己的域名，比如 gitlab，配置好后就能打开相应的项目地址。\n\n可以全局设置 @ext:fabiospampinato.vscode-open-in-github。如下图所示：\n\n。\n\n也可以在项目中新增 .vscode/setting.json 配置。\n\n\n\n除了包含打开项目的命令，还包含了其他很多命令，比如打开 issue、action、pull request、release 等，可以按快捷键：ctrl +\nshift + p 输入 >open in github 查看。\n\n本文主要来讲述它们的实现原理。\n\n学完本文，你将学到：\n\n\n\n\n2. 环境准备#\n\n\n\n也可以 star 我的项目\n\n\n3. vscode-open-in-github-button 项目#\n\n\n3.1 package.json scripts 命令解析#\n\n主要依赖依赖如下：\n\n * eslint 配置 @antfu/eslint-config\n * 使用正确的包 @antfu/ni\n * 提升版本发布相关 bumpp\n * 执行node ts 相关 esno\n * pnpm\n * vite\n * vitest\n * vscode 插件发布相关 vsce\n * tsup ts 打包构建相关\n\nscripts 分析\n\n\n\n\n3.2 github actions#\n\n看项目前，我们先来看下 github actions 配置。 了解 GitHub Actions\n\n一个开源项目，一般会有基础的 workflow。\n\n * ci 每次 git push 命令时自动执行 lint 和 test 等，保证校验通过。\n * release：每次检测到 git tag，就自动发一个包。\n\n3.2.1 ci#\n\n安装 pnpm ，使用 node 16.x，全局安装 ni 工具，执行 nci npm ci npm run lint\n有三个job：lint、typecheck、test。\n\n这块代码由于太长，有删减，可点此查看完整代码。\n\n\n\n3.2.2 release 发布#\n\ngit push tag 时触发，用 changelogithub 生成 changelog。\n\n其中自动令牌身份验证 secrets.GITHUB_TOKEN\n\n\n\n我们来简单看下测试用例。这个项目用 vitest 测试。写了一个假的测试用例，因为在这个项目中没什么好测试的。\n\n3.2.3 vitest 测试#\n\n\n\n\n3.3 入口文件 index.ts#\n\n\n\n点击状态栏的 open in github 按钮，其实执行的是 'openInGitHub.openProject' 命令。\n\n\n3.4 openInGitHub.openProject#\n\n这时放几个官方链接。 VSCode 插件市场 vscode api 如果看英文文档吃力，这里推荐 Edge\n浏览器可以翻译成中文，或者谷歌自带的翻译，或者其他翻译插件。\n\n翻看文档和 项目package.json 文件，我们可以得知，这个命令并不是官方提供的，而是依赖第三方的扩展插件。\n\n\n\n我们来看这个插件，vscode-open-in-github。\n\n> open in project\n\n\n\n贡献文档 Contributing\n\nIf you found a problem, or have a feature request, please open an issue about\nit.\n\nIf you want to make a pull request you can debug the extension using Debug\nLauncher.\n\n调试安装作者推荐的调试工具 Debug Launcher。\n\n\n\n我们找到 main 入口文件。\n\n\n4. vscode-open-in-github package.json#\n\n入口文件\n\n\n\n主要依赖如下：\n\n * lodash\n * 回调函数转 Promise pify\n * simple-git\n\n\n5. 调试项目#\n\n克隆项目，然后安装依赖\n\n\n\n选中 package.json 中的，\"main\": \"out/extension.js\"，按 ctrl + shift + p。输入选择 debug\nlauncher auto 即可调试。\n\n\n\n\n6. 入口 src/extension.ts#\n\n我们可以从 webpack.config.js 配置看到入口文件 src/extension.ts，可以提前去打好断点等。\n\n\n\n\n\n\n6.1 Utils 工具函数#\n\n\n\n\n6.2 Commands 导出的命令函数#\n\n\n\n导出的函数，我们可以看出是调用的 URL.open 函数。 我们可以接着看 URL 对象。\n\n\n6.3 URL 对象#\n\n\n\n之前如果我们在 URL.get 这里断点。 我们可以跟着断点调试，来看 URL.get 函数。\n\n6.3.1 URL.get 函数#\n\n\n\n我们来重点看下 Utils.repo 对象导出的函数。\n\n\n6.4 Utils.repo 对象#\n\n\n\n6.4.1 Utils.repo.getUrl 获取 Url#\n\n\n\n总结一下大致流程：\n\n * vscode 使用 vscode.commands.registerCommand ( command, () => handler () ) 注册\n   openProject 命令\n * ctrl + shift + p 输入 >open in github，选择触发 openInGithub.openProject 命令\n * 执行 openProject 函数，实际调用 URL.open() 函数\n\n\n\n * 实际调用的是 URL.get 函数\n   * 先根据 vscode 的能力，获取到仓库的路径\n   * 再根据仓库的路径，获取 git 实例（simple-git）\n   * 根据 git 实例，获取到仓库的 url\n * 最后打开仓库 url 链接。\n\n\n7. 总结#\n\n行文至此，最后，我们来总结下：\n\n通过学习一个状态栏 github 图标，即可在浏览器中打开仓库的 github 地址功能。 open in github button vscode\n插件的原理，是调用了 vscode-open-in-github 插件提供的 openInGithub.openProject 命令。\n\n而 openInGithub.openProject 命令是 VSCode 插件注册的和执行 node 脚本，使用 simple-git 获取仓库 url\n等。最终 VSCode 打开浏览器访问这个链接地址。\n\n这种场景确实存在，但我们不一定会思考到用技术方案解决它。\n\n打开 github 仓库或者 gitlab 仓库的方式有挺多。比如终端工具 gh browse。或者在 package.json\n配置仓库链接地址，再转到找到链接地址去打开。或者找到 .git/config 中的配置 git 链接打开。\n\n我们学会了如何利用 GitHub Actions，用 tsup 构建 ts，用 bumpp 提升版本号等，用 changelogithub 生成\nchangelog 等等，开发一个开源项目。\n\n我们还学会了用 vsce 如何打包、发布一个 VSCode 插件。学会了使用调试工具 Debug Launcher 自动化调试 VSCode 插件。\nVSCode 详尽的发布插件官方文档\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n\n8. 加源码共读交流群#\n\n最后可以持续关注我@若川，欢迎 follow 我的\ngithub。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.7k+人）第一的专栏，写有20余篇源码文章。\n\n我倾力持续组织了一年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。","routePath":"/open-in-github/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 环境准备","id":"2-环境准备","depth":2,"charIndex":704},{"text":"3. vscode-open-in-github-button 项目","id":"3-vscode-open-in-github-button-项目","depth":2,"charIndex":732},{"text":"3.1 package.json scripts 命令解析","id":"31-packagejson-scripts-命令解析","depth":3,"charIndex":770},{"text":"3.2 github actions","id":"32-github-actions","depth":3,"charIndex":988},{"text":"3.2.1 ci","id":"321-ci","depth":4,"charIndex":1168},{"text":"3.2.2 release 发布","id":"322-release-发布","depth":4,"charIndex":1295},{"text":"3.2.3 vitest 测试","id":"323-vitest-测试","depth":4,"charIndex":1455},{"text":"3.3 入口文件 index.ts","id":"33-入口文件-indexts","depth":3,"charIndex":1476},{"text":"3.4 openInGitHub.openProject","id":"34-openingithubopenproject","depth":3,"charIndex":1563},{"text":"4. vscode-open-in-github package.json","id":"4-vscode-open-in-github-packagejson","depth":2,"charIndex":2034},{"text":"5. 调试项目","id":"5-调试项目","depth":2,"charIndex":2139},{"text":"6. 入口 src/extension.ts","id":"6-入口-srcextensionts","depth":2,"charIndex":2264},{"text":"6.1 Utils 工具函数","id":"61-utils-工具函数","depth":3,"charIndex":2357},{"text":"6.2 Commands 导出的命令函数","id":"62-commands-导出的命令函数","depth":3,"charIndex":2377},{"text":"6.3 URL 对象","id":"63-url-对象","depth":3,"charIndex":2450},{"text":"6.3.1 URL.get 函数","id":"631-urlget-函数","depth":4,"charIndex":2514},{"text":"6.4 Utils.repo 对象","id":"64-utilsrepo-对象","depth":3,"charIndex":2565},{"text":"6.4.1 Utils.repo.getUrl 获取 Url","id":"641-utilsrepogeturl-获取-url","depth":4,"charIndex":2587},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":2976},{"text":"8. 加源码共读交流群","id":"8-加源码共读交流群","depth":2,"charIndex":3715}],"domain":"","frontmatter":{},"version":""},{"id":61,"title":"每次启动项目的服务，电脑竟然乖乖的帮我打开了浏览器，100行源码揭秘！","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动，感兴趣的可以加我微信 ruochuan12\n> 参与，如今已进行三个月，大家一起交流学习，共同进步，很多人都表示收获颇丰。\n\n想学源码，极力推荐之前我写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等10余篇源码文章。\n\n本文仓库 open-analysis，求个star^_^\n\n最近组织了源码共读活动，大家一起学习源码。于是搜寻各种值得我们学习，且代码行数不多的源码。\n\n我们经常遇到类似场景：每次启动项目的服务，电脑竟然乖乖的帮我打开了浏览器。当然你也可能没有碰到过，但可能有这样的需求。而源码300行左右，核心源码不到100行。\n跟我们工作息息相关，非常值得我们学习。\n\n之前写过据说 99% 的人不知道 vue-devtools 还能直接打开对应组件文件？本文原理揭秘，也是跟本文类似原理。\n\n阅读本文，你将学到：\n\n\n\n\n2. 使用#\n\n\n2.1 在 webpack 中使用#\n\ndevServer.open\n\n告诉 dev-server 在服务器启动后打开浏览器。 将其设置为 true 以打开您的默认浏览器。\n\nwebpack.config.js\n\n\n\nUsage via the CLI:\n\n\n\nTo disable:\n\n\n\n现在大多数都不是直接用 webpack 配置了。而是使用脚手架。那么接着来看我们熟悉的脚手架中，打开浏览器的功能是怎么使用的。\n\n\n2.2 在 vue-cli 使用#\n\n\n\n\n2.3 在 create-react-app 使用#\n\n\n\n\n\n终端我用的是 window terminal，推荐我之前的文章：使用 ohmyzsh 打造 windows、ubuntu、mac\n系统高效终端命令行工具，用过都说好。\n\nwebpack、vue-cli和create-react-app，它们三者都有个特点就是不约而同的使用了open。\n\n引用 open 分别的代码位置是：\n\n * webpack-dev-server\n * vue-cli\n * create-react-app\n\n接着我们来学习open原理和源码。\n\n\n3. 原理#\n\n在 npm 之王 @sindresorhus 的 open README文档中，英文描述中写了为什么使用它的几条原因。\n\n为什么推荐使用 open\n\n\n\n一句话概括open原理则是：针对不同的系统，使用Node.js的子进程 child_process 模块的spawn方法，调用系统的命令打开浏览器。\n\n对应的系统命令简单形式则是：\n\n\n\nwindows start 文档\n\nopen包描述信息：open\n\n在这里可以看到有哪些 npm 包依赖了 open\n\n我们熟悉的很多 npm 包都依赖了open。这里列举几个。\n\n * webpack-dev-server\n * react-dev-utils\n * @vue/cli-shared-utils\n * patch-package\n * lighthouse\n * release-it\n\n\n4. 阅读源码前的准备工作#\n\n\n\n\n4.1 写个例子，便于调试源码#\n\n由于测试用例相对较为复杂，我们自己动手写个简单的例子，便于我们自己调试。\n\n根据 README，我们在 open-analysis 文件夹下新建一个文件夹 examples ，里面存放一个 index.js。文件内容如下：\n\n\n\n在 await open('https://ruochuan12.github.io'); 打上断点。在终端命令行中执行\n\n\n\n会自动唤起调试模式。如果不支持先阅读这个官方文档配置：Node.js debugging in VS Code，如果还是不行，可以升级到最新版VSCode试试。\n\n跟着调试我们可以进入 open 函数。\n\n\n\n\n\n\n4.2 open 打开函数#\n\n\n\n跟着断点，我们来看最终调用的 baseOpen。 这个函数比较长，重点可以猜到是：const subprocess =\nchildProcess.spawn(command, cliArguments, childProcessOptions);这句，我们可以打算断点调试。\n\n\n4.3 baseOpen 基础打开函数#\n\n\n\n由此我们可以看出：\n\n一句话概括open原理则是：针对不同的系统，使用Node.js的子进程 child_process 模块的spawn方法，调用系统的命令打开浏览器。\n\n对应的系统命令简单形式则是：\n\n\n\n\n5. 总结#\n\n一句话概括open原理则是：针对不同的系统，使用Node.js的子进程 child_process 模块的spawn方法，调用系统的命令打开浏览器。\n\n本文从日常常见的场景每次启动服务就能自动打开浏览器出发，先讲述了日常在webpack、vue-cli、create-react-app如何使用该功能，最后从源码\n层面解读了open的原理和源码实现。工作常用的知识能做到知其然，知其所以然，就比很多人厉害了。\n\n因为文章不宜过长，所以未全面展开讲述源码中所有细节。非常建议读者朋友按照文中方法使用VSCode调试 open 源码。学会调试源码后，源码并没有想象中的那么难。\n\n最后可以持续关注我@若川。欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。","routePath":"/open/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 使用","id":"2-使用","depth":2,"charIndex":530},{"text":"2.1 在 webpack 中使用","id":"21-在-webpack-中使用","depth":3,"charIndex":539},{"text":"2.2 在 vue-cli 使用","id":"22-在-vue-cli-使用","depth":3,"charIndex":751},{"text":"2.3 在 create-react-app 使用","id":"23-在-create-react-app-使用","depth":3,"charIndex":773},{"text":"3. 原理","id":"3-原理","depth":2,"charIndex":1042},{"text":"4. 阅读源码前的准备工作","id":"4-阅读源码前的准备工作","depth":2,"charIndex":1425},{"text":"4.1 写个例子，便于调试源码","id":"41-写个例子便于调试源码","depth":3,"charIndex":1444},{"text":"4.2 open 打开函数","id":"42-open-打开函数","depth":3,"charIndex":1749},{"text":"4.3 baseOpen 基础打开函数","id":"43-baseopen-基础打开函数","depth":3,"charIndex":1907},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":2037}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":62,"title":"知乎回答：你写过什么自认为惊艳的诗？","content":"#\n\n> 首次整理于 2019-07-27 22:04:00。\n> 整理了一下大学期间2012年～2016年发布在QQ空间，自己感觉写得还行的七首“诗词”。回答知乎问题：你写过什么自认为惊艳的诗？\n\n中国古诗词博大精深。小时候浪费粮食时，父母会告诉你：谁知盘中餐，粒粒皆辛苦。漂泊在外的游子，能想起那一句：慈母手中线，游子身上衣。求学在外，看着天上的明月，思念\n故乡时可能回想起：举头望明月，低头思故乡。当你回到久别的家乡：儿童相见不相识，笑问客从何处来。\n\n其实作为小时候都背诵唐诗宋词的我们，或多或少都会对诗词有所热爱。自己也想着写一写，虽然自己写的大多谈不上是诗词，但也是思想感情的一种抒发。想起前段时间，小学同学\n来杭州游玩，夜游西湖时，他说到小学老师教的诗词真的很美。说他自己最近也写了几句，我们都说念出来听听，我们觉得他确实写得不错。\n\n\n一、《浣溪沙 初冬》#\n\n> 文/若川 时间：2012-11-19 11:41\n\n晨起雾浓难见霜， 眼前双雁碧天航。 初冬草木逝容光。\n\n难见亲朋心自闷， 灯光暗淡意悲沧。 夜深未梦最迷茫。\n\n> 【附】：六点半早起做早操，看见两只小鸟飞过。初冬忙碌的一天开始了，几乎天天满课。与亲朋同学联系甚少。回宿舍的途中，每次都是昏暗的路灯。而且到晚上十一点半还没\n> 进入梦乡。大学里的每天几乎就是这样度过的！谁说大学是天堂，我说大学最迷茫！\n\n\n二、《浪淘沙 雪》#\n\n> 文/若川 时间：2012-12-15 22:03\n\n晨起步庭中， 碎玉悬空， 庭中踏雪欲寻松。 梅溢清香集醉赏， 松柏相拥。\n\n开锁立门中， 遥望天穹， 山形与树影朦胧。 透骨心寒云漠漠， 雪怎消融?\n\n> 【附】：《浪淘沙》平仄谱 中仄仄平平(韵)，中仄平平(韵)。中平中仄仄平平(韵)。中仄中平平仄仄，中仄平平(韵)。\n> 中仄仄平平(韵)，中仄平平(韵)，中平中仄仄平平(韵)。中仄中平平仄仄，中仄平平(韵)。\n\n\n三、《蝶恋花 元旦》#\n\n> 文/若川 时间：2013-01-01 某时刻\n\n寒冷不知元旦到， 同行山庄， 依旧朝阳照。 慢行远观林里鸟， 溪流映照面颊笑。\n\n人有悲欢多自扰， 共举酒杯， 饮尽高声笑。 相聚光阴惜甚少， 归时便是丹霞耀。\n\n\n\n\n\n\n\n\n\n\n\n\n\n> 【附1】此词为记计算机协会元旦去五福山庄自己动手聚餐。\n> 早上迎着朝阳去五福山庄。随后四人一同去湘妃楼，树林里竟有彩色的小鸟。沿途有溪流，桥，人家，真有小桥流水人家的氛围。清澈的溪水倒映我们的笑容。 //\n> 回来五福山庄后，我们一同饮酒，共进午餐。可惜相聚时间太短，但回校的时候已是夕阳照耀了。\n\n> 【附2】：《蝶恋花》平仄谱 中仄中平平仄仄（韵）。中仄平平，中仄平平仄（韵）。中仄中平平仄仄（韵），中平中仄平平仄（韵）。 //\n> 中仄中平平仄仄（韵）。中仄平平，中仄平平仄（韵）。中仄中平平仄仄（韵），中平中仄平平仄（韵）。\n\n\n四、《蝶恋花 寄往》#\n\n> 文/若川 时间：2013-01-20 18:10\n\n昨夜梦回杨柳岸。 心系兰舟， 风过波光滟。 惆怅离别毋送远， 山高水远离人怨。\n\n独倚栏杆残月现。 物是人非， 灯下行人乱。 举目烟花香漫漫， 乡思无处琴弦叹。\n\n\n\n\n\n> 【附】：2013-1-20\n> 18:10，想到21晚八点到家。于是，我独自站在寝室的阳台。仰望挂着残月的夜空。看着远处的灯火阑珊，近处路灯下行人拖着行李箱急忙赶路，显得有些许慌乱。忽然，\n> 亮丽的烟花划破了东方的夜空。此时，室友正弹着吉他，其声饱含悲叹。故作此《蝶恋花 寄往》，以表思乡之情。\n\n\n五、《苏幕遮 游玉田湖景区》#\n\n> 文/若川 时间：2013-04-06 某时刻\n\n紫花妍， 竹叶翠。 踏步前行， 野径双鸟戏。 豌豆花开争献媚。 烧烤飘香， 别有番风味。\n\n玉田湖， 垂钓汇。 春色横湖， 岛上春柔魅。 湖荡清波非恶意。 风起归途， 吹落桃花雨。\n\n\n\n\n\n\n\n\n\n\n\n\n\n> 【附1】：此词《苏幕遮\n> 游玉田湖景区》为记清明后（4月5日）计算机协会成员一同骑车去玉田水库游玩烧烤。路旁田野的紫花开了，竹叶翠绿，竹笋茁壮成长。慢慢前行，一条小路中鸟儿嬉戏，好像\n> 是在为春天而欢跃。菜园里豌豆花开了，白得晶莹剔透。我们烧烤时，炒包菜，烤玉米。香气扑鼻。 //\n> 到了目的地，玉田湖。好多钓鱼爱好者汇集到一起。湖中有个小岛，岛上一片翠绿，把春天的柔和表现得淋漓尽致。湖水荡起清波并无恶意打扰垂钓者。我们下午四点归来时吹起\n> 了风，下起了细雨。就这样结束了一天的玉田水库游玩。总而言之，我们玩得很开心!\n\n> 【附2】：《苏幕遮》平仄谱 仄平平，平仄仄（韵），中仄平平、中仄平平仄（韵）。中仄平平平仄仄（韵）。中仄平平、中仄平平仄（韵）。\n\n\n六、《 临江仙 · 元旦》#\n\n> 文/若川 时间：2014-01-05 21:50\n\n弹指轮回数日月， 又逢元旦出游。 草枯藤败绕成愁。 长桥年数载， 稻谷早丰收。\n\n骏马飞奔蛇远去， 贺新年乐不休。 数人饮散望溪流。 寒歌声悦耳， 欢聚为何求？\n\n\n\n> 【附1】：此次为记计算机协会元旦一起前去五福山庄自己动手烧菜，煮饭。弹指一挥间，一年就过去了，又是一年元旦时，记得去年也是计算机协会前去五福山庄自己动手，丰\n> 衣足食。去年我们是大一，不是组织者，所以我们前去湘妃楼游玩，下文附上去年的《蝶恋花·元旦》。今年买菜，饮料，花生之类的都是我们大二组织的。\n\n> 【附2】：译——弹指一挥间，又是元旦去五福山庄游玩。深冬，枯草和败藤绕成一簇簇的。途中，长长的老桥已经有数载的年头了，桥头一端有个牌子：此桥年久失修，严禁超\n> 载车辆通行。从桥上看去，稻田里只剩荒草，早已丰收。 //\n> 马年飞奔着到了，蛇年悄然远去。共贺新年，欢乐不停休。我们十五个人吃饱喝足后，又来到桥上，望着远去的流水，离开那长桥后，我们一起去K歌。欢聚在一起就是一种幸福\n> ，还有什么要渴求呢？\n\n> 【附3】：《临江仙》平仄谱 中仄中平平仄仄，中平中仄平平（韵）。中平中仄仄平平（韵）。中平平仄仄，中仄仄平平（韵）。 //\n> 中仄中平平仄仄，中平中仄平平（韵）。中平中仄仄平平（韵）。中平平仄仄，中仄仄平平（韵）。\n\n\n七、《青玉案 · 冬韵》#\n\n> 文/若川 时间：2014-12-13 22:50\n\n东风拂面寒霜路。 叶飘落， 随风去。 流水斜桥烟渚处。 钓翁静坐， 轻波风扬， 湖面飞白鹭。\n\n归时忽见羔羊聚。 丝缕阳光照枯树。 一笑匆匆还未暮。 光阴易逝， 可怜须臾， 暗逐流年度。\n\n\n\n\n\n\n\n\n\n> 【附1】：本文背景，上次优秀班集体评选，我做了一个PPT，和主持人配合好。获得了优秀班集体，奖励现金1000元，于是用来班级搞活动。2014年12月13日，\n> 12信管班一起去玉田水库烧烤。早上包车前去，迎着东风，踩着还有霜的小路。树叶随风飘落。看见斜桥，流水，在湖边烧烤。湖边有人在静静坐着垂钓。由于我们的惊扰，湖\n> 面的白鹭飞走了。 //\n> 离开的时候，忽然看见好多只小羔羊。阳光照耀在枯树上。我们唱起歌，唱到开心处都笑了，还没有到傍晚。感慨时光易逝，转眼，已经大三了，再转眼就毕业了。大学班级情感\n> 需好好珍惜。回来后大家一起去Ｋ歌。21点多才回来。\n\n> 【附2】：《青玉案》平仄谱 中平中仄平平仄（韵）。仄中仄、平平仄（韵）。中仄中平平仄仄（韵）。中平中仄，中平平仄，中仄平平仄（韵）。 //\n> 中平中仄平平仄（韵）。中仄平平仄平仄（韵）。中仄中平平仄仄（韵）。中平中仄，中平中仄，中仄平平仄（韵）。 （好久没填词了，写这个花了好久。）\n\n以上七首“诗词”主要是大学期间2012年～2016年所写。 要问我大学以后写了没写。基本没写了。为什么？可能是代码写成了诗吧^_^","routePath":"/poetry/2012-2016/","lang":"zh","toc":[{"text":"一、《浣溪沙 初冬》","id":"一浣溪沙-初冬","depth":2,"charIndex":375},{"text":"二、《浪淘沙    雪》","id":"二浪淘沙----雪","depth":2,"charIndex":-1},{"text":"三、《蝶恋花 元旦》","id":"三蝶恋花-元旦","depth":2,"charIndex":820},{"text":"四、《蝶恋花 寄往》","id":"四蝶恋花-寄往","depth":2,"charIndex":1225},{"text":"五、《苏幕遮 游玉田湖景区》","id":"五苏幕遮-游玉田湖景区","depth":2,"charIndex":1505},{"text":"六、《 临江仙 · 元旦》","id":"六-临江仙--元旦","depth":2,"charIndex":1989},{"text":"七、《青玉案 · 冬韵》","id":"七青玉案--冬韵","depth":2,"charIndex":2591}],"domain":"","frontmatter":{},"version":""},{"id":63,"title":"登高望远，夜幕降临","content":"#\n\n> 写于 2013年8月1日\n\n夜幕即将降临，骑上单车，穿过那片田野。\n\n来到山脚下，惊动雏鸟，鸟儿藏匿。\n\n回望田野，阡陌纵横。\n\n登上山顶，凉风袭来。\n\n遥望夕阳，静观晚霞。\n\n环顾四周，村落人家，炊烟缕缕。\n\n万里群山，千姿百态。\n\n山谷松木，郁郁葱葱。\n\n忽见蛇行，匆匆击掌，惊起白鹤数只。\n\n远处湖泊，听到车声，定睛一看，原是高速路。\n\n天空鸟儿飞过，叫声凄凉，归栖息地。\n\n急忙下山，虫声四起，远处灯火闪烁，骑车归家，一路蚊子嗡嗡作响。\n\n夜幕登高，颇多惬意。\n\n2018年10月5日重新登山 发朋友圈附图\n\n\n\n\n\n\n\n","routePath":"/poetry/2013/","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":64,"title":"若川诚邀你加前端源码共读群，长期交流学习","content":"#\n\n你好，我是若川。目前持续组织了5个月每周一起学200行左右源码共读活动，每周一期，已进行到20期，感兴趣的可以加我微信 ruochuan02\n加群参与，长期交流学习。微信扫码或搜索\n\n可能比较有趣的微信公众号，长按扫码关注（回复pdf获取前端优质书籍pdf）。欢迎加我微信ruochuan12（来者不拒），拉您进【前端视野交流群】，长期交流学习\n~\n\n\n\n博客不经常更新，但公众号经常会更新，欢迎关注。\n\n\n关于我#\n\n你好，我是若川。江西人，某不那么知名的陶瓷大学毕业生，目前在杭州从事前端开发工作，也是一枚PPT爱好者。所知甚少，唯善学。常以若川为名混迹于江湖。更详细的可以点\n击关于我\n\n> vuepress博客：https://ruochuan12.github.io\n> \n> 如果打开比较慢，可以访问http://lxchuan12.gitee.io/，可能会快些\n\n您可以在以下网站（点击图片跳转）关注我：\n\n\n知乎相对高赞高阅读量的问答#\n\n若川知乎回答：一年内的前端看不懂前端框架源码怎么办？ 若川知乎回答：做了两年前端开发，平时就是拿 Vue 写写页面和组件，简历的项目经历应该怎么写得好看？\n若川知乎回答：怎么才能学好前端？ 如果觉得不错，可以点个赞^_^\n\n\n文章列表#\n\nvant 组件库源码分析系列：\n\n * 51.vant4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n * 50.分析 vant4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n\n * 49.分析 vant4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n\n * 48.跟着 vant4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n\n * 47.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n\n学习源码整体架构系列：\n\n * 46.自从学了 react-use 源码，我写自定义 React Hooks 越来越顺了~\n\n * 45.据说90%的人不知道可以用测试用例(Vitest)调试开源项目(Vue3) 源码\n\n * 44.经常用 vant-weapp 开发小程序，却不知道如何开发一个组件？学！\n\n * 43.vite 3.0 都发布了，经常初始化 vite 项目，却不知 create-vite 原理？揭秘！\n\n * 42.还在用开发者工具上传小程序? 快来试试 miniprogram-ci 提效摸鱼\n\n * 41.面试官：项目中常用的 .env 文件原理是什么？如何实现？\n\n * 40.面试官：请手写一个带取消功能的延迟函数，axios 取消功能的原理是什么\n\n * 39.Vue团队核心成员开发的39行小工具 install-pkg 安装包，值得一学！\n\n * 38.从 vue-cli 源码中，我发现了27行读取 json 文件有趣的 npm 包\n\n * 37.从 vue3 和 vite 源码中，我学到了一行代码统一规范团队包管理器的神器\n\n * 36.每次新增页面复制粘贴？100多行源码的 element-ui 新增组件功能告诉你减少重复工作\n\n * 35.新手向：前端程序员必学基本技能——调试JS代码\n\n * 34.从22行有趣的源码库中，我学到了 callback promisify 化的 Node.js 源码实现\n\n * 33.每次启动项目的服务，电脑竟然乖乖的帮我打开了浏览器，100行源码揭秘！\n\n * 32.初学者也能看懂的 Vue2 源码中那些实用的基础工具函数\n\n * 31.尤雨溪推荐神器 ni ，能替代 npm/yarn/pnpm ？简单好用！源码揭秘！\n\n * 30.尤雨溪几年前开发的“玩具 vite”，才100多行代码，却十分有助于理解 vite 原理\n\n * 29.Vue 团队公开快如闪电的全新脚手架工具 create-vue，未来将替代 Vue-CLI，才300余行代码，学它！\n\n * 28.为什么 Vue2 this 能够直接获取到 data 和 methods\n\n * 27.50行代码串行Promise，koa洋葱模型原来是这么实现？\n\n * 26.Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？\n\n * 25.初学者也能看懂的 Vue3 源码中那些实用的基础工具函数\n\n * 24.尤雨溪开发的 vue-devtools 如何安装，为何打开文件的功能鲜有人知？\n\n * 23.面对 this 指向丢失，尤雨溪在 Vuex 源码中是怎么处理的\n\n * 22.一文读懂vuex4源码，原来provide/inject就是妙用了原型链？\n\n * 21.据说 99% 的人不知道 vue-devtools 还能直接打开对应组件文件？本文原理揭秘\n\n * 20.学习 redux 源码整体架构，深入理解 redux 及其中间件原理\n\n * 19.学习 koa 源码的整体架构，浅析koa洋葱模型原理和co原理\n\n * 18.学习 axios 源码整体架构，打造属于自己的请求库\n\n * 17.学习 vuex 源码整体架构，打造属于自己的状态管理库\n\n * 16.学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK\n\n * 15.学习 lodash 源码整体架构，打造属于自己的函数式编程类库\n\n * 14.学习 underscore 源码整体架构，打造属于自己的函数式编程类库\n\n * 13.学习 jQuery 源码整体架构，打造属于自己的 js 类库\n\n面试官问系列：\n\n * 12.面试官问：JS的继承\n\n * 11.面试官问：JS的this指向\n\n * 10.面试官问：能否模拟实现JS的call和apply方法\n\n * 9.面试官问：能否模拟实现JS的bind方法\n\n * 8.面试官问：能否模拟实现JS的new操作符\n\n其他：\n\n * 7.前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并\n\n * 6.分析vue-cli@2.9.3 搭建的webpack项目工程\n\n * 5.oh my zsh 和 windows git bash 设置别名提高效率\n\n * 4.vue 2.x项目 vue-qriously 生成二维码并下载、cliploard复制粘贴\n\n * 3.参加有赞前端技术开放日所感所想\n\n * 2.JavaScript 对象所有API解析\n\n * 1.《JavaScript语言精粹 修订版》 读书笔记\n\n\n免费的知识星球 前端视野#\n\n主要发表一些前端所见所想，Vue、React、构建工具(比如：gulp、webpack)、设计模式等。一个人走得快，一群人走得远。","routePath":"/posts/","lang":"zh","toc":[{"text":"关于我","id":"关于我","depth":2,"charIndex":206},{"text":"知乎相对高赞高阅读量的问答","id":"知乎相对高赞高阅读量的问答","depth":2,"charIndex":415},{"text":"文章列表","id":"文章列表","depth":2,"charIndex":544},{"text":"免费的知识星球 前端视野","id":"免费的知识星球-前端视野","depth":2,"charIndex":2739}],"domain":"","frontmatter":{},"version":""},{"id":65,"title":"promise-serial","content":"#\n\n\n\n\nfor of await#\n\n\nkoa 串行#\n\n\naxios 串行#\n\n\nredux 串行#","routePath":"/promise-serial/","lang":"zh","toc":[{"text":"for of await","id":"for-of-await","depth":3,"charIndex":5},{"text":"koa 串行","id":"koa-串行","depth":3,"charIndex":21},{"text":"axios 串行","id":"axios-串行","depth":3,"charIndex":31},{"text":"redux 串行","id":"redux-串行","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":66,"title":"","content":"","routePath":"/promise-serial/src/js/promise-serial-1","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":67,"title":"","content":"","routePath":"/promise-serial/src/js/request","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":68,"title":"从22行有趣的源码库中，我学到了 callback promisify 化的 Node.js 源码实现","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动，感兴趣的可以加我微信 ruochuan12\n> 参与，如今已进行三个月，大家一起交流学习，共同进步，很多人都表示收获颇丰。\n\n想学源码，极力推荐之前我写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等10余篇源码文章。\n\n本文仓库 remote-git-tags-analysis，求个star^_^\n\n最近组织了源码共读活动，大家一起学习源码。于是搜寻各种值得我们学习，且代码行数不多的源码。\n\n我们经常会在本地git仓库切换tags，或者git仓库切换tags。那么我们是否想过如果获取tags呢。本文就是学习 remote-git-tags\n这个22行代码的源码库。源码不多，但非常值得我们学习。\n\n阅读本文，你将学到：\n\n\n\n刚开始先不急着看上千行、上万行的源码。源码长度越长越不容易坚持下来。看源码讲究循序渐进。比如先从自己会用上的百来行的开始看。\n\n我之前在知乎上回答过类似问题。\n\n一年内的前端看不懂前端框架源码怎么办？\n\n简而言之，看源码\n\n\n\n\n2. 使用#\n\n\n\n\n3. 源码#\n\n> Get tags from a remote Git repo\n\n这个库的作用是：从远程仓库获取所有标签。\n\n原理：通过执行 git ls-remote --tags repoUrl （仓库路径）获取 tags\n\n应用场景：可以看有哪些包依赖的这个包。 npm 包描述信息\n\n其中一个比较熟悉的是npm-check-updates\n\n> npm-check-updates 将您的 package.json 依赖项升级到最新版本，忽略指定的版本。\n\n还有场景可能是 github 中获取所有 tags 信息，切换 tags 或者选定 tags 发布版本等，比如微信小程序版本。\n\n看源码前先看 package.json 文件。\n\n\n3.1 package.json#\n\n\n\n众所周知，Node 之前一直是 CommonJS 模块机制。 Node 13 添加了对标准 ES6 模块的支持。\n\n告诉 Node 它要加载的是什么模块的最简单的方式，就是将信息编码到不同的扩展名中。 如果是 .mjs 结尾的文件，则 Node 始终会将它作为 ES6\n模块来加载。 如果是 .cjs 结尾的文件，则 Node 始终会将它作为 CommonJS 模块来加载。\n\n对于以 .js 结尾的文件，默认是 CommonJS 模块。如果同级目录及所有目录有 package.json 文件，且 type 属性为module 则使用\nES6 模块。type 值为 commonjs 或者为空或者没有 package.json 文件，都是默认 commonjs 模块加载。\n\n关于 Node 模块加载方式，在《JavaScript权威指南第7版》16.1.4 Node 模块\n小节，有更加详细的讲述。此书第16章都是讲述Node，感兴趣的读者可以进行查阅。\n\n\n3.2 调试源码#\n\n\n\n用最新的VSCode 打开项目，找到 package.json 的 scripts 属性中的 test 命令。鼠标停留在test命令上，会出现 运行命令 和\n调试命令 的选项，选择 调试命令 即可。\n\n调试如图所示：\n\n\n\nVSCode 调试 Node.js 说明如下图所示：\n\n\n\n跟着调试，我们来看主文件。\n\n\n3.3 主文件仅有22行源码#\n\n\n\n源码其实一眼看下来就很容易懂。\n\n\n3.4 git ls-remote --tags#\n\n支持远程仓库链接。\n\ngit ls-remote 文档\n\n如下图所示：\n\n\n\n获取所有tags git ls-remote --tags https://github.com/vuejs/vue-next.git\n\n把所有 tags 和对应的 hash值 存在 Map 对象中。\n\n\n3.5 node:util#\n\nNode 文档\n\n> Core modules can also be identified using the node: prefix, in which case it\n> bypasses the require cache. For instance, require('node:http') will always\n> return the built in HTTP module, even if there is require.cache entry by that\n> name.\n\n也就是说引用 node 原生库可以加 node: 前缀，比如 ``\n\n看到这，其实原理就明白了。毕竟只有22行代码。接着讲述 promisify。\n\n\n4. promisify#\n\n源码中有一段：\n\n\n\npromisify 可能有的读者不是很了解。\n\n接下来重点讲述下这个函数的实现。\n\npromisify函数是把 callback 形式转成 promise 形式。\n\n我们知道 Node.js 天生异步，错误回调的形式书写代码。回调函数的第一个参数是错误信息。也就是错误优先。\n\n我们换个简单的场景来看。\n\n\n4.1 简单实现#\n\n假设我们有个用JS加载图片的需求。我们从 这个网站 找来图片。\n\n\n\n我们很容易写出上面的代码，也很容易写出回调函数的代码。需求搞定。\n\n\n\n但是回调函数有回调地狱等问题，我们接着用 promise 来优化下。\n\n\n4.2 promise 初步优化#\n\n我们也很容易写出如下代码实现。\n\n\n\n但这个不通用。我们需要封装一个比较通用的 promisify 函数。\n\n\n4.3 通用 promisify 函数#\n\n\n\n需求搞定。这时就比较通用了。\n\n这些例子在我的仓库存放在 examples 文件夹中。可以克隆下来，npx http-server .跑服务，运行试试。\n\n\n\n跑失败的结果可以把 imageSrc 改成不存在的图片即可。\n\npromisify 可以说是面试高频考点。很多面试官喜欢考此题。\n\n接着我们来看 Node.js 源码中 promisify 的实现。\n\n\n4.4 Node utils promisify 源码#\n\ngithub1s node utils 源码\n\n源码就暂时不做过多解释，可以查阅文档。结合前面的例子，其实也容易理解。\n\nutils promisify 文档\n\n\n\n\n5. ES6+ 等知识#\n\n文中涉及到了Map、for of、正则、解构赋值。\n\n还有涉及封装的\nReflectApply、ObjectSetPrototypeOf、ObjectDefineProperty、ObjectGetOwnPropertyDescr\niptors 等函数都是基础知识。\n\n这些知识可以查看esma规范，或者阮一峰老师的《ES6 入门教程》 等书籍。\n\n\n6. 总结#\n\n一句话简述 remote-git-tags 原理：使用Node.js的子进程 child_process 模块的execFile方法执行 git\nls-remote --tags repoUrl 获取所有 tags 和 tags 对应 hash 值 存放在 Map 对象中。\n\n文中讲述了我们可以循序渐进，借助调试、理清主线、查阅资料、总结记录的流程看源码。\n\n通过 remote-git-tags 这个22行代码的仓库，学会了 Node 加载采用什么模块，知道了原来 git ls-remote\n--tags支持远程仓库，学到了面试高频考点 promisify 函数原理和源码实现，巩固了一些 ES6+ 等基础知识。\n\n建议读者克隆我的仓库动手实践调试源码学习。\n\n后续也可以看看 es6-promisify 这个库的实现。\n\n最后可以持续关注我@若川。欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。","routePath":"/promisify/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 使用","id":"2-使用","depth":2,"charIndex":595},{"text":"3. 源码","id":"3-源码","depth":2,"charIndex":606},{"text":"3.1 package.json","id":"31-packagejson","depth":3,"charIndex":932},{"text":"3.2 调试源码","id":"32-调试源码","depth":3,"charIndex":1385},{"text":"3.3 主文件仅有22行源码","id":"33-主文件仅有22行源码","depth":3,"charIndex":1556},{"text":"3.4 git ls-remote --tags","id":"34-git-ls-remote---tags","depth":3,"charIndex":1593},{"text":"3.5 node:util","id":"35-nodeutil","depth":3,"charIndex":1762},{"text":"4. promisify","id":"4-promisify","depth":2,"charIndex":2108},{"text":"4.1 简单实现","id":"41-简单实现","depth":3,"charIndex":2288},{"text":"4.2 promise 初步优化","id":"42-promise-初步优化","depth":3,"charIndex":2407},{"text":"4.3 通用 promisify 函数","id":"43-通用-promisify-函数","depth":3,"charIndex":2482},{"text":"4.4 Node utils promisify 源码","id":"44-node-utils-promisify-源码","depth":3,"charIndex":2688},{"text":"5. ES6+ 等知识","id":"5-es6-等知识","depth":2,"charIndex":2802},{"text":"6. 总结","id":"6-总结","depth":2,"charIndex":2992}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":69,"title":"前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并","content":"#\n\n> 写于2018年08月29日\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n\n1、puppeteer 是什么？#\n\npuppeteer: Google 官方出品的 headless Chrome node 库 puppeteer github仓库 puppeteer API\n\n官方介绍：\n\n> 您可以在浏览器中手动执行的大多数操作都可以使用Puppeteer完成！\n> \n> 生成页面的屏幕截图和PDF。 抓取SPA并生成预渲染内容（即“SSR”）。 自动化表单提交，UI测试，键盘输入等。\n> 创建最新的自动化测试环境。使用最新的JavaScript和浏览器功能直接在最新版本的Chrome中运行测试。 捕获时间线跟踪 您的网站，以帮助诊断性能问题。\n> 测试Chrome扩展程序。\n\n\n2、爬取网站生成PDF#\n\n\n2.1 安装 puppeteer#\n\n\n\n\n2.2 《React.js小书》简介#\n\n> 《React.js小书》简介 关于作者@胡子大哈 这是⼀本关于 React.js 的⼩书。 因为⼯作中⼀直在使⽤\n> React.js，也⼀直以来想总结⼀下⾃⼰关于 React.js 的⼀些 知识、经验。于是把⼀些想法慢慢整理书写下来，做成⼀本开源、免费、专业、简单\n> 的⼊⻔级别的⼩书，提供给社区。希望能够帮助到更多 React.js 刚⼊⻔朋友。 下图是《React.js 小书》部分截图：\n\n\n2.3 一些可能会用到的 puppeteer API#\n\n\n\n知道这启动浏览器打开页面关闭浏览器主流程后，再来看几个API。\n\n\n\n\n\n\n2.4 知道了以上这些API后，就可以开始写主程序了。#\n\n简单说下：实现功能和主流程。从上面React.js小书截图来看。 1、打开浏览器，进入目录页，生成0. React 小书 目录.pdf 2、跳转到1.\nReact.js 简介页面，获取左侧所有的导航a链接的href，标题。 3、用获取到的a链接数组进行for循环，这个循环里主要做了如下几件事：\n\n> 3.1 隐藏左侧导航，便于生成pdf 3.2 给**React.js简介**等标题 加上序号，便于查看 3.3 设置docment.title 加上序号,\n> 便于在页眉中使用。 3.4 隐藏 传播一下知识也是一个很好的选择 这一个模块（因为页眉页脚中设置了书的链接等信息，就隐藏这个了） 3.5 给 分页\n> 上一节，下一节加上序号，便于查看。 3.6 最末尾声明下该pdf的说明，仅供学习交流，严禁用于商业用途。 3.7 返回宽高，用于设置视图大小 3.8\n> 设置视图大小，创建生成pdf\n\n4、关闭浏览器\n\n具体代码：可以查看这里爬虫生成《React.js小书》的pdf每一小节的代码\n\n\n\n即可生成如下图：每一小节（0-46小节）的pdf\n\n\n\n生成这些后，那么问题来了，就是查看时总不能看一小节，打开一小节来看，这样很不方便。 于是接下来就是合并这些pdf成为一个pdf文件。\n\n\n3、合并成一个PDF文件 pdf-merge#\n\n起初，我是使用在线网站Smallpdf，合并PDF。合并的效果还是很不错的。这网站还是其他功能。比如word转pdf等。 后来找到社区提供的一个npm\npackagepdf merge。 (毕竟笔者是写程序的，所以就用代码来实现合并了)\n\n这个pdf-merge依赖 pdftk\n\n安装 PDFtk Windows 下载并安装 笔者安装后，重启电脑才能使用。\n\nDebian, Ubuntu 安装 笔者在Ubuntu系统安装后，即可使用。 apt-get install pdftk\n\n使用例子\n\n\n\n知道这些后，可以开始写主程序了。 简单说下主流程 1、读取到生成的所有pdf文件路径，并排序（0-46） 2、判断下输出文件夹是否存在，不存在则创建\n3、合并这些小节的pdf保存到新文件 React小书（完整版）-作者：胡子大哈-时间戳.pdf\n\n具体代码：可以查看这里爬虫生成《React.js小书》的pdf合并pdf的代码\n\n最终合并的pdf文件在这里React小书（完整版）-作者：胡子大哈，可供下载。\n\n本想着还可以加下书签和页码，没找到合适的生成方案，那暂时先不加了。如果读者有好的方案，欢迎与笔者交流。\n\n\n小结#\n\n1、puppeteer是Google 官方出品的 headless Chrome\nnode库，可以在浏览器中手动执行的大多数操作都可以使用Puppeteer完成。总之可以用来做很多有趣的事情。 2、用 puppeteer\n生成每一小节的pdf，用依赖pdftk的pdf-merge npm包, 合并成一个新的pdf文件。或者使用Smallpdf等网站合并。\n3、《React.js小书》，推荐给大家。爬虫生成pdf，应该不会对作者@胡子大哈有什么影响。作者写书服务社区不易，尽可能多支持作者。\n\n最后推荐几个链接，方便大家学习 puppeteer。 puppeteer入门教程 Puppeteer 初探之前端自动化测试 爬虫生成ES6标准入门 pdf\n大前端神器安利之 Puppeteer puppeteer API中文文档\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客 掘金专栏，欢迎关注~\nsegmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/puppeteer-create-pdf-and-merge/","lang":"zh","toc":[{"text":"1、`puppeteer` 是什么？","id":"1puppeteer-是什么","depth":2,"charIndex":-1},{"text":"2、爬取网站生成`PDF`","id":"2爬取网站生成pdf","depth":2,"charIndex":-1},{"text":"2.1 安装 puppeteer","id":"21-安装-puppeteer","depth":3,"charIndex":484},{"text":"2.2 《`React.js`小书》简介","id":"22-reactjs小书简介","depth":3,"charIndex":-1},{"text":"2.3 一些可能会用到的 `puppeteer API`","id":"23-一些可能会用到的-puppeteer-api","depth":3,"charIndex":-1},{"text":"2.4 知道了以上这些`API`后，就可以开始写主程序了。","id":"24-知道了以上这些api后就可以开始写主程序了","depth":3,"charIndex":-1},{"text":"3、合并成一个PDF文件 `pdf-merge`","id":"3合并成一个pdf文件-pdf-merge","depth":2,"charIndex":-1},{"text":"小结","id":"小结","depth":2,"charIndex":1913},{"text":"关于","id":"关于","depth":2,"charIndex":2283},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":70,"title":"自从学了 react-use 源码，我写自定义 React Hooks 越来越顺了~","content":"#\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.7k+人）第一的专栏，写有20余篇源码文章。\n\n最近 React 出了 新文档 react.dev，新中文文档 zh-hans.react.dev。\n\n现在用 react 开发离不开各种 hooks。学习各种 hooks 的工具库，有助于我们更好的使用和理解 hooks 。前端社区中有活跃的\nahooks。不过，这次我们来学习目前 36.2k star 的 react-use 库。\n\nreact-use 文档 是用 storybook 搭建的。\n\n如果公司项目需要搭建组件库或者 hooks、工具库等，storybook 或许是不错的选择。\n\n> react-use 中文翻译仓库，最后更新是2年前，可能有点老。\n\n\n2. 环境准备#\n\n看一个开源仓库，第一步一般是看 README.md 和 contributing.md 贡献文档。第二步的克隆下来。按照贡献指南文档，把项目跑起来。\n\n贡献文档中有如下文档。\n\n\n2.1 创建一个新 hook 的步骤#\n\n 1. 创建 src/useYourHookName.ts 和 stories/useYourHookName.story.tsx，然后运行 yarn\n    start。\n 2. 创建 tests/useYourHookName.test.ts，运行 yarn test:watch 监听测试用例执行。\n 3. 创建 docs/useYourHookName.md 文档。\n 4. 在 src/index.ts 文件导出你写的 hook，然后添加你的 hook 到 REAMDE.md 中。\n\n我们可以得知具体要做什么，新增 hook 关联哪些文件。\n\n\n\n克隆项目到本地，安装依赖完成后，执行 yarn start。\n\n\n\n本地环境打开 useEffectOnce\ndocs：http://localhost:6008/?path=/story/lifecycle-useeffectonce--docs\n\n我们先挑选这个 useEffectOnce 简单的 hook 来分析。\n\n\n2.2 useEffectOnce#\n\n2.2.1 react-use/src/useEffectOnce.ts#\n\n\n\n我们来看测试用例，直接使用测试用例调试 useEffectOnce 源码。\n\n我之前写过相关文章。可以参考学习。 你可能不知道测试用例(Vitest)可以调试开源项目(Vue3) 源码\n\n我装了 jest 和 jest runner vscode 插件，装完后测试用例中会直接显示 run、和 debug 按钮。还在装了 vitest、vitest\nrunner vscode 插件，装完后测试用例中会直接显示 run(vitest)和 debug(vitest) 按钮。\n\n如下图所示。\n\n\n\n这个项目使用的是 jest。于是我点击最右侧的 debug。\n\n\n\n2.2.2 react-use/tests/useEffectOnce.test.ts#\n\n\n\n2.2.3 react-use/stories/useEffectOnce.story.tsx#\n\nxxx.story.tsx 渲染组件，可以直接操作。Demo 和 docs。\n\n\n\ndocs/useEffectOnce.md 省略，基本跟测试用例一样。可以说测试用例就是活文档。\n\n接下来我们来看其他的 hooks 源码，限于篇幅，主要就讲述源码，不包含测试用例、文档、story。\n\nTS 也不会过多描述。如果对TS不太熟悉，推荐学习这个《TypeScript 入门教程》。\n\n我们先来看 Sensors 行为部分。\n\n\n3. Sensors 行为#\n\n\n3.1 useIdle#\n\nuseIdle docs | useIdle demo\n\n> tracks whether user is being inactive. 跟踪用户是否处于非活动状态。\n\n主要是：监听用户行为的事件（默认的 'mousemove', 'mousedown', 'resize', 'keydown', 'touchstart',\n'wheel' ），指定时间内没有用户操作行为就是非活动状态。\n\n\n\n我们接着来看，useLocation hook。\n\n\n3.2 useLocation#\n\nuseLocation docs | useLocation demo\n\n> React sensor hook that tracks brower's location.\n\n主要获取 window.location 等对象信息。\n\nmdn History API\n\n阮一峰老师的网道：history 阮一峰老师的网道：location\n\n自定义事件 mdn 创建和触发 events\n\n\n\n接着我们继续来看 State 状态部分。\n\n\n4. State 状态#\n\n\n4.1 useFirstMountState#\n\nuseFirstMountState docs | useFirstMountState demo\n\n> Returns true if component is just mounted (on first render) and false\n> otherwise. 若组件刚刚加载（在第一次渲染时），则返回 true，否则返回 false。\n\n\n\n\n4.2 usePrevious#\n\nusePrevious docs | usePrevious demo\n\n> React state hook that returns the previous state as described in the React\n> hooks FAQ. 保留上一次的状态。\n\n利用 useRef 的不变性。\n\n\n\n\n4.3 useSet#\n\nuseSet docs | useSet demo\n\n> React state hook that tracks a Set.\n\nnew Set 的 hooks 用法。 useSet 可以用来列表展开、收起等其他场景。 返回 [set ,{add, remove, toggle,\nreset, has }]\n\n\n\n\n4.4 useToggle#\n\nuseToggle docs | useToggle demo\n\n> tracks state of a boolean. 跟踪布尔值的状态。 切换 false => true => false\n\n\n\n我们继续来看 Side-effects 副作用部分。\n\n\n5. Side-effects 副作用#\n\n\n5.1 useMountedState#\n\nuseMountedState 属于 lifecycle 模块，但这个 hook 在 useAsyncFn 中使用，所以放到这里讲述。\n\nuseMountedState docs | useMountedState demo\n\n> NOTE!: despite having State in its name this hook does not cause component\n> re-render. This component designed to be used to avoid state updates on\n> unmounted components.\n\n> 注意！：尽管名称中有State，但该钩子不会导致组件重新呈现。此组件设计用于避免对未安装的组件进行状态更新。\n\n> Lifecycle hook providing ability to check component's mount state. Returns a\n> function that will return true if component mounted and false otherwise.\n> 生命周期挂钩提供了检查组件装载状态的能力。 返回一个函数，如果组件已安装，则返回true，否则返回false。\n\n\n\n\n5.2 useAsyncFn#\n\n看了 useMountedState hook，我们继续看 useAsyncFn 函数源码。\n\n主要函数传入 Promise 函数 fn，然后执行函数 fn.then()。 返回 state、callback(fn.then)。\n\n\n\n\n5.3 useAsync#\n\nuseAsync docs | useAsync demo\n\n> React hook that resolves an async function or a function that returns a\n> promise; 解析异步函数或返回 promise 的函数的 React 钩子；\n\n\n\n\n5.4 useAsyncRetry#\n\nuseAsyncRetry docs | useAsyncRetry demo\n\n> Uses useAsync with an additional retry method to easily retry/refresh the\n> async function; 重试\n\n主要就是变更依赖，次数（attempt），变更时会执行 useAsync 的 fn 函数。\n\n\n\n\n5.5 useTimeoutFn#\n\nuseTimeoutFn 属于 Animations 模块，但这个 hook 在 useDebounce 中使用，所以放到这里讲述。\n\nuseTimeoutFn docs | useTimeoutFn demo\n\n> Calls given function after specified amount of milliseconds. 在指定的毫秒数后调用给定的函数。\n\n主要是 useRef 和 setTimeout 结合实现的。\n\n\n\n\n5.6 useDebounce#\n\nuseDebounce docs | useDebounce demo\n\n> React hook that delays invoking a function until after wait milliseconds have\n> elapsed since the last time the debounced function was invoked. 防抖\n\n\n\n\n5.7 useThrottle#\n\nuseThrottle docs | useThrottle demo\n\n> React hooks that throttle.\n\n节流\n\n\n\n我们继续来看 UI 用户界面部分。\n\n\n6. UI 用户界面#\n\n\n6.1 useFullscreen#\n\nuseFullscreen docs | useFullscreen demo\n\n> Display an element full-screen, optional fallback for fullscreen video on iOS.\n> 实现全屏\n\n主要使用 screenfull npm 包实现。\n\n\n\n我们继续来看 Lifecycles 生命周期部分。\n\n\n7. Lifecycles 生命周期#\n\n\n7.1 useLifecycles#\n\nuseLifecycles docs | useLifecycles demo\n\n> React lifecycle hook that call mount and unmount callbacks, when component is\n> mounted and un-mounted, respectively. React 生命周期挂钩，分别在组件安装和卸载时调用。\n\n\n\n\n7.2 useCustomCompareEffect#\n\nuseCustomCompareEffect docs | useCustomCompareEffect demo\n\n> A modified useEffect hook that accepts a comparator which is used for\n> comparison on dependencies instead of reference equality.\n> 一个经过修改的useEffect钩子，它接受一个比较器，该比较器用于对依赖项进行比较，而不是对引用相等进行比较。\n\n\n\n\n7.3 useDeepCompareEffect#\n\nuseDeepCompareEffect docs | useDeepCompareEffect demo\n\n> A modified useEffect hook that is using deep comparison on its dependencies\n> instead of reference equality. 一个修改后的 useEffect 钩子，它对其依赖项使用深度比较，而不是引用相等。\n\n\n\n最后，我们来看 Animations 生命周期部分。\n\n\n8. Animations 动画#\n\n\n8.1 useUpdate#\n\nuseUpdate docs | useUpdate demo\n\n> React utility hook that returns a function that forces component to re-render\n> when called. React 实用程序钩子返回一个函数，该函数在调用时强制组件重新渲染。\n\n主要用了 useReducer 每次调用 updateReducer 方法，来达到强制组件重新渲染的目的。\n\n\n\n\n9. 总结#\n\n行文至此，我们简单分析了若干 react-use 的自定义 React Hooks。想进一步学习的小伙伴，可以继续学完剩余的 hooks。还可以学习\nahooks、别人写的 ahooks 源码分析、 beautiful-react-hooks、mantine-hooks等。\n\n学习过程中带着问题多查阅 React 新文档 react.dev，新中文文档 zh-hans.react.dev，相信收获更大。\n\n如果技术栈是 Vue，感兴趣的小伙伴可以学习 VueUse。\n\n如果能看完一些 React Hooks 工具集合库的源码。相信一定能对 React Hooks 有更深的理解，自己写自定义 React Hooks\n时也会更加顺利、快速。\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n最后可以持续关注我@若川。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.7k+人）第一的专栏，写有20余篇源码文章。\n\n我倾力持续组织了一年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。","routePath":"/react-use/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 环境准备","id":"2-环境准备","depth":2,"charIndex":437},{"text":"2.1 创建一个新 hook 的步骤","id":"21-创建一个新-hook-的步骤","depth":3,"charIndex":537},{"text":"2.2 useEffectOnce","id":"22-useeffectonce","depth":3,"charIndex":1002},{"text":"2.2.1 react-use/src/useEffectOnce.ts","id":"221-react-usesrcuseeffectoncets","depth":4,"charIndex":1022},{"text":"2.2.2 react-use/tests/useEffectOnce.test.ts","id":"222-react-usetestsuseeffectoncetestts","depth":4,"charIndex":1345},{"text":"2.2.3 react-use/stories/useEffectOnce.story.tsx","id":"223-react-usestoriesuseeffectoncestorytsx","depth":4,"charIndex":1393},{"text":"3. Sensors 行为","id":"3-sensors-行为","depth":2,"charIndex":1656},{"text":"3.1 useIdle","id":"31-useidle","depth":3,"charIndex":1673},{"text":"3.2 useLocation","id":"32-uselocation","depth":3,"charIndex":1914},{"text":"4. State 状态","id":"4-state-状态","depth":2,"charIndex":2152},{"text":"4.1 useFirstMountState","id":"41-usefirstmountstate","depth":3,"charIndex":2167},{"text":"4.2 usePrevious","id":"42-useprevious","depth":3,"charIndex":2370},{"text":"4.3 useSet","id":"43-useset","depth":3,"charIndex":2546},{"text":"4.4 useToggle","id":"44-usetoggle","depth":3,"charIndex":2719},{"text":"5. Side-effects 副作用","id":"5-side-effects-副作用","depth":2,"charIndex":2865},{"text":"5.1 useMountedState","id":"51-usemountedstate","depth":3,"charIndex":2888},{"text":"5.2 useAsyncFn","id":"52-useasyncfn","depth":3,"charIndex":3474},{"text":"5.3 useAsync","id":"53-useasync","depth":3,"charIndex":3610},{"text":"5.4 useAsyncRetry","id":"54-useasyncretry","depth":3,"charIndex":3778},{"text":"5.5 useTimeoutFn","id":"55-usetimeoutfn","depth":3,"charIndex":3987},{"text":"5.6 useDebounce","id":"56-usedebounce","depth":3,"charIndex":4229},{"text":"5.7 useThrottle","id":"57-usethrottle","depth":3,"charIndex":4437},{"text":"6. UI 用户界面","id":"6-ui-用户界面","depth":2,"charIndex":4548},{"text":"6.1 useFullscreen","id":"61-usefullscreen","depth":3,"charIndex":4562},{"text":"7. Lifecycles 生命周期","id":"7-lifecycles-生命周期","depth":2,"charIndex":4768},{"text":"7.1 useLifecycles","id":"71-uselifecycles","depth":3,"charIndex":4790},{"text":"7.2 useCustomCompareEffect","id":"72-usecustomcompareeffect","depth":3,"charIndex":5003},{"text":"7.3 useDeepCompareEffect","id":"73-usedeepcompareeffect","depth":3,"charIndex":5286},{"text":"8. Animations 动画","id":"8-animations-动画","depth":2,"charIndex":5553},{"text":"8.1 useUpdate","id":"81-useupdate","depth":3,"charIndex":5573},{"text":"9. 总结","id":"9-总结","depth":2,"charIndex":5812}],"domain":"","frontmatter":{},"version":""},{"id":71,"title":"从 vue-cli 源码中，我发现27行读取 json 文件有趣的 npm 包","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。为了能帮助到更多对源码感兴趣、想学会看源码、提升自己前端技术能力的同学。我倾力组织了源码共读活动，感兴趣的可以加我微信\n> ruochuan12 参与，或者关注我的公众号若川视野，回复“源码”参与。已进行4个月，每周大家一起学习200行左右的源码，共同进步，很多人都表示收获颇丰。\n\n想学源码，极力推荐关注我写的专栏（目前1.8K人关注）《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等20余篇源码文章。\n\n本文仓库 https://github.com/ruochuan12/read-pkg-analysis.git，求个star^_^\n\n源码共读活动 每周一期，已进行到15期。源码群里有小伙伴提问，如何用 import 加载 json 文件。同时我之前看到了vue-cli 源码 里有\nread-pkg 这个包。源码仅27行，非常值得我们学习。\n\n阅读本文，你将学到：\n\n\n\n\n2. 场景#\n\n优雅的获取 package.json 文件。\n\nread-pkg\n\nvue-cli 源码\n\n\n\n封装这个函数的commit 记录\n\n你也许会想直接 require('package.json'); 不就可以了。但在ES模块下，目前无法直接引入JSON文件。\n\n在 stackoverflow 也有相关提问\n\n我们接着来看 阮一峰老师的 JSON 模块\n\n> import 命令目前只能用于加载 ES 模块，现在有一个提案，允许加载 JSON 模块。 import 命令能够直接加载 JSON\n> 模块以后，就可以像下面这样写。\n\n\n\n> import 命令导入 JSON 模块时，命令结尾的 assert {type: \"json\"} 不可缺 少。这叫做导入断言，用来告诉 JavaScript\n> 引擎，现在加载的是 JSON 模块。\n\n接下来我们学习 read-pkg 源码。\n\n\n3. 环境准备#\n\n\n3.1 克隆#\n\n\n\n看源码一般先看 package.json，再看 script。\n\n\n3.2 package.json#\n\n\n\ntest命令有三个包，我们一一查阅了解。\n\nxo\n\n> JavaScript/TypeScript linter (ESLint wrapper) with great defaults\n> JavaScript/TypeScript linter（ESLint 包装器）具有很好的默认值\n\ntsd\n\n> Check TypeScript type definitions 检查 TypeScript 类型定义\n\nnodejs 测试工具 ava\n\n> Node.js test runner that lets you develop with confidence\n\n\n3.3 调试#\n\n提前在入口测试文件 test/test.js 和入口文件 index.js 打好断点。\n\n用最新的VSCode 打开项目，找到 package.json 的 scripts 属性中的 test 命令。鼠标停留在test命令上，会出现 运行命令 和\n调试命令 的选项，选择 调试命令 即可。\n\n调试如图所示：\n\n\n\n更多调试细节可以看我的这篇文章：新手向：前端程序员必学基本技能——调试JS代码\n\n我们跟着调试来看测试用例。\n\n\n4. 测试用例#\n\n这个测试用例文件，主要就是主入口 index.js 导出的两个方法 readPackage, readPackageSync。异步和同步的方法。\n\n判断读取的 package.json 的 name 属性与测试用例的 name 属性是否相等。\n\n判断读取 package.json 的 _id 是否是真值。\n\n同时支持指定目录。{ cwd }\n\n\n\n这个测试用例文件，涉及到一些值得一提的知识点。接下来就简单讲述下。\n\n\n4.1 url 模块#\n\nurl 模块提供用于网址处理和解析的实用工具。\n\nurl 中文文档\n\nurl.fileURLToPath(url)\n\nurl | 要转换为路径的文件网址字符串或网址对象。 返回: 完全解析的特定于平台的 Node.js 文件路径。\n此函数可确保正确解码百分比编码字符，并确保跨平台有效的绝对路径字符串。\n\n\n4.2 import.meta.url#\n\nimport.meta.url\n\n> （1）import.meta.url import.meta.url返回当前模块的 URL\n> 路径。举例来说，当前模块主文件的路径是https://foo.com/main.js，import.meta.url就返回这个路径。如果模块里面还有一个数据\n> 文件 data.txt，那么就可以用下面的代码，获取这个数据文件的路径。 new URL('data.txt', import.meta.url)\n> 注意，Node.js 环境中，import.meta.url 返回的总是本地路径，即是file:URL协议的字符串，比如\n> file:///home/user/foo.js。\n\n\n4.3 process.chdir#\n\nprocess.chdir() 方法更改 Node.js 进程的当前工作目录，如果失败则抛出异常（例如，如果指定的 directory 不存在）。\n\n\n5. 27行主入口源码#\n\n导出异步和同步的两个方法，支持传递参数对象，cwd 默认是 process.cwd()，normalize 默认标准化。\n\n分别是用 fsPromises.readFile fs.readFileSync 读取 package.json 文件。\n\n用 parse-json 解析 json 文件。\n\n用 npm 官方库 normalize-package-data 规范化 package 元数据。\n\n\n\n\n5.1 process 进程模块#\n\n很常用的模块。\n\nprocess 中文文档\n\nprocess 对象提供有关当前 Node.js 进程的信息并对其进行控制。 虽然它作为全局可用，但是建议通过 require 或 import 显式地访问它：\n\n\n\nNode 文档\n\n也就是说引用 node 原生库可以加 node: 前缀，比如 ``\n\n\n5.2 path 路径模块#\n\n很常用的模块。\n\npath 中文文档\n\npath 模块提供了用于处理文件和目录的路径的实用工具。\n\n\n5.3 fs 文件模块#\n\n很常用的模块。\n\nfs 中文文档\n\n\n5.4 parseJson 解析 JSON#\n\nparse-json\n\n文档介绍：\n\n> Parse JSON with more helpful errors\n\n更多有用的错误提示。\n\n\n\n\n5.5 normalizePackageData 规范化包元数据#\n\nnpm 官方库 normalize-package-data\n\n> normalizes package metadata, typically found in package.json file.\n\n规范化包元数据\n\n\n\n这也就是为啥测试用例中用了t.truthy(package_._id); 来检测 _id 属性是否为真值。\n\n\n6. 总结#\n\n最后总结下我们学到了如下知识：\n\n\n\nread-pkg 源码 整体而言相对比较简单，但是也有很多可以学习深挖的学习的知识点。\n\n作为一个 npm 包，拥有完善的测试用例。\n\n学 Node.js 可以多找找简单的 npm 包学习。比直接看官方文档有趣多了。不懂的就去查官方文档。查的多了，自然常用的就熟练了。\n\n建议读者克隆 我的仓库 动手实践调试源码学习。\n\n最后可以持续关注我@若川。欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，每周大家一起学习200行左右的源码，共同进步。","routePath":"/read-pkg/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 场景","id":"2-场景","depth":2,"charIndex":529},{"text":"3. 环境准备","id":"3-环境准备","depth":2,"charIndex":930},{"text":"3.1 克隆","id":"31-克隆","depth":3,"charIndex":941},{"text":"3.2 package.json","id":"32-packagejson","depth":3,"charIndex":986},{"text":"3.3 调试","id":"33-调试","depth":3,"charIndex":1293},{"text":"4. 测试用例","id":"4-测试用例","depth":2,"charIndex":1516},{"text":"4.1 url 模块","id":"41-url-模块","depth":3,"charIndex":1737},{"text":"4.2 import.meta.url","id":"42-importmetaurl","depth":3,"charIndex":1904},{"text":"4.3 process.chdir","id":"43-processchdir","depth":3,"charIndex":2241},{"text":"5. 27行主入口源码","id":"5-27行主入口源码","depth":2,"charIndex":2337},{"text":"5.1 process 进程模块","id":"51-process-进程模块","depth":3,"charIndex":2555},{"text":"5.2 path 路径模块","id":"52-path-路径模块","depth":3,"charIndex":2726},{"text":"5.3 fs 文件模块","id":"53-fs-文件模块","depth":3,"charIndex":2793},{"text":"5.4 parseJson 解析 JSON","id":"54-parsejson-解析-json","depth":3,"charIndex":2826},{"text":"5.5 normalizePackageData 规范化包元数据","id":"55-normalizepackagedata-规范化包元数据","depth":3,"charIndex":2923},{"text":"6. 总结","id":"6-总结","depth":2,"charIndex":3127}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":72,"title":"","content":"","routePath":"/redux/examples/compose/compose.0.calc","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":73,"title":"","content":"","routePath":"/redux/examples/compose/compose.1.add.etc","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":74,"title":"","content":"","routePath":"/redux/examples/compose/compose.2.add.etc","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":75,"title":"","content":"","routePath":"/redux/examples/compose/compose.2","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":76,"title":"","content":"","routePath":"/redux/examples/compose/compose.3.reduce","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":77,"title":"","content":"","routePath":"/redux/examples/compose/compose.4.reduce","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":78,"title":"","content":"","routePath":"/redux/examples/compose/compose.5.reduce","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":79,"title":"","content":"","routePath":"/redux/examples/dist/redux","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":80,"title":"","content":"","routePath":"/redux/examples/dist/redux.min","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":81,"title":"","content":"","routePath":"/redux/examples/js/index.3.applyMiddleware.compose.simple","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":82,"title":"","content":"","routePath":"/redux/examples/js/index.3.dom.listener","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":83,"title":"","content":"","routePath":"/redux/examples/js/index.4.bindActionCreators.combineReducers.example","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":84,"title":"","content":"","routePath":"/redux/examples/js/middlewares.logger.example","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":85,"title":"","content":"","routePath":"/redux/examples/js/react-thunk","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":86,"title":"","content":"","routePath":"/redux/examples/js/request","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":87,"title":"学习 redux 源码整体架构，深入理解 redux 及其中间件原理","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 你好，我是若川。这是学习源码整体架构系列第八篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数\n> 的实现。本篇文章学习的是实际仓库的代码。\n\n> 要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了。\n\n学习源码整体架构系列文章如下：\n\n> 1.学习 jQuery 源码整体架构，打造属于自己的 js 类库 2.学习 underscore 源码整体架构，打造属于自己的函数式编程类库 3.学习\n> lodash 源码整体架构，打造属于自己的函数式编程类库 4.学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK 5.学习 vuex\n> 源码整体架构，打造属于自己的状态管理库 6.学习 axios 源码整体架构，打造属于自己的请求库 7.学习 koa\n> 源码的整体架构，浅析koa洋葱模型原理和co原理 8.学习 redux 源码整体架构，深入理解 redux 及其中间件原理\n\n感兴趣的读者可以点击阅读。 其他源码计划中的有：express、vue-rotuer、react-redux\n等源码，不知何时能写完（哭泣），欢迎持续关注我（若川）。\n\n源码类文章，一般阅读量不高。已经有能力看懂的，自己就看了。不想看，不敢看的就不会去看源码。 所以我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。\n\n阅读本文你将学到：\n\n>  1. git subtree 管理子仓库\n>  2. 如何学习 redux 源码\n>  3. redux 中间件原理\n>  4. redux 各个API的实现\n>  5. vuex 和 redux 的对比\n>  6. 等等\n\n\n1.1 本文阅读最佳方式#\n\n把我的redux源码仓库 git clone\nhttps://github.com/ruochuan12/redux-analysis.git克隆下来，顺便star一下我的redux源码学习仓库^_^。跟着\n文章节奏调试和示例代码调试，用chrome动手调试印象更加深刻。文章长段代码不用细看，可以调试时再细看。看这类源码文章百遍，可能不如自己多调试几遍。也欢迎加我微\n信交流ruochuan12。\n\n\n2. git subtree 管理子仓库#\n\n写了很多源码文章，vuex、axios、koa等都是使用新的仓库克隆一份源码在自己仓库中。\n虽然电脑可以拉取最新代码，看到原作者的git信息。但上传到github后。读者却看不到原仓库作者的git信息了。于是我找到了git submodules\n方案，但并不是很适合。再后来发现了git subtree。\n\n简单说下 npm package和git subtree的区别。 npm package是单向的。git subtree则是双向的。\n\n具体可以查看这篇文章@德来（原有赞大佬）：用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册\n\n学会了git\nsubtree后，我新建了redux-analysis项目后，把redux源码4.x（截止至2020年06月13日，4.x分支最新版本是4.0.5，master\n分支是ts，文章中暂不想让一些不熟悉ts的读者看不懂）分支克隆到了我的项目里的一个子项目，得以保留git信息。\n\n对应命令则是：\n\n\n\n\n3. 调试 redux 源码准备工作#\n\n之前，我在知乎回答了一个问题若川：一年内的前端看不懂前端框架源码怎么办？ 推荐了一些资料，阅读量还不错，大家有兴趣可以看看。主要有四点：\n\n> 1.借助调试 2.搜索查阅相关高赞文章 3.把不懂的地方记录下来，查阅相关文档 4.总结\n\n看源码调试很重要，所以我的每篇源码文章都详细描述（也许有人看来是比较啰嗦...）如何调试源码。\n\n> 断点调试要领： 赋值语句可以一步按F10跳过，看返回值即可，后续详细再看。 函数执行需要断点按F11跟着看，也可以结合注释和上下文倒推这个函数做了什么。\n> 有些不需要细看的，直接按F8走向下一个断点 刷新重新调试按F5\n\n调试源码前，先简单看看 redux 的工作流程，有个大概印象。\n\n\n\n\n3.1 rollup 生成 sourcemap 便于调试#\n\n修改rollup.config.js文件，output输出的配置生成sourcemap。\n\n\n\n安装依赖\n\n\n\n仔细看看redux/examples目录和redux/README。\n\n这时我在根路径下，新建文件夹examples，把原生js写的计数器redux/examples/counter-vanilla/index.html，复制到ex\namples/index.html。同时把打包后的包含sourcemap的redux/dist目录，复制到examples/dist目录。\n\n修改index.html的script的redux.js文件为dist中的路径。\n\n> 为了便于区分和调试后续html文件，我把index.html重命名为index.1.redux.getState.dispatch.html。\n\n\n\n就可以开心的调试啦。可以直接克隆我的项目git clone\nhttp://github.com/ruochuan12/redux-analysis.git。本地调试，动手实践，容易消化吸收。\n\n\n4. 通过调试计数器例子的学习 redux 源码#\n\n接着我们来看examples/index.1.redux.getState.dispatch.html文件。先看html部分。只是写了几个\nbutton，比较简单。\n\n\n\njs部分，也比较简单。声明了一个counter函数，传递给Redux.createStore(counter)，得到结果store，而store是个对象。ren\nder方法渲染数字到页面。用store.subscribe(render)订阅的render方法。还有store.dispatch({type:\n'INCREMENT' })方法，调用store.dispatch时会触发render方法。这样就实现了一个计数器。\n\n\n\n思考：看了这段代码，你会在哪打断点来调试呢。\n\n\n\n\n\n图中的右边Scope，有时需要关注下，会显示闭包、全局环境、当前环境等变量，还可以显示函数等具体代码位置，能帮助自己理解代码。\n\n断点调试，按F5刷新页面后，按F8，把鼠标放在Redux和store上。\n\n可以看到Redux上有好几个方法。分别是：\n\n * __DO_NOT_USE__ActionTypes: {INIT: \"@@redux/INITu.v.d.u.6.r\", REPLACE:\n   \"@@redux/REPLACEg.u.u.7.c\", PROBE_UNKNOWN_ACTION: ƒ}\n * applyMiddleware: ƒ applyMiddleware()\n   函数是一个增强器，组合多个中间件，最终增强store.dispatch函数，dispatch时，可以串联执行所有中间件。\n * bindActionCreators: ƒ bindActionCreators(actionCreators, dispatch)\n   生成actions，主要用于其他库，比如react-redux。\n * combineReducers: ƒ combineReducers(reducers) 组合多个reducers，返回一个总的reducer函数。\n * compose: ƒ compose() 组合多个函数，从右到左，比如：compose(f, g, h) 最终得到这个结果 (...args) =>\n   f(g(h(...args))).\n * createStore: ƒ createStore(reducer, preloadedState, enhancer) 生成 store 对象\n\n再看store也有几个方法。分别是：\n\n * dispatch: ƒ dispatch(action) 派发动作，也就是把subscribe收集的函数，依次遍历执行\n * subscribe: ƒ subscribe(listener)\n   订阅收集函数存在数组中，等待触发dispatch依次执行。返回一个取消订阅的函数，可以取消订阅监听。\n * getState: ƒ getState() 获取存在createStore函数内部闭包的对象。\n * replaceReducer: ƒ replaceReducer(nextReducer)\n   主要用于redux开发者工具，对比当前和上一次操作的异同。有点类似时间穿梭功能。\n * Symbol(observable): ƒ observable()\n\n也就是官方文档redux.org.js上的 API。\n\n暂时不去深究每一个API的实现。重新按F5刷新页面，断点到var store =\nRedux.createStore(counter)。一直按F11，先走一遍主流程。\n\n\n4.1 Redux.createSotre#\n\ncreateStore\n函数结构是这样的，是不是看起来很简单，最终返回对象store，包含dispatch、subscribe、getState、replaceReducer等方法。\n\n\n\n\n4.2 store.dispatch(action)#\n\n\n\n\n\n上文调试完了这句。\n\n继续按F11调试。\n\n\n\n\n4.3 store.getState()#\n\ngetState函数实现比较简单。\n\n\n\n\n4.4 store.subscribe(listener)#\n\n订阅监听函数，存放在数组中，store.dispatch(action)时遍历执行。\n\n\n\n到这里，我们就调试学习完了Redux.createSotre、store.dispatch、store.getState、store.subscribe的源码。\n\n接下来，我们写个中间件例子，来调试中间件相关源码。\n\n\n5. Redux 中间件相关源码#\n\n中间件是重点，面试官也经常问这类问题。\n\n\n5.1 Redux.applyMiddleware(...middlewares)#\n\n5.1.1 准备 logger 例子调试#\n\n为了调试Redux.applyMiddleware(...middlewares)，我在examples/js/middlewares.logger.examp\nle.js写一个简单的logger例子。分别有三个logger1，logger2，logger3函数。由于都是类似，所以我在这里只展示logger1函数。\n\n\n\nlogger中间件函数做的事情也比较简单，返回两层函数，next就是下一个中间件函数，调用返回结果。为了让读者能看懂，我把logger1用箭头函数、logger\n2则用普通函数。\n\n写好例子后，我们接着来看怎么调试Redux.applyMiddleware(...middlewares))源码。\n\n\n\n打开http://localhost:5000/examples/index.2.redux.applyMiddleware.compose.html，按F12\n打开控制台，\n\n先点击加号操作+1，把结果展示出来。 从图中可以看出，next则是下一个函数。先1-2-3，再3-2-1这样的顺序。\n\n这种也就是我们常说的中间件，面向切面编程（AOP）。\n\n接下来调试，在以下语句打上断点和一些你觉得重要的地方打上断点。\n\n\n\n5.1.2 Redux.applyMiddleware(...middlewares) 源码#\n\n\n\n\n\n把接收的中间件函数logger1, logger2, logger3放入到\n了middlewares数组中。Redux.applyMiddleware最后返回两层函数。 把中间件函数都混入了参数getState和dispatch。\n\n\n\n最后这句其实是返回一个增强了dispatch的store对象。\n\n而增强的dispatch函数，则是用Redux.compose(...functions)进行串联起来执行的。\n\n\n5.2 Redux.compose(...functions)#\n\n\n\n\n\n这两句可能不是那么好理解，可以断点多调试几次。我把箭头函数转换成普通函数。\n\n\n\n其实redux源码中注释很清晰了，这个compose函数上方有一堆注释，其中有一句：组合多个函数，从右到左，比如：compose(f, g, h)\n最终得到这个结果 (...args) => f(g(h(...args))).\n\n5.2.1 compose 函数演化#\n\n看Redux.compose(...functions)函数源码后，还是不明白，不要急不要慌，吃完鸡蛋还有汤。仔细来看如何演化而来，先来简单看下如下需求。\n\n传入一个数值，计算数值乘以10再加上10，再减去2。\n\n实现起来很简单。\n\n\n\n但这样写有个问题，不好扩展，比如我想乘以10时就打印出结果。 为了便于扩展，我们分开写成三个函数。\n\n\n\n再来实现一个相对通用的函数，计算这三个函数的结果。\n\n\n\n这样还是有问题，只支持三个函数。我想支持多个函数。 我们了解到数组的reduce方法就能实现这样的功能。 前一个函数\n\n\n\npre 是上一次返回值，在这里是数值1,3,6,10。在下一个例子中则是匿名函数。\n\n\n\nitem是2,3,4,5，在下一个例子中是minus、add、multiply。\n\n\n\n而Redux.compose(...functions)其实就是这样，只不过中间件是返回双层函数罢了。\n\n所以返回的是next函数，他们串起来执行了，形成了中间件的洋葱模型。 人们都说一图胜千言。我画了一个相对简单的redux中间件原理图。\n\n\n\n如果还不是很明白，建议按照我给出的例子，多调试。\n\n\n\n打开http://localhost:5000/examples/index.3.html，按F12打开控制台调试。\n\n5.2.2 前端框架的 compose 函数的实现#\n\nlodash源码中 compose函数的实现，也是类似于数组的reduce，只不过是内部实现的arrayReduce\n\n引用自我的文章：学习lodash源码整体架构\n\n\n\nkoa-compose源码也有compose函数的实现。实现是循环加promise。 由于代码比较长我就省略了，具体看链接若川：学习 koa\n源码的整体架构，浅析koa洋葱模型原理和co原理小节 koa-compose 源码（洋葱模型实现）\n\n\n6. Redux.combineReducers(reducers)#\n\n打开http://localhost:5000/examples/index.4.html，按F12打开控制台，按照给出的例子，调试接下来的Redux.comb\nineReducers(reducers)和Redux.bindActionCreators(actionCreators,\ndispatch)具体实现。由于文章已经很长了，这两个函数就不那么详细解释了。\n\ncombineReducers函数简单来说就是合并多个reducer为一个函数combination。\n\n\n\n\n7. Redux.bindActionCreators(actionCreators, dispatch)#\n\n如果第一个参数是一个函数，那就直接返回一个函数。如果是一个对象，则遍历赋值，最终生成boundActionCreators对象。\n\n\n\nredux所提供的的API 除了store.replaceReducer(nextReducer)没分析，其他都分析了。\n\n\n8. vuex 和 redux 简单对比#\n\n\n8.1 源码实现形式#\n\n从源码实现上来看，vuex源码主要使用了构造函数，而redux则是多用函数式编程、闭包。\n\n\n8.2 耦合度#\n\nvuex 与 vue\n强耦合，脱离了vue则无法使用。而redux跟react没有关系，所以它可以使用于小程序或者jQuery等。如果需要和react使用，还需要结合react-re\ndux库。\n\n\n8.3 扩展#\n\n\n\nvuex实现扩展则是使用插件形式，而redux是中间件的形式。redux的中间件则是AOP（面向切面编程），redux中Redux.applyMiddlewar\ne()其实也是一个增强函数，所以也可以用户来实现增强器，所以redux生态比较繁荣。\n\n\n8.4 上手难易度#\n\n相对来说，vuex上手相对简单，redux相对难一些，redux涉及到一些函数式编程、高阶函数、纯函数等概念。\n\n\n9. 总结#\n\n文章主要通过一步步调试的方式循序渐进地讲述redux源码的具体实现。旨在教会读者调试源码，不惧怕源码。\n\n面试官经常喜欢考写一个redux中间件，说说redux中间件的原理。\n\n\n\n\n\n\n\n用户触发enhancerStore.dispatch(action)是增强后的，其实就是第一个中间件函数，中间的next是下一个中间件函数，最后next是没有增\n强的store.dispatch(action)。\n\n最后再来看张redux工作流程图 是不是就更理解些了呢。\n\n如果读者发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出。另外觉得写得不错，对你有些许帮助，可以点赞、评论、转发分享，也是对我的一种支持，非常感谢\n呀。要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了。\n\n\n推荐阅读#\n\n@胡子大哈：动手实现 Redux（一）：优雅地修改共享状态，总共6小节，非常推荐，虽然我很早前就看完了《react小书》，现在再看一遍又有收获 美团@莹莹\nRedux从设计到源码，美团这篇是我基本写完文章后看到的，感觉写得很好，非常推荐 redux 中文文档 redux 英文文档 若川的学习redux源码仓库\n\n\n另一个系列#\n\n面试官问：JS的继承 面试官问：JS的this指向 面试官问：能否模拟实现JS的call和apply方法 面试官问：能否模拟实现JS的bind方法\n面试官问：能否模拟实现JS的new操作符\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 若川的博客，使用vuepress重构了，阅读体验可能更好些\n掘金专栏，欢迎关注~ segmentfault前端视野专栏，欢迎关注~ 知乎前端视野专栏，欢迎关注~ 语雀前端视野专栏，新增语雀专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n欢迎加微信交流 微信公众号#\n\n可能比较有趣的微信公众号，长按扫码关注（回复pdf获取前端优质书籍pdf）。欢迎加我微信ruochuan12（注明来源，基本来者不拒），拉你进【前端视野交流群】\n，长期交流学习~\n\n","routePath":"/redux/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"1.1 本文阅读最佳方式","id":"11-本文阅读最佳方式","depth":3,"charIndex":888},{"text":"2. git subtree 管理子仓库","id":"2-git-subtree-管理子仓库","depth":2,"charIndex":1105},{"text":"3. 调试 redux 源码准备工作","id":"3-调试-redux-源码准备工作","depth":2,"charIndex":1570},{"text":"3.1 rollup 生成 sourcemap 便于调试","id":"31-rollup-生成-sourcemap-便于调试","depth":3,"charIndex":1908},{"text":"4. 通过调试计数器例子的学习 redux 源码","id":"4-通过调试计数器例子的学习-redux-源码","depth":2,"charIndex":2400},{"text":"4.1 Redux.createSotre","id":"41-reduxcreatesotre","depth":3,"charIndex":3948},{"text":"4.2 store.dispatch(action)","id":"42-storedispatchaction","depth":3,"charIndex":4068},{"text":"4.3 store.getState()","id":"43-storegetstate","depth":3,"charIndex":4126},{"text":"4.4 store.subscribe(listener)","id":"44-storesubscribelistener","depth":3,"charIndex":4171},{"text":"5. Redux 中间件相关源码","id":"5-redux-中间件相关源码","depth":2,"charIndex":4359},{"text":"5.1 Redux.applyMiddleware(...middlewares)","id":"51-reduxapplymiddlewaremiddlewares","depth":3,"charIndex":4400},{"text":"5.1.1 准备 logger 例子调试","id":"511-准备-logger-例子调试","depth":4,"charIndex":4444},{"text":"5.1.2 Redux.applyMiddleware(...middlewares) 源码","id":"512-reduxapplymiddlewaremiddlewares-源码","depth":4,"charIndex":4993},{"text":"5.2 Redux.compose(...functions)","id":"52-reduxcomposefunctions","depth":3,"charIndex":5256},{"text":"5.2.1 compose 函数演化","id":"521-compose-函数演化","depth":4,"charIndex":5450},{"text":"5.2.2 前端框架的 compose 函数的实现","id":"522-前端框架的-compose-函数的实现","depth":4,"charIndex":6035},{"text":"6. Redux.combineReducers(reducers)","id":"6-reduxcombinereducersreducers","depth":2,"charIndex":6272},{"text":"7. Redux.bindActionCreators(actionCreators, dispatch)","id":"7-reduxbindactioncreatorsactioncreators-dispatch","depth":2,"charIndex":6550},{"text":"8. vuex 和 redux 简单对比","id":"8-vuex-和-redux-简单对比","depth":2,"charIndex":6737},{"text":"8.1 源码实现形式","id":"81-源码实现形式","depth":3,"charIndex":6761},{"text":"8.2 耦合度","id":"82-耦合度","depth":3,"charIndex":6821},{"text":"8.3 扩展","id":"83-扩展","depth":3,"charIndex":6931},{"text":"8.4 上手难易度","id":"84-上手难易度","depth":3,"charIndex":7068},{"text":"9. 总结","id":"9-总结","depth":2,"charIndex":7138},{"text":"推荐阅读","id":"推荐阅读","depth":2,"charIndex":7503},{"text":"另一个系列","id":"另一个系列","depth":2,"charIndex":7668},{"text":"关于","id":"关于","depth":2,"charIndex":7773},{"text":"欢迎加微信交流 微信公众号","id":"欢迎加微信交流-微信公众号","depth":2,"charIndex":7960}],"domain":"","frontmatter":{},"version":""},{"id":88,"title":"","content":"","routePath":"/sentry/README-juejin","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":89,"title":"学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 这是学习源码整体架构系列第四篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。文章学习\n> 的是打包整合后的代码，不是实际仓库中的拆分的代码。\n\n> 本文仓库地址：git clone https://github.com/ruochuan12/sentry-analysis.git\n\n> 要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了。\n\n学习源码整体架构系列文章如下：\n\n> 1.学习 jQuery 源码整体架构，打造属于自己的 js 类库 2.学习 underscore 源码整体架构，打造属于自己的函数式编程类库 3.学习\n> lodash 源码整体架构，打造属于自己的函数式编程类库 4.学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK 5.学习 vuex\n> 源码整体架构，打造属于自己的状态管理库 6.学习 axios 源码整体架构，打造属于自己的请求库 7.学习 koa\n> 源码的整体架构，浅析koa洋葱模型原理和co原理 8.学习 redux 源码整体架构，深入理解 redux 及其中间件原理\n\n感兴趣的读者可以点击阅读。 其他源码计划中的有：express、vue-rotuer、react-redux\n等源码，不知何时能写完（哭泣），欢迎持续关注我（若川）。\n\n源码类文章，一般阅读量不高。已经有能力看懂的，自己就看了。不想看，不敢看的就不会去看源码。 所以我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。\n\n导读\n本文通过梳理前端错误监控知识、介绍sentry错误监控原理、sentry初始化、Ajax上报、window.onerror、window.onunhandled\nrejection几个方面来学习sentry的源码。\n\n开发微信小程序，想着搭建小程序错误监控方案。最近用了丁香园 开源的Sentry 小程序 SDKsentry-miniapp。\n顺便研究下sentry-javascript仓库 的源码整体架构，于是有了这篇文章。\n\n本文分析的是打包后未压缩的源码，源码总行数五千余行，链接地址是：https://browser.sentry-cdn.com/5.7.1/bundle.js，\n版本是v5.7.1。\n\n本文示例等源代码在这我的github博客中github blog sentry，需要的读者可以点击查看，如果觉得不错，可以顺便star一下。\n\n看源码前先来梳理下前端错误监控的知识。\n\n\n2. 前端错误监控知识#\n\n摘抄自 慕课网视频教程：前端跳槽面试必备技巧 别人做的笔记：前端跳槽面试必备技巧-4-4 错误监控类\n\n\n2.1 前端错误的分类#\n\n> 1.即时运行错误：代码错误\n\ntry...catch\n\nwindow.onerror (也可以用DOM2事件监听)\n\n> 2.资源加载错误\n\nobject.onerror: dom对象的onerror事件\n\nperformance.getEntries()\n\nError事件捕获\n\n> 3.使用performance.getEntries()获取网页图片加载错误\n\nvar allImgs = document.getElementsByTagName('image')\n\nvar loadedImgs = performance.getEntries().filter(i => i.initiatorType === 'img')\n\n最后allIms和loadedImgs对比即可找出图片资源未加载项目\n\n\n2.2 Error事件捕获代码示例#\n\n\n\n\n2.3 上报错误的基本原理#\n\n1.采用Ajax通信的方式上报\n\n2.利用Image对象上报 (主流方式)\n\nImage上报错误方式： (new Image()).src = 'https://ruochuan12.github.io/error?name=若川'\n\n\n3. Sentry 前端异常监控基本原理#\n\n> 1.重写 window.onerror 方法、重写 window.onunhandledrejection 方法\n\n如果不了解onerror和onunhandledrejection方法的读者，可以看相关的MDN文档。这里简要介绍一下：\n\nMDN GlobalEventHandlers.onerror\n\n\n\n> 参数： message：错误信息（字符串）。可用于HTML onerror=\"\"处理程序中的event。 source：发生错误的脚本URL（字符串）\n> lineno：发生错误的行号（数字） colno：发生错误的列号（数字） error：Error对象（对象）\n\nMDN unhandledrejection\n\n> 当 Promise 被 reject 且没有 reject 处理器的时候，会触发 unhandledrejection 事件；这可能发生在 window\n> 下，但也可能发生在 Worker 中。 这对于调试回退错误处理非常有用。\n\nSentry 源码可以搜索 global.onerror 定位到具体位置\n\n\n\n同样，可以搜索global.onunhandledrejection 定位到具体位置\n\n\n\n> 2.采用Ajax上传\n\n支持 fetch 使用 fetch，否则使用　XHR。\n\n\n\n> 2.1 fetch\n\n\n\n> 2.2 XMLHttpRequest\n\n\n\n接下来主要通过Sentry初始化、如何Ajax上报和window.onerror、window.onunhandledrejection三条主线来学习源码。\n\n> 如果看到这里，暂时不想关注后面的源码细节，直接看后文小结1和2的两张图。或者可以点赞或收藏这篇文章，后续想看了再看。\n\n\n4. Sentry 源码入口和出口#\n\n\n\n\n5. Sentry.init 初始化 之 init 函数#\n\n初始化\n\n\n\n\n\n\n5.1 getGlobalObject、inNodeEnv 函数#\n\n很多地方用到这个函数getGlobalObject。其实做的事情也比较简单，就是获取全局对象。浏览器中是window。\n\n\n\n继续看 initAndBind 函数\n\n\n6. initAndBind 函数之 new BrowserClient(options)#\n\n\n\n可以看出 initAndBind()，第一个参数是 BrowserClient 构造函数，第二个参数是初始化后的options。 接着先看 构造函数\nBrowserClient。 另一条线 getCurrentHub().bindClient() 先不看。\n\n\n6.1 BrowserClient 构造函数#\n\n\n\n从代码中可以看出： BrowserClient 继承自BaseClient，并且把BrowserBackend，options传参给BaseClient调用。\n\n先看 BrowserBackend，这里的BaseClient，暂时不看。\n\n看BrowserBackend之前，先提一下继承、继承静态属性和方法。\n\n\n6.2 __extends、extendStatics 打包代码实现的继承#\n\n未打包的源码是使用ES6 extends实现的。这是打包后的对ES6的extends的一种实现。\n\n如果对继承还不是很熟悉的读者，可以参考我之前写的文章。面试官问：JS的继承\n\n\n\n不得不说这打包后的代码十分严谨，上面说的我的文章《面试官问：JS的继承》中没有提到不支持__proto__的情况。看来这文章可以进一步严谨修正了。\n让我想起Vue源码中对数组检测代理判断是否支持__proto__的判断。\n\n\n\n看完打包代码实现的继承，继续看 BrowserBackend 构造函数\n\n\n6.3 BrowserBackend 构造函数 （浏览器后端）#\n\n\n\nBrowserBackend 又继承自 BaseBackend。\n\n6.3.1 BaseBackend 构造函数 （基础后端）#\n\n\n\n通过一系列的继承后，回过头来看 BaseClient 构造函数。\n\n6.3.2 BaseClient 构造函数（基础客户端）#\n\n\n\n\n6.4 小结1. new BrowerClient 经过一系列的继承和初始化#\n\n可以输出下具体new clientClass(options)之后的结果：\n\n\n\n最终输出得到这样的数据。我画了一张图表示。重点关注的原型链用颜色标注了，其他部分收缩了。\n\n\n\n\n7. initAndBind 函数之 getCurrentHub().bindClient()#\n\n继续看 initAndBind 的另一条线。\n\n\n\n获取当前的控制中心 Hub，再把new BrowserClient() 的实例对象绑定在Hub上。\n\n\n7.1 getCurrentHub 函数#\n\n\n\n\n7.2 衍生的函数 getMainCarrier、getHubFromCarrier#\n\n\n\n\n\n\n7.3 bindClient 绑定客户端在当前控制中心上#\n\n\n\n\n\n\n7.4 小结2. 经过一系列的继承和初始化#\n\n再回过头来看 initAndBind函数\n\n\n\n最终会得到这样的Hub实例对象。笔者画了一张图表示，便于查看理解。\n\n\n\n初始化完成后，再来看具体例子。 具体 captureMessage 函数的实现。\n\n\n\n\n8. captureMessage 函数#\n\n通过之前的阅读代码，知道会最终会调用Fetch接口，所以直接断点调试即可，得出如下调用栈。 接下来描述调用栈的主要流程。\n\n\n\n> 调用栈主要流程：\n\ncaptureMessage\n\n\n\n=> callOnHub\n\n\n\n=> Hub.prototype.captureMessage\n\n接着看Hub.prototype 上定义的 captureMessage 方法\n\n\n\n=> Hub.prototype._invokeClient\n\n\n\n=> BaseClient.prototype.captureMessage\n\n\n\n最后会调用 _processEvent 也就是\n\n=> BaseClient.prototype._processEvent\n\n这个函数最终会调用\n\n\n\n也就是\n\n=> BaseBackend.prototype.sendEvent\n\n\n\n=> FetchTransport.prototype.sendEvent 最终发送了请求\n\n\n8.1 FetchTransport.prototype.sendEvent#\n\n\n\n看完 Ajax 上报 主线，再看本文的另外一条主线 window.onerror 捕获。\n\n\n9. window.onerror 和 window.onunhandledrejection 捕获 错误#\n\n例子：调用一个未申明的变量。\n\n\n\nPromise 不捕获错误\n\n\n\n\n9.1 captureEvent#\n\n> 调用栈主要流程：\n\n> window.onerror\n\n\n\n> window.onunhandledrejection\n\n\n\n共同点：都会调用currentHub.captureEvent\n\n\n\n=> Hub.prototype.captureEvent\n\n最终又是调用 _invokeClient ，调用流程跟 captureMessage 类似，这里就不再赘述。\n\n\n\n=> Hub.prototype._invokeClient\n\n=> BaseClient.prototype.captureEvent\n\n=> BaseClient.prototype._processEvent\n\n=> BaseBackend.prototype.sendEvent\n\n=> FetchTransport.prototype.sendEvent\n\n最终同样是调用了这个函数发送了请求。\n\n可谓是殊途同归，行文至此就基本已经结束，最后总结一下。\n\n\n10. 总结#\n\nSentry-JavaScript源码高效利用了JS的原型链机制。可谓是惊艳，值得学习。\n\n本文通过梳理前端错误监控知识、介绍sentry错误监控原理、sentry初始化、Ajax上报、window.onerror、window.onunhandled\nrejection几个方面来学习sentry的源码。还有很多细节和构造函数没有分析。\n\n总共的构造函数（类）有25个，提到的主要有9个，分别是：Hub、BaseClient、BaseBackend、BaseTransport、FetchTransp\nort、XHRTransport、BrowserBackend、BrowserClient、GlobalHandlers。\n\n其他没有提到的分别是\nSentryError、Logger、Memo、SyncPromise、PromiseBuffer、Span、Scope、Dsn、API、NoopTranspo\nrt、FunctionToString、InboundFilters、TryCatch、Breadcrumbs、LinkedErrors、UserAgent。\n\n这些构造函数（类）中还有很多值得学习，比如同步的Promise（SyncPromise）。\n有兴趣的读者，可以看这一块官方仓库中采用typescript写的源码SyncPromise，也可以看打包后出来未压缩的代码。\n\n读源码比较耗费时间，写文章记录下来更加费时间（比如写这篇文章跨度十几天...），但收获一般都比较大。\n\n如果读者发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出。另外觉得写得不错，对您有些许帮助，可以点赞、评论、转发分享，也是对笔者的一种支持。万分感\n谢。\n\n\n11. 推荐阅读#\n\n知乎滴滴云：超详细！搭建一个前端错误监控系统 掘金BlackHole1：JavaScript集成Sentry 丁香园 开源的Sentry 小程序\nSDKsentry-miniapp sentry官网 sentry-javascript仓库\n\n\n笔者往期文章#\n\n面试官问：JS的继承 面试官问：JS的this指向 面试官问：能否模拟实现JS的call和apply方法 面试官问：能否模拟实现JS的bind方法\n面试官问：能否模拟实现JS的new操作符 前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 若川的博客，使用vuepress重构了，阅读体验可能更好些\n掘金专栏，欢迎关注~ segmentfault前端视野专栏，欢迎关注~ 知乎前端视野专栏，欢迎关注~ 语雀前端视野专栏，新增语雀专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注（回复pdf获取前端优质书籍pdf）。欢迎加笔者微信ruochuan12（注明来源，基本来者不拒），拉您进【前端视野交流群\n】，长期交流学习~\n\n","routePath":"/sentry/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 前端错误监控知识","id":"2-前端错误监控知识","depth":2,"charIndex":1240},{"text":"2.1 前端错误的分类","id":"21-前端错误的分类","depth":3,"charIndex":1307},{"text":"2.2 Error事件捕获代码示例","id":"22-error事件捕获代码示例","depth":3,"charIndex":1679},{"text":"2.3 上报错误的基本原理","id":"23-上报错误的基本原理","depth":3,"charIndex":1702},{"text":"3. Sentry 前端异常监控基本原理","id":"3-sentry-前端异常监控基本原理","depth":2,"charIndex":1837},{"text":"4. Sentry 源码入口和出口","id":"4-sentry-源码入口和出口","depth":2,"charIndex":2609},{"text":"5. Sentry.init 初始化 之 init 函数","id":"5-sentryinit-初始化-之-init-函数","depth":2,"charIndex":2632},{"text":"5.1 getGlobalObject、inNodeEnv 函数","id":"51-getglobalobjectinnodeenv-函数","depth":3,"charIndex":2673},{"text":"6. initAndBind 函数之 new BrowserClient(options)","id":"6-initandbind-函数之-new-browserclientoptions","depth":2,"charIndex":2792},{"text":"6.1 BrowserClient 构造函数","id":"61-browserclient-构造函数","depth":3,"charIndex":2973},{"text":"6.2 __extends、extendStatics 打包代码实现的继承","id":"62-__extendsextendstatics-打包代码实现的继承","depth":3,"charIndex":3158},{"text":"6.3 BrowserBackend  构造函数 （浏览器后端）","id":"63-browserbackend--构造函数-浏览器后端","depth":3,"charIndex":-1},{"text":"6.3.1 BaseBackend  构造函数 （基础后端）","id":"631-basebackend--构造函数-基础后端","depth":4,"charIndex":-1},{"text":"6.3.2 BaseClient 构造函数（基础客户端）","id":"632-baseclient-构造函数基础客户端","depth":4,"charIndex":3579},{"text":"6.4 小结1. new BrowerClient 经过一系列的继承和初始化","id":"64-小结1-new-browerclient-经过一系列的继承和初始化","depth":3,"charIndex":3613},{"text":"7. initAndBind 函数之 getCurrentHub().bindClient()","id":"7-initandbind-函数之-getcurrenthubbindclient","depth":2,"charIndex":3744},{"text":"7.1 getCurrentHub 函数","id":"71-getcurrenthub-函数","depth":3,"charIndex":3872},{"text":"7.2 衍生的函数 getMainCarrier、getHubFromCarrier","id":"72-衍生的函数-getmaincarriergethubfromcarrier","depth":3,"charIndex":3898},{"text":"7.3 bindClient 绑定客户端在当前控制中心上","id":"73-bindclient-绑定客户端在当前控制中心上","depth":3,"charIndex":3948},{"text":"7.4 小结2. 经过一系列的继承和初始化","id":"74-小结2-经过一系列的继承和初始化","depth":3,"charIndex":3984},{"text":"8. captureMessage 函数","id":"8-capturemessage-函数","depth":2,"charIndex":4114},{"text":"8.1 FetchTransport.prototype.sendEvent","id":"81-fetchtransportprototypesendevent","depth":3,"charIndex":4567},{"text":"9. window.onerror 和 window.onunhandledrejection 捕获 错误","id":"9-windowonerror-和-windowonunhandledrejection-捕获-错误","depth":2,"charIndex":4657},{"text":"9.1 captureEvent","id":"91-captureevent","depth":3,"charIndex":4749},{"text":"10. 总结","id":"10-总结","depth":2,"charIndex":5191},{"text":"11. 推荐阅读","id":"11-推荐阅读","depth":2,"charIndex":5936},{"text":"笔者往期文章","id":"笔者往期文章","depth":2,"charIndex":6069},{"text":"关于","id":"关于","depth":2,"charIndex":6213},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":90,"title":"","content":"","routePath":"/sentry/src/sentry-javascript-bundle","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":91,"title":"","content":"","routePath":"/sentry/src/syncPromise","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":92,"title":"","content":"抽象类\n\n 1. setupTransaction - init\n 2. setup\n 3. setupTransaction - close\n 4. buildTransaction - init\n 5. build\n 6. buildTransaction - close","routePath":"/taro/cli-build/bak","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":93,"title":"Taro 4.0 已正式发布 - 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。\n\n截至目前（2024-08-16），taro 4.0 正式版已经发布，目前最新是 4.0.4，官方4.0正式版本的介绍文章暂未发布。官方之前发过Taro 4.0\nBeta 发布：支持开发鸿蒙应用、小程序编译模式、Vite 编译等。\n\n计划写一个 taro 源码揭秘系列，欢迎持续关注。初步计划有如下文章：\n\n * Taro 源码揭秘 - 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密\n * Taro 源码揭秘 - 2. 揭开整个架构的插件系统的秘密\n * Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么\n * Taro 4.0 已正式发布 - 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？\n * Taro 4.0 已发布 - 5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？\n * 等等\n\n学完本文，你将学到：\n\n\n\n经常使用 Taro 开发小程序的小伙伴，一定日常使用 npm run dev:weapp 等命令运行小程序。我们这篇文章就来解读这个命令背后，Taro\n到底做了什么。 npm run dev:weapp 对应的是 taro build --type weapp --watch。 npm run\nbuild:weapp 对应的是 taro build --type weapp。\n\n关于克隆项目、环境准备、如何调试代码等，参考第一篇文章-准备工作、调试。后续文章基本不再过多赘述。\n\n> 文章中基本是先放源码，源码中不做过多解释。源码后面再做简单讲述。\n\n\n2. 调试源码#\n\n初始化 taro 项目，方便调试，选择React、TS、Less、pnpm、webpack5、CLI内置默认模板。\n\n\n\n如图所示\n\n\n\n如图\n\n\n\n如图\n\n我们来学习 taro 编译打包的源码。\n\n\n2.1 调试方式1：使用项目里的依赖#\n\n克隆 taro 项目\n\n\n\n方式1调试截图如下：\n\n\n\n优点，无需多余的配置，可以直接调试本身项目。 缺点：安装的 taro 依赖都是 dist 目录，压缩过后的，不方便查看原始代码。\n\n我们使用调试方法2。\n\n\n2.2 调试方式2：使用 taro 源码#\n\n我把 taro 源码和 taro4-debug 克隆到了同一个目录 github。\n\n优点：可以调试本身不压缩的源码。因为 taro 自身打包生成了对应的 sourcemap 文件，所以可以调试源码文件。 缺点：\n\n * 1. 需要配置 .vscode/launch.json。\n * 2. 还需要在对应的 dist 文件修改一些包的路径。\n\n2.2.1 配置 .vscode/launch.json#\n\n重点添加配置 \"cwd\": \"/Users/ruochuan/git-source/github/taro4-debug\"、 \"args\":\n[\"build\",\"--type\",\"weapp\" ] 和 \"console\": \"integratedTerminal\"\n\n我们配置调试微信小程序打包。\n\n\n\n2.2.2 修改以下两个包的路径#\n\n * @tarojs/plugin-platform-weapp =>\n   ../taro/packages/taro-platform-weapp/index.js\n * @tarojs/webpack5-runner => ../taro/packages/taro-webpack5-runner/index.js\n\n对应的具体代码位置如下\n\n\n\n\n\n不配置的话，不会调用对应的 taro 文件源码，而是调用项目中的依赖包源码，路径不对。\n\n方式2调试截图如下：\n\n\n\n根据前面两篇 1. taro cli init、2. taro 插件机制 文章，我们可以得知：taro build 初始化命令，最终调用的是\npackages/taro-cli/src/presets/commands/build.ts 文件中的 ctx.registerCommand 注册的\nbuild 命令行的 fn 函数。\n\n\n\nTaro build 插件主要做了以下几件事：\n\n * 判断 config/index 配置文件是否存在，如果不存在，则报错退出程序。\n * 判断 platform 参数是否是字符串，这里是 weapp，如果不是，退出程序。\n * 使用 @tarojs/plugin-doctor 中的 validateConfig 方法 (checkConfig) 函数校验配置文件\n   config/index，如果配置文件出错，退出程序。\n * 调用 ctx.applyPlugins(hooks.ON_BUILD_START) （编译开始）onBuildStart 钩子。\n * 调用 ctx.applyPlugins({ name: platform, }) （调用 weapp） 钩子。\n * 调用 ctx.applyPlugins(hooks.ON_BUILD_COMPLETE) （编译结束）onBuildComplete 钩子。\n\n其中\n\n\n\n调用的是端平台插件，本文以微信小程序为例，所以调用的是\nweapp。对应的源码文件路径是：packages/taro-platform-weapp/src/index.ts。我们来看具体实现。\n\n\n3. 端平台插件 Weapp#\n\nTaro文档 - 端平台插件 中，有对端平台插件的比较详细的描述，可以参考学习。\n\n\n\n我们接着学习微信小程序端平台插件源码。\n\n\n\n重点就是这两行代码。\n\n\n\nctx.registerPlatform 注册 weapp 平台插件，调用 Weapp 构造函数，传入 ctx 、config 和 options\n等配置。再调用实例对象的 start 方法。\n\n\n4. new Weapp 构造函数#\n\n> packages/taro-platform-weapp/src/program.ts\n\n\n\n * class Weapp 继承于抽象类 TaroPlatformBase 继承于抽象类 TaroPlatform\n\n如图所示：\n\n关于抽象类和更多类相关，可以参考： TypeScript 入门教程 - 类\n\n> 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现 Classes(中文版)\n> ECMAScript 6 入门 - Class\n\n这样抽象的好处，在于其他端平台插件 比如小红书 基于这个抽象类扩展继承就比较方便。\n\n\n5. TaroPlatform 端平台插件抽象类#\n\n\n5.1 Transaction 事务#\n\n\n\n这样的好处在于，方便按顺序执行 init perform close 函数。我们也可以在工作中使用。\n\n我们接着来看 class TaroPlatform。\n\n\n\n\n5.2 emptyOutputDir 清空输出的文件夹等#\n\n\n\n我们来看 TaroPlatformBase 的实现\n\n\n6. TaroPlatformBase 端平台插件基础抽象类#\n\n\n\nstart 实现，setup 再执行 build。我们来看 setup 函数。\n\n\n6.1 setup#\n\n\n\n\n\n\n\n我们继续来看 build 函数。\n\n\n6.2 build#\n\n\n\n\n\n我们来看下 getRunner 的实现：\n\n\n\nbuild 函数最后调用 runner 函数。appPath\n项目路径是/Users/ruochuan/git-source/github/taro4-debug。\n\n初始化项目使用的 webpack5 所以使用的是 @tarojs/webpack5-runner 我们来看它的具体实现。\n\n\n7. runner => @tarojs/webpack5-runner#\n\npackage.json 属性 \"main\": \"index.js\" 入口文件 index.js\n\n\n\n本文中打包微信小程序，根据 process.env.TARO_PLATFORM 和 process.env.TARO_ENV 调用的是打包后的文件\ndist/index.mini.js，源码文件是 packages/taro-webpack5-runner/src/index.mini.ts。\n\n\n\nconst compiler = webpack(webpackConfig) 使用 webpack 编译。这部分代码比较多。后续有空再写 webpack\n编译的文章。\n\n\n8. 总结#\n\n我们学习了两种方式如何调试 taro build 部分的源码。\n\n我们来总结下，打包构建流程简单梳理。\n\n * 调用 taro 插件 build\n * 调用端平台插件 Weapp\n * 平台插件继承自 TaroPlatformBase 端平台插件基础抽象类\n * 平台插件继承自 TaroPlatform 端平台插件抽象类\n\n简版代码\n\n\n\n\n\n最后调用的是 @tarojs/webpack5-runner，webpack 编译打包生成项目文件。\n\n在 packages/taro-service/dist/Kernel.js 的 applyPlugins 方法中，打印出 plugins-name\n，调用插件的依次顺序是：\n\n也是开发者开发插件配置钩子的执行。\n\n更多 Taro 端平台插件实现细节可参考Taro文档 - 端平台插件，更多 Taro 实现细节也可以参考官方文档：Taro 实现细节。\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。也欢迎提建议和交流讨论。\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。若川的博客，github blog，可以点个 star 鼓励下持续创作。\n\n最后可以持续关注我@若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。","routePath":"/taro/cli-build/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 调试源码","id":"2-调试源码","depth":2,"charIndex":882},{"text":"2.1 调试方式1：使用项目里的依赖","id":"21-调试方式1使用项目里的依赖","depth":3,"charIndex":993},{"text":"2.2 调试方式2：使用 taro 源码","id":"22-调试方式2使用-taro-源码","depth":3,"charIndex":1121},{"text":"2.2.1 配置 `.vscode/launch.json`","id":"221-配置-vscodelaunchjson","depth":4,"charIndex":-1},{"text":"2.2.2 修改以下两个包的路径","id":"222-修改以下两个包的路径","depth":4,"charIndex":1499},{"text":"3. 端平台插件 Weapp","id":"3-端平台插件-weapp","depth":2,"charIndex":2449},{"text":"4. new Weapp 构造函数","id":"4-new-weapp-构造函数","depth":2,"charIndex":2646},{"text":"5. TaroPlatform 端平台插件抽象类","id":"5-taroplatform-端平台插件抽象类","depth":2,"charIndex":2971},{"text":"5.1 Transaction 事务","id":"51-transaction-事务","depth":3,"charIndex":2999},{"text":"5.2 emptyOutputDir 清空输出的文件夹等","id":"52-emptyoutputdir-清空输出的文件夹等","depth":3,"charIndex":3105},{"text":"6. TaroPlatformBase 端平台插件基础抽象类","id":"6-taroplatformbase-端平台插件基础抽象类","depth":2,"charIndex":3166},{"text":"6.1 setup","id":"61-setup","depth":3,"charIndex":3243},{"text":"6.2 build","id":"62-build","depth":3,"charIndex":3280},{"text":"7. runner => @tarojs/webpack5-runner","id":"7-runner--tarojswebpack5-runner","depth":2,"charIndex":3467},{"text":"8. 总结","id":"8-总结","depth":2,"charIndex":3796}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":94,"title":"Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。\n\n截至目前（2024-07-17），taro 正式版是 3.6.34，Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite\n编译等。文章提到将于 2024 年第二季度，发布 4.x。目前已经发布 4.x。所以我们直接学习 main 分支最新版本是 4.0.2。\n\n计划写一个 taro 源码揭秘系列，欢迎持续关注。初步计划有如下文章：\n\n * Taro 源码揭秘 - 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密\n * Taro 源码揭秘 - 2. 揭开整个架构的插件系统的秘密\n * Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么\n * Taro 4.0 已正式发布 - 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？\n * Taro 4.0 已发布 - 5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？\n * 等等\n\n学完本文，你将学到：\n\n\n\n关于克隆项目、环境准备、如何调试代码等，参考第一篇文章-准备工作、调试。后续文章基本不再过多赘述。\n\n> 文章中基本是先放源码，源码中不做过多解释。源码后面再做简单讲述。\n\n众所周知，我们最开始初始化项目时都是使用 taro init 命令，本文我们继续来学习这个命令是如何实现的。\n\n我们可以通过 npm-dist-tag 文档 命令来查看 @tarojs/cli 包的所有 tag 版本。\n\n\n\n如图所示：\n\n\n\n目前 latest 标签（默认版本）是 3.6.34，next 标签是 4.0.0。后续 latest 标签会设置为 4.x 版本。\n\n我们先用 @tarojs/cli@next 初始化一个项目看看。全局安装相对麻烦，我们不全局安装，使用 npx 来运行 next tag 版本。\n\n\n\n这个初始化完整的过程，我用 GIPHY CAPTURE 工具录制了一个gif，如下图所示：\n\n\n\n我们接下来就是一步步来分析这个 gif 中的每一个步骤的实现原理。\n\n\n2. 调试 taro init#\n\n我们在 .vscode/launch.json 中的原有的 CLI debug 命令行调试配置，添加 init 配置如下：\n\n\n\n其中 \"console\": \"integratedTerminal\", 配置是为了在调试时，可以在终端输入和交互。\n\n\n3. init 命令行 fn 函数#\n\n根据前面两篇 1. taro cli init、2. taro 插件机制 文章，我们可以得知：taro init 初始化命令，最终调用的是\npackages/taro-cli/src/presets/commands/init.ts 文件中的 ctx.registerCommand 注册的 init\n命令行的 fn 函数。\n\n\n\nfn 函数，其中 options 参数是 init 命令行中的所有参数。 主要做了如下几件事：\n\n * 读取组合各种参数，初始化 project 对象，并调用 create 方法。\n\n我们重点来看 packages/taro-cli/src/create/project.ts 的 Project 类的实现，和 create 方法。\n\n\n4. new Project 构造函数#\n\n\n\nProject 继承了 Creator 类。\n\n构造函数中，使用 semver.lt 判断当前 node 版本是否低于 v18.0.0，如果低于则报错。 semver 是一个版本号比较库，可以用来判断\nnode 版本是否符合要求。\n\n其次就是初始化 this.rootPath 和 this.conf。\n\n我们继续来看 Creator 类，构造函数中调用了 init 方法。\n\n\n\n所以继续来看 init 方法。\n\n\n\n调试截图如下：\n\n\n\n输出就是这个图：\n\n\n\n其中👽 Taro v4.0.0 输出的是 tarojs-cli/package.json 的版本，第一篇文章 4.\ntaro-cli/src/utils/index.ts 中有详细讲述，这里就不再赘述了。\n\n输出获取 taro 全局配置成功是指获取 ~/.taro-global-config/index.json 文件的插件集 presets 和插件\nplugins。第一篇文章 6.2.2 config.initGlobalConfig 初始化全局配置中有详细讲述，spinner.succeed('获取\ntaro 全局配置成功') 这里就不再赘述了。\n\n看完了 Project 构造函数，我们来看 Project 类的 create 方法。\n\n\n4.1 project.create 创建项目#\n\n\n\ncreate 函数主要做了以下几件事：\n\n * 调用 ask 询问用户输入项目名称、描述、CSS预处理器、包管理工具等。\n * 把用户反馈的结果和之前的配置合并起来，得到 this.conf。\n * 调用 write 方法，写入文件，初始化模板项目。\n\n调试截图如下：\n\n\n\nthis.conf 参数结果如下：\n\n\n\n我们来看 ask 方法。\n\n\n5. ask 询问用户输入项目名称、描述等#\n\n\n\n简单来说 ask 方法就是一系列的 inquirer 交互。\n\n> inquirer 是一个命令行交互库，可以用来创建命令行程序。\n\n如果参数中没指定相应参数，那么就询问：\n\n * 项目名称\n * 项目介绍\n * 选择框架（React、PReact、Vue3、Solid）\n * 是否启用TS\n * CSS预处理器（Sass、less、Stylus、无等）\n * 编译工具（webpack、vite）\n * 包管理工具（npm、yarn、pnpm）\n * 选择模板源（gitee最快、github最新、CLI 内置模板等）\n * 选择模板（默认模板等）\n * 等等\n\n如图所示：\n\n\n\n我们重点讲述以下几个方法\n\n * askProjectName 询问项目名称\n * askTemplateSource 询问模板源\n * fetchTemplates 获取模板列表\n * askTemplate 询问模板\n\n我们来看第一个 askProjectName 方法。\n\n\n5.1 askProjectName 询问项目名称#\n\n\n\n后面的\naskDescription、askFramework、askFramework、askTypescript、askCSS、askCompiler、askNpm\n，都是类似方法，就不再赘述了。\n\n\n5.2 askTemplateSource 询问模板源#\n\n\n\n导出的就是这些常量。\n\n\n\n\n\n简单来说：\n\n * 就是判断本地是否存在配置 ~/.taro3.7/index.json，如果存在则读取模板源，如果不存在则创建配置。创建配置时，默认模板源为\n   github:NervJS/taro-project-templates#v4.0。\n * 另外，如果本地模板源不是默认模板源，那么就把本地模板源作为选项，放在最前面，供用户选择。\n\n其中，~/.taro3.7/index.json 内容格式如下：\n\n\n\n\n\n\n\n我们继续来看 fetchTemplates 函数：\n\n\n5.3 fetchTemplates 获取模板列表#\n\n\n\n我们继续来看 fetchTemplate 函数，它主要做了以下几件事情：\n\n5.3.1 fetchTemplate 获取模板#\n\n\n\n这个方法主要做了以下几件事情：\n\n * 判断模板来源地址是 git 类型，那么使用 download-git-repo 下载远程仓库到本地。\n * 判断模板来源地址是 git 类型，那么则用 axios 下载。\n\nthen 部分\n\n\n\n这段代码主要做了以下几件事情：\n\n * 判断是否是模板组，如果是模板组，则遍历 packages/taro-cli/templates/taro-temp 文件夹下的所有文件夹，并移动到\n   packages/taro-cli 目录下的 templates 文件夹。\n * 不是模板组，则直接移动到 packages/taro-cli/templates/taro-temp 目录下单个模板到 templates 文件夹。\n\n用一张图来展示：\n\n\n\n\n5.4 askTemplate 询问用户选择模板#\n\n\n\n\n6. write 写入项目#\n\n\n\nwrite 函数主要做了以下几件事情：\n\n * 获取用户输入的参数，包括项目名称、项目目录、模板名称等。\n * 引入模板编写者的自定义逻辑。\n * 调用 createProject 函数，传入用户输入的参数和模板编写者的自定义逻辑。\n\n调试截图\n\n\n\n\n6.1 template_creator.js 默认模板中创建模板的自定义逻辑#\n\n\n\ntemplate_creator.js 文件中的 handler 对象，定义了模板中创建的文件和自定义逻辑。 比如当 !!params.typescript\n的时候，创建 /tsconfig.json、types/global.d.ts 文件。 当 ['Vue3'].includes(framework) &&\n!!typescript 的时候，创建 types/vue.d.ts 文件。 根据 '/_env.development' 文件创建\n.env.development 等等\n\n> 因为在一些场景下，. 开头文件会出现问题，所以改用 _ 开头命名文件，创建时做一次替换。\n\n\n7. 调试 rust 代码#\n\n我们从 write 函数调用 createProject 函数，可以看到 createProject 等是从 @tarojs/binding 引入的。\n\n\n\n简单来说就是：通过 napi-rs 把 create_project 函数暴露给 nodejs ，然后通过 nodejs 调用 rust 的\ncreate_project 函数。\n\n关于具体细节，用 rust 改造 taro init 这部分代码的作者 @luckyadam，写了一篇文章。可以参考学习解锁前端新潜能：如何使用 Rust\n锈化前端工具链，我在这里就不赘述了。\n\n> 安装 VSCode 插件 rust-analyzer (方便跳转代码定义等) 和调试代码的插件 CodeLLDB\n\n更多 rust 学习，可参考 rust 官网：rust-lang.org\n\n我们在 .vscode/launch.json 中的原有的 debug-init 命令行调试配置，修改 \"type\": \"lldb\", 配置如下：\n\n\n\n这样我们就可以在 crates/native_binding/src/lib.rs 文件中打断点调试了。\n\n调试截图如下：\n\n\n\n我们继续来看 crates/native_binding/src/lib.rs 文件中的 create_project （ nodejs 中调用则是\ncreateProject ）函数：\n\n\n8. rust create_project 创建项目#\n\n\n\n我们重点来看一下 project.create 函数：\n\n\n8.1 create 创建文件#\n\n\n\ncreate 主要做了以下几件事情：\n\n 1. 创建项目目录\n 2. 创建项目文件 creator.create_files\n 3. 初始化 git init_git\n 4. 安装依赖 install_deps\n\n如下图所示：\n\n\n\n接着我们重点来看一下 creator.create_files 函数：\n\n\n8.2 creator.create_files#\n\n\n\n我们重点来看一下 creator.tempate 函数：\n\n\n8.3 creator.tempate 模板#\n\n\n\n我们重点来看一下 generate_with_template 函数：\n\n\n8.4 generate_with_template 根据数据渲染模板，生成文件#\n\n\n\ntaro init 的 rust代码中，安装依赖引入了crates/handlebars rust包，类似 npm 包管理官网。\n\n经过 HANDLEBARS.render_template(&from_template, data) handlebars-rust\n根据数据渲染模板，生成文件。\n\n比如：handlebars 模板中的 app.config.js => app.config.ts\n\n如下图所示：\n\n\n\n更多 handlebars 用法，参考handlebars官网。\n\n\n9. 总结#\n\n我们再来看下开头初始化项目的 gif 回顾下整个 taro init 过程：\n\n\n\n根据前面两篇 1. taro cli init、2. taro 插件机制 文章，我们可以得知：taro init 初始化命令，最终调用的是\npackages/taro-cli/src/presets/commands/init.ts 文件中的 ctx.registerCommand 注册的 init\n命令行的 fn 函数。\n\n可以根据配置 .vscode/launch.json 文件调试 taro init node 部分代码和 rust 配置 type:lldb 代码。\n\n\n\n\n\nask 命令行交互式选择使用的是 inquirer inquirer.prompt 实现。使用 download-git-repo 包（如果是 url 则用\naxios 下载）把远程仓库下载到本地移动到packages/taro-cli/templates。\n\n\n\n\n\nwrite 函数中的 createProject 创建文件部分是使用 rust 实现的。使用 napi-rs 包绑定 rust 代码，给 nodejs 调用。\n\n模板部分使用的是 handlebars，rust 使用的 handlebars rust 包 crates/handlebars rust 实现。\n\n根据数据渲染 handlebars 模板，创建项目，生成文件。\n\n再根据包管理器安装依赖。最后打印创建项目成功，请进入项目目录工作。\n\n整个 taro init 创建新项目流程用一张图表示如图所示：\n\n\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。也欢迎提建议和交流讨论。\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。若川的博客，github blog，可以点个 star 鼓励下持续创作。\n\n最后可以持续关注我@若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。","routePath":"/taro/cli-init-2/README.juejin","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 调试 taro init","id":"2-调试-taro-init","depth":2,"charIndex":1068},{"text":"3. init 命令行 fn 函数","id":"3-init-命令行-fn-函数","depth":2,"charIndex":1211},{"text":"4. new Project 构造函数","id":"4-new-project-构造函数","depth":2,"charIndex":1566},{"text":"4.1 project.create 创建项目","id":"41-projectcreate-创建项目","depth":3,"charIndex":2150},{"text":"5. ask 询问用户输入项目名称、描述等","id":"5-ask-询问用户输入项目名称描述等","depth":2,"charIndex":2352},{"text":"5.1 askProjectName 询问项目名称","id":"51-askprojectname-询问项目名称","depth":3,"charIndex":2812},{"text":"5.2 askTemplateSource 询问模板源","id":"52-asktemplatesource-询问模板源","depth":3,"charIndex":2945},{"text":"5.3 fetchTemplates 获取模板列表","id":"53-fetchtemplates-获取模板列表","depth":3,"charIndex":3236},{"text":"5.3.1 fetchTemplate 获取模板","id":"531-fetchtemplate-获取模板","depth":4,"charIndex":3304},{"text":"5.4 askTemplate 询问用户选择模板","id":"54-asktemplate-询问用户选择模板","depth":3,"charIndex":3678},{"text":"6. write 写入项目","id":"6-write-写入项目","depth":2,"charIndex":3708},{"text":"6.1 template_creator.js 默认模板中创建模板的自定义逻辑","id":"61-template_creatorjs-默认模板中创建模板的自定义逻辑","depth":3,"charIndex":3853},{"text":"7. 调试 rust 代码","id":"7-调试-rust-代码","depth":2,"charIndex":4191},{"text":"8. rust create_project 创建项目","id":"8-rust-create_project-创建项目","depth":2,"charIndex":4811},{"text":"8.1 create 创建文件","id":"81-create-创建文件","depth":3,"charIndex":4873},{"text":"8.2 creator.create_files","id":"82-creatorcreate_files","depth":3,"charIndex":5048},{"text":"8.3 creator.tempate 模板","id":"83-creatortempate-模板","depth":3,"charIndex":5108},{"text":"8.4 generate_with_template 根据数据渲染模板，生成文件","id":"84-generate_with_template-根据数据渲染模板生成文件","depth":3,"charIndex":5173},{"text":"9. 总结","id":"9-总结","depth":2,"charIndex":5464}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":95,"title":"","content":"askDescription#\n\n\n\n\naskFramework#\n\n\n\n\naskTypescript#\n\n\n\n\naskCSS#\n\n\n\n\naskCompiler#\n\n\n\n\naskNpm#\n\n","routePath":"/taro/cli-init-2/bak","lang":"zh","toc":[{"text":"askDescription","id":"askdescription","depth":2,"charIndex":-1},{"text":"askFramework","id":"askframework","depth":2,"charIndex":19},{"text":"askTypescript","id":"asktypescript","depth":2,"charIndex":37},{"text":"askCSS","id":"askcss","depth":2,"charIndex":56},{"text":"askCompiler","id":"askcompiler","depth":2,"charIndex":68},{"text":"askNpm","id":"asknpm","depth":2,"charIndex":85}],"domain":"","frontmatter":{},"version":""},{"id":96,"title":"Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。\n\n截至目前（2024-07-17），taro 正式版是 3.6.34，Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite\n编译等。文章提到将于 2024 年第二季度，发布 4.x。目前已经发布 4.x。所以我们直接学习 main 分支最新版本是 4.0.2。\n\n计划写一个 taro 源码揭秘系列，欢迎持续关注。初步计划有如下文章：\n\n * Taro 源码揭秘 - 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密\n * Taro 源码揭秘 - 2. 揭开整个架构的插件系统的秘密\n * Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么\n * Taro 4.0 已正式发布 - 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？\n * Taro 4.0 已发布 - 5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？\n * 等等\n\n学完本文，你将学到：\n\n\n\n关于克隆项目、环境准备、如何调试代码等，参考第一篇文章-准备工作、调试。后续文章基本不再过多赘述。\n\n> 文章中基本是先放源码，源码中不做过多解释。源码后面再做简单讲述。\n\n众所周知，我们最开始初始化项目时都是使用 taro init 命令，本文我们继续来学习这个命令是如何实现的。\n\n我们可以通过 npm-dist-tag 文档 命令来查看 @tarojs/cli 包的所有 tag 版本。\n\n\n\n如图所示：\n\n目前 latest 标签（默认版本）是 3.6.34，next 标签是 4.0.0。后续 latest 标签会设置为 4.x 版本。\n\n我们先用 @tarojs/cli@next 初始化一个项目看看。全局安装相对麻烦，我们不全局安装，使用 npx 来运行 next tag 版本。\n\n\n\n这个初始化完整的过程，我用 GIPHY CAPTURE 工具录制了一个gif，如下图所示：\n\n\n\n我们接下来就是一步步来分析这个 gif 中的每一个步骤的实现原理。\n\n\n2. 调试 taro init#\n\n我们在 .vscode/launch.json 中的原有的 CLI debug 命令行调试配置，添加 init 配置如下：\n\n\n\n其中 \"console\": \"integratedTerminal\", 配置是为了在调试时，可以在终端输入和交互。\n\n\n3. init 命令行 fn 函数#\n\n根据前面两篇 1. taro cli init、2. taro 插件机制 文章，我们可以得知：taro init 初始化命令，最终调用的是\npackages/taro-cli/src/presets/commands/init.ts 文件中的 ctx.registerCommand 注册的 init\n命令行的 fn 函数。\n\n\n\nfn 函数，其中 options 参数是 init 命令行中的所有参数。 主要做了如下几件事：\n\n * 读取组合各种参数，初始化 project 对象，并调用 create 方法。\n\n我们重点来看 packages/taro-cli/src/create/project.ts 的 Project 类的实现，和 create 方法。\n\n\n4. new Project 构造函数#\n\n\n\nProject 继承了 Creator 类。\n\n构造函数中，使用 semver.lt 判断当前 node 版本是否低于 v18.0.0，如果低于则报错。 semver 是一个版本号比较库，可以用来判断\nnode 版本是否符合要求。\n\n其次就是初始化 this.rootPath 和 this.conf。\n\n我们继续来看 Creator 类，构造函数中调用了 init 方法。\n\n\n\n所以继续来看 init 方法。\n\n\n\n调试截图如下：\n\n输出就是这个图：\n\n其中👽 Taro v4.0.0 输出的是 tarojs-cli/package.json 的版本，第一篇文章 4.\ntaro-cli/src/utils/index.ts 中有详细讲述，这里就不再赘述了。\n\n输出获取 taro 全局配置成功是指获取 ~/.taro-global-config/index.json 文件的插件集 presets 和插件\nplugins。第一篇文章 6.2.2 config.initGlobalConfig 初始化全局配置中有详细讲述，spinner.succeed('获取\ntaro 全局配置成功') 这里就不再赘述了。\n\n看完了 Project 构造函数，我们来看 Project 类的 create 方法。\n\n\n4.1 project.create 创建项目#\n\n\n\ncreate 函数主要做了以下几件事：\n\n * 调用 ask 询问用户输入项目名称、描述、CSS预处理器、包管理工具等。\n * 把用户反馈的结果和之前的配置合并起来，得到 this.conf。\n * 调用 write 方法，写入文件，初始化模板项目。\n\n调试截图如下：\n\n\n\nthis.conf 参数结果如下：\n\n\n\n我们来看 ask 方法。\n\n\n5. ask 询问用户输入项目名称、描述等#\n\n\n\n简单来说 ask 方法就是一系列的 inquirer 交互。\n\n> inquirer 是一个命令行交互库，可以用来创建命令行程序。\n\n如果参数中没指定相应参数，那么就询问：\n\n * 项目名称\n * 项目介绍\n * 选择框架（React、PReact、Vue3、Solid）\n * 是否启用TS\n * CSS预处理器（Sass、less、Stylus、无等）\n * 编译工具（webpack、vite）\n * 包管理工具（npm、yarn、pnpm）\n * 选择模板源（gitee最快、github最新、CLI 内置模板等）\n * 选择模板（默认模板等）\n * 等等\n\n如图所示：\n\n我们重点讲述以下几个方法\n\n * askProjectName 询问项目名称\n * askTemplateSource 询问模板源\n * fetchTemplates 获取模板列表\n * askTemplate 询问模板\n\n我们来看第一个 askProjectName 方法。\n\n\n5.1 askProjectName 询问项目名称#\n\n\n\n后面的\naskDescription、askFramework、askFramework、askTypescript、askCSS、askCompiler、askNpm\n，都是类似方法，就不再赘述了。\n\n\n5.2 askTemplateSource 询问模板源#\n\n\n\n导出的就是这些常量。\n\n\n\n\n\n简单来说：\n\n * 就是判断本地是否存在配置 ~/.taro3.7/index.json，如果存在则读取模板源，如果不存在则创建配置。创建配置时，默认模板源为\n   github:NervJS/taro-project-templates#v4.0。\n * 另外，如果本地模板源不是默认模板源，那么就把本地模板源作为选项，放在最前面，供用户选择。\n\n其中，~/.taro3.7/index.json 内容格式如下：\n\n\n\n\n\n\n\n我们继续来看 fetchTemplates 函数：\n\n\n5.3 fetchTemplates 获取模板列表#\n\n\n\n我们继续来看 fetchTemplate 函数，它主要做了以下几件事情：\n\n5.3.1 fetchTemplate 获取模板#\n\n\n\n这个方法主要做了以下几件事情：\n\n * 判断模板来源地址是 git 类型，那么使用 download-git-repo 下载远程仓库到本地。\n * 判断模板来源地址是 git 类型，那么则用 axios 下载。\n\nthen 部分\n\n\n\n这段代码主要做了以下几件事情：\n\n * 判断是否是模板组，如果是模板组，则遍历 packages/taro-cli/templates/taro-temp 文件夹下的所有文件夹，并移动到\n   packages/taro-cli 目录下的 templates 文件夹。\n * 不是模板组，则直接移动到 packages/taro-cli/templates/taro-temp 目录下单个模板到 templates 文件夹。\n\n用一张图来展示：\n\n\n\n\n5.4 askTemplate 询问用户选择模板#\n\n\n\n\n6. write 写入项目#\n\n\n\nwrite 函数主要做了以下几件事情：\n\n * 获取用户输入的参数，包括项目名称、项目目录、模板名称等。\n * 引入模板编写者的自定义逻辑。\n * 调用 createProject 函数，传入用户输入的参数和模板编写者的自定义逻辑。\n\n调试截图\n\n\n\n\n6.1 template_creator.js 默认模板中创建模板的自定义逻辑#\n\n\n\ntemplate_creator.js 文件中的 handler 对象，定义了模板中创建的文件和自定义逻辑。 比如当 !!params.typescript\n的时候，创建 /tsconfig.json、types/global.d.ts 文件。 当 \\['Vue3'].includes(framework) &&\n!!typescript 的时候，创建 types/vue.d.ts 文件。 根据 /\\_env.development 文件创建\n.env.development 等等\n\n> 因为在一些场景下，. 开头文件会出现问题，所以改用 _ 开头命名文件，创建时做一次替换。\n\n\n7. 调试 rust 代码#\n\n我们从 write 函数调用 createProject 函数，可以看到 createProject 等是从 @tarojs/binding 引入的。\n\n\n\n简单来说就是：通过 napi-rs 把 create_project 函数暴露给 nodejs ，然后通过 nodejs 调用 rust 的\ncreate_project 函数。\n\n关于具体细节，用 rust 改造 taro init 这部分代码的作者 @luckyadam，写了一篇文章。可以参考学习解锁前端新潜能：如何使用 Rust\n锈化前端工具链，我在这里就不赘述了。\n\n> 安装 VSCode 插件 rust-analyzer (方便跳转代码定义等) 和调试代码的插件 CodeLLDB\n\n更多 rust 学习，可参考 rust 官网：rust-lang.org\n\n我们在 .vscode/launch.json 中的原有的 debug-init 命令行调试配置，修改 \"type\": \"lldb\", 配置如下：\n\n\n\n这样我们就可以在 crates/native_binding/src/lib.rs 文件中打断点调试了。\n\n调试截图如下：\n\n我们继续来看 crates/native_binding/src/lib.rs 文件中的 create_project （ nodejs 中调用则是\ncreateProject ）函数：\n\n\n8. rust create_project 创建项目#\n\n\n\n我们重点来看一下 project.create 函数：\n\n\n8.1 create 创建文件#\n\n\n\ncreate 主要做了以下几件事情：\n\n 1. 创建项目目录\n 2. 创建项目文件 creator.create_files\n 3. 初始化 git init_git\n 4. 安装依赖 install_deps\n\n如下图所示：\n\n\n\n接着我们重点来看一下 creator.create_files 函数：\n\n\n8.2 creator.create_files#\n\n\n\n我们重点来看一下 creator.tempate 函数：\n\n\n8.3 creator.tempate 模板#\n\n\n\n我们重点来看一下 generate_with_template 函数：\n\n\n8.4 generate_with_template 根据数据渲染模板，生成文件#\n\n\n\ntaro init 的 rust代码中，安装依赖引入了crates/handlebars rust包，类似 npm 包管理官网。\n\n经过 HANDLEBARS.render_template(&from_template, data) handlebars-rust\n根据数据渲染模板，生成文件。\n\n比如：handlebars 模板中的 app.config.js => app.config.ts\n\n如下图所示：\n\n\n\n更多 handlebars 用法，参考handlebars官网。\n\n\n9. 总结#\n\n我们再来看下开头初始化项目的 gif 回顾下整个 taro init 过程：\n\n\n\n根据前面两篇 1. taro cli init、2. taro 插件机制 文章，我们可以得知：taro init 初始化命令，最终调用的是\npackages/taro-cli/src/presets/commands/init.ts 文件中的 ctx.registerCommand 注册的 init\n命令行的 fn 函数。\n\n可以根据配置 .vscode/launch.json 文件调试 taro init node 部分代码和 rust 配置 type:lldb 代码。\n\n\n\n\n\nask 命令行交互式选择使用的是 inquirer inquirer.prompt 实现。使用 download-git-repo 包（如果是 url 则用\naxios 下载）把远程仓库下载到本地移动到packages/taro-cli/templates。\n\n\n\n\n\nwrite 函数中的 createProject 创建文件部分是使用 rust 实现的。使用 napi-rs 包绑定 rust 代码，给 nodejs 调用。\n\n模板部分使用的是 handlebars，rust 使用的 handlebars rust 包 crates/handlebars rust 实现。\n\n根据数据渲染 handlebars 模板，创建项目，生成文件。\n\n再根据包管理器安装依赖。最后打印创建项目成功，请进入项目目录工作。\n\n整个 taro init 创建新项目流程用一张图表示如图所示：\n\n\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。也欢迎提建议和交流讨论。\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。若川的博客，github blog，可以点个 star 鼓励下持续创作。\n\n最后可以持续关注我@若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。","routePath":"/taro/cli-init-2/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 调试 taro init","id":"2-调试-taro-init","depth":2,"charIndex":1066},{"text":"3. init 命令行 fn 函数","id":"3-init-命令行-fn-函数","depth":2,"charIndex":1209},{"text":"4. new Project 构造函数","id":"4-new-project-构造函数","depth":2,"charIndex":1564},{"text":"4.1 project.create 创建项目","id":"41-projectcreate-创建项目","depth":3,"charIndex":2144},{"text":"5. ask 询问用户输入项目名称、描述等","id":"5-ask-询问用户输入项目名称描述等","depth":2,"charIndex":2346},{"text":"5.1 askProjectName 询问项目名称","id":"51-askprojectname-询问项目名称","depth":3,"charIndex":2804},{"text":"5.2 askTemplateSource 询问模板源","id":"52-asktemplatesource-询问模板源","depth":3,"charIndex":2937},{"text":"5.3 fetchTemplates 获取模板列表","id":"53-fetchtemplates-获取模板列表","depth":3,"charIndex":3228},{"text":"5.3.1 fetchTemplate 获取模板","id":"531-fetchtemplate-获取模板","depth":4,"charIndex":3296},{"text":"5.4 askTemplate 询问用户选择模板","id":"54-asktemplate-询问用户选择模板","depth":3,"charIndex":3670},{"text":"6. write 写入项目","id":"6-write-写入项目","depth":2,"charIndex":3700},{"text":"6.1 template_creator.js 默认模板中创建模板的自定义逻辑","id":"61-template_creatorjs-默认模板中创建模板的自定义逻辑","depth":3,"charIndex":3845},{"text":"7. 调试 rust 代码","id":"7-调试-rust-代码","depth":2,"charIndex":4183},{"text":"8. rust create_project 创建项目","id":"8-rust-create_project-创建项目","depth":2,"charIndex":4801},{"text":"8.1 create 创建文件","id":"81-create-创建文件","depth":3,"charIndex":4863},{"text":"8.2 creator.create_files","id":"82-creatorcreate_files","depth":3,"charIndex":5038},{"text":"8.3 creator.tempate 模板","id":"83-creatortempate-模板","depth":3,"charIndex":5098},{"text":"8.4 generate_with_template 根据数据渲染模板，生成文件","id":"84-generate_with_template-根据数据渲染模板生成文件","depth":3,"charIndex":5163},{"text":"9. 总结","id":"9-总结","depth":2,"charIndex":5454}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":97,"title":"","content":"1. 前言#\n\n大家好，我是若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。\n\n截至目前（2024-07-17），taro 正式版是 3.6.34，Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite\n编译等。文章提到将于 2024 年第二季度，发布 4.x。目前已经发布 4.x。所以我们直接学习 main 分支最新版本是 4.0.2。\n\n多编译内核生态下的极速研发体验 官方博客有如下图。\n\n\n\n计划写一个 taro 源码揭秘系列，欢迎持续关注。初步计划有如下文章：\n\n * Taro 源码揭秘 - 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密\n * Taro 源码揭秘 - 2. 揭开整个架构的插件系统的秘密\n * Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么\n * Taro 4.0 已正式发布 - 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？\n * Taro 4.0 已发布 - 5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？\n * 等等\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n\n\n看一个开源项目，第一步应该是先看 README.md 再看 贡献文档 和 package.json。\n\n环境准备\n\n> 需要安装 Node.js 16（建议安装 16.20.0 及以上版本）及 pnpm 7\n\n我使用的环境：mac，当然 Windows 一样可以。\n\n一般用 nvm 管理 node 版本。\n\n\n\n\n\n安装依赖可能会报错。\n\n\n\n\n\n通过谷歌等搜索引擎可以找到解决方法。\n\nstackoverflow\n\nMac : export PUPPETEER_SKIP_DOWNLOAD='true' Windows: SET\nPUPPETEER_SKIP_DOWNLOAD='true'\n\npnpm build 完成，如下图所示：\n\n\n\n\n3. 调试#\n\npackage.json\n\n\n\n\n3.1 入口文件 packages/taro-cli/bin/taro#\n\n\n\n\n3.2 调试方法 1 JavaScript Debug Terminal#\n\n可参考我的文章新手向：前端程序员必学基本技能——调试 JS 代码，或者据说 90%的人不知道可以用测试用例(Vitest)调试开源项目(Vue3) 源码\n\n简而言之就是以下步骤：\n\n\n\n\n\n本文将都是使用 init 命令作为示例。\n\n如下图所示：\n\n\n\n调试时应该会报错 binding taro.[os-platform].node。如下图所示：\n\n\n\n运行等过程报错，不要慌。可能是我们遗漏了一些细节，贡献文档等应该会给出答案。所以再来看下 贡献文档-10-rust-部分\n\n\n\n通过 rustup 找到安装命令：\n\n\n\n安装完成后，执行 pnpm run build:binding:debug 或 pnpm run binding:release\n编译出文件：crates/native_binding/taro.darwin-arm64.node。\n\n就完美解决了，调试时不会报错了。\n\n\n3.3 调试方式 2 配置 .vscode/launch.json#\n\ntaro 文档 - 单步调测配置 写的挺好的，通过配置 launch.json 来调试，在此就不再赘述了。\n\n不过补充一条：launch.json 文件可以添加一条 \"console\":\n\"integratedTerminal\"（集成终端）配置，就可以在调试终端输入内容。args 参数添加 init\n和指定要初始化项目的文件夹。当然调试其他的时候也可以修改为其他参数。比如args: [\"build\", \"--type\", \"weapp\",\n\"--watch\"]。\n\n\n\nvscode nodejs 调试\n\nconsole- 启动程序的控制台（internalConsole，integratedTerminal，externalTerminal）。\n\n\n\n\n\n我们跟着断点进入，入口文件中的第一句require(\"../dist/util\").printPkgVersion(); printPkgVersion 函数。\n\n\n4. taro-cli/src/utils/index.ts#\n\n工具函数\n\n\n\n可以看出这句输出的是 taro/packages/taro-cli/package.json 的版本号。\n\n\n\n我们继续跟着断点，进入第二第三句，可以进入到 packages/taro-cli/src/cli.ts 这个文件。\n\n\n5. CLI 整体结构#\n\ntaro-cli 对应的文件路径是：\n\n> packages/taro-cli/src/cli.ts\n\n我们先来看下这个文件的整体结构。class CLI 一个 appPath 属性（一般指 taro 工作目录），两个函数 run 和 parseArgs。\n\n\n\n使用了minimist，参数解析工具。\n\n同类工具还有： commander，命令行工具。功能齐全的框架，提供类似 git 的子命令系统，自动生成帮助信息等。有很多知名的 cli\n都是用的这个commander。比如：vue-cli、webpack-cli 和 create-react-app 用的是这个。\n\ncac，类似 Commander.js 但更轻巧、现代，支持插件。也有很多使用这个cac npm，比如vite 使用的是这个。\n\nyargs，交互式命令行工具。功能强大的框架，但显得过于臃肿。\n\ncli.run 函数最终调用的是 cli.parseArgs 函数。我们接着来看 parseArgs 函数。\n\n\n6. cli parseArgs#\n\n\n6.1 presets 预设插件集合#\n\n\n\npresets 对应的目录结构如图所示：\n\n\n\n\n6.2 Config#\n\n\n\n64-78 行代码，代码量相对较少，就截图同时顺便直接放代码了。\n\n\n\ndotenvParse 函数简单来说就是通过 dotenv 和 dotenv-expand 解析\n.env、.env.development、.env.production 等文件和变量的。\n\n> dotenv 是一个零依赖模块，可将 .env 文件中的环境变量加载到 process.env 中。\n\n我之前写过一篇 面试官：项目中常用的 .env 文件原理是什么？如何实现？\n\n接着我们来看 Config 类。\n\n\n\nConfig 构造函数有两个属性。 appPath 是 taro 项目路径。 disableGlobalConfig 是禁用全局配置。\n\n接着我们来看 Config 类的实例上的 init 方法。\n\n6.2.1 config.init 初始化配置#\n\n读取的是 config/index .ts 或者 .js 后缀。 判断是否禁用 disableGlobalConfig 全局配置。不禁用则读取全局配置\n~/.taro-global-config/index.json。\n\n\n\n值得一提的是：\n\n\n\ncreateSwcRegister 使用了 @swc/register 来编译 ts 等转换成 commonjs。可以直接用 require。\n\n> 使用 swc 的方法之一是通过 require 钩子。require 钩子会将自身绑定到 node 的 require 并自动动态编译文件。不过现在更推荐\n> @swc-node/register。\n\n\n\nthis.initialConfig = typeof userExport === 'function' ? await userExport(merge,\nconfigEnv) : userExport。这句就是 config/index.ts 支持函数也支持对象的实现。\n\n接着我们来看 Config 类的实例上的 initGlobalConfig 方法。\n\n6.2.2 config.initGlobalConfig 初始化全局配置#\n\n读取配置 ~/.taro-global-config/index.json。\n\n\n\n\n\ngetUserHomeDir 函数主要是获取用户的主页路径。比如 mac 中是 /Users/用户名/。 如果支持 os.homedir()\n直接获取返回，如果不支持则根据各种操作系统和环境变量判断获取。\n\nora 是控制台的 loading 小动画。\n\n> 优雅的终端旋转器\n\n这里的是 fs 是 @tarojs/helper 。\n\n> Taro 编译时工具库，主要供 CLI、编译器插件使用。\n\n导出的 fs-extra。\n\n> fs-extra 添加本机模块中未包含的文件系统方法 fs，并为这些方法添加承诺支持 fs。它还用于 graceful-fs 防止 EMFILE\n> 错误。它应该是 的替代品 fs。\n\n使用 fs.readJSONSync 同步读取 json 的方法。\n\n文档中也有对这个全局参数的描述。\n\n全局插件或插件集配置\n\n\n\nConfig 部分我们基本分析完成，接下来我们学习 Kernel （内核）部分。\n\n\n7. Kernel （内核）#\n\n\n\n接着我们来看 Kernel 类， Kernel 类继承自 Nodejs 的事件模块EventEmitter。\n\n\n\n\n\nthis.debugger 当没有配置 DEBUG 环境变量时，则 debugger 是空函数。配置了 process.env.DEBUG ===\n\"Taro:Kernel\" 为则调用的 npm 包 debug。\n\n> 一个仿照 Node.js 核心调试技术的微型 JavaScript 调试实用程序。适用于 Node.js 和 Web 浏览器。\n\n我们接着看构造器函数里调用的几个初始化函数，基本都是顾名知义。\n\n\n\n\n\n初始化后的参数，如 taro 官方文档 - 编写插件 api中所示。\n\n\n\n\n7.1 cli kernel.optsPlugins 等#\n\n\n\n我们接下来看，customCommand 函数。\n\n\n7.2 cli customCommand 函数#\n\n\n\n我们可以看到最终调用的是 customCommand 函数\n\n\n\ncustomCommand 函数移除一些 run 函数不需要的参数，最终调用的是 kernal.run 函数。\n\n接下来，我们来看 kernal.run 函数的具体实现。\n\n\n8. kernal.run 执行函数#\n\n\n\nrun 函数中，开头主要是兼容两种参数传递。\n\n\n9. kernal.setRunOpts#\n\n把参数先存起来。便于给插件使用。\n\n\n\nTaro 文档 - 编写插件 - ctx.runOpts\n\n\n\n我们接着来看，run 函数的下半部分。\n\n\n\nrun 函数下半部分主要有三个函数：\n\n\n\n我们分开叙述\n\n> this.initPresetsAndPlugins()函数，因为此处涉及到的代码相对较多，容易影响主线流程。所以本文在此先不展开深入学习了。将放在下一篇文\n> 章中详细讲述。\n\n执行 this.initPresetsAndPlugins() 函数之后。我们完全可以在调试时把 kernal 实例对象打印出来。\n\n我们来看插件的注册。\n\n\n10. kernal ctx.registerCommand 注册 init 命令#\n\n\n\n通过 ctx.registerCommand 注册了一个 name 为 init 的命令，会存入到内核 Kernal 实例对象的 hooks 属性中，其中\nctx 就是 Kernal 的实例对象。具体实现是 fn 函数。\n\n\n11. kernal.applyPlugins 触发插件#\n\n\n\n上半部分，主要是适配两种传参的方式。\n\n\n\nTaro 的插件架构基于 Tapable。\n\n这里使用了这个函数：AsyncSeriesWaterfallHook。\n\n> The hook type is reflected in its class name. E.g., AsyncSeriesWaterfallHook\n> allows asynchronous functions and runs them in series, passing each function’s\n> return value into the next function.\n\n简言之就是异步或者同步方法串联起来，上一个函数的结果作为下一个函数的参数依次执行。依次执行。\n\n这时让我想起一句小虎队的爱的歌词。\n\n> 喔，把你的心我的心串一串，串一株幸运草串一个同心圆...\n\n举个例子用户写的插件中有多个钩子函数。比如 onReday 等可以有多个。\n\n\n\n\n\napplyPlugins 根据执行的命令 init 从 hooks 取出，串起来，然后依次执行插件的 fn 方法。\n\n我们顺便来看一下，kernal.runHelp 的实现。\n\n\n12. kernal.runHelp 命令帮助信息#\n\n在 kernal.run 函数中，有一个 opts.isHelp 的判断，执行 kernal.runHelp 方法。\n\n\n\n以 taro init --help 为例。输出结果如下图所示：\n\n\n\n具体实现代码如下：\n\n\n\n根据 name 从 this.commands Map 中获取到命令，输出对应的 optionsMap 和 synopsisList。\n\n\n13. 总结#\n\n我们主要学了\n\n 1. 学会通过两种方式调试 taro 源码\n 2. 学会入口 taro-cli 具体实现方式\n 3. 学会 cli init 命令实现原理，读取用户项目配置文件和用户全局配置文件\n 4. 学会 taro-service kernal （内核）解耦实现\n 5. 初步学会 taro 插件架构，学会了如何编写一个 taro 插件\n\ntaro-cli 使用了minimist，命令行参数解析工具。\n\n使用了 @swc/register 读取 config/index .js 或者 .ts 配置文件和用 fs-extra fs.readJSONSync\n全局配置文件。\n\nCLI 部分有各种预设插件集合 presets。\n\ntaro 单独抽离了一个 tarojs/service (packages/taro-service) 模块，包含 Kernal\n内核、Config、Plugin 等。\n\ntaro 的基于 Tapable 的 AsyncSeriesWaterfallHook (把函数组合在一起串行)\n实现的插件机制。各个插件可以分开在各个地方，达到解耦效果。非常值得我们学习。\n\n简单做了一个本文的总结图。\n\n\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。若川的博客，github blog，可以点个 star 鼓励下持续创作。\n\n最后可以持续关注我@若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。","routePath":"/taro/cli-init/README.juejin","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":-1},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":656},{"text":"3. 调试","id":"3-调试","depth":2,"charIndex":992},{"text":"3.1 入口文件 packages/taro-cli/bin/taro","id":"31-入口文件-packagestaro-clibintaro","depth":3,"charIndex":1017},{"text":"3.2 调试方法 1 JavaScript Debug Terminal","id":"32-调试方法-1-javascript-debug-terminal","depth":3,"charIndex":1058},{"text":"3.3 调试方式 2 配置 .vscode/launch.json","id":"33-调试方式-2-配置-vscodelaunchjson","depth":3,"charIndex":1497},{"text":"4. taro-cli/src/utils/index.ts","id":"4-taro-clisrcutilsindexts","depth":2,"charIndex":1948},{"text":"5. CLI 整体结构","id":"5-cli-整体结构","depth":2,"charIndex":2105},{"text":"6. cli parseArgs","id":"6-cli-parseargs","depth":2,"charIndex":2562},{"text":"6.1 presets 预设插件集合","id":"61-presets-预设插件集合","depth":3,"charIndex":2582},{"text":"6.2 Config","id":"62-config","depth":3,"charIndex":2630},{"text":"6.2.1 config.init 初始化配置","id":"621-configinit-初始化配置","depth":4,"charIndex":2991},{"text":"6.2.2 config.initGlobalConfig 初始化全局配置","id":"622-configinitglobalconfig-初始化全局配置","depth":4,"charIndex":3502},{"text":"7. Kernel （内核）","id":"7-kernel-内核","depth":2,"charIndex":4006},{"text":"7.1 cli kernel.optsPlugins 等","id":"71-cli-kerneloptsplugins-等","depth":3,"charIndex":4336},{"text":"7.2 cli customCommand 函数","id":"72-cli-customcommand-函数","depth":3,"charIndex":4396},{"text":"8. kernal.run 执行函数","id":"8-kernalrun-执行函数","depth":2,"charIndex":4546},{"text":"9. kernal.setRunOpts","id":"9-kernalsetrunopts","depth":2,"charIndex":4594},{"text":"10. kernal ctx.registerCommand 注册 init 命令","id":"10-kernal-ctxregistercommand-注册-init-命令","depth":2,"charIndex":4894},{"text":"11. kernal.applyPlugins 触发插件","id":"11-kernalapplyplugins-触发插件","depth":2,"charIndex":5053},{"text":"12. kernal.runHelp 命令帮助信息","id":"12-kernalrunhelp-命令帮助信息","depth":2,"charIndex":5600},{"text":"13. 总结","id":"13-总结","depth":2,"charIndex":5809}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":98,"title":"Taro 源码揭秘 - 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。\n\n截至目前（2024-07-17），taro 正式版是 3.6.34，Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite\n编译等。文章提到将于 2024 年第二季度，发布 4.x。目前已经发布 4.x。所以我们直接学习 main 分支最新版本是 4.0.2。\n\n多编译内核生态下的极速研发体验 官方博客有如下图。\n\n\n\n计划写一个 taro 源码揭秘系列，欢迎持续关注。初步计划有如下文章：\n\n * Taro 源码揭秘 - 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密\n * Taro 源码揭秘 - 2. 揭开整个架构的插件系统的秘密\n * Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么\n * Taro 4.0 已正式发布 - 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？\n * Taro 4.0 已发布 - 5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？\n * 等等\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n\n\n看一个开源项目，第一步应该是先看 README.md 再看 贡献文档 和 package.json。\n\n环境准备\n\n> 需要安装 Node.js 16（建议安装 16.20.0 及以上版本）及 pnpm 7\n\n我使用的环境：mac，当然 Windows 一样可以。\n\n一般用 nvm 管理 node 版本。\n\n\n\n\n\n安装依赖可能会报错。\n\n\n\n\n\n通过谷歌等搜索引擎可以找到解决方法。\n\nstackoverflow\n\nMac : export PUPPETEER_SKIP_DOWNLOAD='true' Windows: SET\nPUPPETEER_SKIP_DOWNLOAD='true'\n\npnpm build 完成，如下图所示：\n\n\n\n\n3. 调试#\n\npackage.json\n\n\n\n\n3.1 入口文件 packages/taro-cli/bin/taro#\n\n\n\n\n3.2 调试方法 1 JavaScript Debug Terminal#\n\n可参考我的文章新手向：前端程序员必学基本技能——调试 JS 代码，或者据说 90%的人不知道可以用测试用例(Vitest)调试开源项目(Vue3) 源码\n\n简而言之就是以下步骤：\n\n\n\n\n\n本文将都是使用 init 命令作为示例。\n\n如下图所示：\n\n\n\n调试时应该会报错 binding taro.[os-platform].node。如下图所示：\n\n\n\n运行等过程报错，不要慌。可能是我们遗漏了一些细节，贡献文档等应该会给出答案。所以再来看下 贡献文档-10-rust-部分\n\n\n\n通过 rustup 找到安装命令：\n\n\n\n安装完成后，执行 pnpm run build:binding:debug 或 pnpm run binding:release\n编译出文件：crates/native_binding/taro.darwin-arm64.node。\n\n就完美解决了，调试时不会报错了。\n\n\n3.3 调试方式 2 配置 .vscode/launch.json#\n\ntaro 文档 - 单步调测配置 写的挺好的，通过配置 launch.json 来调试，在此就不再赘述了。\n\n不过补充一条：launch.json 文件可以添加一条 \"console\":\n\"integratedTerminal\"（集成终端）配置，就可以在调试终端输入内容。args 参数添加 init\n和指定要初始化项目的文件夹。当然调试其他的时候也可以修改为其他参数。比如args: [\"build\", \"--type\", \"weapp\",\n\"--watch\"]。\n\n\n\nvscode nodejs 调试\n\nconsole- 启动程序的控制台（internalConsole，integratedTerminal，externalTerminal）。\n\n\n\n\n\n我们跟着断点进入，入口文件中的第一句require(\"../dist/util\").printPkgVersion(); printPkgVersion 函数。\n\n\n4. taro-cli/src/utils/index.ts#\n\n工具函数\n\n\n\n可以看出这句输出的是 taro/packages/taro-cli/package.json 的版本号。\n\n\n\n我们继续跟着断点，进入第二第三句，可以进入到 packages/taro-cli/src/cli.ts 这个文件。\n\n\n5. CLI 整体结构#\n\ntaro-cli 对应的文件路径是：\n\n> packages/taro-cli/src/cli.ts\n\n我们先来看下这个文件的整体结构。class CLI 一个 appPath 属性（一般指 taro 工作目录），两个函数 run 和 parseArgs。\n\n\n\n使用了minimist，参数解析工具。\n\n同类工具还有： commander，命令行工具。功能齐全的框架，提供类似 git 的子命令系统，自动生成帮助信息等。有很多知名的 cli\n都是用的这个commander。比如：vue-cli、webpack-cli 和 create-react-app 用的是这个。\n\ncac，类似 Commander.js 但更轻巧、现代，支持插件。也有很多使用这个cac npm，比如vite 使用的是这个。\n\nyargs，交互式命令行工具。功能强大的框架，但显得过于臃肿。\n\ncli.run 函数最终调用的是 cli.parseArgs 函数。我们接着来看 parseArgs 函数。\n\n\n6. cli parseArgs#\n\n\n6.1 presets 预设插件集合#\n\n\n\npresets 对应的目录结构如图所示：\n\n\n\n\n6.2 Config#\n\n\n\n64-78 行代码，代码量相对较少，就截图同时顺便直接放代码了。\n\n\n\ndotenvParse 函数简单来说就是通过 dotenv 和 dotenv-expand 解析\n.env、.env.development、.env.production 等文件和变量的。\n\n> dotenv 是一个零依赖模块，可将 .env 文件中的环境变量加载到 process.env 中。\n\n我之前写过一篇 面试官：项目中常用的 .env 文件原理是什么？如何实现？\n\n接着我们来看 Config 类。\n\n\n\nConfig 构造函数有两个属性。 appPath 是 taro 项目路径。 disableGlobalConfig 是禁用全局配置。\n\n接着我们来看 Config 类的实例上的 init 方法。\n\n6.2.1 config.init 初始化配置#\n\n读取的是 config/index .ts 或者 .js 后缀。 判断是否禁用 disableGlobalConfig 全局配置。不禁用则读取全局配置\n~/.taro-global-config/index.json。\n\n\n\n值得一提的是：\n\n\n\ncreateSwcRegister 使用了 @swc/register 来编译 ts 等转换成 commonjs。可以直接用 require。\n\n> 使用 swc 的方法之一是通过 require 钩子。require 钩子会将自身绑定到 node 的 require 并自动动态编译文件。不过现在更推荐\n> @swc-node/register。\n\n\n\nthis.initialConfig = typeof userExport === 'function' ? await userExport(merge,\nconfigEnv) : userExport。这句就是 config/index.ts 支持函数也支持对象的实现。\n\n接着我们来看 Config 类的实例上的 initGlobalConfig 方法。\n\n6.2.2 config.initGlobalConfig 初始化全局配置#\n\n读取配置 ~/.taro-global-config/index.json。\n\n\n\n\n\ngetUserHomeDir 函数主要是获取用户的主页路径。比如 mac 中是 /Users/用户名/。 如果支持 os.homedir()\n直接获取返回，如果不支持则根据各种操作系统和环境变量判断获取。\n\nora 是控制台的 loading 小动画。\n\n> 优雅的终端旋转器\n\n这里的是 fs 是 @tarojs/helper 。\n\n> Taro 编译时工具库，主要供 CLI、编译器插件使用。\n\n导出的 fs-extra。\n\n> fs-extra 添加本机模块中未包含的文件系统方法 fs，并为这些方法添加承诺支持 fs。它还用于 graceful-fs 防止 EMFILE\n> 错误。它应该是 的替代品 fs。\n\n使用 fs.readJSONSync 同步读取 json 的方法。\n\n文档中也有对这个全局参数的描述。\n\n全局插件或插件集配置\n\n\n\nConfig 部分我们基本分析完成，接下来我们学习 Kernel （内核）部分。\n\n\n7. Kernel （内核）#\n\n\n\n接着我们来看 Kernel 类， Kernel 类继承自 Nodejs 的事件模块EventEmitter。\n\n\n\n\n\nthis.debugger 当没有配置 DEBUG 环境变量时，则 debugger 是空函数。配置了 process.env.DEBUG ===\n\"Taro:Kernel\" 为则调用的 npm 包 debug。\n\n> 一个仿照 Node.js 核心调试技术的微型 JavaScript 调试实用程序。适用于 Node.js 和 Web 浏览器。\n\n我们接着看构造器函数里调用的几个初始化函数，基本都是顾名知义。\n\n\n\n\n\n初始化后的参数，如 taro 官方文档 - 编写插件 api中所示。\n\n\n\n\n7.1 cli kernel.optsPlugins 等#\n\n\n\n我们接下来看，customCommand 函数。\n\n\n7.2 cli customCommand 函数#\n\n\n\n我们可以看到最终调用的是 customCommand 函数\n\n\n\ncustomCommand 函数移除一些 run 函数不需要的参数，最终调用的是 kernal.run 函数。\n\n接下来，我们来看 kernal.run 函数的具体实现。\n\n\n8. kernal.run 执行函数#\n\n\n\nrun 函数中，开头主要是兼容两种参数传递。\n\n\n9. kernal.setRunOpts#\n\n把参数先存起来。便于给插件使用。\n\n\n\nTaro 文档 - 编写插件 - ctx.runOpts\n\n\n\n我们接着来看，run 函数的下半部分。\n\n\n\nrun 函数下半部分主要有三个函数：\n\n\n\n我们分开叙述\n\n> this.initPresetsAndPlugins()函数，因为此处涉及到的代码相对较多，容易影响主线流程。所以本文在此先不展开深入学习了。将放在下一篇文\n> 章中详细讲述。\n\n执行 this.initPresetsAndPlugins() 函数之后。我们完全可以在调试时把 kernal 实例对象打印出来。\n\n我们来看插件的注册。\n\n\n10. kernal ctx.registerCommand 注册 init 命令#\n\n\n\n通过 ctx.registerCommand 注册了一个 name 为 init 的命令，会存入到内核 Kernal 实例对象的 hooks 属性中，其中\nctx 就是 Kernal 的实例对象。具体实现是 fn 函数。\n\n\n11. kernal.applyPlugins 触发插件#\n\n\n\n上半部分，主要是适配两种传参的方式。\n\n\n\nTaro 的插件架构基于 Tapable。\n\n这里使用了这个函数：AsyncSeriesWaterfallHook。\n\n> The hook type is reflected in its class name. E.g., AsyncSeriesWaterfallHook\n> allows asynchronous functions and runs them in series, passing each function’s\n> return value into the next function.\n\n简言之就是异步或者同步方法串联起来，上一个函数的结果作为下一个函数的参数依次执行。依次执行。\n\n这时让我想起一句小虎队的爱的歌词。\n\n> 喔，把你的心我的心串一串，串一株幸运草串一个同心圆...\n\n举个例子用户写的插件中有多个钩子函数。比如 onReday 等可以有多个。\n\n\n\n\n\napplyPlugins 根据执行的命令 init 从 hooks 取出，串起来，然后依次执行插件的 fn 方法。\n\n我们顺便来看一下，kernal.runHelp 的实现。\n\n\n12. kernal.runHelp 命令帮助信息#\n\n在 kernal.run 函数中，有一个 opts.isHelp 的判断，执行 kernal.runHelp 方法。\n\n\n\n以 taro init --help 为例。输出结果如下图所示：\n\n\n\n具体实现代码如下：\n\n\n\n根据 name 从 this.commands Map 中获取到命令，输出对应的 optionsMap 和 synopsisList。\n\n\n13. 总结#\n\n我们主要学了\n\n 1. 学会通过两种方式调试 taro 源码\n 2. 学会入口 taro-cli 具体实现方式\n 3. 学会 cli init 命令实现原理，读取用户项目配置文件和用户全局配置文件\n 4. 学会 taro-service kernal （内核）解耦实现\n 5. 初步学会 taro 插件架构，学会了如何编写一个 taro 插件\n\ntaro-cli 使用了minimist，命令行参数解析工具。\n\n使用了 @swc/register 读取 config/index .js 或者 .ts 配置文件和用 fs-extra fs.readJSONSync\n全局配置文件。\n\nCLI 部分有各种预设插件集合 presets。\n\ntaro 单独抽离了一个 tarojs/service (packages/taro-service) 模块，包含 Kernal\n内核、Config、Plugin 等。\n\ntaro 的基于 Tapable 的 AsyncSeriesWaterfallHook (把函数组合在一起串行)\n实现的插件机制。各个插件可以分开在各个地方，达到解耦效果。非常值得我们学习。\n\n简单做了一个本文的总结图。\n\n\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。若川的博客，github blog，可以点个 star 鼓励下持续创作。\n\n最后可以持续关注我@若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。","routePath":"/taro/cli-init/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":660},{"text":"3. 调试","id":"3-调试","depth":2,"charIndex":996},{"text":"3.1 入口文件 packages/taro-cli/bin/taro","id":"31-入口文件-packagestaro-clibintaro","depth":3,"charIndex":1021},{"text":"3.2 调试方法 1 JavaScript Debug Terminal","id":"32-调试方法-1-javascript-debug-terminal","depth":3,"charIndex":1062},{"text":"3.3 调试方式 2 配置 .vscode/launch.json","id":"33-调试方式-2-配置-vscodelaunchjson","depth":3,"charIndex":1501},{"text":"4. taro-cli/src/utils/index.ts","id":"4-taro-clisrcutilsindexts","depth":2,"charIndex":1952},{"text":"5. CLI 整体结构","id":"5-cli-整体结构","depth":2,"charIndex":2109},{"text":"6. cli parseArgs","id":"6-cli-parseargs","depth":2,"charIndex":2566},{"text":"6.1 presets 预设插件集合","id":"61-presets-预设插件集合","depth":3,"charIndex":2586},{"text":"6.2 Config","id":"62-config","depth":3,"charIndex":2634},{"text":"6.2.1 config.init 初始化配置","id":"621-configinit-初始化配置","depth":4,"charIndex":2995},{"text":"6.2.2 config.initGlobalConfig 初始化全局配置","id":"622-configinitglobalconfig-初始化全局配置","depth":4,"charIndex":3506},{"text":"7. Kernel （内核）","id":"7-kernel-内核","depth":2,"charIndex":4010},{"text":"7.1 cli kernel.optsPlugins 等","id":"71-cli-kerneloptsplugins-等","depth":3,"charIndex":4340},{"text":"7.2 cli customCommand 函数","id":"72-cli-customcommand-函数","depth":3,"charIndex":4400},{"text":"8. kernal.run 执行函数","id":"8-kernalrun-执行函数","depth":2,"charIndex":4550},{"text":"9. kernal.setRunOpts","id":"9-kernalsetrunopts","depth":2,"charIndex":4598},{"text":"10. kernal ctx.registerCommand 注册 init 命令","id":"10-kernal-ctxregistercommand-注册-init-命令","depth":2,"charIndex":4898},{"text":"11. kernal.applyPlugins 触发插件","id":"11-kernalapplyplugins-触发插件","depth":2,"charIndex":5057},{"text":"12. kernal.runHelp 命令帮助信息","id":"12-kernalrunhelp-命令帮助信息","depth":2,"charIndex":5604},{"text":"13. 总结","id":"13-总结","depth":2,"charIndex":5813}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":99,"title":"","content":"1. 前言#\n\n大家好，我是若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.8k+人）第一的专栏，写有几十篇源码文章。\n\n截至目前（2024-07-17），taro 正式版是 3.6.34，Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite\n编译等。文章提到将于 2024 年第二季度，发布 4.x。目前已经发布 4.x。所以我们直接学习 main 分支最新版本是 4.0.2。\n\n计划写一个 taro 源码揭秘系列，欢迎持续关注。初步计划有如下文章：\n\n * Taro 源码揭秘 - 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密\n * Taro 源码揭秘 - 2. 揭开整个架构的插件系统的秘密\n * Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么\n * Taro 4.0 已正式发布 - 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？\n * Taro 4.0 已发布 - 5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？\n * 等等\n\n学完本文，你将学到：\n\n\n\n关于克隆项目、环境准备、如何调试代码等，参考第一篇文章-准备工作、调试。后续文章基本不再过多赘述。\n\n上一篇文章中提到 CLI 最终执行的是 Kernel (内核) 中的 run 函数，其中 this.initPresetsAndPlugins\n初始化预设插件集合和插件没讲述。\n\n我们先来回顾一下上文中的 Kernal 构造函数。文章中基本是先放源码，源码中不做过多解释。源码后面再做简单讲述。\n\n\n2. new Kernal 构造函数#\n\n\n\n执行完 initPresetsAndPlugins 之后，这里以 init 为例。 使用 JavaScript 调试终端，输入 node\n./packages/taro-cli/bin/taro init taro-init-debug 调试。 我们可以在\npackages/taro-service/dist/Kernel.js 打印 this 出来。\n\n如下图所示：\n\n\n\n本文我们主要是学习 initPresetsAndPlugins 具体实现。\n\n我们继续来分析这个函数的具体实现，也就是说来看 Taro 的插件机制是如何实现的。可以打开Taro文档 - 使用插件和编写插件 配合看可能效果更佳。\n\n本文讲述的函数源码位置是 packages/taro-service/src/Kernel.ts。 基本包含在下图中。\n\n\n\n我们来看 CLI 调用 new Kernal 的地方，源码所在位置 packages/taro-cli/src/cli.ts\n\n\n\n本文以 init 命令为例，那么 kernel.optsPlugins 这里则注入的是 command/init.js 插件。\n\n\n\n传入的参数 presets 预设插件集合如下图所示：\n\n\n\n其中 hooks/build.js 如下图所示：\n\n\n\n使用 ctx.registerMethod 注册方法。其中 ctx 就是 Kernal 实例对象。\n\n\n\n源码实现如下，存入到 methods Map 中。后面我们会再次遇到它。\n\n\n\n\n3. initPresetsAndPlugins 初始化预设插件集合和插件#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. mergePlugins 合并预设插件集合和插件\n>  2. convertPluginsToObject 转换全局配置里的插件集和插件为对象\n>  3. 非测试环境，createSwcRegister 使用了 @swc/register 来编译 ts 等转换成 commonjs。可以直接用\n>     require 读取文件。\n>  4. resolvePresets 解析预设插件集合和 resolvePlugins 解析插件\n\n\n3.1 工具函数 mergePlugins、convertPluginsToObject#\n\n\n\n\n\n我们来看解析插件集合 resolvePresets。\n\n\n4. resolvePresets 解析预设插件集合#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. resolvedCliAndProjectPresets 解析 cli 和项目配置的预设插件集合\n>  2. resolvedGlobalPresets 解析全局的预设插件集合\n\n其中主要有两个函数，我们分开讲述 resolvePresetsOrPlugins initPreset。\n\n执行后 resolvePresetsOrPlugins 函数得到的 resolvedCliAndProjectPresets 如图所示：\n\n\n\nglobalConfigRootPath 路径是： /Users/用户名/.taro-global-config\n\n全局 .taro-global-config/index.json 我们默认是没有配置预设插件集合的。\n\n\n\n我们接着具体断点调试来看 resolvePresetsOrPlugins。\n\n\n4.1 resolvePresetsOrPlugins 解析插件集或者插件#\n\n\n\n代码看起来很长，但主要就是使用 resolve.sync 获取路径。\n\n\n\n组成这样的数组对象返回。\n\n我们接着来看 this.initPreset 的具体实现。\n\n\n5. initPreset 初始化预设插件集合#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. initPluginCtx 初始化插件 ctx\n>  2. 执行插件，获得预设插件集合和插件。\n>  3. 注册插件\n>  4. 如果预设插件集合是数组继续递归调用。\n>  5. 如果插件是数组，是全局插件就合并到全局额外的插件 globalExtraPlugins 中，否则就合并到额外的插件 extraPlugins\n>     中。后面统一处理插件。\n\n我们分别来看 initPluginCtx、registerPlugin 的实现。\n\n\n6. initPluginCtx 初始化插件 ctx#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. new Plugin 生成插件的 pluginCtx\n>  2. internalMethods 内部方法 注册到 ctx.onReady ctx.onStart\n>  3. this.methods 数组绑定 this 指向到 Kernal 实例对象上\n>  4. kernelApis 的方法，代理绑定下 this 指向到 Kernal 实例对象上。\n\n\n\n因为 new Proxy 代理后，可以直接使用 ctx.methodName 直接调用相应方法。\n\n我们接着来看，class Plugin 的具体实现。\n\n\n6.1 new Plugin({ id, path, ctx })#\n\n\n\n6.1.1 register 注册 hook#\n\n\n\n判断下 name 和 fn，最后存入 hooks 的值。可以通过 this.applyPlugins()触发插件。\n\n第一篇文章 kernal.applyPlugins 触发插件，有提到，此处就不在赘述。\n\n6.1.2 registerCommand 注册方法#\n\n\n\n存入到 commands Map 中。而且再通过 this.register(command) 存入到 hooks 中。便于在\nthis.applyPlugins() 使用。\n\ncommand 和 hooks 如下图所示：\n\n\n\n6.1.3 registerPlatform 注册平台#\n\n\n\n同样存入到 platforms 中。同时存入到 hooks 中。\n\n6.1.4 registerMethod 注册方法#\n\n\n\n前文提到。没有函数，则会存入到 hooks 中。\n\n\n\nprocessArgs 函数主要就是统一下不同传参形式，最终都是返回 name 和 fn。\n\n6.1.5 addPluginOptsSchema 添加插件的参数 Schema#\n\n\n\n我们接着来看，注册插件函数。\n\n\n7. registerPlugin 注册插件#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. 注册插件到 plugins Map 中。\n\n最终的插件 plugins 如图所示：\n\n\n\n\n8. resolvePlugins 解析插件#\n\n解析插件和解析预设插件集合类似。\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. 合并预设插件集合中的插件、CLI 和项目中配置的插件\n>  2. resolvedCliAndProjectPlugins CLI 和项目中配置的插件\n>  3. 合并全局预设插件集合中的插件、全局配置的插件\n>  4. 最后遍历所有解析后的插件一次调用 this.initPlugin 初始化插件\n\n\n9. initPlugin 初始化插件#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. initPluginCtx 初始化插件的 ctx\n>  2. 注册插件\n>  3. apply 执行插件，插件本身也是一个函数，传入插件 pluginCtx 对象（包含\n>     register、registerCommand、registerMethods 等方法的对象），作为 ctx，传入参数 opts\n>  4. 校验插件的参数是否符合要求\n\n\n10. checkPluginOpts 校验插件的参数#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. 使用 joi 最强大的 JavaScript 模式描述语言和数据验证器。校验插件参数 schema。\n\n搜索整个项目中，好像只有 plugin-mini-ci 插件中加了这个参数校验。\n\n\n\nKernal 实例对象中还有一个方法，顺便提一下。\n\n\n11. applyCliCommandPlugin 暴露 taro cli 内部命令插件#\n\n\n\n\n\n\n12. 总结#\n\n我们学了\n\n\n\n以 command/init.ts 插件为例。\n\n\n\n非测试环境，先通过 createSwcRegister 使用了 @swc/register 来编译 ts 等转换成 commonjs。可以直接用 require\n读取文件。\n\n\n\n最终的插件 plugins 如图所示：\n\n\n\n\n\n再 apply 执行插件，插件本身也是一个函数，传入插件 pluginCtx 对象（包含\nregister、registerCommand、registerMethods 等方法的对象），作为 ctx，传入参数 opts。\n\n而这三个方法最终都是会调用 Plugin 实例对象的 register 方法，把方法存入到 Kernal 实例对象中的 hooks 属性中。\n\n\n\n然后再通过 Kernal 实例对象中的 run 函数里的 applyPlugins 链接里有函数具体实现 方法。\n\n从 Kernal 的实例对象中，取出相应的 hooks，使用 tapable 的 AsyncSeriesWaterfallHook 钩子串联起来，依次执行\nhook.fn 方法。\n\n调试如图所示：\n\n\n\n从而达到调用的是 command/init.ts 中的 fn 函数。不得不惊叹一声：Taro 插件机制设计的秒啊。\n\n强烈建议读者朋友们，空闲时自己看着文章，多尝试调试源码。单看文章，可能觉得看懂了，但自己调试可能会发现更多细节，收获更多。\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。若川的博客，github blog，可以点个 star 鼓励下持续创作。\n\n最后可以持续关注我@若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.8k+人）第一的专栏，写有几十篇源码文章。","routePath":"/taro/cli-plugins/README.juejin","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":-1},{"text":"2. new Kernal 构造函数","id":"2-new-kernal-构造函数","depth":2,"charIndex":829},{"text":"3. initPresetsAndPlugins 初始化预设插件集合和插件","id":"3-initpresetsandplugins-初始化预设插件集合和插件","depth":2,"charIndex":1504},{"text":"3.1 工具函数 mergePlugins、convertPluginsToObject","id":"31-工具函数-mergepluginsconvertpluginstoobject","depth":3,"charIndex":1788},{"text":"4. resolvePresets 解析预设插件集合","id":"4-resolvepresets-解析预设插件集合","depth":2,"charIndex":1868},{"text":"4.1 resolvePresetsOrPlugins 解析插件集或者插件","id":"41-resolvepresetsorplugins-解析插件集或者插件","depth":3,"charIndex":2290},{"text":"5. initPreset 初始化预设插件集合","id":"5-initpreset-初始化预设插件集合","depth":2,"charIndex":2416},{"text":"6. initPluginCtx 初始化插件 ctx","id":"6-initpluginctx-初始化插件-ctx","depth":2,"charIndex":2689},{"text":"6.1 new Plugin({ id, path, ctx })","id":"61-new-plugin-id-path-ctx-","depth":3,"charIndex":3002},{"text":"6.1.1 register 注册 hook","id":"611-register-注册-hook","depth":4,"charIndex":3040},{"text":"6.1.2 registerCommand 注册方法","id":"612-registercommand-注册方法","depth":4,"charIndex":3171},{"text":"6.1.3 registerPlatform 注册平台","id":"613-registerplatform-注册平台","depth":4,"charIndex":3317},{"text":"6.1.4 registerMethod 注册方法","id":"614-registermethod-注册方法","depth":4,"charIndex":3383},{"text":"6.1.5 addPluginOptsSchema 添加插件的参数 Schema","id":"615-addpluginoptsschema-添加插件的参数-schema","depth":4,"charIndex":3488},{"text":"7. registerPlugin 注册插件","id":"7-registerplugin-注册插件","depth":2,"charIndex":3550},{"text":"8. resolvePlugins 解析插件","id":"8-resolveplugins-解析插件","depth":2,"charIndex":3645},{"text":"9. initPlugin 初始化插件","id":"9-initplugin-初始化插件","depth":2,"charIndex":3864},{"text":"10. checkPluginOpts 校验插件的参数","id":"10-checkpluginopts-校验插件的参数","depth":2,"charIndex":4089},{"text":"11. applyCliCommandPlugin 暴露 taro cli 内部命令插件","id":"11-applyclicommandplugin-暴露-taro-cli-内部命令插件","depth":2,"charIndex":4267},{"text":"12. 总结","id":"12-总结","depth":2,"charIndex":4319}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":100,"title":"Taro 源码揭秘 - 2. 揭开整个架构的插件系统的秘密","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。\n\n截至目前（2024-07-17），taro 正式版是 3.6.34，Taro 4.0 Beta 发布：支持开发鸿蒙应用、小程序编译模式、Vite\n编译等。文章提到将于 2024 年第二季度，发布 4.x。目前已经发布 4.x。所以我们直接学习 main 分支最新版本是 4.0.2。\n\n计划写一个 taro 源码揭秘系列，欢迎持续关注。初步计划有如下文章：\n\n * Taro 源码揭秘 - 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密\n * Taro 源码揭秘 - 2. 揭开整个架构的插件系统的秘密\n * Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么\n * Taro 4.0 已正式发布 - 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？\n * Taro 4.0 已发布 - 5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？\n * 等等\n\n学完本文，你将学到：\n\n\n\n关于克隆项目、环境准备、如何调试代码等，参考第一篇文章-准备工作、调试。后续文章基本不再过多赘述。\n\n上一篇文章中提到 CLI 最终执行的是 Kernel (内核) 中的 run 函数，其中 this.initPresetsAndPlugins\n初始化预设插件集合和插件没讲述。\n\n我们先来回顾一下上文中的 Kernal 构造函数。文章中基本是先放源码，源码中不做过多解释。源码后面再做简单讲述。\n\n\n2. new Kernal 构造函数#\n\n\n\n执行完 initPresetsAndPlugins 之后，这里以 init 为例。 使用 JavaScript 调试终端，输入 node\n./packages/taro-cli/bin/taro init taro-init-debug 调试。 我们可以在\npackages/taro-service/dist/Kernel.js 打印 this 出来。\n\n如下图所示：\n\n\n\n本文我们主要是学习 initPresetsAndPlugins 具体实现。\n\n我们继续来分析这个函数的具体实现，也就是说来看 Taro 的插件机制是如何实现的。可以打开Taro文档 - 使用插件和编写插件 配合看可能效果更佳。\n\n本文讲述的函数源码位置是 packages/taro-service/src/Kernel.ts。 基本包含在下图中。\n\n\n\n我们来看 CLI 调用 new Kernal 的地方，源码所在位置 packages/taro-cli/src/cli.ts\n\n\n\n本文以 init 命令为例，那么 kernel.optsPlugins 这里则注入的是 command/init.js 插件。\n\n\n\n传入的参数 presets 预设插件集合如下图所示：\n\n\n\n其中 hooks/build.js 如下图所示：\n\n\n\n使用 ctx.registerMethod 注册方法。其中 ctx 就是 Kernal 实例对象。\n\n\n\n源码实现如下，存入到 methods Map 中。后面我们会再次遇到它。\n\n\n\n\n3. initPresetsAndPlugins 初始化预设插件集合和插件#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. mergePlugins 合并预设插件集合和插件\n>  2. convertPluginsToObject 转换全局配置里的插件集和插件为对象\n>  3. 非测试环境，createSwcRegister 使用了 @swc/register 来编译 ts 等转换成 commonjs。可以直接用\n>     require 读取文件。\n>  4. resolvePresets 解析预设插件集合和 resolvePlugins 解析插件\n\n\n3.1 工具函数 mergePlugins、convertPluginsToObject#\n\n\n\n\n\n我们来看解析插件集合 resolvePresets。\n\n\n4. resolvePresets 解析预设插件集合#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. resolvedCliAndProjectPresets 解析 cli 和项目配置的预设插件集合\n>  2. resolvedGlobalPresets 解析全局的预设插件集合\n\n其中主要有两个函数，我们分开讲述 resolvePresetsOrPlugins initPreset。\n\n执行后 resolvePresetsOrPlugins 函数得到的 resolvedCliAndProjectPresets 如图所示：\n\n\n\nglobalConfigRootPath 路径是： /Users/用户名/.taro-global-config\n\n全局 .taro-global-config/index.json 我们默认是没有配置预设插件集合的。\n\n\n\n我们接着具体断点调试来看 resolvePresetsOrPlugins。\n\n\n4.1 resolvePresetsOrPlugins 解析插件集或者插件#\n\n\n\n代码看起来很长，但主要就是使用 resolve.sync 获取路径。\n\n\n\n组成这样的数组对象返回。\n\n我们接着来看 this.initPreset 的具体实现。\n\n\n5. initPreset 初始化预设插件集合#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. initPluginCtx 初始化插件 ctx\n>  2. 执行插件，获得预设插件集合和插件。\n>  3. 注册插件\n>  4. 如果预设插件集合是数组继续递归调用。\n>  5. 如果插件是数组，是全局插件就合并到全局额外的插件 globalExtraPlugins 中，否则就合并到额外的插件 extraPlugins\n>     中。后面统一处理插件。\n\n我们分别来看 initPluginCtx、registerPlugin 的实现。\n\n\n6. initPluginCtx 初始化插件 ctx#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. new Plugin 生成插件的 pluginCtx\n>  2. internalMethods 内部方法 注册到 ctx.onReady ctx.onStart\n>  3. this.methods 数组绑定 this 指向到 Kernal 实例对象上\n>  4. kernelApis 的方法，代理绑定下 this 指向到 Kernal 实例对象上。\n\n。\n\n因为 new Proxy 代理后，可以直接使用 ctx.methodName 直接调用相应方法。\n\n我们接着来看，class Plugin 的具体实现。\n\n\n6.1 new Plugin({ id, path, ctx })#\n\n\n\n6.1.1 register 注册 hook#\n\n\n\n判断下 name 和 fn，最后存入 hooks 的值。可以通过 this.applyPlugins()触发插件。\n\n第一篇文章 kernal.applyPlugins 触发插件，有提到，此处就不在赘述。\n\n6.1.2 registerCommand 注册方法#\n\n\n\n存入到 commands Map 中。而且再通过 this.register(command) 存入到 hooks 中。便于在\nthis.applyPlugins() 使用。\n\ncommand 和 hooks 如下图所示：\n\n\n\n6.1.3 registerPlatform 注册平台#\n\n\n\n同样存入到 platforms 中。同时存入到 hooks 中。\n\n6.1.4 registerMethod 注册方法#\n\n\n\n前文提到。没有函数，则会存入到 hooks 中。\n\n\n\nprocessArgs 函数主要就是统一下不同传参形式，最终都是返回 name 和 fn。\n\n6.1.5 addPluginOptsSchema 添加插件的参数 Schema#\n\n\n\n我们接着来看，注册插件函数。\n\n\n7. registerPlugin 注册插件#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. 注册插件到 plugins Map 中。\n\n最终的插件 plugins 如图所示：\n\n\n\n\n8. resolvePlugins 解析插件#\n\n解析插件和解析预设插件集合类似。\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. 合并预设插件集合中的插件、CLI 和项目中配置的插件\n>  2. resolvedCliAndProjectPlugins CLI 和项目中配置的插件\n>  3. 合并全局预设插件集合中的插件、全局配置的插件\n>  4. 最后遍历所有解析后的插件一次调用 this.initPlugin 初始化插件\n\n\n9. initPlugin 初始化插件#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. initPluginCtx 初始化插件的 ctx\n>  2. 注册插件\n>  3. apply 执行插件，插件本身也是一个函数，传入插件 pluginCtx 对象（包含\n>     register、registerCommand、registerMethods 等方法的对象），作为 ctx，传入参数 opts\n>  4. 校验插件的参数是否符合要求\n\n\n10. checkPluginOpts 校验插件的参数#\n\n\n\n这个方法主要做了如下几件事：\n\n>  1. 使用 joi 最强大的 JavaScript 模式描述语言和数据验证器。校验插件参数 schema。\n\n搜索整个项目中，好像只有 plugin-mini-ci 插件中加了这个参数校验。\n\n\n\nKernal 实例对象中还有一个方法，顺便提一下。\n\n\n11. applyCliCommandPlugin 暴露 taro cli 内部命令插件#\n\n\n\n\n\n\n12. 总结#\n\n我们学了\n\n\n\n以 command/init.ts 插件为例。\n\n\n\n非测试环境，先通过 createSwcRegister 使用了 @swc/register 来编译 ts 等转换成 commonjs。可以直接用 require\n读取文件。\n\n\n\n最终的插件 plugins 如图所示：\n\n\n\n\n\n再 apply 执行插件，插件本身也是一个函数，传入插件 pluginCtx 对象（包含\nregister、registerCommand、registerMethods 等方法的对象），作为 ctx，传入参数 opts。\n\n而这三个方法最终都是会调用 Plugin 实例对象的 register 方法，把方法存入到 Kernal 实例对象中的 hooks 属性中。\n\n\n\n然后再通过 Kernal 实例对象中的 run 函数里的 applyPlugins 链接里有函数具体实现 方法。\n\n从 Kernal 的实例对象中，取出相应的 hooks，使用 tapable 的 AsyncSeriesWaterfallHook 钩子串联起来，依次执行\nhook.fn 方法。\n\n调试如图所示：\n\n从而达到调用的是 command/init.ts 中的 fn 函数。不得不惊叹一声：Taro 插件机制设计的秒啊。\n\n强烈建议读者朋友们，空闲时自己看着文章，多尝试调试源码。单看文章，可能觉得看懂了，但自己调试可能会发现更多细节，收获更多。\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。若川的博客，github blog，可以点个 star 鼓励下持续创作。\n\n最后可以持续关注我@若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.8k+人）第一的专栏，写有几十篇源码文章。","routePath":"/taro/cli-plugins/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. new Kernal 构造函数","id":"2-new-kernal-构造函数","depth":2,"charIndex":831},{"text":"3. initPresetsAndPlugins 初始化预设插件集合和插件","id":"3-initpresetsandplugins-初始化预设插件集合和插件","depth":2,"charIndex":1506},{"text":"3.1 工具函数 mergePlugins、convertPluginsToObject","id":"31-工具函数-mergepluginsconvertpluginstoobject","depth":3,"charIndex":1790},{"text":"4. resolvePresets 解析预设插件集合","id":"4-resolvepresets-解析预设插件集合","depth":2,"charIndex":1870},{"text":"4.1 resolvePresetsOrPlugins 解析插件集或者插件","id":"41-resolvepresetsorplugins-解析插件集或者插件","depth":3,"charIndex":2292},{"text":"5. initPreset 初始化预设插件集合","id":"5-initpreset-初始化预设插件集合","depth":2,"charIndex":2418},{"text":"6. initPluginCtx 初始化插件 ctx","id":"6-initpluginctx-初始化插件-ctx","depth":2,"charIndex":2691},{"text":"6.1 new Plugin({ id, path, ctx })","id":"61-new-plugin-id-path-ctx-","depth":3,"charIndex":3005},{"text":"6.1.1 register 注册 hook","id":"611-register-注册-hook","depth":4,"charIndex":3043},{"text":"6.1.2 registerCommand 注册方法","id":"612-registercommand-注册方法","depth":4,"charIndex":3174},{"text":"6.1.3 registerPlatform 注册平台","id":"613-registerplatform-注册平台","depth":4,"charIndex":3320},{"text":"6.1.4 registerMethod 注册方法","id":"614-registermethod-注册方法","depth":4,"charIndex":3386},{"text":"6.1.5 addPluginOptsSchema 添加插件的参数 Schema","id":"615-addpluginoptsschema-添加插件的参数-schema","depth":4,"charIndex":3491},{"text":"7. registerPlugin 注册插件","id":"7-registerplugin-注册插件","depth":2,"charIndex":3553},{"text":"8. resolvePlugins 解析插件","id":"8-resolveplugins-解析插件","depth":2,"charIndex":3648},{"text":"9. initPlugin 初始化插件","id":"9-initplugin-初始化插件","depth":2,"charIndex":3867},{"text":"10. checkPluginOpts 校验插件的参数","id":"10-checkpluginopts-校验插件的参数","depth":2,"charIndex":4092},{"text":"11. applyCliCommandPlugin 暴露 taro cli 内部命令插件","id":"11-applyclicommandplugin-暴露-taro-cli-内部命令插件","depth":2,"charIndex":4270},{"text":"12. 总结","id":"12-总结","depth":2,"charIndex":4322}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":101,"title":"","content":"","routePath":"/taro/events/events","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":102,"title":"Taro 4.0 已发布 - 5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。\n\n截至目前（2024-08-18），taro 4.0 正式版已经发布，目前最新是 4.0.4，官方4.0正式版本的介绍文章暂未发布。官方之前发过Taro 4.0\nBeta 发布：支持开发鸿蒙应用、小程序编译模式、Vite 编译等。\n\n计划写一个 taro 源码揭秘系列，欢迎持续关注。\n\n * Taro 源码揭秘 - 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密\n * Taro 源码揭秘 - 2. 揭开整个架构的插件系统的秘密\n * Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么\n * Taro 4.0 已正式发布 - 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？\n * Taro 4.0 已发布 - 5.高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？\n * 等等\n\n前面 4 篇文章都是讲述编译相关的，CLI、插件机制、初始化项目、编译构建流程。第 5 篇我们来讲些相对简单的，Taro 是如何实现发布订阅机制 Events\n的。\n\n学完本文，你将学到：\n\n\n\n\n2. Taro 消息机制#\n\nTaro 消息机制文档上，Taro 提供了消息机制 Events，用来实现组件间通信。我们来学习下如何实现的。\n\nTaro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，如下\n\n\n\n同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例\n\n\n\nVue2 中也有类似的事件 events api $on、$off、$once、$emit，不过 Vue3 移除了。 vue2 events\n\n也有一些 npm 包，如：mitt、tiny-emitter\n\n源码共读也有一期第8期 | mitt、tiny-emitter 发布订阅\n\n\n3. 根据文档使用实现 Events#\n\n文档中，主要有如下几个需求点：\n\n * 监听同个事件，同时绑定多个 handler\n * 触发事件，传入多个参数\n * 取消监听一个事件某个 handler\n * 取消监听所有事件\n\n我们可以先自行实现一个符合要求的 Events 类，然后再去 Taro 源码中寻找实现，最后可以对比各自的实现优缺点。\n\n\n3.1 初步实现 Events#\n\n\n\n我们用 callbacks 数组来存储事件，push 方法用来添加事件，支持多个同名的 eventName。\n\n\n3.2 off 方法实现#\n\n\n\noff 方法用来取消监听事件，如果传入 eventName 参数，则取消监听该事件，如果还传入了特定的 handler，则只取消监听这个\nhandler。否则取消所有事件。\n\n\n3.3 trigger 方法实现#\n\n\n\ntrigger 传入 eventName 和参数，遍历所有事件，如果 eventName 匹配，则执行 handler。\n\nTaro events 自行实现所有代码 demo，可打开调试运行\n\n\n4. 在茫茫源码中寻找 class Events 实现#\n\n文档示例：\n\n\n\n@tarojs/taro 对应的源码路径是 taro/packages/taro\n\n\n4.1 @tarojs/taro 暴露者开发者的 Taro 核心 API#\n\n> 暴露给应用开发者的 Taro 核心 API。包含以下小程序端入口文件 index.js 等。\n\n\n\n@tarojs/api 对应的源码路径是 taro/packages/taro-api\n\n\n4.2 @tarojs/api 所有端的公有 API#\n\n> 暴露给 @tarojs/taro 的所有端的公有 API。@tarojs/api 会跨 node/浏览器/小程序/React Native\n> 使用，不得使用/包含平台特有特性。\n\n入口文件：packages/taro-api/src/index.ts\n\n\n\n这个文件代码不多，省略了一部分。默认导出Taro，其中 eventCenter,Events是从 @tarojs/runtime 引入的。\n\n@tarojs/runtime 对应的源码路径是 taro/packages/taro-runtime\n\n\n4.3 @tarojs/runtime Taro 运行时#\n\n> Taro 运行时。在小程序端连接框架（DSL）渲染机制到小程序渲染机制，连接小程序路由和生命周期到框架对应的生命周期。在 H5/RN\n> 端连接小程序生命周期规范到框架生命周期。\n\n> Events Taro 消息机制。\n\n\n\n\n\n@tarojs/shared 对应的源码路径是 taro/packages/shared\n\n\n4.4 @tarojs/shared 内部使用的 utils#\n\n> Taro 内部使用的 utils。包含了常用的类型判断、错误断言、组件类型/声明/参数等。@tarojs/shared 会跨\n> node/浏览器/小程序/React Native 使用，不得使用平台特有特性。\n\n> 引入此包的必须采用 ES6 引用单个模块语法，且打包配置 external 不得包括此包。\n\n\n\n\n5. class Events 的具体实现#\n\n终于在 packages/shared/src/event-emitter.ts 找到了 class Events 的实现代码。\n\n\n\neventSplitter 事件分割符 ,。 callbacks 对象存储事件名和回调函数。\n\n\n5.1 on 事件监听#\n\n\n\n这里可能有点抽象，我们举个例子调试下：\n\n我们直接找到打包后的代码，路径：taro/packages/shared/dist/event-emitter.js，注释// export { Events\n};，追加如下代码：\n\n\n\n打开终端，新建 JavaScript Debug Terminal 调试，运行：\n\n\n\n调试截图如下：\n\n复制监视的 events.callbacks 的值，它的对象存储如下结构：\n\n\n\n\n\n也就是链表形式。同名的事件名，会追加到链表的 next 节点。所以同名的事件名，可以触发多个 callback 函数。\n\n\n5.2 once 事件监听只执行一次#\n\n\n\n执行一遍后，调用 off 方法移除事件。\n\n\n5.3 off 事件移除#\n\n\n\n\n5.4 trigger 事件触发#\n\n\n\n遍历链表，依次执行回调函数。 tail 结尾作为判断，到末尾了，终止遍历。\n\n接着我们来学习 eventCenter 全局消息中心的实现。\n\n\n6. eventCenter 全局消息中心#\n\n\n\n\n7. hooks#\n\n根据上文的信息，我们可以找到 hooks 对象的代码位置是 packages/shared/src/runtime-hooks.ts。\n\n\n\n这段代码声明了一些 TS 接口和类型等，TaroHook 函数返回一个 Hook 对象。\n\n\n\nhooks 对象是 TaroHooks 的实例对象。TaroHooks 继承自 Events。\n\n我们来看 TaroHooks 的具体实现\n\n\n8. class TaroHooks 的具体实现#\n\n\n\n\n8.1 tap 方法 - 监听事件#\n\n\n\ntap 方法是监听事件，hook类型是SINGLE类型时，直接取消，重新监听。不是SINGLE类型时，则取消监听指定回调函数的事件，重新监听一个或多个事件。\n\n\n8.2 call 方法 - 触发事件#\n\n\n\n因为 TaroHooks 是继承自 Events，所以 call 实现和 Events 的 trigger 触发事件类似。\n都是遍历链表，依次执行回调函数。还有一个判断，就是 type 是 HOOK_TYPE.WATERFALL 的时候，将返回值作为参数传给下一个回调。\n\n换句话说\n\n\n\n简化之后，其实就是：\n\n\n\n单从 getEventCenter\n函数来看，好像有些多此一举，为啥要这样写呢？可能是为了修复多个平台的bug。暂时不知道好处是啥，知道的读者朋友也可以反馈告知。\n\n\n9. 总结#\n\n我们通过文档Taro 消息机制，了解到 Taro 提供了Events 和 Taro.eventCenter 对象，用于发布订阅。我们根据文档也实现了。\n\n我们在茫茫源码中，寻找 class Events 的实现，依次在 @tarojs/taro => @tarojs/api => @tarojs/runtime\n=> @tarojs/shared 层层查找，我们终于在 packages/shared/src/event-emitter.ts 找到了 class\nEvents 的实现代码。\n\nclass Events 用链表存储事件，实现了 on、once、off、trigger 等方法，用于发布订阅。\n\nTaro.eventCenter 对象其实也是 class Events 的实例，只不过绕了一圈，用 TaroHooks 实例\nhooks.call('getEventCenter', Events) 来获取。\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。也欢迎提建议和交流讨论。\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。若川的博客，github blog，可以点个 star 鼓励下持续创作。\n\n最后可以持续关注我@若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。","routePath":"/taro/events/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. Taro 消息机制","id":"2-taro-消息机制","depth":2,"charIndex":678},{"text":"3. 根据文档使用实现 Events","id":"3-根据文档使用实现-events","depth":2,"charIndex":1003},{"text":"3.1 初步实现 Events","id":"31-初步实现-events","depth":3,"charIndex":1178},{"text":"3.2 off 方法实现","id":"32-off-方法实现","depth":3,"charIndex":1255},{"text":"3.3 trigger 方法实现","id":"33-trigger-方法实现","depth":3,"charIndex":1361},{"text":"4. 在茫茫源码中寻找 class Events 实现","id":"4-在茫茫源码中寻找-class-events-实现","depth":2,"charIndex":1480},{"text":"4.1 @tarojs/taro 暴露者开发者的 Taro 核心 API","id":"41-tarojstaro-暴露者开发者的-taro-核心-api","depth":3,"charIndex":1562},{"text":"4.2 @tarojs/api 所有端的公有 API","id":"42-tarojsapi-所有端的公有-api","depth":3,"charIndex":1699},{"text":"4.3 @tarojs/runtime Taro 运行时","id":"43-tarojsruntime-taro-运行时","depth":3,"charIndex":1985},{"text":"4.4 @tarojs/shared 内部使用的 utils","id":"44-tarojsshared-内部使用的-utils","depth":3,"charIndex":2181},{"text":"5. class Events 的具体实现","id":"5-class-events-的具体实现","depth":2,"charIndex":2375},{"text":"5.1 on 事件监听","id":"51-on-事件监听","depth":3,"charIndex":2516},{"text":"5.2 once 事件监听只执行一次","id":"52-once-事件监听只执行一次","depth":3,"charIndex":2805},{"text":"5.3 off 事件移除","id":"53-off-事件移除","depth":3,"charIndex":2851},{"text":"5.4 trigger 事件触发","id":"54-trigger-事件触发","depth":3,"charIndex":2869},{"text":"6. eventCenter 全局消息中心","id":"6-eventcenter-全局消息中心","depth":2,"charIndex":2962},{"text":"7. hooks","id":"7-hooks","depth":2,"charIndex":2989},{"text":"8. class TaroHooks 的具体实现","id":"8-class-tarohooks-的具体实现","depth":2,"charIndex":3191},{"text":"8.1 tap 方法 - 监听事件","id":"81-tap-方法---监听事件","depth":3,"charIndex":3221},{"text":"8.2 call 方法 - 触发事件","id":"82-call-方法---触发事件","depth":3,"charIndex":3324},{"text":"9. 总结","id":"9-总结","depth":2,"charIndex":3590}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":103,"title":"taro 源码系列","content":"#\n\nTODOs\n\n * Taro 源码揭秘 - 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密\n * Taro 源码揭秘 - 2. 揭开整个架构的插件系统的秘密\n * Taro 源码揭秘 - 3. 每次创建新的 taro 项目（taro init）的背后原理是什么\n * Taro 4.0 已正式发布 - 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？\n * Taro 4.0 已发布 - 5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？\n * Taro 4.0 已发布 - 6. 为什么 Taro.xxx 能访问 wx.xxx ?","routePath":"/taro/","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":104,"title":"","content":"hostConfig\n\nmergeReconciler(hostConfig)","routePath":"/taro/native-apis/bak","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":105,"title":"Taro 4.0 已正式发布 - 6. 为什么通过 Taro.xxx 能调用各个小程序平台的 API，如何设计实现的?","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。\n\n截至目前（2024-08-28），taro 4.0 正式版已经发布，目前最新是 4.0.5，官方4.0正式版本的介绍文章暂未发布。官方之前发过Taro 4.0\nBeta 发布：支持开发鸿蒙应用、小程序编译模式、Vite 编译等。\n\n计划写一个 taro 源码揭秘系列，欢迎持续关注。\n\n * 1. 揭开整个架构的入口 CLI => taro init 初始化项目的秘密\n * 2. 揭开整个架构的插件系统的秘密\n * 3. 每次创建新的 taro 项目（taro init）的背后原理是什么\n * 4. 每次 npm run dev:weapp 开发小程序，build 编译打包是如何实现的？\n * 5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？\n * 等等\n\n前面 4 篇文章都是讲述编译相关的，CLI、插件机制、初始化项目、编译构建流程。第 6 篇我们来讲些相对简单的，Taro 是如何实现 Taro.xxx 能访问\nwx.xxx（文章以微信小程序为例）。\n\n关于克隆项目、环境准备、如何调试代码等，参考第一篇文章-准备工作、调试。后续文章基本不再过多赘述。\n\n学完本文，你将学到：\n\n\n\n\n2. Taro 文档 - API 说明#\n\nTaro 文档 - API 说明\n\n\n\n\n\n我们具体来分析下，Taro 源码中是如何实现 Taro.xxx 访问 wx.xxx 的，并且是如何实现 promisify 的。\n\npromisify 把回调函数转成 promise 避免回调地狱问题。面试也经常考察此题。我之前写过一篇文章：从22行有趣的源码库中，我学到了 callback\npromisify 化的 Node.js 源码实现\n\n文章中简单的 promisify 函数实现如下：\n\n\n\n我们日常开发都会引入 @tarojs/taro，然后调用 Taro.xxx 方法，比如 Taro.navigateTo，微信小程序调用的是\nwx.navigateTo，支付宝小程序则是 my.navigateTo。\n\n我们先来看 @tarojs/taro 的代码。\n\n\n3. @tarojs/taro taro 入口#\n\n\n\nhooks 和 @tarojs/api 在上篇文章5. 高手都在用的发布订阅机制 Events 在 Taro 中是如何实现的？讲过。 简单来说就是 tap\n是注册事件，call 是触发事件。其中 mergeReconciler 函数中注册initNativeApi函数。\n\n这时我们需要来寻找 initNativeApi 函数在哪里实现的。可以在Taro源码中根据 initNativeApi 关键字搜索。或者之前的第三篇文章 3.\ntaro build。我们知道端平台插件的代码在 @tarojs/plugin-platform-weapp 包中，路径是\npackages/taro-platform-weapp/src/program.ts。\n\n\n4. new Weapp 端平台插件#\n\n\n\nruntimePath 路径：@tarojs/plugin-platform-weapp/dist/runtime。\n\n对应的运行时路径 packages/taro-platform-weapp/src/runtime.ts。\n\n\n5. 运行时 runtime.ts#\n\n\n\n * 使用 mergeReconciler 函数把自定义的 hostConfig 合并到全局 Reconciler 中。\n * 使用 mergeInternalComponents 函数把自定义组件信息 components.ts 合并到全局 internalComponents\n   组件信息对象中。\n\n我们来看下 mergeReconciler 函数的实现。\n\n\n6. mergeReconciler 函数#\n\n\n\nobj.tap(key, hostConfig[key]) 是注册事件，在 call 调用。\n\n再看 hostConfig 配置对象。\n\n\n7. hostConfig 配置对象#\n\n\n\nhostConfig 对象中包含了 initNativeApi 等函数。我们接着来看 initNativeApi 函数。\n\n\n8. initNativeApi 初始化原始 api#\n\n\n\ninitNativeApi 函数中调用了 processApis 函数，把 wx 的 api 转换成 taro 的 api。我们接着来看 processApis\n函数的具体实现。\n\n\n9. processApis 处理 apis#\n\n\n\n我们来看 processApis 函数的具体实现。\n\n\n\n\n9.1 apis.forEach 需要 promisify 的 api 逻辑#\n\n\n\nnonsupport 函数\n\n\n\npromisify 具体实现\n\n\n\n上传和下载文件的 API 需要特殊处理，因为它们返回的是 Task 对象，需要将 Task 对象的属性和方法挂载到 Promise 对象上。\n\n\n\nequipTaskMethodsIntoPromise 方法的实现如下：\n\n\n\n文档 - wx.uploadFile | 文档 - 返回值 UploadTask | 文档 - wx.downloadFile | 文档 - 返回值\nDownloadTask |\n\n\n9.2 apis.forEach 不需要 promisify 的 api 逻辑#\n\n\n\n\n9.3 挂载常用 API#\n\n\n\n我们来看 equipCommonApis 的具体实现。\n\n\n\nisOnlyPromisify 参数为 true，表示只 promisify。\n\n\n9.4 @tarojs/plugin-inject 插件注入公共的组件、API 等逻辑#\n\n我们可以搜索 taro 源码中 isOnlyPromisify 查找到 processApis 传入 isOnlyPromisify 为 true。只在\n@tarojs/plugin-inject 插件使用\n\n> 可以为小程序平台注入公共的组件、API 等逻辑\n\n\n\n我们来看具体是如何实现支持开发者自定义 API 的。\n\n添加 asyncApis 也就是 needPromiseApis 字段。\n\n插件支持为小程序新增 异步的 API。\n\n用法：\n\n\n\n运行时即可调用此新增的 API：\n\n\n\napis-list.ts 文件默认内容如下：\n\n\n\n调用 @tarojs/plugin-inject 插件时会调用 injectApis 函数，修改这个文件里的 needPromiseApis。\n\n\n\n这一步即可注入开发者自定义的公共的组件和 API 等。\n\n后续有时间再单独写一篇文章分析 @tarojs/plugin-inject 的具体实现，这里限于篇幅就不详细讲述了。\n\n\n10. 总结#\n\n我们最后来总结一下整个过程。\n\n端平台插件运行时 mergeReconciler(hostConfig)\n\n\n\nclass TaroHooks(实例对象hooks) 继承自 Events，tap 注册事件回调，call 调用事件。\n\nEvents 机制的好处在于解耦。缺点是维护成本较高，可能消耗内存较多。\n\nhostConfig 对象中存在 initNativeApi 函数调用 processApis。\n\n\n\n@tarojs/taro call 调用 initNativeApi 函数。\n\n@tarojs/taro 最终会调用不同小程序端的运行时注册是事件。会调用 hostConfig 中的 initNativeApi 函数中的\nprocessApis。\n\nprocessApis(taro, global, config)：\n\n * 挂载小程序平台公共的小程序 API 到 Taro 对象上，需要 needPromiseApis 异步 API，promisify 转换返回 Promise\n   对象。传入一些配置修改 apis 等，支持抹平平台差异等。\n * 挂载常用的小程序全局对象属性 到 Taro 对象上。\n * 挂载开发者传入的小程序 API 到 Taro 对象上，@tarojs/plugin-inject 插件支持开发者自定义的公共组件和 API 等。\n\n\n11. 参考#\n\n * Taro文档 - 端平台插件\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。也欢迎提建议和交流讨论。\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。若川的博客，github blog，可以点个 star 鼓励下持续创作。\n\n最后可以持续关注我@若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。","routePath":"/taro/native-apis/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. Taro 文档 - API 说明","id":"2-taro-文档---api-说明","depth":2,"charIndex":679},{"text":"3. @tarojs/taro taro 入口","id":"3-tarojstaro-taro-入口","depth":2,"charIndex":1060},{"text":"4. new Weapp 端平台插件","id":"4-new-weapp-端平台插件","depth":2,"charIndex":1414},{"text":"5. 运行时 runtime.ts","id":"5-运行时-runtimets","depth":2,"charIndex":1553},{"text":"6. mergeReconciler 函数","id":"6-mergereconciler-函数","depth":2,"charIndex":1760},{"text":"7. hostConfig 配置对象","id":"7-hostconfig-配置对象","depth":2,"charIndex":1856},{"text":"8. initNativeApi 初始化原始 api","id":"8-initnativeapi-初始化原始-api","depth":2,"charIndex":1942},{"text":"9. processApis 处理 apis","id":"9-processapis-处理-apis","depth":2,"charIndex":2065},{"text":"9.1 apis.forEach 需要 promisify 的 api 逻辑","id":"91-apisforeach-需要-promisify-的-api-逻辑","depth":3,"charIndex":2122},{"text":"9.2 apis.forEach 不需要 promisify 的 api 逻辑","id":"92-apisforeach-不需要-promisify-的-api-逻辑","depth":3,"charIndex":2406},{"text":"9.3 挂载常用 API","id":"93-挂载常用-api","depth":3,"charIndex":2451},{"text":"9.4 @tarojs/plugin-inject 插件注入公共的组件、API 等逻辑","id":"94-tarojsplugin-inject-插件注入公共的组件api-等逻辑","depth":3,"charIndex":2541},{"text":"10. 总结","id":"10-总结","depth":2,"charIndex":3026},{"text":"11. 参考","id":"11-参考","depth":2,"charIndex":3625}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":106,"title":"学习`underscore`源码整体架构，打造属于自己的函数式编程类库","content":"学习underscore源码整体架构，打造属于自己的函数式编程类库#\n\n> 写于2019年8月8日\n\n\n1. 前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 这是学习源码整体架构系列第二篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。本篇文章\n> 学习的是打包整合后的代码，不是实际仓库中的拆分的代码。\n\n> 本文仓库地址：git clone https://github.com/ruochuan12/underscore-analysis.git\n\n> 要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了。\n\n学习源码整体架构系列文章如下：\n\n> 1.学习 jQuery 源码整体架构，打造属于自己的 js 类库 2.学习 underscore 源码整体架构，打造属于自己的函数式编程类库 3.学习\n> lodash 源码整体架构，打造属于自己的函数式编程类库 4.学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK 5.学习 vuex\n> 源码整体架构，打造属于自己的状态管理库 6.学习 axios 源码整体架构，打造属于自己的请求库 7.学习 koa\n> 源码的整体架构，浅析koa洋葱模型原理和co原理 8.学习 redux 源码整体架构，深入理解 redux 及其中间件原理\n\n感兴趣的读者可以点击阅读。 其他源码计划中的有：express、vue-rotuer、react-redux\n等源码，不知何时能写完（哭泣），欢迎持续关注我（若川）。\n\n源码类文章，一般阅读量不高。已经有能力看懂的，自己就看了。不想看，不敢看的就不会去看源码。 所以我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。\n\n虽然看过挺多underscore.js分析类的文章，但总感觉少点什么。这也许就是纸上得来终觉浅，绝知此事要躬行吧。于是决定自己写一篇学习underscore.j\ns整体架构的文章。\n\n本文章学习的版本是v1.9.1。 unpkg.com underscore 源码地址\n\n虽然很多人都没用过underscore.js，但看下官方文档都应该知道如何使用。\n\n从一个官方文档_.chain简单例子看起：\n\n\n\n看例子中可以看出，这是支持链式调用。\n\n读者也可以顺着文章思路，自行打开下载源码进行调试，这样印象更加深刻。\n\n\n2. 链式调用#\n\n_.chain 函数源码：\n\n\n\n这个函数比较简单，就是传递obj调用_()。但返回值变量竟然是instance实例对象。添加属性_chain赋值为true，并返回intance对象。但再看例子\n，实例对象竟然可以调用reverse方法，再调用value方法。猜测支持OOP（面向对象）调用。\n\n带着问题，笔者看了下定义 _ 函数对象的代码。\n\n\n3. _ 函数对象 支持OOP#\n\n\n\n如果参数obj已经是_的实例了，则返回obj。 如果this不是_的实例，则手动 new _(obj);\n再次new调用时，把obj对象赋值给_wrapped这个属性。 也就是说最后得到的实例对象是这样的结构 { _wrapped: '参数obj', }\n它的原型_(obj).__proto__ 是 _.prototype;\n\n如果对这块不熟悉的读者，可以看下以下这张图(之前写面试官问：JS的继承画的图)。\n\n继续分析官方的_.chain例子。这个例子拆开，写成三步。\n\n\n\n思考问题：reverse本是Array.prototype上的方法呀。为啥支持链式调用呢。 搜索reverse，可以看到如下这段代码：\n\n并将例子代入这段代码可得（怎么有种高中做数学题的既视感^_^）：\n\n\n\n\n\n\n\nif ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n提一下上面源码中的这一句，看到这句是百思不得其解。于是赶紧在github中搜索这句加上\"\"双引号。表示全部搜索。\n\n搜索到两个在官方库中的ISSUE，大概意思就是兼容IE低版本的写法。有兴趣的可以点击去看看。\n\nI don't understand the meaning of this sentence.\n\nwhy delete obj[0]\n\n\n4. 基于流的编程#\n\n至此就算是分析完了链式调用_.chain()和_ 函数对象。这种把数据存储在实例对象{_wrapped: '', _chain: true}\n中，_chain判断是否支持链式调用，来传递给下一个函数处理。这种做法叫做 基于流的编程。\n\n最后数据处理完，要返回这个数据怎么办呢。underscore提供了一个value的方法。\n\n\n\n顺便提供了几个别名。toJSON、valueOf。 _.prototype.valueOf = _.prototype.toJSON =\n_.prototype.value;\n\n还提供了 toString的方法。\n\n\n\n这里的String() 和new String() 效果是一样的。 可以猜测内部实现和 _函数对象类似。\n\n\n\n\n\n细心的读者会发现chainResult函数中的_(obj).chain()，是怎么实现实现链式调用的呢。\n\n而_(obj) 是返回的实例对象{_wrapped:\nobj}呀。怎么会有chain()方法，肯定有地方挂载了这个方法到_.prototype上或者其他操作，这就是_.mixin()。\n\n\n5. _.mixin 挂载所有的静态方法到 _.prototype， 也可以挂载自定义的方法#\n\n_.mixin\n混入。但侵入性太强，经常容易出现覆盖之类的问题。记得之前React有mixin功能，Vue也有mixin功能。但版本迭代更新后基本都是慢慢的都不推荐或者不支持m\nixin。\n\n\n\n_mixin(_) 把静态方法挂载到了_.prototype上，也就是_.prototype.chain方法 也就是 _.chain方法。\n\n所以_.chain(obj)和_(obj).chain()效果一样，都能实现链式调用。\n\n关于上述的链式调用，笔者画了一张图，所谓一图胜千言。\n\n\n\n\n5.1 _.mixin 挂载自定义方法#\n\n挂载自定义方法： 举个例子：\n\n\n\n\n5.2 _.functions(obj)#\n\n\n\n_.functions 和 _.methods 两个方法，遍历对象上的方法，放入一个数组，并且排序。返回排序后的数组。\n\n\n5.3 underscore.js 究竟在_和_.prototype挂载了多少方法和属性#\n\n再来看下underscore.js究竟挂载在_函数对象上有多少静态方法和属性，和挂载_.prototype上有多少方法和属性。\n\n使用for in循环一试便知。看如下代码：\n\n\n\n\n\n根据这些，笔者又画了一张图underscore.js 原型关系图，毕竟一图胜千言。\n\n\n\n\n6. 整体架构概览#\n\n\n6.1 匿名函数自执行#\n\n\n\n这样保证不污染外界环境，同时隔离外界环境，不是外界影响内部环境。\n\n外界访问不到里面的变量和函数，里面可以访问到外界的变量，但里面定义了自己的变量，则不会访问外界的变量。\n匿名函数将代码包裹在里面，防止与其他代码冲突和污染全局环境。 关于自执行函数不是很了解的读者可以参看这篇文章。 [译]\nJavaScript：立即执行函数表达式（IIFE）\n\n\n6.2 root 处理#\n\n\n\n支持浏览器环境、node、Web Worker、node vm、微信小程序。\n\n\n6.3 导出#\n\n\n\n关于root处理和导出的这两段代码的解释，推荐看这篇文章冴羽：underscore 系列之如何写自己的\nunderscore，讲得真的太好了。笔者在此就不赘述了。\n总之，underscore.js作者对这些处理也不是一蹴而就的，也是慢慢积累，和其他人提ISSUE之后不断改进的。\n\n\n6.4 支持 amd 模块化规范#\n\n\n\n\n6.5 _.noConflict 防冲突函数#\n\n源码：\n\n\n\n使用：\n\n\n\n\n7. 总结#\n\n全文根据官网提供的链式调用的例子， _.chain([1, 2,\n3]).reverse().value();较为深入的调试和追踪代码，分析链式调用（_.chain() 和\n_(obj).chain()）、OOP、基于流式编程、和_.mixin(_)在_.prototype挂载方法，最后整体架构分析。学习underscore.js整\n体架构，利于打造属于自己的函数式编程类库。\n\n文章分析的源码整体结构。\n\n\n\n下一篇文章可能是学习lodash的源码整体架构。\n\n读者发现有不妥或可改善之处，欢迎评论指出。另外觉得写得不错，可以点赞、评论、转发，也是对笔者的一种支持。\n\n\n8. 推荐阅读#\n\nunderscorejs.org 官网 undersercore-analysis underscore 系列之如何写自己的 underscore\n\n\n笔者往期文章#\n\n面试官问：JS的继承 面试官问：JS的this指向 面试官问：能否模拟实现JS的call和apply方法 面试官问：能否模拟实现JS的bind方法\n面试官问：能否模拟实现JS的new操作符 前端使用puppeteer 爬虫生成《React.js 小书》PDF并合并\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 若川的博客，使用vuepress重构了，阅读体验可能更好些\n掘金专栏，欢迎关注~ segmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~\n语雀前端视野专栏，新增语雀专栏，欢迎关注~ github blog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注（回复pdf获取前端优质书籍pdf）。欢迎加笔者微信ruochuan12（注明来源，基本来者不拒），拉您进【前端视野交流群\n】，长期交流学习~\n\n","routePath":"/underscore/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":51},{"text":"2. 链式调用","id":"2-链式调用","depth":2,"charIndex":1149},{"text":"3. `_` 函数对象 支持`OOP`","id":"3-_-函数对象-支持oop","depth":2,"charIndex":-1},{"text":"4. 基于流的编程","id":"4-基于流的编程","depth":2,"charIndex":1958},{"text":"5. `_.mixin` 挂载所有的静态方法到 `_.prototype`， 也可以挂载自定义的方法","id":"5-_mixin-挂载所有的静态方法到-_prototype-也可以挂载自定义的方法","depth":2,"charIndex":-1},{"text":"5.1 _.mixin 挂载自定义方法","id":"51-_mixin-挂载自定义方法","depth":3,"charIndex":2747},{"text":"5.2 _.functions(obj)","id":"52-_functionsobj","depth":3,"charIndex":2788},{"text":"5.3 `underscore.js` 究竟在`_`和`_.prototype`挂载了多少方法和属性","id":"53-underscorejs-究竟在_和_prototype挂载了多少方法和属性","depth":3,"charIndex":-1},{"text":"6. 整体架构概览","id":"6-整体架构概览","depth":2,"charIndex":3060},{"text":"6.1 匿名函数自执行","id":"61-匿名函数自执行","depth":3,"charIndex":3073},{"text":"6.2 root 处理","id":"62-root-处理","depth":3,"charIndex":3264},{"text":"6.3 导出","id":"63-导出","depth":3,"charIndex":3321},{"text":"6.4 支持 `amd` 模块化规范","id":"64-支持-amd-模块化规范","depth":3,"charIndex":-1},{"text":"6.5 _.noConflict 防冲突函数","id":"65-_noconflict-防冲突函数","depth":3,"charIndex":3496},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":3536},{"text":"8. 推荐阅读","id":"8-推荐阅读","depth":2,"charIndex":3832},{"text":"笔者往期文章","id":"笔者往期文章","depth":2,"charIndex":3918},{"text":"关于","id":"关于","depth":2,"charIndex":4062},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":107,"title":"","content":"","routePath":"/underscore/underscore-v0.1","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":108,"title":"","content":"","routePath":"/underscore/underscore-v1.9.1","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":109,"title":"经常用 vant-weapp 开发小程序，却不知道如何开发一个组件？","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。为了能帮助到更多对源码感兴趣、想学会看源码、提升自己前端技术能力的同学。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感\n> 兴趣的可以 点此扫码加我微信 ruochuan02 参与。\n\n想学源码，极力推荐关注我写的专栏（目前是掘金专栏关注人数第一，3.6K+人）《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等20余篇源码文章。\n\n\n2. stepper 步进器#\n\n> 感兴趣的小伙伴，可以克隆我的仓库调试学习 git clone\n> https://github.com/ruochuan12/vant-weapp-analysis.git。\n\n我们开发微信小程序时经常会使用到 stepper 步进器组件。本文就来分析 vant-weapp stepper 步进器源码实现。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\nstepper 步进器文档\n\nstepper 图\n\n\n\n如何开发一个微信小程序组件，可以参考官方文档。 微信小程序自定义组件 文档\n\n看完本文，你将学到：\n\n\n\n\n3. 克隆项目 && 调试#\n\n\n\n由于 yarn run dev 没有压缩代码，本文就基于运行 dev 后没有压缩的代码进行讲述。\n\n打开微信开发者工具，把 vant-weapp/example 目录添加进去就可以预览示例了。注意：如果没有自己的 appid，可以选择测试号。\n\n添加编译模式，启动页面为 pages/stepper/index，即可单独调试该页面。\n\n关于更多 JS 调试，之前文章写过，新手向：前端程序员必学基本技能——调试JS代码，这里就不赘述。\n\n前端容易忽略的 debugger 调试技巧\n\n附上一张图。\n\n\n\n我们找到对应的文件，查看下组件源码的整体结构。\n\n\n4. 整体结构#\n\n\n4.1 组件的 wxml 结构#\n\nwxml 部分相对简单清晰，这里就不过多讲述。\n\n\n\n\n4.2 组件的 JS 结构#\n\n\n\n\n4.3 VantComponent 组件#\n\n我们可以在 vant-weapp/example/dist/stepper/index.js 文件的 VantComponent({}) 上方加上\ndebugger; 调试源码。按进入函数按钮。\n\n\n\n调试如图所示：\n\n\n\n\n\n4.3.1 Behavior 如同 mixins#\n\n\n\n看完了 VantComponent 函数。 再来看看组件的初始化。\n\n\n5. 组件初始化#\n\n\n\n接着我们继续调试加减号基础功能。\n\n\n6. 点击加号/减号#\n\n\n6.1 onTap 函数#\n\n\n\n我们可以在 onTap 函数处断点，或者加上 debugger。\n\n\n\n再在 onChange 函数断点，点击进入函数按钮操作。 接着我们来看 onChange 函数实现。\n\n\n6.2 onChange 函数#\n\n\n\n\n6.3 isDisabled 函数#\n\n最大最小值比较等。\n\n\n\n\n6.4 emitChange 函数#\n\n\n\n如果不是异步，则直接赋值给 currentValue。 并且派发 change 事件。\n\n断点调试在 $emit 函数。点击开发者工具的进入函数按钮。\n\n\n6.5 $emit 函数#\n\n在上文提到过 Behavior basic。类似于 vue 中的 $emit。\n\n\n\n组件间通信与事件 文档\n\n\n\n\n\n\n\n我们接着看输入框输入。\n\n\n7. 输入框输入 onInput 函数#\n\n\n\n\n\n\n8. 输入框聚焦/失焦#\n\n\n\nfocus、blur事件\n\n\n\n\n9. 长按加号/减号 累计功能#\n\n\n\n\n\n\n10. 总结#\n\n行文至此，就基本接近尾声了。我们从 vant-weapp 常用的 stepper 步进器组件源码出发。整体源码并不长。\n\n我们通过调试方法，分析了整体结构，VantComponent 函数组件的实现，还有加号减号的功能基本实现，input输入功能、聚焦失焦、还有长按累计的功能等。\n\n或许我们自己实现，可能就写的一团糟。所以，相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n不过大多时候，学习源码或许是重要但不紧急的事情。除了公司项目外，我们可以多尝试学习开源项目的源码，从而贡献自己的代码，拥抱开源，会让自己更上一层楼。\n\n感兴趣的小伙伴，可以克隆我的仓库调试学习 git clone\nhttps://github.com/ruochuan12/vant-weapp-analysis.git。\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力~\n\n我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。\n\n另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。包含jQuery、under\nscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-compose、vue 3.2\n发布、vue-this、create-vue、玩具vite、create-vite 等20余篇源码文章。\n\n我正在参与掘金技术社区创作者签约计划招募活动，点击链接报名投稿。","routePath":"/vant-weapp-stepper/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. stepper 步进器","id":"2-stepper-步进器","depth":2,"charIndex":313},{"text":"3. 克隆项目 && 调试","id":"3-克隆项目--调试","depth":2,"charIndex":627},{"text":"4. 整体结构","id":"4-整体结构","depth":2,"charIndex":923},{"text":"4.1 组件的 wxml 结构","id":"41-组件的-wxml-结构","depth":3,"charIndex":934},{"text":"4.2 组件的 JS 结构","id":"42-组件的-js-结构","depth":3,"charIndex":980},{"text":"4.3 VantComponent 组件","id":"43-vantcomponent-组件","depth":3,"charIndex":999},{"text":"4.3.1 Behavior 如同 mixins","id":"431-behavior-如同-mixins","depth":4,"charIndex":1136},{"text":"5. 组件初始化","id":"5-组件初始化","depth":2,"charIndex":1201},{"text":"6. 点击加号/减号","id":"6-点击加号减号","depth":2,"charIndex":1233},{"text":"6.1 onTap 函数","id":"61-ontap-函数","depth":3,"charIndex":1247},{"text":"6.2 onChange 函数","id":"62-onchange-函数","depth":3,"charIndex":1353},{"text":"6.3 isDisabled 函数","id":"63-isdisabled-函数","depth":3,"charIndex":1374},{"text":"6.4 emitChange 函数","id":"64-emitchange-函数","depth":3,"charIndex":1408},{"text":"6.5 $emit 函数","id":"65-emit-函数","depth":3,"charIndex":1508},{"text":"7. 输入框输入 onInput 函数","id":"7-输入框输入-oninput-函数","depth":2,"charIndex":1599},{"text":"8. 输入框聚焦/失焦","id":"8-输入框聚焦失焦","depth":2,"charIndex":1626},{"text":"9. 长按加号/减号 累计功能","id":"9-长按加号减号-累计功能","depth":2,"charIndex":1659},{"text":"10. 总结","id":"10-总结","depth":2,"charIndex":1682}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":110,"title":"","content":"本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2022-11-20）star 多达 20.5k，最新版本是\nv4.0.0-rc7。我们可以挑选 vant 组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n这次我们来学习倒计时组件，countdown。\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，我们可以先看 README.md 再看 github/CONTRIBUTING.md\n\n\n2.1 克隆源码#\n\nYou will need Node.js >= 14 and pnpm.\n\n\n\n执行 pnpm dev 后，这时我们打开倒计时组件 http://localhost:5173/#/zh-CN/count-down。\n\n\n3. 倒计时组件可谓是十分常用#\n\n在各种电商类或者其他的移动端页面中，倒计时真的是太常见了。我们自己也基本能够快速的写一个倒计时组件。代码实现参考这里，主要是\nJavaScript。码上掘金倒计时初步代码@若川\n\n代码中，我直接使用的 setInterval 和每秒钟执行一次。把倒计时的时候减去1s，当倒计时毫秒数不足时用 clearInterval 清除停止定时器。\n\n但如果要实现毫秒级的倒计时这种方法行不通。 另外 setInterval 这种做法，并不是最优的。 那么，vant\n倒计时组件中，是如何处理毫秒级和实现倒计时呢。\n\n带着问题我们直接找到 countdown demo\n文件：vant/packages/vant/src/count-down/demo/index.vue。为什么是这个文件，我在之前文章跟着 vant4\n源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码分析了其原理，感兴趣的小伙伴点击查看。这里就不赘述了。\n\n\n4. 利用 demo 调试源码#\n\n组件源码中的 TS 代码我不会过多解释。没学过 TS 的小伙伴，推荐学这个TypeScript 入门教程。 另外，vant 使用了\n@vue/babel-plugin-jsx 插件来支持 JSX、TSX。\n\n\n\n\n\n从 demo 文件中，我们可以看出 ``，引入自 vant/packages/vant/src/count-down/index.ts。我们继续来看入口\nindex.ts。\n\n\n5. 入口 index.ts#\n\n主要就是导出一下类型和变量等。\n\n\n\nwithInstall 函数在之前文章5.1 withInstall 给组件对象添加 install 方法 也有分析，这里就不赘述了。\n\n我们可以在这些文件，任意位置加上 debugger 调试源码。\n\n截两张调试图。\n\n调试 Countdown setup。\n\n\n\n调试 useCountDown。\n\n\n\n我们跟着调试，继续分析 Countdown。\n\n\n6. 主文件 Countdown#\n\n\n\n\n6.1 setup 部分#\n\n这一部分主要使用了useCountDown。\n\n\n\n\n6.2 useExpose 暴露#\n\n\n\n通过 ref 可以获取到 Countdown 实例并调用实例方法，详见组件实例方法。\n\n> Vant 中的许多组件提供了实例方法，调用实例方法时，我们需要通过 ref 来注册组件引用信息，引用信息将会注册在父组件的 $refs\n> 对象上。注册完成后，我们可以通过 this.$refs.xxx 或者\n\n\n\n访问到对应的组件实例，并调用上面的实例方法。\n\n\n7. useCountDown 组合式 API#\n\n\n7.1 parseTime 解析时间#\n\n\n\n以上这大段代码，parseTime 是主要函数，解析时间，生成天数、小时、分钟、秒、毫秒的对象。\n\n\n7.2 useCountDown 真实逻辑#\n\n真实逻辑这一段可以不用细看。可以调试时再细看。\n\n主要就是利用 Date.now() 会自己走的原理。\n\n\n\n设计的十分巧妙，看到这里，我们可能感慨：不得不佩服。\n\n\n\n码上掘金倒计时简化版二\n\n码上掘金倒计时简化版二@若川\n\n\n\n我们继续来看 raf 和 cancelRaf，是如何实现的。\n\n\n8. raf、cancelRaf、inBrowser 实现#\n\n\n\n上文代码，主要一个 API，requestAnimationFrame、cancelAnimationFrame。\n\n我们这里简单理解为 window.requestAnimationFrame() 中的回调函数，每 16.67ms 执行一次回调函数即可。\n\n也就是类似 setTimeout、clearTimeout\n\n\n\n也可以自行搜索这个 API 查阅更多资料。比如 MDN 上的解释。\n\nmdn window.requestAnimationFrame\n\n> window.requestAnimationFrame()\n> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘\n> 之前执行\n\n> 回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。\n\n> 备注： 若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 window.requestAnimationFrame()。\n\n\n9. 支持格式化时间，默认 HH:mm:ss#\n\n\n9.1 parseFormat 处理格式化#\n\n再来看看，组件中，是如何格式化时间的。这个值得我们参考。我们很多时候可能都是写死天数、小时等文案。不支持自定义格式化。\n\n\n\n\n9.2 padZero 补零#\n\n\n\n行文自此，我们就分析完了毫秒级渲染的倒计时组件的实现。\n\n\n10. 总结#\n\n我们来简单总结下。通过 demo 文件调试，入口文件，主文件，useCountDown 组合式 API，插槽等。\n分析了自定义格式、毫秒级渲染、自定义样式（利用插槽）等功能的实现。\n\n其中毫秒级渲染，主要就是利用 Date.now() 和 （window.requestAnimationFrame）每 16.67ms 执行一次回调函数。\n\n大致流程如下：\n\n\n\n看完这篇源码文章，再去看 CountDown 组件文档，可能就会有豁然开朗的感觉。再看其他组件，可能就可以猜测出大概实现的代码了。\n\n如果是使用 react、Taro 技术栈，感兴趣也可以看看 taroify CountDown 组件的实现 文档，源码。\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n\n11. 加源码共读群交流#\n\n最后可以持续关注我@若川。我会写一个组件库源码系列专栏，欢迎大家关注。\n\n我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。\n\n另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.2k+人）第一的专栏，写有20余篇源码文章。包含jQuery、under\nscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-compose、vue 3.2\n发布、vue-this、create-vue、玩具vite、create-vite 等20余篇源码文章。","routePath":"/vant/count-down/README.juejin","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":47},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":778},{"text":"2.1 克隆源码","id":"21-克隆源码","depth":3,"charIndex":841},{"text":"3. 倒计时组件可谓是十分常用","id":"3-倒计时组件可谓是十分常用","depth":2,"charIndex":963},{"text":"4. 利用 demo 调试源码","id":"4-利用-demo-调试源码","depth":2,"charIndex":1404},{"text":"5. 入口 index.ts","id":"5-入口-indexts","depth":2,"charIndex":1619},{"text":"6. 主文件 Countdown","id":"6-主文件-countdown","depth":2,"charIndex":1834},{"text":"6.1 setup 部分","id":"61-setup-部分","depth":3,"charIndex":1856},{"text":"6.2 useExpose 暴露","id":"62-useexpose-暴露","depth":3,"charIndex":1898},{"text":"7. useCountDown 组合式 API","id":"7-usecountdown-组合式-api","depth":2,"charIndex":2098},{"text":"7.1 parseTime 解析时间","id":"71-parsetime-解析时间","depth":3,"charIndex":2125},{"text":"7.2 useCountDown 真实逻辑","id":"72-usecountdown-真实逻辑","depth":3,"charIndex":2199},{"text":"8. raf、cancelRaf、inBrowser 实现","id":"8-rafcancelrafinbrowser-实现","depth":2,"charIndex":2372},{"text":"9. 支持格式化时间，默认 HH:mm:ss","id":"9-支持格式化时间默认-hhmmss","depth":2,"charIndex":2905},{"text":"9.1 parseFormat 处理格式化","id":"91-parseformat-处理格式化","depth":3,"charIndex":2931},{"text":"9.2 padZero 补零","id":"92-padzero-补零","depth":3,"charIndex":3019},{"text":"10. 总结","id":"10-总结","depth":2,"charIndex":3068},{"text":"11. 加源码共读群交流","id":"11-加源码共读群交流","depth":2,"charIndex":3428}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":111,"title":"分析 vant4 源码，学会了如何开发毫秒级渲染的倒计时组件，真是秒啊","content":"#\n\n本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2022-11-20）star 多达 20.5k，最新版本是\nv4.0.0-rc7。我们可以挑选 vant 组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n这次我们来学习倒计时组件，countdown。\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，我们可以先看 README.md 再看 github/CONTRIBUTING.md\n\n\n2.1 克隆源码#\n\nYou will need Node.js >= 14 and pnpm.\n\n\n\n执行 pnpm dev 后，这时我们打开倒计时组件 http://localhost:5173/#/zh-CN/count-down。\n\n\n3. 倒计时组件可谓是十分常用#\n\n在各种电商类或者其他的移动端页面中，倒计时真的是太常见了。我们自己也基本能够快速的写一个倒计时组件。代码实现参考这里，主要是\nJavaScript。码上掘金倒计时初步代码@若川\n\n代码中，我直接使用的 setInterval 和每秒钟执行一次。把倒计时的时候减去1s，当倒计时毫秒数不足时用 clearInterval 清除停止定时器。\n\n但如果要实现毫秒级的倒计时这种方法行不通。 另外 setInterval 这种做法，并不是最优的。 那么，vant\n倒计时组件中，是如何处理毫秒级和实现倒计时呢。\n\n带着问题我们直接找到 countdown demo\n文件：vant/packages/vant/src/count-down/demo/index.vue。为什么是这个文件，我在之前文章跟着 vant4\n源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码分析了其原理，感兴趣的小伙伴点击查看。这里就不赘述了。\n\n\n4. 利用 demo 调试源码#\n\n组件源码中的 TS 代码我不会过多解释。没学过 TS 的小伙伴，推荐学这个TypeScript 入门教程。 另外，vant 使用了\n@vue/babel-plugin-jsx 插件来支持 JSX、TSX。\n\n\n\n\n\n从 demo 文件中，我们可以看出 ``，引入自 vant/packages/vant/src/count-down/index.ts。我们继续来看入口\nindex.ts。\n\n\n5. 入口 index.ts#\n\n主要就是导出一下类型和变量等。\n\n\n\nwithInstall 函数在之前文章5.1 withInstall 给组件对象添加 install 方法 也有分析，这里就不赘述了。\n\n我们可以在这些文件，任意位置加上 debugger 调试源码。\n\n截两张调试图。\n\n调试 Countdown setup。\n\n\n\n调试 useCountDown。\n\n\n\n我们跟着调试，继续分析 Countdown。\n\n\n6. 主文件 Countdown#\n\n\n\n\n6.1 setup 部分#\n\n这一部分主要使用了useCountDown。\n\n\n\n\n6.2 useExpose 暴露#\n\n\n\n通过 ref 可以获取到 Countdown 实例并调用实例方法，详见组件实例方法。\n\n> Vant 中的许多组件提供了实例方法，调用实例方法时，我们需要通过 ref 来注册组件引用信息，引用信息将会注册在父组件的 $refs\n> 对象上。注册完成后，我们可以通过 this.$refs.xxx 或者\n\n\n\n访问到对应的组件实例，并调用上面的实例方法。\n\n\n7. useCountDown 组合式 API#\n\n\n7.1 parseTime 解析时间#\n\n\n\n以上这大段代码，parseTime 是主要函数，解析时间，生成天数、小时、分钟、秒、毫秒的对象。\n\n\n7.2 useCountDown 真实逻辑#\n\n真实逻辑这一段可以不用细看。可以调试时再细看。\n\n主要就是利用 Date.now() 会自己走的原理。\n\n\n\n设计的十分巧妙，看到这里，我们可能感慨：不得不佩服。\n\n\n\n码上掘金倒计时简化版二\n\n码上掘金倒计时简化版二@若川\n\n\n\n我们继续来看 raf 和 cancelRaf，是如何实现的。\n\n\n8. raf、cancelRaf、inBrowser 实现#\n\n\n\n上文代码，主要一个 API，requestAnimationFrame、cancelAnimationFrame。\n\n我们这里简单理解为 window.requestAnimationFrame() 中的回调函数，每 16.67ms 执行一次回调函数即可。\n\n也就是类似 setTimeout、clearTimeout\n\n\n\n也可以自行搜索这个 API 查阅更多资料。比如 MDN 上的解释。\n\nmdn window.requestAnimationFrame\n\n> window.requestAnimationFrame()\n> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘\n> 之前执行\n\n> 回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。\n\n> 备注： 若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 window.requestAnimationFrame()。\n\n\n9. 支持格式化时间，默认 HH:mm:ss#\n\n\n9.1 parseFormat 处理格式化#\n\n再来看看，组件中，是如何格式化时间的。这个值得我们参考。我们很多时候可能都是写死天数、小时等文案。不支持自定义格式化。\n\n\n\n\n9.2 padZero 补零#\n\n\n\n行文自此，我们就分析完了毫秒级渲染的倒计时组件的实现。\n\n\n10. 总结#\n\n我们来简单总结下。通过 demo 文件调试，入口文件，主文件，useCountDown 组合式 API，插槽等。\n分析了自定义格式、毫秒级渲染、自定义样式（利用插槽）等功能的实现。\n\n其中毫秒级渲染，主要就是利用 Date.now() 和 （window.requestAnimationFrame）每 16.67ms 执行一次回调函数。\n\n大致流程如下：\n\n\n\n看完这篇源码文章，再去看 CountDown 组件文档，可能就会有豁然开朗的感觉。再看其他组件，可能就可以猜测出大概实现的代码了。\n\n如果是使用 react、Taro 技术栈，感兴趣也可以看看 taroify CountDown 组件的实现 文档，源码。\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n\n11. 加源码共读群交流#\n\n最后可以持续关注我@若川。我会写一个组件库源码系列专栏，欢迎大家关注。\n\n我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。\n\n另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.2k+人）第一的专栏，写有20余篇源码文章。包含jQuery、under\nscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-compose、vue 3.2\n发布、vue-this、create-vue、玩具vite、create-vite 等20余篇源码文章。","routePath":"/vant/count-down/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":50},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":781},{"text":"2.1 克隆源码","id":"21-克隆源码","depth":3,"charIndex":844},{"text":"3. 倒计时组件可谓是十分常用","id":"3-倒计时组件可谓是十分常用","depth":2,"charIndex":966},{"text":"4. 利用 demo 调试源码","id":"4-利用-demo-调试源码","depth":2,"charIndex":1407},{"text":"5. 入口 index.ts","id":"5-入口-indexts","depth":2,"charIndex":1622},{"text":"6. 主文件 Countdown","id":"6-主文件-countdown","depth":2,"charIndex":1837},{"text":"6.1 setup 部分","id":"61-setup-部分","depth":3,"charIndex":1859},{"text":"6.2 useExpose 暴露","id":"62-useexpose-暴露","depth":3,"charIndex":1901},{"text":"7. useCountDown 组合式 API","id":"7-usecountdown-组合式-api","depth":2,"charIndex":2101},{"text":"7.1 parseTime 解析时间","id":"71-parsetime-解析时间","depth":3,"charIndex":2128},{"text":"7.2 useCountDown 真实逻辑","id":"72-usecountdown-真实逻辑","depth":3,"charIndex":2202},{"text":"8. raf、cancelRaf、inBrowser 实现","id":"8-rafcancelrafinbrowser-实现","depth":2,"charIndex":2375},{"text":"9. 支持格式化时间，默认 HH:mm:ss","id":"9-支持格式化时间默认-hhmmss","depth":2,"charIndex":2908},{"text":"9.1 parseFormat 处理格式化","id":"91-parseformat-处理格式化","depth":3,"charIndex":2934},{"text":"9.2 padZero 补零","id":"92-padzero-补零","depth":3,"charIndex":3022},{"text":"10. 总结","id":"10-总结","depth":2,"charIndex":3071},{"text":"11. 加源码共读群交流","id":"11-加源码共读群交流","depth":2,"charIndex":3431}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":112,"title":"","content":"本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2022-10-24） star 多达 20.3k。我们可以挑选 vant\n组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n这次我们来分析 vant4 新增的暗黑主题是如何实现的。文章中的 vant4 的版本是 4.0.0-rc.6。vant\n的核心开发者是@chenjiahan，一直在更新vant 。预计不久后就会发布 vant4 正式版。\n\n暗黑主题如图所示:\n\n\n\n也可以打开官方文档链接，自行体验。\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，第一步应该是先看 README.md 再看贡献文档 github/CONTRIBUTING.md。\n\n不知道大家有没有发现，很多开源项目都是英文的 README.md，即使刚开始明显是为面向中国开发者。再给定一个中文的\nREADME.md。主要原因是因为英文是世界通用的语言。想要非中文用户参与进来，英文是必备。也就是说你开源的项目能提供英文版就提供。\n\n\n2.1 克隆源码#\n\n贡献文档中有要求：You will need Node.js >= 14 and pnpm.\n\n\n\n我们先来看 pnpm dev 最终执行的什么命令。\n\nvant 项目使用的是 monorepo 结构。查看根路径下的 package.json。\n\n\n2.2 pnpm dev#\n\n\n\n再看 packages/vant/package.json。\n\n\n\npnpm dev 最终执行的是：vant-cli dev 启动了一个服务。本文主要是讲主题切换的实现，所以我们就不深入 vant-cli dev 命令了。\n\n执行 pnpm dev 后，命令终端输入如图所示，可以发现是使用的是目前最新版本的 vite 3.1.8。\n\n\n\n这时我们打开 http://localhost:5173/#/zh-CN/config-provider。\n\n\n3. 文档网站#\n\n打开后，我们可以按 F12 和 vue-devtools 来查看vant 官方文档的结构。如果没有安装，我们可以访问vue-devtools\n官网通过谷歌应用商店去安装。如果无法打开谷歌应用商店，可以通过这个极简插件链接 下载安装。\n\n\n\nmobile 端\n\n\n\n\n3.1 通过 vue-devtools 打开组件文件#\n\n\n\n如图所示，我们通过 vue-devtools 打开 VanDocSimulator 组件文件。\n\n> 曾经在我的公众号@若川视野 发起投票 发现有很多人不知道这个功能。我也曾经写过文章《据说 99% 的人不知道 vue-devtools\n> 还能直接打开对应组件文件？本文原理揭秘》分析这个功能的原理。感兴趣的小伙伴可以查看。\n\n我们可以看到 vant/packages/vant-cli/site/desktop/components/Simulator.vue 文件，主要是\niframe 实现的，渲染的链接是 /mobile.html#/zh-CN。我们也可以直接打开 mobile 官网 验证下。\n\n\n\n\n3.3 iframe 通信 iframe-sync#\n\n上文JS代码中，有 getDefaultTheme, syncThemeToChild 函数引自文件\nvant/packages/vant-cli/site/common/iframe-sync.js\n\n文件开头主要判断 iframe 渲染完成。\n\n\n\n后半部分主要是三个函数 getDefaultTheme、syncThemeToChild、useCurrentTheme。\n\n\n\n在项目中，我们可以可以搜索 useCurrentTheme 看在哪里使用的。很容易我们可以发现\nvant/packages/vant-cli/site/mobile/App.vue 文件中有使用。\n\n\n3.4 mobile 端#\n\n\n\n\n\n上文阐述了浅色主题和暗黑主题的实现原理，我们接着来看如何通过 ConfigProvider 组件实现主题的深度定制。\n\n\n4. ConfigProvider 组件，深度定制主题#\n\n这个组件的文档有说明，主要就是利用 CSS 变量 来实现的，具体可以查看这个链接学习。这里举个简单的例子。\n\n\n\n可以预设写好若干变量，然后在 style 中修改相关变量，就能得到相应的样式，从而达到深度定制修改主题的能力。\n\n比如：如果把 --van-color: black;，改成 --van-color: red; 则字体颜色是红色。 如果把\n--van-background-color: pink; 改成 --van-background-color: white; 则背景色是白色。\n\nvant 中有一次提交把之前所有的 less 变量，改成了原生 css 的 var 变量。breaking change: no longer support\nless vars\n\nvant 中 ConfigProvider 组件其实就是利用了这个原理。\n\n知晓了上面的原理，我们再来简单看下 ConfigProvider 具体实现。\n\n\n\n有小伙伴可能注意到了，这感觉就是和 react 类似啊。其实 vue 也是支持 jsx。不过需要配置插件\n@vue/babel-plugin-jsx。全局搜索这个插件，可以搜索到在 vant-cli 中配置了这个插件。\n\n\n5. 总结#\n\n我们通过查看 README.md 和贡献文档等，知道了项目使用的 monorepo，vite 等，pnpm i 安装依赖，pnpm dev 跑项目。\n\n我们学会了利用 vue-devtools 快速找到我们不那么熟悉的项目中的文件，并打开相应的文件。\n\n通过文档桌面端和移动端的主题切换，我们学到了原来是 iframe 渲染的移动（mobile）端，通过 iframe postMessage 和\naddEventListener 通信切换主题。\n\n学会了 ConfigProvider 组件是利用 CSS 变量 预设变量样式，来实现的定制主题。\n\n也学会使用 @vue/babel-plugin-jsx 编写 jsx 组件，和写 react 类似。\n\n相比于原生 JS\n等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。开源项目通常有很多优雅实现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n如果是自己开源写项目相对耗时耗力，而且短时间很难有很大收益，很容易放弃。而刚开始可能也无法参与到开源项目中，这时我们可以先从看懂开源项目的源码做起。对于写源码来\n说，看懂源码相对容易。看懂源码后可以写文章分享回馈给社区，也算是对开源做出一种贡献。重要的是行动起来，学着学着就会发现很多都已经学会，锻炼了自己看源码的能力。\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n最后可以持续关注我@若川。这是 vant 第一篇文章。我会写一个组件库源码系列专栏，欢迎大家关注。\n\n我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。\n\n另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。包含jQuery、under\nscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-compose、vue 3.2\n发布、vue-this、create-vue、玩具vite、create-vite 等20余篇源码文章。","routePath":"/vant/dark-theme/README.juejin","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":47},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":881},{"text":"2.1 克隆源码","id":"21-克隆源码","depth":3,"charIndex":1078},{"text":"2.2 pnpm dev","id":"22-pnpm-dev","depth":3,"charIndex":1214},{"text":"3. 文档网站","id":"3-文档网站","depth":2,"charIndex":1457},{"text":"3.1 通过 vue-devtools 打开组件文件","id":"31-通过-vue-devtools-打开组件文件","depth":3,"charIndex":1600},{"text":"3.2 desktop 端","id":"32-desktop-端","depth":3,"charIndex":-1},{"text":"3.3 iframe 通信 iframe-sync","id":"33-iframe-通信-iframe-sync","depth":3,"charIndex":1938},{"text":"3.4 mobile 端","id":"34-mobile-端","depth":3,"charIndex":2259},{"text":"4. ConfigProvider 组件，深度定制主题","id":"4-configprovider-组件深度定制主题","depth":2,"charIndex":2339},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":2902}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":113,"title":"vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢","content":"#\n\n本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2022-10-24） star 多达 20.3k。我们可以挑选 vant\n组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n这次我们来分析 vant4 新增的暗黑主题是如何实现的。文章中的 vant4 的版本是 4.0.0-rc.6。vant\n的核心开发者是@chenjiahan，一直在更新vant 。预计不久后就会发布 vant4 正式版。\n\n暗黑主题如图所示:\n\n\n\n也可以打开官方文档链接，自行体验。\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，第一步应该是先看 README.md 再看贡献文档 github/CONTRIBUTING.md。\n\n不知道大家有没有发现，很多开源项目都是英文的 README.md，即使刚开始明显是为面向中国开发者。再给定一个中文的\nREADME.md。主要原因是因为英文是世界通用的语言。想要非中文用户参与进来，英文是必备。也就是说你开源的项目能提供英文版就提供。\n\n\n2.1 克隆源码#\n\n贡献文档中有要求：You will need Node.js >= 14 and pnpm.\n\n\n\n我们先来看 pnpm dev 最终执行的什么命令。\n\nvant 项目使用的是 monorepo 结构。查看根路径下的 package.json。\n\n\n2.2 pnpm dev#\n\n\n\n再看 packages/vant/package.json。\n\n\n\npnpm dev 最终执行的是：vant-cli dev 启动了一个服务。本文主要是讲主题切换的实现，所以我们就不深入 vant-cli dev 命令了。\n\n执行 pnpm dev 后，命令终端输入如图所示，可以发现是使用的是目前最新版本的 vite 3.1.8。\n\n\n\n这时我们打开 http://localhost:5173/#/zh-CN/config-provider。\n\n\n3. 文档网站#\n\n打开后，我们可以按 F12 和 vue-devtools 来查看vant 官方文档的结构。如果没有安装，我们可以访问vue-devtools\n官网通过谷歌应用商店去安装。如果无法打开谷歌应用商店，可以通过这个极简插件链接 下载安装。\n\n\n\nmobile 端\n\n\n\n\n3.1 通过 vue-devtools 打开组件文件#\n\n\n\n如图所示，我们通过 vue-devtools 打开 VanDocSimulator 组件文件。\n\n> 曾经在我的公众号@若川视野 发起投票 发现有很多人不知道这个功能。我也曾经写过文章《据说 99% 的人不知道 vue-devtools\n> 还能直接打开对应组件文件？本文原理揭秘》分析这个功能的原理。感兴趣的小伙伴可以查看。\n\n我们可以看到 vant/packages/vant-cli/site/desktop/components/Simulator.vue 文件，主要是\niframe 实现的，渲染的链接是 /mobile.html#/zh-CN。我们也可以直接打开 mobile 官网 验证下。\n\n\n\n\n3.3 iframe 通信 iframe-sync#\n\n上文JS代码中，有 getDefaultTheme, syncThemeToChild 函数引自文件\nvant/packages/vant-cli/site/common/iframe-sync.js\n\n文件开头主要判断 iframe 渲染完成。\n\n\n\n后半部分主要是三个函数 getDefaultTheme、syncThemeToChild、useCurrentTheme。\n\n\n\n在项目中，我们可以可以搜索 useCurrentTheme 看在哪里使用的。很容易我们可以发现\nvant/packages/vant-cli/site/mobile/App.vue 文件中有使用。\n\n\n3.4 mobile 端#\n\n\n\n\n\n上文阐述了浅色主题和暗黑主题的实现原理，我们接着来看如何通过 ConfigProvider 组件实现主题的深度定制。\n\n\n4. ConfigProvider 组件，深度定制主题#\n\n这个组件的文档有说明，主要就是利用 CSS 变量 来实现的，具体可以查看这个链接学习。这里举个简单的例子。\n\n\n\n可以预设写好若干变量，然后在 style 中修改相关变量，就能得到相应的样式，从而达到深度定制修改主题的能力。\n\n比如：如果把 --van-color: black;，改成 --van-color: red; 则字体颜色是红色。 如果把\n--van-background-color: pink; 改成 --van-background-color: white; 则背景色是白色。\n\nvant 中有一次提交把之前所有的 less 变量，改成了原生 css 的 var 变量。breaking change: no longer support\nless vars\n\nvant 中 ConfigProvider 组件其实就是利用了这个原理。\n\n知晓了上面的原理，我们再来简单看下 ConfigProvider 具体实现。\n\n\n\n有小伙伴可能注意到了，这感觉就是和 react 类似啊。其实 vue 也是支持 jsx。不过需要配置插件\n@vue/babel-plugin-jsx。全局搜索这个插件，可以搜索到在 vant-cli 中配置了这个插件。\n\n\n5. 总结#\n\n我们通过查看 README.md 和贡献文档等，知道了项目使用的 monorepo，vite 等，pnpm i 安装依赖，pnpm dev 跑项目。\n\n我们学会了利用 vue-devtools 快速找到我们不那么熟悉的项目中的文件，并打开相应的文件。\n\n通过文档桌面端和移动端的主题切换，我们学到了原来是 iframe 渲染的移动（mobile）端，通过 iframe postMessage 和\naddEventListener 通信切换主题。\n\n学会了 ConfigProvider 组件是利用 CSS 变量 预设变量样式，来实现的定制主题。\n\n也学会使用 @vue/babel-plugin-jsx 编写 jsx 组件，和写 react 类似。\n\n相比于原生 JS\n等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。开源项目通常有很多优雅实现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n如果是自己写开源项目相对耗时耗力，而且短时间很难有很大收益，很容易放弃。而刚开始可能也无法参与到开源项目中，这时我们可以先从看懂开源项目的源码做起。对于写源码来\n说，看懂源码相对容易。看懂源码后可以写文章分享回馈给社区，也算是对开源做出一种贡献。重要的是行动起来，学着学着就会发现很多都已经学会，锻炼了自己看源码的能力。\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n最后可以持续关注我@若川。这是 vant 第一篇文章。我会写一个组件库源码系列专栏，欢迎大家关注。\n\n我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。\n\n另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。包含jQuery、under\nscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-compose、vue 3.2\n发布、vue-this、create-vue、玩具vite、create-vite 等20余篇源码文章。","routePath":"/vant/dark-theme/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":50},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":884},{"text":"2.1 克隆源码","id":"21-克隆源码","depth":3,"charIndex":1081},{"text":"2.2 pnpm dev","id":"22-pnpm-dev","depth":3,"charIndex":1217},{"text":"3. 文档网站","id":"3-文档网站","depth":2,"charIndex":1460},{"text":"3.1 通过 vue-devtools 打开组件文件","id":"31-通过-vue-devtools-打开组件文件","depth":3,"charIndex":1603},{"text":"3.2 desktop 端","id":"32-desktop-端","depth":3,"charIndex":-1},{"text":"3.3 iframe 通信 iframe-sync","id":"33-iframe-通信-iframe-sync","depth":3,"charIndex":1941},{"text":"3.4 mobile 端","id":"34-mobile-端","depth":3,"charIndex":2262},{"text":"4. ConfigProvider 组件，深度定制主题","id":"4-configprovider-组件深度定制主题","depth":2,"charIndex":2342},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":2905}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":114,"title":"分析 vant4 组件库源码，写一个常用的 highlight 高亮文本的组件","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎 follow 我的 github。我倾力持续组织了3年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.7k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2024-05-02） star 多达 22.7k，已经正式发布\n4.9.0。我们可以挑选 vant 组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n这次我们来学习 highlight 高亮文本组件，可以点此查看 highlight 文档体验。\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，第一步应该是先看 README.md 再看贡献文档 github/CONTRIBUTING.md。\n\n\n2.1 克隆源码 && 跑起来#\n\nYou will need Node.js >= 18 and pnpm.\n\n\n\n执行 pnpm dev 后，这时我们打开高亮文本组件 http://localhost:8080/#/zh-CN/highlight。\n\n\n\n\n3. pnpm run dev => vant-cli dev#\n\n我们从 package.json 脚本查看 dev 命令。\n\n\n\n限制了 pnpm 版本大于 9.0.0，如果运行报版本错误，可以升级（比如：npm i -g pnpm） pnpm 版本到 9.x。\n\n我们继续跟着 vant/package.json 脚本查看 dev 命令。\n\n\n\n我们继续跟着 vant-cli/package.json 脚本查看 bin 命令。\n\n\n\n\n\n从 package.json 中的 bin 属性可以看出，vant-cli 最终入口文件是lib/cli.js。\n\n\n3.1 lib/cli.js#\n\n\n\n\n\n我们可以找到对应的源文件是：vant-v4.x/packages/vant-cli/src/compiler/compile-site.ts\n\n我们可以从 vant-cli changelog 得知，最新 7.x 版本，采用了 rsbuild，作为打包构建工具，弃用了原有的 vite。\n\n这时我们查阅下 rsbuild 文档，找到配置 sourceMap 的方法。 rsbuild output.sourceMap\n\n\n\n可以搜索 vant-v4.x/packages/vant-cli 项目中的搜索 sourceMap 知道配置开启 sourceMap。\n\n\n\n往期讲述了很多工具函数和脚手架相关的等，所以在此不再赘述。\n\n\n3.2 利用 demo 调试源码#\n\n带着\"高亮文本是如何实现的\"问题我们直接找到 highlight demo\n文件：vant/packages/vant/src/highlight/demo/index.vue。为什么是这个文件，我在之前文章跟着 vant4\n源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码分析了其原理，感兴趣的小伙伴点击查看。这里就不赘述了。\n\n文档上的 demo 图如下：\n\n\n\n对应的是以下代码：\n\n\n\n\n4. 高亮#\n\n我们可以看到入口文件 src/highlight/index.ts。\n\n\n4.1 入口文件 src/highlight/index.ts#\n\n\n\nwithInstall 函数在之前文章5.1 withInstall 给组件对象添加 install 方法 也有分析，这里就不赘述了。\n\n我们可以继续看主文件 src/highlight/Highlight.tsx。\n\n\n4.2 主文件 src/highlight/Highlight.tsx#\n\n\n\n上面代码主要是 Props 定义：\n\n定义了一系列 props，包括控制高亮的各种配置项，如是否自动转义、是否区分大小写、高亮样式类名等。可直接参见文档中的API属性。\n\n\n\n我们可以在这些文件，任意位置加上 debugger 调试源码。比如在 renderContent 函数 debugger 调试。如下图所示：\n\n\n\n如果不知道怎么调试，可以看我之前的文章新手向：前端程序员必学基本技能——调试JS代码\n\n\n\n这段代码不多，就是把高亮的文本组成一个新的标签，可以支持自定义标签和自定义class，渲染结果如下图所示：\n\n\n\nsetup 函数：\n\n在 setup 函数中，通过 computed 创建了一个名为 highlightChunks 的 computed\n属性，该属性根据传入的关键词在原始字符串中生成并合并高亮块。\n\nhighlightChunks 的计算过程包括将关键词转为正则表达式，匹配原始字符串中的位置，并生成含有高亮样式标记的块。\n\nrenderContent 函数：\n\nrenderContent 函数根据 highlightChunks 的结果在原始字符串中提取每个块并生成相应的高亮或非高亮段落。\n\n返回函数：\n\n返回一个渲染函数，在渲染时根据 props 中的设置，生成相应的高亮标签或非高亮标签，并以适当的方式组织和呈现高亮内容。\n\n实现原理概述：\n\n提取关键词：\n\n首先，根据传入的关键词（可以是字符串或字符串数组），将其转换为数组形式。\n\n生成高亮块：\n\n遍历关键词数组，根据是否需要转义和是否区分大小写，生成正则表达式进行匹配，找出原始字符串中的关键词位置，并记录下每个关键词的起始和结束位置以及是否需要高亮。\n\n合并相邻块：\n\n将相邻的高亮块合并为一个块，以减少多余的高亮标记。\n\n生成最终内容：\n\n根据高亮块的信息，在原始字符串中按要求插入高亮标签或非高亮标签，形成最终的高亮内容。\n\n通过以上这些步骤，highlight 组件实现了在给定字符串中根据关键词进行高亮展示的功能。\n\n整体思路是根据关键词通过正则匹配生成高亮块，然后在渲染时根据这些块的信息插入合适的标签和自定义样式名实现高亮效果。\n\n\n4.3 highlightChunks 函数#\n\n我们简单分析下 setup 中的 highlightChunks 函数。不用细看，可以在自己动手调试源码时再细看。\n\n\n\n\n5. 总结#\n\n本文主要讲述了，如何阅读组件库的源码，如何将使用了 rsbuild 的最新版本的 vant-cli 配置开启 sourceMap 进行调试源码。\n\n学习了高亮文本组件的原理和具体实现。实现原理是根据关键词通过正则匹配生成高亮块，然后在渲染时根据这些块的信息插入合适的标签和自定义样式名实现高亮效果。\n\n组件代码虽不多，但实现相对比较优雅。\n\n学会写一个组件就能学会多个组件。建议自己多打断点调试源码，哪里不懂调试哪里。常看我的源码文章的读者都知道，我经常推荐要自己多动手调试源码，这样印象更为深刻。避免\n出现看懂了，但动手实践就不知道如何操作了的情况。纸上得来终觉浅，绝知此事要躬行。\n\n\n6. 加源码共读交流群#\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。\n\n最后可以持续关注我@若川，欢迎 follow 我的\ngithub。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.7k+人）第一的专栏，写有20余篇源码文章。\n\n我倾力持续组织了3年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。","routePath":"/vant/highlight/README.juejin","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":776},{"text":"2.1 克隆源码 && 跑起来","id":"21-克隆源码--跑起来","depth":3,"charIndex":846},{"text":"3. pnpm run dev => vant-cli dev","id":"3-pnpm-run-dev--vant-cli-dev","depth":2,"charIndex":977},{"text":"3.1 lib/cli.js","id":"31-libclijs","depth":3,"charIndex":1259},{"text":"3.2 利用 demo 调试源码","id":"32-利用-demo-调试源码","depth":3,"charIndex":1595},{"text":"4. 高亮","id":"4-高亮","depth":2,"charIndex":1826},{"text":"4.1 入口文件 src/highlight/index.ts","id":"41-入口文件-srchighlightindexts","depth":3,"charIndex":1871},{"text":"4.2 主文件 src/highlight/Highlight.tsx","id":"42-主文件-srchighlighthighlighttsx","depth":3,"charIndex":2018},{"text":"4.3 highlightChunks 函数","id":"43-highlightchunks-函数","depth":3,"charIndex":2982},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":3069},{"text":"6. 加源码共读交流群","id":"6-加源码共读交流群","depth":2,"charIndex":3372}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":115,"title":"分析 vant4 组件库源码，写一个常用的 highlight 高亮文本的组件","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎 follow 我的 github。我倾力持续组织了3年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.7k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2024-05-02） star 多达 22.7k，已经正式发布\n4.9.0。我们可以挑选 vant 组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n这次我们来学习 highlight 高亮文本组件，可以点此查看 highlight 文档体验。\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，第一步应该是先看 README.md 再看贡献文档 github/CONTRIBUTING.md。\n\n\n2.1 克隆源码 && 跑起来#\n\nYou will need Node.js >= 18 and pnpm.\n\n\n\n执行 pnpm dev 后，这时我们打开高亮文本组件 http://localhost:8080/#/zh-CN/highlight。\n\n\n\n\n3. pnpm run dev => vant-cli dev#\n\n我们从 package.json 脚本查看 dev 命令。\n\n\n\n限制了 pnpm 版本大于 9.0.0，如果运行报版本错误，可以升级（比如：npm i -g pnpm） pnpm 版本到 9.x。\n\n我们继续跟着 vant/package.json 脚本查看 dev 命令。\n\n\n\n我们继续跟着 vant-cli/package.json 脚本查看 bin 命令。\n\n\n\n\n\n从 package.json 中的 bin 属性可以看出，vant-cli 最终入口文件是lib/cli.js。\n\n\n3.1 lib/cli.js#\n\n\n\n\n\n我们可以找到对应的源文件是：vant-v4.x/packages/vant-cli/src/compiler/compile-site.ts\n\n我们可以从 vant-cli changelog 得知，最新 7.x 版本，采用了 rsbuild，作为打包构建工具，弃用了原有的 vite。\n\n这时我们查阅下 rsbuild 文档，找到配置 sourceMap 的方法。 rsbuild output.sourceMap\n\n\n\n可以搜索 vant-v4.x/packages/vant-cli 项目中的搜索 sourceMap 知道配置开启 sourceMap。\n\n\n\n往期讲述了很多工具函数和脚手架相关的等，所以在此不再赘述。\n\n\n3.2 利用 demo 调试源码#\n\n带着\"高亮文本是如何实现的\"问题我们直接找到 highlight demo\n文件：vant/packages/vant/src/highlight/demo/index.vue。为什么是这个文件，我在之前文章跟着 vant4\n源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码分析了其原理，感兴趣的小伙伴点击查看。这里就不赘述了。\n\n文档上的 demo 图如下：\n\n\n\n对应的是以下代码：\n\n\n\n\n4. 高亮#\n\n我们可以看到入口文件 src/highlight/index.ts。\n\n\n4.1 入口文件 src/highlight/index.ts#\n\n\n\nwithInstall 函数在之前文章5.1 withInstall 给组件对象添加 install 方法 也有分析，这里就不赘述了。\n\n我们可以继续看主文件 src/highlight/Highlight.tsx。\n\n\n4.2 主文件 src/highlight/Highlight.tsx#\n\n\n\n上面代码主要是 Props 定义：\n\n定义了一系列 props，包括控制高亮的各种配置项，如是否自动转义、是否区分大小写、高亮样式类名等。可直接参见文档中的API属性。\n\n\n\n我们可以在这些文件，任意位置加上 debugger 调试源码。比如在 renderContent 函数 debugger 调试。如下图所示：\n\n\n\n如果不知道怎么调试，可以看我之前的文章新手向：前端程序员必学基本技能——调试JS代码\n\n\n\n这段代码不多，就是把高亮的文本组成一个新的标签，可以支持自定义标签和自定义class，渲染结果如下图所示：\n\n\n\nsetup 函数：\n\n在 setup 函数中，通过 computed 创建了一个名为 highlightChunks 的 computed\n属性，该属性根据传入的关键词在原始字符串中生成并合并高亮块。\n\nhighlightChunks 的计算过程包括将关键词转为正则表达式，匹配原始字符串中的位置，并生成含有高亮样式标记的块。\n\nrenderContent 函数：\n\nrenderContent 函数根据 highlightChunks 的结果在原始字符串中提取每个块并生成相应的高亮或非高亮段落。\n\n返回函数：\n\n返回一个渲染函数，在渲染时根据 props 中的设置，生成相应的高亮标签或非高亮标签，并以适当的方式组织和呈现高亮内容。\n\n实现原理概述：\n\n提取关键词：\n\n首先，根据传入的关键词（可以是字符串或字符串数组），将其转换为数组形式。\n\n生成高亮块：\n\n遍历关键词数组，根据是否需要转义和是否区分大小写，生成正则表达式进行匹配，找出原始字符串中的关键词位置，并记录下每个关键词的起始和结束位置以及是否需要高亮。\n\n合并相邻块：\n\n将相邻的高亮块合并为一个块，以减少多余的高亮标记。\n\n生成最终内容：\n\n根据高亮块的信息，在原始字符串中按要求插入高亮标签或非高亮标签，形成最终的高亮内容。\n\n通过以上这些步骤，highlight 组件实现了在给定字符串中根据关键词进行高亮展示的功能。\n\n整体思路是根据关键词通过正则匹配生成高亮块，然后在渲染时根据这些块的信息插入合适的标签和自定义样式名实现高亮效果。\n\n\n4.3 highlightChunks 函数#\n\n我们简单分析下 setup 中的 highlightChunks 函数。不用细看，可以在自己动手调试源码时再细看。\n\n\n\n\n5. 总结#\n\n本文主要讲述了，如何阅读组件库的源码，如何将使用了 rsbuild 的最新版本的 vant-cli 配置开启 sourceMap 进行调试源码。\n\n学习了高亮文本组件的原理和具体实现。实现原理是根据关键词通过正则匹配生成高亮块，然后在渲染时根据这些块的信息插入合适的标签和自定义样式名实现高亮效果。\n\n组件代码虽不多，但实现相对比较优雅。\n\n学会写一个组件就能学会多个组件。建议自己多打断点调试源码，哪里不懂调试哪里。常看我的源码文章的读者都知道，我经常推荐要自己多动手调试源码，这样印象更为深刻。避免\n出现看懂了，但动手实践就不知道如何操作了的情况。纸上得来终觉浅，绝知此事要躬行。\n\n\n6. 加源码共读交流群#\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。\n\n最后可以持续关注我@若川，欢迎 follow 我的\ngithub。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.7k+人）第一的专栏，写有20余篇源码文章。\n\n我倾力持续组织了3年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。","routePath":"/vant/highlight/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":776},{"text":"2.1 克隆源码 && 跑起来","id":"21-克隆源码--跑起来","depth":3,"charIndex":846},{"text":"3. pnpm run dev => vant-cli dev","id":"3-pnpm-run-dev--vant-cli-dev","depth":2,"charIndex":977},{"text":"3.1 lib/cli.js","id":"31-libclijs","depth":3,"charIndex":1259},{"text":"3.2 利用 demo 调试源码","id":"32-利用-demo-调试源码","depth":3,"charIndex":1595},{"text":"4. 高亮","id":"4-高亮","depth":2,"charIndex":1826},{"text":"4.1 入口文件 src/highlight/index.ts","id":"41-入口文件-srchighlightindexts","depth":3,"charIndex":1871},{"text":"4.2 主文件 src/highlight/Highlight.tsx","id":"42-主文件-srchighlighthighlighttsx","depth":3,"charIndex":2018},{"text":"4.3 highlightChunks 函数","id":"43-highlightchunks-函数","depth":3,"charIndex":2982},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":3069},{"text":"6. 加源码共读交流群","id":"6-加源码共读交流群","depth":2,"charIndex":3372}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":116,"title":"","content":" * demos","routePath":"/vant/highlight/todo","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":117,"title":"","content":"本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.3k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2022-11-29） star 多达 20.5k，已经正式发布 4.0\n了。我们可以挑选 vant 组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n这次我们来学习 Lazyload 懒加载组件，可以点此查看 lazyload 文档体验。\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，第一步应该是先看 README.md 再看贡献文档 github/CONTRIBUTING.md。\n\n\n2.1 克隆源码 && 跑起来#\n\nYou will need Node.js >= 14 and pnpm.\n\n\n\n执行 pnpm dev 后，这时我们打开懒加载组件 http://localhost:5173/#/zh-CN/lazyload。\n\n\n3. 图片懒加载原理#\n\n众所周知，图片懒加载的原理其实相对简单。就是进入可视区再加载图片。涉及到的知识点主要有：节流、新API、IntersectionObserver。\n\n大致流程：\n\n * 事件模式\n\n\n\n * observer 模式\n\n主要是第二步用 IntersectionObserver API。\n\n那么 vant4 中的 lazyload 怎么做的呢。\n\n带着问题我们直接找到 lazyload demo\n文件：vant/packages/vant/src/lazyload/demo/index.vue。为什么是这个文件，我在之前文章跟着 vant4\n源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码分析了其原理，感兴趣的小伙伴点击查看。这里就不赘述了。\n\n\n4. 利用 demo 调试源码#\n\n\n\n我们可以看出 lazy-load 为入口文件。\n\n这里先附上两张调试截图。动手调试时可以参考学习。\n\ninstall 函数调试\n\n\n\nLazyClass 调试\n\n\n\n\n5. lazy-load 入口文件#\n\n从 vue-lazyload 文件引入导出和默认导出 Lazyload。 主要包含：\n\n * 把 lazy 实例对象添加到全局上\n * 注册懒加载组件\n * 注册图片组件\n * 注册指令 lazy\n * 注册指令 lazy-container\n\n\n\n我们接着来看 vue-lazyload/index.js 主文件。\n\n\n6. vue-lazyload/index.js 主文件#\n\n主要导出一个包含 install 方法的对象 Lazyload。\n\n\n\n单从图片懒加载来看，简化上面的代码，则是这样。\n\n\n\n我们先来看 LazyImage 组件。\n\n\n7. lazy-image 组件#\n\n传入 lazy 实例对象作为参数，默认导出一个返回 vue 组件对象的函数。\n\n我看这块源码时，调试发现由于 render 函数 vue2 和 vue3 写法不同，导致报错。于是提了一个PR，修复了这个问题。\n\nfix(lazyload): lazy-image h is not a function (#11229)\n\n\n\n\n7.1 watch、created、mounted、beforeUnmount#\n\n\n\n我们可以看出，主要有以下三个实例方法，下文细述。\n\n\n\n\n7.2 methods init 初始化函数#\n\n\n\n\n7.3 methods checkInView 检查元素是否在视图中的函数#\n\n\n\n这里主要是用了 useRect 组合式 API。\n\nvant 文档：useRect 获取元素的大小及其相对于视口的位置\n\n获取元素的大小及其相对于视口的位置，等价于 Element.getBoundingClientRect。\n\n更多介绍，我在文章 分析 vant4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？分析过，这里就不在赘述了。\n\n\n7.4 methods load 函数#\n\n\n\n我们来看 loadImageAsync 函数。\n\n\n7.5 loadImageAsync 加载图片#\n\nmdn 文档：HTMLImageElement\n\n\n\n我们接着来看 lazy.js 文件中的 Lazy 类。\n\n\n8. lazy 类#\n\n我们来看 lazy.js 主结构，拥有若干实例方法。\n\n\n\n\n8.1 构造函数 Lazy#\n\n\n\n值得一提的是：throttle 节流函数，包裹 lazyLoadHandler。为了防止多次快速加载，影响性能。\n\n\n8.2 实例方法 lazyLoadHandler#\n\n英文注释：发现节点（元素）在视口，触发 load 事件\n\n\n\n\n8.3 setMode 设置模式：事件模式还是 observer 模式#\n\n\n\n\n\n\n8.4 initListen 初始化监听事件#\n\n添加和移除事件监听\n\n\n\n8.4.1 on、off 监听事件，移除事件#\n\n\n\n\n\n\n8.5 initIntersectionObserver 初始化#\n\n\n\n\n8.6 observerHandler 观测，触发 load 事件#\n\nmdn 文档：IntersectionObserverEntry\n\n\n\n\n8.7 实例方法 addLazyBox 添加要懒加载的组件到队列（数组）#\n\n\n\n\n8.8 实例方法 removeComponent 移除组件#\n\n\n\n\n8.9 addListenerTarget 添加事件的目标元素#\n\n比如 window 等。\n\n\n\n\n8.10 removeListenerTarget 移除事件的目标元素#\n\n\n\n\n9. 总结#\n\n大致流程：\n\n * 事件模式\n\n\n\n * observer 模式\n\n主要是第二步用 IntersectionObserver API。\n\n\n\n在 load 事件中，调用 loadImageAsync 函数。\n\n\n\n行文至此，我们就算分析完了 lazyload 组件。\n\n其中，有很多细节处理值得我们学习。 比如：\n\n * 监听事件，不仅仅是 scroll\n   事件，还有'scroll','wheel','mousewheel','resize','animationend','transitionend','t\n   ouchmove'\n * 监听本身数组存起来了\n * 目标元素也用数组存起来了。\n\ninstall 函数主要有以下实现：\n\n * 把 lazy 实例对象添加到全局上\n * 注册懒加载组件\n * 注册图片组件\n * 注册指令 lazy\n * 注册指令 lazy-container 没有分析。\n\n但限于篇幅原因，组件源码还有指令部分没有分析。 感兴趣的小伙伴可以自行分析学习。\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n\n10. 加源码共读群交流#\n\n最后可以持续关注我@若川。我会写一个组件库源码系列专栏，欢迎大家关注。\n\n我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。\n\n另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。","routePath":"/vant/lazyload/README.juejin","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":47},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":796},{"text":"2.1 克隆源码 && 跑起来","id":"21-克隆源码--跑起来","depth":3,"charIndex":866},{"text":"3. 图片懒加载原理","id":"3-图片懒加载原理","depth":2,"charIndex":993},{"text":"4. 利用 demo 调试源码","id":"4-利用-demo-调试源码","depth":2,"charIndex":1346},{"text":"5. lazy-load 入口文件","id":"5-lazy-load-入口文件","depth":2,"charIndex":1450},{"text":"6. vue-lazyload/index.js 主文件","id":"6-vue-lazyloadindexjs-主文件","depth":2,"charIndex":1631},{"text":"7. lazy-image 组件","id":"7-lazy-image-组件","depth":2,"charIndex":1747},{"text":"7.1 watch、created、mounted、beforeUnmount","id":"71-watchcreatedmountedbeforeunmount","depth":3,"charIndex":1931},{"text":"7.2 methods init 初始化函数","id":"72-methods-init-初始化函数","depth":3,"charIndex":2004},{"text":"7.3 methods checkInView 检查元素是否在视图中的函数","id":"73-methods-checkinview-检查元素是否在视图中的函数","depth":3,"charIndex":2032},{"text":"7.4 methods load 函数","id":"74-methods-load-函数","depth":3,"charIndex":2258},{"text":"7.5 loadImageAsync 加载图片","id":"75-loadimageasync-加载图片","depth":3,"charIndex":2308},{"text":"8. lazy 类","id":"8-lazy-类","depth":2,"charIndex":2391},{"text":"8.1 构造函数 Lazy","id":"81-构造函数-lazy","depth":3,"charIndex":2434},{"text":"8.2 实例方法 lazyLoadHandler","id":"82-实例方法-lazyloadhandler","depth":3,"charIndex":2511},{"text":"8.3 setMode 设置模式：事件模式还是 observer 模式","id":"83-setmode-设置模式事件模式还是-observer-模式","depth":3,"charIndex":2570},{"text":"8.4 initListen 初始化监听事件","id":"84-initlisten-初始化监听事件","depth":3,"charIndex":2613},{"text":"8.4.1 on、off 监听事件，移除事件","id":"841-onoff-监听事件移除事件","depth":4,"charIndex":2651},{"text":"8.5 initIntersectionObserver 初始化","id":"85-initintersectionobserver-初始化","depth":3,"charIndex":2681},{"text":"8.6 observerHandler 观测，触发 load 事件","id":"86-observerhandler-观测触发-load-事件","depth":3,"charIndex":2719},{"text":"8.7 实例方法 addLazyBox 添加要懒加载的组件到队列（数组）","id":"87-实例方法-addlazybox-添加要懒加载的组件到队列数组","depth":3,"charIndex":2792},{"text":"8.8 实例方法 removeComponent 移除组件","id":"88-实例方法-removecomponent-移除组件","depth":3,"charIndex":2834},{"text":"8.9 addListenerTarget 添加事件的目标元素","id":"89-addlistenertarget-添加事件的目标元素","depth":3,"charIndex":2869},{"text":"8.10 removeListenerTarget 移除事件的目标元素","id":"810-removelistenertarget-移除事件的目标元素","depth":3,"charIndex":2920},{"text":"9. 总结","id":"9-总结","depth":2,"charIndex":2961},{"text":"10. 加源码共读群交流","id":"10-加源码共读群交流","depth":2,"charIndex":3460}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":118,"title":"vant4.0 正式发布了，跟着学会用 vue3 写一个图片懒加载组件！","content":"#\n\n本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.3k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2022-11-29） star 多达 20.5k，已经正式发布 4.0\n了。我们可以挑选 vant 组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n这次我们来学习 Lazyload 懒加载组件，可以点此查看 lazyload 文档体验。\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，第一步应该是先看 README.md 再看贡献文档 github/CONTRIBUTING.md。\n\n\n2.1 克隆源码 && 跑起来#\n\nYou will need Node.js >= 14 and pnpm.\n\n\n\n执行 pnpm dev 后，这时我们打开懒加载组件 http://localhost:5173/#/zh-CN/lazyload。\n\n\n3. 图片懒加载原理#\n\n众所周知，图片懒加载的原理其实相对简单。就是进入可视区再加载图片。涉及到的知识点主要有：节流、新API、IntersectionObserver。\n\n大致流程：\n\n * 事件模式\n\n\n\n * observer 模式\n\n主要是第二步用 IntersectionObserver API。\n\n那么 vant4 中的 lazyload 怎么做的呢。\n\n带着问题我们直接找到 lazyload demo\n文件：vant/packages/vant/src/lazyload/demo/index.vue。为什么是这个文件，我在之前文章跟着 vant4\n源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码分析了其原理，感兴趣的小伙伴点击查看。这里就不赘述了。\n\n\n4. 利用 demo 调试源码#\n\n\n\n我们可以看出 lazy-load 为入口文件。\n\n这里先附上两张调试截图。动手调试时可以参考学习。\n\ninstall 函数调试\n\nLazyClass 调试\n\n\n5. lazy-load 入口文件#\n\n从 vue-lazyload 文件引入导出和默认导出 Lazyload。 主要包含：\n\n * 把 lazy 实例对象添加到全局上\n * 注册懒加载组件\n * 注册图片组件\n * 注册指令 lazy\n * 注册指令 lazy-container\n\n\n\n我们接着来看 vue-lazyload/index.js 主文件。\n\n\n6. vue-lazyload/index.js 主文件#\n\n主要导出一个包含 install 方法的对象 Lazyload。\n\n\n\n单从图片懒加载来看，简化上面的代码，则是这样。\n\n\n\n我们先来看 LazyImage 组件。\n\n\n7. lazy-image 组件#\n\n传入 lazy 实例对象作为参数，默认导出一个返回 vue 组件对象的函数。\n\n我看这块源码时，调试发现由于 render 函数 vue2 和 vue3 写法不同，导致报错。于是提了一个PR，修复了这个问题。\n\nfix(lazyload): lazy-image h is not a function (#11229)\n\n\n\n\n7.1 watch、created、mounted、beforeUnmount#\n\n\n\n我们可以看出，主要有以下三个实例方法，下文细述。\n\n\n\n\n7.2 methods init 初始化函数#\n\n\n\n\n7.3 methods checkInView 检查元素是否在视图中的函数#\n\n\n\n这里主要是用了 useRect 组合式 API。\n\nvant 文档：useRect 获取元素的大小及其相对于视口的位置\n\n获取元素的大小及其相对于视口的位置，等价于 Element.getBoundingClientRect。\n\n更多介绍，我在文章 分析 vant4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？分析过，这里就不在赘述了。\n\n\n7.4 methods load 函数#\n\n\n\n我们来看 loadImageAsync 函数。\n\n\n7.5 loadImageAsync 加载图片#\n\nmdn 文档：HTMLImageElement\n\n\n\n我们接着来看 lazy.js 文件中的 Lazy 类。\n\n\n8. lazy 类#\n\n我们来看 lazy.js 主结构，拥有若干实例方法。\n\n\n\n\n8.1 构造函数 Lazy#\n\n\n\n值得一提的是：throttle 节流函数，包裹 lazyLoadHandler。为了防止多次快速加载，影响性能。\n\n\n8.2 实例方法 lazyLoadHandler#\n\n英文注释：发现节点（元素）在视口，触发 load 事件\n\n\n\n\n8.3 setMode 设置模式：事件模式还是 observer 模式#\n\n\n\n\n\n\n8.4 initListen 初始化监听事件#\n\n添加和移除事件监听\n\n\n\n8.4.1 on、off 监听事件，移除事件#\n\n\n\n\n\n\n8.5 initIntersectionObserver 初始化#\n\n\n\n\n8.6 observerHandler 观测，触发 load 事件#\n\nmdn 文档：IntersectionObserverEntry\n\n\n\n\n8.7 实例方法 addLazyBox 添加要懒加载的组件到队列（数组）#\n\n\n\n\n8.8 实例方法 removeComponent 移除组件#\n\n\n\n\n8.9 addListenerTarget 添加事件的目标元素#\n\n比如 window 等。\n\n\n\n\n8.10 removeListenerTarget 移除事件的目标元素#\n\n\n\n\n9. 总结#\n\n大致流程：\n\n * 事件模式\n\n\n\n * observer 模式\n\n主要是第二步用 IntersectionObserver API。\n\n\n\n在 load 事件中，调用 loadImageAsync 函数。\n\n\n\n行文至此，我们就算分析完了 lazyload 组件。\n\n其中，有很多细节处理值得我们学习。 比如：\n\n * 监听事件，不仅仅是 scroll\n   事件，还有'scroll','wheel','mousewheel','resize','animationend','transitionend','t\n   ouchmove'\n * 监听本身数组存起来了\n * 目标元素也用数组存起来了。\n\ninstall 函数主要有以下实现：\n\n * 把 lazy 实例对象添加到全局上\n * 注册懒加载组件\n * 注册图片组件\n * 注册指令 lazy\n * 注册指令 lazy-container 没有分析。\n\n但限于篇幅原因，组件源码还有指令部分没有分析。 感兴趣的小伙伴可以自行分析学习。\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n\n10. 加源码共读群交流#\n\n最后可以持续关注我@若川。我会写一个组件库源码系列专栏，欢迎大家关注。\n\n我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。\n\n另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。","routePath":"/vant/lazyload/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":50},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":799},{"text":"2.1 克隆源码 && 跑起来","id":"21-克隆源码--跑起来","depth":3,"charIndex":869},{"text":"3. 图片懒加载原理","id":"3-图片懒加载原理","depth":2,"charIndex":996},{"text":"4. 利用 demo 调试源码","id":"4-利用-demo-调试源码","depth":2,"charIndex":1349},{"text":"5. lazy-load 入口文件","id":"5-lazy-load-入口文件","depth":2,"charIndex":1449},{"text":"6. vue-lazyload/index.js 主文件","id":"6-vue-lazyloadindexjs-主文件","depth":2,"charIndex":1630},{"text":"7. lazy-image 组件","id":"7-lazy-image-组件","depth":2,"charIndex":1746},{"text":"7.1 watch、created、mounted、beforeUnmount","id":"71-watchcreatedmountedbeforeunmount","depth":3,"charIndex":1930},{"text":"7.2 methods init 初始化函数","id":"72-methods-init-初始化函数","depth":3,"charIndex":2003},{"text":"7.3 methods checkInView 检查元素是否在视图中的函数","id":"73-methods-checkinview-检查元素是否在视图中的函数","depth":3,"charIndex":2031},{"text":"7.4 methods load 函数","id":"74-methods-load-函数","depth":3,"charIndex":2257},{"text":"7.5 loadImageAsync 加载图片","id":"75-loadimageasync-加载图片","depth":3,"charIndex":2307},{"text":"8. lazy 类","id":"8-lazy-类","depth":2,"charIndex":2390},{"text":"8.1 构造函数 Lazy","id":"81-构造函数-lazy","depth":3,"charIndex":2433},{"text":"8.2 实例方法 lazyLoadHandler","id":"82-实例方法-lazyloadhandler","depth":3,"charIndex":2510},{"text":"8.3 setMode 设置模式：事件模式还是 observer 模式","id":"83-setmode-设置模式事件模式还是-observer-模式","depth":3,"charIndex":2569},{"text":"8.4 initListen 初始化监听事件","id":"84-initlisten-初始化监听事件","depth":3,"charIndex":2612},{"text":"8.4.1 on、off 监听事件，移除事件","id":"841-onoff-监听事件移除事件","depth":4,"charIndex":2650},{"text":"8.5 initIntersectionObserver 初始化","id":"85-initintersectionobserver-初始化","depth":3,"charIndex":2680},{"text":"8.6 observerHandler 观测，触发 load 事件","id":"86-observerhandler-观测触发-load-事件","depth":3,"charIndex":2718},{"text":"8.7 实例方法 addLazyBox 添加要懒加载的组件到队列（数组）","id":"87-实例方法-addlazybox-添加要懒加载的组件到队列数组","depth":3,"charIndex":2791},{"text":"8.8 实例方法 removeComponent 移除组件","id":"88-实例方法-removecomponent-移除组件","depth":3,"charIndex":2833},{"text":"8.9 addListenerTarget 添加事件的目标元素","id":"89-addlistenertarget-添加事件的目标元素","depth":3,"charIndex":2868},{"text":"8.10 removeListenerTarget 移除事件的目标元素","id":"810-removelistenertarget-移除事件的目标元素","depth":3,"charIndex":2919},{"text":"9. 总结","id":"9-总结","depth":2,"charIndex":2960},{"text":"10. 加源码共读群交流","id":"10-加源码共读群交流","depth":2,"charIndex":3459}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":119,"title":"分析 vant4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？","content":"#\n\n本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2022-11-13） star 多达 20.4k。我们可以挑选 vant\n组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，第一步应该是先看 README.md 再看贡献文档 github/CONTRIBUTING.md。\n\n\n2.1 克隆源码 && 跑起来#\n\nYou will need Node.js >= 14 and pnpm.\n\n\n\n我们先来看 pnpm dev 最终执行的什么命令。\n\nvant 项目使用的是 monorepo 结构。查看根路径下的 package.json。\n\nvant/package.json => \"dev\": \"pnpm --dir ./packages/vant dev\"\nvant/packages/vant/package.json => \"dev\": \"vant-cli dev\"\n\npnpm dev 最终执行的是：vant-cli dev 执行测试用例。本文主要是学习 List 组件 的实现，所以我们就不深入 vant-cli dev\n命令了。\n\n\n3. List 组件#\n\nList 组件文档\n\n> 瀑布流滚动加载，用于展示长列表，当列表即将滚动到底部时，会触发事件并加载更多列表项。\n\n从这个描述和我们自己体验 demo 来。 至少有以下三个问题值得去了解学习。\n\n * 如何监听滚动\n * 如何计算滚动到了底部\n * 如何触发事件加载更多\n\n带着问题我们直接找到 list demo\n文件：vant/packages/vant/src/list/demo/index.vue。为什么是这个文件，我在上篇文章跟着 vant4 源码学习如何用\nvue3+ts 开发一个 loading 组件，仅88行代码分析了其原理，感兴趣的小伙伴点击查看。这里就不赘述了。\n\n\n3.1 利用 demo 调试#\n\n组件源码中的 TS 代码我不会过多解释。没学过 TS 的小伙伴，推荐学这个TypeScript 入门教程。 另外，vant 使用了\n@vue/babel-plugin-jsx 插件来支持 JSX、TSX。\n\n\n\n\n4. 入口文件#\n\n主要就是导出一下类型和变量等。\n\n\n\nwithInstall 函数在上篇文章5.1 withInstall 给组件对象添加 install 方法 也有分析，这里就不赘述了。\n\n我们可以在这些文件，任意位置加上 debugger 调试源码。\n\n\n5. 主文件#\n\n\n\nList 组件 api\n\n\n\ndebugger 调试截图。\n\n\n\n接着我们来看其他一些事件。\n\n\n5.1 一些事件 useExpose、useEventListener#\n\n\n\n由上面代码可以看出，check 函数非常重要，我们在下文分析它。\n\n我们先分析上面代码用到的 useExpose、useEventListener 组合式 API。\n\n\n5.2 useExpose 暴露#\n\n\n\n通过 ref 可以获取到 List 实例并调用实例方法，详见组件实例方法。\n\n> Vant 中的许多组件提供了实例方法，调用实例方法时，我们需要通过 ref 来注册组件引用信息，引用信息将会注册在父组件的 $refs\n> 对象上。注册完成后，我们可以通过 this.$refs.xxx 访问到对应的组件实例，并调用上面的实例方法。\n\n\n5.3 useEventListener 绑定事件#\n\n方便地进行事件绑定，在组件 mounted 和 activated 时绑定事件，unmounted 和 deactivated 时解绑事件。\n\n\n\n\n\n\n6. steup check 函数#\n\n\n\n从 check 函数可以看出，主要就是利用滚动高度，接下来我们看这个函数中，使用到的组合式\nAPI，useTabStatus、useScrollParent、useRect。\n\n\n6.1 useTabStatus tab 组件的状态#\n\n\n\n代码根据 commit 可以发现 useTabStatus 有这样一次提交。\n\nfix(List): skip check when inside an inactive tab\n\n主要是在 van-tabs 组件中，provide(TAB_STATUS_KEY, active); 提供了一个状态。tab 不活跃时，跳过 check\n函数，不执行。\n\n\n6.2 useScrollParent 获取元素最近的可滚动父元素#\n\n获取元素最近的可滚动父元素。\n\n给定参数 el, root 节点，遍历父级节点查找 style 包含 scroll|auto|overlay 的元素，如果没找到，返回第二个 root\n参数（没有第二个参数则是 window）。\n\nuseScrollParent 文档\n\n\n\n\n6.3 useRect 获取元素的大小及其相对于视口的位置#\n\nhttps://vant-contrib.gitee.io/vant/#/zh-CN/use-rect\n\n获取元素的大小及其相对于视口的位置，等价于 Element.getBoundingClientRect。\n\n\n\n\n\n\n6.4 isHidden 是否隐藏#\n\n\n\n接着我们来分析开头的插槽部分。\n\n\n7. 插槽#\n\n插槽部分基本都是有插槽用插槽没有则用默认的。\n\n插槽是函数，比如 slots.default()。\n\n\n\n\n7.1 renderFinishedText 渲染加载完成文字#\n\n\n\n\n7.2 renderErrorText 渲染加载失败文字#\n\n\n\n\n7.3 renderLoading 渲染 loading#\n\n\n\n\n8. 总结#\n\n我们主要分析了 List 组件 实现原理。\n\n原理：使用 addEventListener 监听父级元素的 sroll 事件，用 Element.getBoundingClientRect\n获取元素的大小及其相对于视口的位置，（滚动父级元素和占位元素计算和组件属性 offset（默认300） 属性比较），检测是否触底，触底则加载更多。\n\n\n\n同时分析了一些相关组合式 API\n\n * useExpose 暴露接口供 this.$refs.xxx 使用\n * useEventListener 绑定事件\n * useTabStatus 当前 tab 是否激活的状态\n * useScrollParent 获取元素最近的可滚动父元素\n * useRect 获取元素的大小及其相对于视口的位置\n\n组件留有四个插槽，分别是：\n\n * default 列表内容\n * loading 自定义底部加载中提示\n * finished 自定义加载完成后的提示文案\n * error 自定义加载失败后的提示文案\n\n至此，我们就分析完了 List 组件，主要与 DOM 操作会比较多。List 组件 主文件的代码仅有 100 多行，但封装了很多组合式 API\n。看完这篇源码文章，再去看 List 组件文档，可能就会有豁然开朗的感觉。再看其他组件，可能就可以猜测出大概实现的代码了。\n\n如果是使用 react、Taro 技术栈，感兴趣也可以看看 taroify List 组件的实现 文档，源码。\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n\n9. 加源码共读群交流#\n\n最后可以持续关注我@若川。我会写一个组件库源码系列专栏，欢迎大家关注。\n\n我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。\n\n另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。","routePath":"/vant/list/README.juejin","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":50},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":740},{"text":"2.1 克隆源码 && 跑起来","id":"21-克隆源码--跑起来","depth":3,"charIndex":810},{"text":"3. List 组件","id":"3-list-组件","depth":2,"charIndex":1147},{"text":"3.1 利用 demo 调试","id":"31-利用-demo-调试","depth":3,"charIndex":1455},{"text":"4. 入口文件","id":"4-入口文件","depth":2,"charIndex":1579},{"text":"5. 主文件","id":"5-主文件","depth":2,"charIndex":1711},{"text":"5.1 一些事件 useExpose、useEventListener","id":"51-一些事件-useexposeuseeventlistener","depth":3,"charIndex":1771},{"text":"5.2 useExpose 暴露","id":"52-useexpose-暴露","depth":3,"charIndex":1896},{"text":"5.3 useEventListener 绑定事件","id":"53-useeventlistener-绑定事件","depth":3,"charIndex":2085},{"text":"6. steup check 函数","id":"6-steup-check-函数","depth":2,"charIndex":2190},{"text":"6.1 useTabStatus tab 组件的状态","id":"61-usetabstatus-tab-组件的状态","depth":3,"charIndex":2302},{"text":"6.2 useScrollParent 获取元素最近的可滚动父元素","id":"62-usescrollparent-获取元素最近的可滚动父元素","depth":3,"charIndex":2511},{"text":"6.3 useRect 获取元素的大小及其相对于视口的位置","id":"63-userect-获取元素的大小及其相对于视口的位置","depth":3,"charIndex":2685},{"text":"6.4 isHidden 是否隐藏","id":"64-ishidden-是否隐藏","depth":3,"charIndex":2829},{"text":"7. 插槽","id":"7-插槽","depth":2,"charIndex":2869},{"text":"7.1 renderFinishedText 渲染加载完成文字","id":"71-renderfinishedtext-渲染加载完成文字","depth":3,"charIndex":2931},{"text":"7.2 renderErrorText 渲染加载失败文字","id":"72-rendererrortext-渲染加载失败文字","depth":3,"charIndex":2968},{"text":"7.3 renderLoading  渲染 loading","id":"73-renderloading--渲染-loading","depth":3,"charIndex":-1},{"text":"8. 总结","id":"8-总结","depth":2,"charIndex":3036},{"text":"9. 加源码共读群交流","id":"9-加源码共读群交流","depth":2,"charIndex":3725}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":120,"title":"分析 vant4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？","content":"#\n\n本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2022-11-13） star 多达 20.4k。我们可以挑选 vant\n组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，第一步应该是先看 README.md 再看贡献文档 github/CONTRIBUTING.md。\n\n\n2.1 克隆源码 && 跑起来#\n\nYou will need Node.js >= 14 and pnpm.\n\n\n\n我们先来看 pnpm dev 最终执行的什么命令。\n\nvant 项目使用的是 monorepo 结构。查看根路径下的 package.json。\n\nvant/package.json => \"dev\": \"pnpm --dir ./packages/vant dev\"\nvant/packages/vant/package.json => \"dev\": \"vant-cli dev\"\n\npnpm dev 最终执行的是：vant-cli dev 执行测试用例。本文主要是学习 List 组件 的实现，所以我们就不深入 vant-cli dev\n命令了。\n\n\n3. List 组件#\n\nList 组件文档\n\n> 瀑布流滚动加载，用于展示长列表，当列表即将滚动到底部时，会触发事件并加载更多列表项。\n\n从这个描述和我们自己体验 demo 来。 至少有以下三个问题值得去了解学习。\n\n * 如何监听滚动\n * 如何计算滚动到了底部\n * 如何触发事件加载更多\n\n带着问题我们直接找到 list demo\n文件：vant/packages/vant/src/list/demo/index.vue。为什么是这个文件，我在上篇文章跟着 vant4 源码学习如何用\nvue3+ts 开发一个 loading 组件，仅88行代码分析了其原理，感兴趣的小伙伴点击查看。这里就不赘述了。\n\n\n3.1 利用 demo 调试#\n\n组件源码中的 TS 代码我不会过多解释。没学过 TS 的小伙伴，推荐学这个TypeScript 入门教程。 另外，vant 使用了\n@vue/babel-plugin-jsx 插件来支持 JSX、TSX。\n\n\n\n\n4. 入口文件#\n\n主要就是导出一下类型和变量等。\n\n\n\nwithInstall 函数在上篇文章5.1 withInstall 给组件对象添加 install 方法 也有分析，这里就不赘述了。\n\n我们可以在这些文件，任意位置加上 debugger 调试源码。\n\n\n5. 主文件#\n\n\n\nList 组件 api\n\n\n\ndebugger 调试截图。\n\n接着我们来看其他一些事件。\n\n\n5.1 一些事件 useExpose、useEventListener#\n\n\n\n由上面代码可以看出，check 函数非常重要，我们在下文分析它。\n\n我们先分析上面代码用到的 useExpose、useEventListener 组合式 API。\n\n\n5.2 useExpose 暴露#\n\n\n\n通过 ref 可以获取到 List 实例并调用实例方法，详见组件实例方法。\n\n> Vant 中的许多组件提供了实例方法，调用实例方法时，我们需要通过 ref 来注册组件引用信息，引用信息将会注册在父组件的 $refs\n> 对象上。注册完成后，我们可以通过 this.$refs.xxx 访问到对应的组件实例，并调用上面的实例方法。\n\n\n5.3 useEventListener 绑定事件#\n\n方便地进行事件绑定，在组件 mounted 和 activated 时绑定事件，unmounted 和 deactivated 时解绑事件。\n\n\n\n\n\n\n6. steup check 函数#\n\n\n\n从 check 函数可以看出，主要就是利用滚动高度，接下来我们看这个函数中，使用到的组合式\nAPI，useTabStatus、useScrollParent、useRect。\n\n\n6.1 useTabStatus tab 组件的状态#\n\n\n\n代码根据 commit 可以发现 useTabStatus 有这样一次提交。\n\nfix(List): skip check when inside an inactive tab\n\n主要是在 van-tabs 组件中，provide(TAB_STATUS_KEY, active); 提供了一个状态。tab 不活跃时，跳过 check\n函数，不执行。\n\n\n6.2 useScrollParent 获取元素最近的可滚动父元素#\n\n获取元素最近的可滚动父元素。\n\n给定参数 el, root 节点，遍历父级节点查找 style 包含 scroll|auto|overlay 的元素，如果没找到，返回第二个 root\n参数（没有第二个参数则是 window）。\n\nuseScrollParent 文档\n\n\n\n\n6.3 useRect 获取元素的大小及其相对于视口的位置#\n\nhttps://vant-contrib.gitee.io/vant/#/zh-CN/use-rect\n\n获取元素的大小及其相对于视口的位置，等价于 Element.getBoundingClientRect。\n\n\n\n\n\n\n6.4 isHidden 是否隐藏#\n\n\n\n接着我们来分析开头的插槽部分。\n\n\n7. 插槽#\n\n插槽部分基本都是有插槽用插槽没有则用默认的。\n\n插槽是函数，比如 slots.default()。\n\n\n\n\n7.1 renderFinishedText 渲染加载完成文字#\n\n\n\n\n7.2 renderErrorText 渲染加载失败文字#\n\n\n\n\n7.3 renderLoading 渲染 loading#\n\n\n\n\n8. 总结#\n\n我们主要分析了 List 组件 实现原理。\n\n原理：使用 addEventListener 监听父级元素的 sroll 事件，用 Element.getBoundingClientRect\n获取元素的大小及其相对于视口的位置，（滚动父级元素和占位元素计算和组件属性 offset（默认300） 属性比较），检测是否触底，触底则加载更多。\n\n\n\n同时分析了一些相关组合式 API\n\n * useExpose 暴露接口供 this.$refs.xxx 使用\n * useEventListener 绑定事件\n * useTabStatus 当前 tab 是否激活的状态\n * useScrollParent 获取元素最近的可滚动父元素\n * useRect 获取元素的大小及其相对于视口的位置\n\n组件留有四个插槽，分别是：\n\n * default 列表内容\n * loading 自定义底部加载中提示\n * finished 自定义加载完成后的提示文案\n * error 自定义加载失败后的提示文案\n\n至此，我们就分析完了 List 组件，主要与 DOM 操作会比较多。List 组件 主文件的代码仅有 100 多行，但封装了很多组合式 API\n。看完这篇源码文章，再去看 List 组件文档，可能就会有豁然开朗的感觉。再看其他组件，可能就可以猜测出大概实现的代码了。\n\n如果是使用 react、Taro 技术栈，感兴趣也可以看看 taroify List 组件的实现 文档，源码。\n\n如果看完有收获，欢迎点赞、评论、分享支持。你的支持和肯定，是我写作的动力。\n\n\n9. 加源码共读群交流#\n\n最后可以持续关注我@若川。我会写一个组件库源码系列专栏，欢迎大家关注。\n\n我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。\n\n另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。","routePath":"/vant/list/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":50},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":740},{"text":"2.1 克隆源码 && 跑起来","id":"21-克隆源码--跑起来","depth":3,"charIndex":810},{"text":"3. List 组件","id":"3-list-组件","depth":2,"charIndex":1147},{"text":"3.1 利用 demo 调试","id":"31-利用-demo-调试","depth":3,"charIndex":1455},{"text":"4. 入口文件","id":"4-入口文件","depth":2,"charIndex":1579},{"text":"5. 主文件","id":"5-主文件","depth":2,"charIndex":1711},{"text":"5.1 一些事件 useExpose、useEventListener","id":"51-一些事件-useexposeuseeventlistener","depth":3,"charIndex":1769},{"text":"5.2 useExpose 暴露","id":"52-useexpose-暴露","depth":3,"charIndex":1894},{"text":"5.3 useEventListener 绑定事件","id":"53-useeventlistener-绑定事件","depth":3,"charIndex":2083},{"text":"6. steup check 函数","id":"6-steup-check-函数","depth":2,"charIndex":2188},{"text":"6.1 useTabStatus tab 组件的状态","id":"61-usetabstatus-tab-组件的状态","depth":3,"charIndex":2300},{"text":"6.2 useScrollParent 获取元素最近的可滚动父元素","id":"62-usescrollparent-获取元素最近的可滚动父元素","depth":3,"charIndex":2509},{"text":"6.3 useRect 获取元素的大小及其相对于视口的位置","id":"63-userect-获取元素的大小及其相对于视口的位置","depth":3,"charIndex":2683},{"text":"6.4 isHidden 是否隐藏","id":"64-ishidden-是否隐藏","depth":3,"charIndex":2827},{"text":"7. 插槽","id":"7-插槽","depth":2,"charIndex":2867},{"text":"7.1 renderFinishedText 渲染加载完成文字","id":"71-renderfinishedtext-渲染加载完成文字","depth":3,"charIndex":2929},{"text":"7.2 renderErrorText 渲染加载失败文字","id":"72-rendererrortext-渲染加载失败文字","depth":3,"charIndex":2966},{"text":"7.3 renderLoading  渲染 loading","id":"73-renderloading--渲染-loading","depth":3,"charIndex":-1},{"text":"8. 总结","id":"8-总结","depth":2,"charIndex":3034},{"text":"9. 加源码共读群交流","id":"9-加源码共读群交流","depth":2,"charIndex":3723}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":121,"title":"跟着 vant4 源码学习如何用 vue3 + ts 开发一个 loading 组件","content":"#\n\n本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2022-10-31） star 多达 20.4k。我们可以挑选 vant\n组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n这次我们来学习 loading 组件。\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，第一步应该是先看 README.md 再看贡献文档 github/CONTRIBUTING.md。\n\n\n2.1 克隆源码 && 跑起来#\n\nYou will need Node.js >= 14 and pnpm.\n\n\n\n我们先来看 pnpm dev 最终执行的什么命令。\n\nvant 项目使用的是 monorepo 结构。查看根路径下的 package.json。\n\nvant/package.json => \"dev\": \"pnpm --dir ./packages/vant dev\"\nvant/packages/vant/package.json => \"dev\": \"vant-cli dev\"`\n\npnpm dev 最终执行的是：vant-cli dev 启动了一个服务。本文主要是学习 loading 组件 的实现，所以我们就不深入 vant-cli\ndev 命令了。\n\n\n3. 从官方文档入手找到 demo 文件#\n\n有些小伙伴喜欢在新的项目中去安装组件，再去自行新建 demo 文件去调试预览。一般来说，其实没有必要。开源项目中一般就有 demo\n类文件了。直接学习即可，省去新建的麻烦。\n\n我们凭着前端人直觉，应该很容易在找到 loading 文件夹的路径：vant/packages/vant/src/loading/demo/index.vue。\n但真的是这个路径吗？或者说这个路径是怎么渲染到官方文档中页面上的呢。带着这个疑问，我们从文档网站入手。\n\n我们很容易我们通过 http://localhost:5173/#/zh-CN/loading。 接下来我们来看，这个页面的对应的文件是在哪里，为啥路由\nloading 就能到达这个页面。\n\n\n3.1 mobile 项目中的 DemoBlock 组件#\n\n我们通过 vue-devtools 可以找到和打开 DemoBlock 组件文件。也可以通过极简插件下载安装。我曾经写过文章分析原理《据说 99% 的人不知道\nvue-devtools 还能直接打开对应组件文件？本文原理揭秘》\n\n\n\n打开后的文件是这样的，主要传入插槽，还有 card 和 title 属性。\n\n\n\n在编辑器左侧，我们可以看到 vant-cli/site 目录结构。\n\n\n\n\n3.2 mobile 项目中的 main.js 主入口文件#\n\n我们很容易看出这就是一个 vue 的项目。我们打开 main.js 查看。\n\n\n\n\n3.3 mobile 项目中的 App.vue 文件#\n\n\n\n查看vue-router 文档，可以发现： 暴露了一个 v-slot API，主要使用 和 组件来包裹你的路由组件。 Component: VNodes,\n传递给 的 is prop。 route: 解析出的标准化路由地址。\n\n\n3.4 mobile 项目中的 rotuer.js 路由文件#\n\n\n\n\n\n按调试点进函数看到截图，可以看到具体代码和路径。\n\n\n\n\n\n果然，确实是我们在前文猜测路径 vant/packages/vant/src/loading/demo/index.vue。\n\n小结：通过路由 /loading 匹配组件 demos 中的组件 Loading component: () =>\nimport('xxx/loading/demo/index.vue')， 传递给 v-slot Component 属性渲染，不得不说妙啊。\n\n接着我们继续来看，loading 的 demo 文件。\n\n\n4. loading demo 文件 loading/demo/index.vue#\n\n\n\nvue 文档 component is如果将组件本身传递给 is 而不是其名称，则不需要注册，例如在","routePath":"/vant/loading/README.juejin","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":50},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":761},{"text":"2.1 克隆源码 && 跑起来","id":"21-克隆源码--跑起来","depth":3,"charIndex":831},{"text":"3. 从官方文档入手找到 demo 文件","id":"3-从官方文档入手找到-demo-文件","depth":2,"charIndex":1173},{"text":"3.1 mobile 项目中的 DemoBlock 组件","id":"31-mobile-项目中的-demoblock-组件","depth":3,"charIndex":1515},{"text":"3.2 mobile 项目中的 main.js 主入口文件","id":"32-mobile-项目中的-mainjs-主入口文件","depth":3,"charIndex":1742},{"text":"3.3 mobile 项目中的 App.vue 文件","id":"33-mobile-项目中的-appvue-文件","depth":3,"charIndex":1816},{"text":"3.4 mobile 项目中的 rotuer.js 路由文件","id":"34-mobile-项目中的-rotuerjs-路由文件","depth":3,"charIndex":1962},{"text":"4. loading demo 文件 loading/demo/index.vue","id":"4-loading-demo-文件-loadingdemoindexvue","depth":2,"charIndex":2254},{"text":"5. loading 入口文件 loading/index.ts","id":"5-loading-入口文件-loadingindexts","depth":2,"charIndex":-1},{"text":"5.1 withInstall 给组件对象添加 install 方法","id":"51-withinstall-给组件对象添加-install-方法","depth":3,"charIndex":-1},{"text":"5.2 安装 vant","id":"52-安装-vant","depth":3,"charIndex":-1},{"text":"6. 主文件 loading/Loading.tsx","id":"6-主文件-loadingloadingtsx","depth":2,"charIndex":-1},{"text":"6.1 工具函数 extend","id":"61-工具函数-extend","depth":3,"charIndex":-1},{"text":"6.2 工具函数 addUnit 添加单位","id":"62-工具函数-addunit-添加单位","depth":3,"charIndex":-1},{"text":"6.3 工具函数 numericProp 数组或字符串属性","id":"63-工具函数-numericprop-数组或字符串属性","depth":3,"charIndex":-1},{"text":"6.4 工具函数 getSizeStyle 获取样式","id":"64-工具函数-getsizestyle-获取样式","depth":3,"charIndex":-1},{"text":"6.5 工具函数 createNamespace 创建域名空间","id":"65-工具函数-createnamespace-创建域名空间","depth":3,"charIndex":-1},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":122,"title":"跟着 vant4 源码学习如何用 vue3 + ts 开发一个 loading 组件","content":"#\n\n本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n我们开发业务时经常会使用到组件库，一般来说，很多时候我们不需要关心内部实现。但是如果希望学习和深究里面的原理，这时我们可以分析自己使用的组件库实现。有哪些优雅实\n现、最佳实践、前沿技术等都可以值得我们借鉴。\n\n相比于原生 JS 等源码。我们或许更应该学习，正在使用的组件库的源码，因为有助于帮助我们写业务和写自己的组件。\n\n如果是 Vue 技术栈，开发移动端的项目，大多会选用 vant 组件库，目前（2022-10-31） star 多达 20.4k。我们可以挑选 vant\n组件库学习，我会写一个vant 组件库源码系列专栏，欢迎大家关注。\n\nvant 组件库源码分析系列：\n\n * 1.vant 4 即将正式发布，支持暗黑主题，那么是如何实现的呢\n * 2.跟着 vant 4 源码学习如何用 vue3+ts 开发一个 loading 组件，仅88行代码\n * 3.分析 vant 4 源码，如何用 vue3 + ts 开发一个瀑布流滚动加载的列表组件？\n * 4.分析 vant 4 源码，学会用 vue3 + ts 开发毫秒级渲染的倒计时组件，真是妙啊\n * 5.vant 4.0 正式发布了，分析其源码学会用 vue3 写一个图片懒加载组件！\n\n这次我们来学习 loading 组件。\n\n学完本文，你将学到：\n\n\n\n\n2. 准备工作#\n\n看一个开源项目，第一步应该是先看 README.md 再看贡献文档 github/CONTRIBUTING.md。\n\n\n2.1 克隆源码 && 跑起来#\n\nYou will need Node.js >= 14 and pnpm.\n\n\n\n我们先来看 pnpm dev 最终执行的什么命令。\n\nvant 项目使用的是 monorepo 结构。查看根路径下的 package.json。\n\nvant/package.json => \"dev\": \"pnpm --dir ./packages/vant dev\"\nvant/packages/vant/package.json => \"dev\": \"vant-cli dev\"`\n\npnpm dev 最终执行的是：vant-cli dev 启动了一个服务。本文主要是学习 loading 组件 的实现，所以我们就不深入 vant-cli\ndev 命令了。\n\n\n3. 从官方文档入手找到 demo 文件#\n\n有些小伙伴喜欢在新的项目中去安装组件，再去自行新建 demo 文件去调试预览。一般来说，其实没有必要。开源项目中一般就有 demo\n类文件了。直接学习即可，省去新建的麻烦。\n\n我们凭着前端人直觉，应该很容易在找到 loading 文件夹的路径：vant/packages/vant/src/loading/demo/index.vue。\n但真的是这个路径吗？或者说这个路径是怎么渲染到官方文档中页面上的呢。带着这个疑问，我们从文档网站入手。\n\n我们很容易我们通过 http://localhost:5173/#/zh-CN/loading。 接下来我们来看，这个页面的对应的文件是在哪里，为啥路由\nloading 就能到达这个页面。\n\n\n3.1 mobile 项目中的 DemoBlock 组件#\n\n我们通过 vue-devtools 可以找到和打开 DemoBlock 组件文件。也可以通过极简插件下载安装。我曾经写过文章分析原理《据说 99% 的人不知道\nvue-devtools 还能直接打开对应组件文件？本文原理揭秘》\n\n\n\n打开后的文件是这样的，主要传入插槽，还有 card 和 title 属性。\n\n\n\n在编辑器左侧，我们可以看到 vant-cli/site 目录结构。\n\n\n\n\n3.2 mobile 项目中的 main.js 主入口文件#\n\n我们很容易看出这就是一个 vue 的项目。我们打开 main.js 查看。\n\n\n\n\n3.3 mobile 项目中的 App.vue 文件#\n\n\n\n查看vue-router 文档，可以发现： 暴露了一个 v-slot API，主要使用 和 组件来包裹你的路由组件。 Component: VNodes,\n传递给 的 is prop。 route: 解析出的标准化路由地址。\n\n\n3.4 mobile 项目中的 rotuer.js 路由文件#\n\n\n\n\n\n按调试点进函数看到截图，可以看到具体代码和路径。\n\n\n\n\n\n果然，确实是我们在前文猜测路径 vant/packages/vant/src/loading/demo/index.vue。\n\n小结：通过路由 /loading 匹配组件 demos 中的组件 Loading component: () =>\nimport('xxx/loading/demo/index.vue')， 传递给 v-slot Component 属性渲染，不得不说秒啊。\n\n接着我们继续来看，loading 的 demo 文件。\n\n\n4. loading demo 文件 loading/demo/index.vue#\n\n\n\nvue 文档 component is如果将组件本身传递给 is 而不是其名称，则不需要注册，例如在","routePath":"/vant/loading/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":50},{"text":"2. 准备工作","id":"2-准备工作","depth":2,"charIndex":761},{"text":"2.1 克隆源码 && 跑起来","id":"21-克隆源码--跑起来","depth":3,"charIndex":831},{"text":"3. 从官方文档入手找到 demo 文件","id":"3-从官方文档入手找到-demo-文件","depth":2,"charIndex":1173},{"text":"3.1 mobile 项目中的 DemoBlock 组件","id":"31-mobile-项目中的-demoblock-组件","depth":3,"charIndex":1515},{"text":"3.2 mobile 项目中的 main.js 主入口文件","id":"32-mobile-项目中的-mainjs-主入口文件","depth":3,"charIndex":1742},{"text":"3.3 mobile 项目中的 App.vue 文件","id":"33-mobile-项目中的-appvue-文件","depth":3,"charIndex":1816},{"text":"3.4 mobile 项目中的 rotuer.js 路由文件","id":"34-mobile-项目中的-rotuerjs-路由文件","depth":3,"charIndex":1962},{"text":"4. loading demo 文件 loading/demo/index.vue","id":"4-loading-demo-文件-loadingdemoindexvue","depth":2,"charIndex":2254},{"text":"5. loading 入口文件 loading/index.ts","id":"5-loading-入口文件-loadingindexts","depth":2,"charIndex":-1},{"text":"5.1 withInstall 给组件对象添加 install 方法","id":"51-withinstall-给组件对象添加-install-方法","depth":3,"charIndex":-1},{"text":"5.2 安装 vant","id":"52-安装-vant","depth":3,"charIndex":-1},{"text":"6. 主文件 loading/Loading.tsx","id":"6-主文件-loadingloadingtsx","depth":2,"charIndex":-1},{"text":"6.1 工具函数 extend","id":"61-工具函数-extend","depth":3,"charIndex":-1},{"text":"6.2 工具函数 addUnit 添加单位","id":"62-工具函数-addunit-添加单位","depth":3,"charIndex":-1},{"text":"6.3 工具函数 numericProp 数组或字符串属性","id":"63-工具函数-numericprop-数组或字符串属性","depth":3,"charIndex":-1},{"text":"6.4 工具函数 getSizeStyle 获取样式","id":"64-工具函数-getsizestyle-获取样式","depth":3,"charIndex":-1},{"text":"6.5 工具函数 createNamespace 创建域名空间","id":"65-工具函数-createnamespace-创建域名空间","depth":3,"charIndex":-1},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":123,"title":"vite 那些常用的小技巧","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎 follow 我的 github。我倾力持续组织了一年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.7k+人）第一的专栏，写有20余篇源码文章。\n\n我常建议大家公司项目之外，有时间也可以多参与开源项目。\n\n 1. 分析的打包依赖大小\n    1. 配置命令到 package.json\n 2. echarts 按需引入\n 3. \n\n初始化项目\n\n\n\n\n环境准备#\n\n\nvite.config.ts 配置#\n\n\n配置别名#\n\n\n\n\n生产环境 移除 console.log、debugger#\n\n\n\n\n打包分析依赖大小#\n\n用过 webpack 的小伙伴都知道，有一个很好用的打包文件可视化分析的插件，webpack-bundle-analyzer\n\nrollup-plugin-bundle-analyzer\n\n\nrollup-plugin-bundle-analyzer#\n\n\nrollup-plugin-visualizer#\n\n但每次打包编译都打开输出页面，也是不合适。 所以这时我们考虑加个命令行的参数。\n\n\n\n\n\nvite 源码用的是 cac 。会报错。\n\nminimist 解析命令行参数\n\nHow to remove console.log ,when vite build use esbuild? #7920\n\n行文至此，文章接近尾声。 完整代码。方便读者朋友们复制粘贴。\n\n\n\n\n8. 加源码共读交流群#\n\n最后可以持续关注我@若川，欢迎 follow 我的\ngithub。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（5.7k+人）第一的专栏，写有20余篇源码文章。\n\n我倾力持续组织了一年多每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02 参与。","routePath":"/vite-report/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"环境准备","id":"环境准备","depth":3,"charIndex":272},{"text":"vite.config.ts 配置","id":"viteconfigts-配置","depth":2,"charIndex":280},{"text":"配置别名","id":"配置别名","depth":2,"charIndex":301},{"text":"生产环境 移除 console.log、debugger","id":"生产环境-移除-consolelogdebugger","depth":2,"charIndex":311},{"text":"打包分析依赖大小","id":"打包分析依赖大小","depth":2,"charIndex":345},{"text":"rollup-plugin-bundle-analyzer","id":"rollup-plugin-bundle-analyzer","depth":3,"charIndex":452},{"text":"rollup-plugin-visualizer","id":"rollup-plugin-visualizer","depth":3,"charIndex":485},{"text":"8. 加源码共读交流群","id":"8-加源码共读交流群","depth":2,"charIndex":695}],"domain":"","frontmatter":{},"version":""},{"id":124,"title":"vite 源码系列","content":"#\n\n\n\n\nvite 入口#\n\n\n\n\ncac dev action#\n\n","routePath":"/vite/dev/","lang":"zh","toc":[{"text":"vite 入口","id":"vite-入口","depth":2,"charIndex":5},{"text":"cac dev action","id":"cac-dev-action","depth":2,"charIndex":18}],"domain":"","frontmatter":{},"version":""},{"id":125,"title":"vite 源码系列","content":"#","routePath":"/vite/","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":126,"title":"vue 2.x项目 vue-qriously 生成二维码并下载、cliploard复制粘贴","content":"#\n\n> 写于2018年05月15日\n\n近日，重构项目某一老模块时，有一个功能是生成二维码并下载，还可以复制链接。列表每项都有二维码、下载二维码和复制链接和列表上方总的二维码。\n老模块是用的qrocode中文文档，qrcode github。\n\n先想着新模块中是否有生成二维码的插件，看了下package.json。\n有安装一个vue-qriously。但搜索了一下，竟然没有使用，可能是因为很多二维码都是后端生成返回链接给前端的。而在其他H5、微信项目中使用了。看了下这个项目\nstar数是113。但我不想重新引入老模块的qrcodejs，重新引入其他的二维码插件，相对比较麻烦。于是就保持统一用vue-qriously了。\n猜想当时引入这个是vue 资源合集awesome-vue中，qrcode相关第一个就是vue-qriously。\n\n\nvue-qriously插件使用#\n\n\n\n\n\n更多参数配置可以查看：github 仓库 v-qriously.vue源码 查看代码可以发现，开头引用了qrious，这个star就多一点，600多。\n\n\n\nqrious github 地址 qrious 文档\n\n\n下载二维码#\n\n粗略的翻看下以上相关文档，写完正准备要做下载功能。这时发现，哎呀，竟然就是只生成了一个canvas。\n于是百度(暴露了用百度...我也想用谷歌，但现在不行...)了下canvas如何转图片。 stackoverflow Capture HTML Canvas\nas gif/jpg/png/pdf?\n\n\n\n生成了img的src资源，那么就可以下载了。\n\n\n\n\n\n但这样写也相对比较麻烦。 项目中封装了一个v-click指令。\n\n\n\n\n\n代码写到这里，嗯，实现完了下载。但又发现又一需求，显示大小是80 * 80，下载需要是160 * 160。\n\n\n显示大小和下载大小不一样#\n\n参考了下老模块，qrcodejs渲染出来的html,\n\n\n\nvue-qriously渲染出来是\n\n\n\n于是我可以把生成的imgSrc资源,\n\n\n\n这就实现了下载的资源是160 * 160，用样式控制图片显示80 * 80。 代码写完，觉得应该给vue-qriously写个pr,实现\n不仅仅是渲染canvas，而是让大家可以选择时img还是canvas。又去翻了翻这个项目的issue,有一个issue链接：how to make this\ncanvas exchange to img 就是说的这个。还没关闭。\n\n\n\n\n\n文章写到这里，我发现这样似乎不太妥。我的场景，是点击时显示浮层（浮层有二维码和复制链接地址和下载二维码按钮等），获取canvas元素，去转成img\nsrc，再去渲染到页面，而且图片可能会闪，因为是实际大小是160，样式强制控制在80。\n何不生成两份，一份是用来获取资源下载的。一份用来显示的。嗯，之后去优化下。 顺带说一下，复制粘贴\n\n\ncliploard 复制粘贴#\n\n老模块中是用的cliploardclipboard github仓库。就是我引入的。\n\n新模块还没使用过，但依然使用这个。\n\n\n\n当然也可以封装成vue指令。 可以参考vue-element-admin这个项目 之前我看的时候还是3000多star，现在1.2w+，说明值得学习。\n另外推荐awesomes网站 工具类库合集\n\n\n小结#\n\n1、引入第三方插件等使用时，多查看github 文档 issue等，在技术社区搜索别人使用的方案。\n2、选用第三方插件时，尽可能挑选star比较多的，issue处理比较及时的，在更新维护的。\n3、富余时间可以多研究下别人的项目是如何组织文件，和实现的一些常用功能的。 4、尽可能去优化自己的代码，总结回顾。\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客 掘金专栏，欢迎关注~\nsegmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/vue-2-qrcode/","lang":"zh","toc":[{"text":"`vue-qriously`插件使用","id":"vue-qriously插件使用","depth":2,"charIndex":-1},{"text":"下载二维码","id":"下载二维码","depth":2,"charIndex":503},{"text":"显示大小和下载大小不一样","id":"显示大小和下载大小不一样","depth":2,"charIndex":785},{"text":"cliploard 复制粘贴","id":"cliploard-复制粘贴","depth":2,"charIndex":1231},{"text":"小结","id":"小结","depth":2,"charIndex":1413},{"text":"关于","id":"关于","depth":2,"charIndex":1574},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":127,"title":"分析vue-cli@2.9.3 搭建的webpack项目工程","content":"#\n\n> 写于2018年06月11日\n\n\n前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 已经有很多分析Vue-cli搭建工程的文章，为什么自己还要写一遍呢。学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的\n> 风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。\n\n项目放在笔者的github上，分析vue-cli@2.9.3 搭建的webpack项目工程。方便大家克隆下载，或者在线查看。同时也求个star\n^_^，也是对笔者的一种鼓励和支持。\n\n正文从这里开始～\n\n\n使用vue-cli初始化webpack工程#\n\n\n\n更多vue-cli如何工作的可以查看这篇文章vue-cli是如何工作的，或者分析Vue-cli源码查看这篇走进Vue-cli源码，自己动手搭建前端脚手架工具，再\n或者直接查看vue-cli github仓库源码\n\n如果对webpack还不是很了解，可以查看webpack官方文档中的概念，虽然是最新版本的，但概念都是差不多的。\n\n\npackage.json#\n\n分析一个项目，一般从package.json的命令入口scripts开始。\n\n\n\nNpm Script 底层实现原理是通过调用 Shell 去运行脚本命令。npm run start等同于运行npm run dev。\n\nNpm Script 还有一个重要的功能是能运行安装到项目目录里的 node_modules 里的可执行模块。\n\n例如在通过命令npm i -D webpack-dev-server将webpack-dev-server安装到项目后，是无法直接在项目根目录下通过命令\nwebpack-dev-server 去执行 webpack-dev-server 构建的，而是要通过命令\n./node_modules/.bin/webpack-dev-server 去执行。\n\nNpm Script 能方便的解决这个问题，只需要在 scripts 字段里定义一个任务，例如：\n\n\n\nNpm Script 会先去项目目录下的 node_modules 中寻找有没有可执行的 webpack-dev-server\n文件，如果有就使用本地的，如果没有就使用全局的。 所以现在执行 webpack-dev-server 启动服务时只需要通过执行 npm run dev 去实现。\n\n> 再来看下 npm run dev webpack-dev-server\n> 其实是一个node.js的应用程序，它是通过JavaScript开发的。在命令行执行npm run dev命令等同于执行node\n> ./node_modules/webpack-dev-server/bin/webpack-dev-server.js --inline\n> --progress --config build/webpack.dev.conf.js。你可以试试。\n\n更多package.json的配置项，可以查看阮一峰老师的文章 package.json文件\n\nnpm run dev指定了build/webpack.dev.conf.js配置去启动服务，那么我们来看下这个文件做了什么。\n\n\nbuild/webpack.dev.conf.js webpack开发环境配置#\n\n这个文件主要做了以下几件事情： 1、引入各种依赖，同时也引入了config文件夹下的变量和配置，和一个工具函数build/utils.js，\n2、合并build/webpack.base.conf.js配置文件， 3、配置开发环境一些devServer，plugin等配置，\n4、最后导出了一个Promise，根据配置的端口，寻找可用的端口来启动服务。\n\n具体可以看build/webpack.dev.conf.js这个文件注释：\n\n\n\n\nbuild/utils.js 工具函数#\n\n上文build/webpack.dev.conf.js提到引入了build/utils.js工具函数。 该文件主要写了以下几个工具函数：\n1、assetsPath返回输出路径， 2、cssLoaders返回相应的css-loader配置， 3、styleLoaders返回相应的处理样式的配置，\n4、createNotifierCallback创建启动服务时出错时提示信息回调。\n\n具体配置可以看该文件注释：\n\n\n\n\nbuild/webpack.base.conf.js webpack基本配置文件#\n\n上文build/webpack.dev.conf.js提到引入了build/webpack.base.conf.js这个webpack基本配置文件。\n这个文件主要做了以下几件事情： 1、引入各种插件、配置等，其中引入了build/vue-loader.conf.js相关配置，\n2、创建eslint规则配置，默认启用，\n3、导出webpack配置对象，其中包含context，入口entry，输出output，resolve，module下的rules（处理对应文件的规则），和n\node相关的配置等。\n\n具体可以看这个文件注释：\n\n\n\n\nbuild/vue-loader.conf.js vue-loader配置文件#\n\n上文build/webpack.dev.conf.js提到引入了build/vue-loader.conf.js。\n\n这个文件主要导出了一份Vue-loader的配置，\n主要有：loaders，cssSourceMap，cacheBusting，transformToRequire。\n\n具体看该文件注释：\n\n\n\n看完了这些文件相应配置，开发环境的相关配置就串起来了。其中config/文件夹下的配置，笔者都已经注释在build/文件夹下的对应的文件中，所以就不单独说明了。\n\n那回过头来看，package.json的scripts中的npm run build配置，node\nbuild/build.js，其实就是用node去执行build/build.js文件。\n\n\nbuild/build.js npm run build 指定执行的文件#\n\n这个文件主要做了以下几件事情： 1、引入build/check-versions文件，检查node和npm的版本，\n2、引入相关插件和配置，其中引入了webpack生产环境的配置build/webpack.prod.conf.js，\n3、先控制台输出loading，删除dist目录下的文件，开始构建，构建失败和构建成功都给出相应的提示信息。\n\n具体可以查看相应的注释：\n\n\n\n\nbuild/check-versions 检查node和npm版本#\n\n上文提到build/check-versions 检查node和npm版本，这个文件主要引入了一些插件和配置，最后导出一个函数，版本不符合预期就输出警告。\n\n具体查看这个配置文件注释：\n\n\n\n\nbuild/webpack.prod.conf.js webpack生产环境配置#\n\n上文build/build.js提到，引入了这个配置文件。 这个文件主要做了以下几件事情：\n1、引入一些插件和配置，其中引入了build/webpack.base.conf.js webpack基本配置文件， 2、用DefinePlugin定义环境，\n3、合并基本配置，定义自己的配置webpackConfig，配置了一些modules下的rules，devtools配置，output输出配置，一些处理js、提\n取css、压缩css、输出html插件、提取公共代码等的 plugins， 4、如果启用gzip，再使用相应的插件处理，\n5、如果启用了分析打包后的插件，则用webpack-bundle-analyzer， 6、最后导出这份配置。\n\n具体可以查看这个文件配置注释：\n\n\n\n至此，我们就分析完了package.json中的npm run dev和npm run build两个命令。测试相关的类似就略过吧。\n\nnpm run\nlint，.eslintrc.js中的配置不多，更多可以查看eslint英文文档或eslint中文官网，所以也略过吧。不过提一下，把eslint整合到git工作\n流。可以安装husky，npm i husky -S。安装后，配置package.json的scripts中，配置precommit，具体如下：\n\n\n\n配置好后，每次git commit\n-m提交会检查代码是否通过eslint校验，如果没有校验通过则提交失败。还可以配置prepush。husky不断在更新，现在可能与原先的配置不太相同了，具体查看\nhusky\ngithub仓库。原理就是git-hooks,pre-commit的钩子。对shell脚本熟悉的同学也可以自己写一份pre-commit。复制到项目的.git/\nhooks/pre-commit中。不需要依赖husky包。我司就是用的shell脚本。\n\n最后提一下.babelrc文件中的配置。\n\n\n.babelrc babel相关配置#\n\n配置了一些转码规则。这里附上两个链接：babel英文官网和babel的中文官网。\n\n具体看文件中的配置注释：\n\n\n\n文件中presets中有配置env和stage-2，可能不知道是什么。这里引用深入浅出webpack书中，第三章，3-1使用ES6语言 小节的一段，解释一下。\n\n> presets 属性告诉 Babel 要转换的源码使用了哪些新的语法特性，一个 Presets 对一组新语法特性提供支持，多个 Presets 可以叠加。\n> Presets 其实是一组 Plugins 的集合，每一个 Plugin 完成一个新语法的转换工作。Presets 是按照 ECMAScript\n> 草案来组织的，通常可以分为以下三大类（书中就是说三大类，我发现就两点~~~）： 1、已经被写入 ECMAScript\n> 标准里的特性，由于之前每年都有新特性被加入到标准里，所以又可细分为： es2015 包含在2015里加入的新特性； es2016\n> 包含在2016里加入的新特性； es2017 包含在2017里加入的新特性； es2017 包含在2017里加入的新特性； env 包含当前所有\n> ECMAScript 标准里的最新特性。 2、被社区提出来的但还未被写入 ECMAScript 标准里特性，这其中又分为以下四种： stage0\n> 只是一个美好激进的想法，有 Babel 插件实现了对这些特性的支持，但是不确定是否会被定为标准； stage1 值得被纳入标准的特性； stage2\n> 该特性规范已经被起草，将会被纳入标准里； stage3 该特性规范已经定稿，各大浏览器厂商和 `` 社区开始着手实现； stage4\n> 在接下来的一年将会加入到标准里去。\n\n至此，就算相对完整的分析完了Vue-cli(版本v2.9.3)搭建的webpack项目工程。希望对大家有所帮助。\n项目放在笔者的github上，分析vue-cli@2.9.3 搭建的webpack项目工程。方便大家克隆下载，或者在线查看。同时也求个star\n^_^，也是对笔者的一种鼓励和支持。 笔者知识能力有限，文章有什么不妥之处，欢迎指出~\n\n\n小结#\n\n1、分析这些，逐行注释，还是需要一些时间的。其中有些不是很明白的地方，及时查阅相应的官方文档和插件文档（建议看英文文档和最新的文档），不过文档没写明白的地方，可\n以多搜索一些别人的博客文章，相对比较清晰明了。 2、前端发展太快，这个Vue-cli@2.9.3\nwebpack版本还是v3.x，webpack现在官方版本已经是v4.12.0，相信不久后，Vue-cli也将发布支持webpack\nv4.x的版本，v3.0.0已经是beta.16了。 3、后续有余力，可能会继续分析新版的vue-cli构建的webpack项目工程。\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客 掘金专栏，欢迎关注~\nsegmentfault前端视野专栏，开通了前端视野专栏，欢迎关注~ 知乎前端视野专栏，开通了前端视野专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n微信公众号 若川视野#\n\n可能比较有趣的微信公众号，长按扫码关注。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/vue-cli-2-webpack/","lang":"zh","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":20},{"text":"使用`vue-cli`初始化`webpack`工程","id":"使用vue-cli初始化webpack工程","depth":2,"charIndex":-1},{"text":"`package.json`","id":"packagejson","depth":2,"charIndex":-1},{"text":"`build/webpack.dev.conf.js` `webpack`开发环境配置","id":"buildwebpackdevconfjs-webpack开发环境配置","depth":2,"charIndex":-1},{"text":"`build/utils.js` 工具函数","id":"buildutilsjs-工具函数","depth":2,"charIndex":-1},{"text":"`build/webpack.base.conf.js` `webpack`基本配置文件","id":"buildwebpackbaseconfjs-webpack基本配置文件","depth":2,"charIndex":-1},{"text":"`build/vue-loader.conf.js` `vue-loader`配置文件","id":"buildvue-loaderconfjs-vue-loader配置文件","depth":2,"charIndex":-1},{"text":"`build/build.js` `npm run build` 指定执行的文件","id":"buildbuildjs-npm-run-build-指定执行的文件","depth":2,"charIndex":-1},{"text":"`build/check-versions` 检查`node`和`npm`版本","id":"buildcheck-versions-检查node和npm版本","depth":2,"charIndex":-1},{"text":"`build/webpack.prod.conf.js` `webpack`生产环境配置","id":"buildwebpackprodconfjs-webpack生产环境配置","depth":2,"charIndex":-1},{"text":"`.babelrc` `babel`相关配置","id":"babelrc-babel相关配置","depth":2,"charIndex":-1},{"text":"小结","id":"小结","depth":2,"charIndex":4843},{"text":"关于","id":"关于","depth":2,"charIndex":5115},{"text":"微信公众号  若川视野","id":"微信公众号--若川视野","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":128,"title":"","content":"element-plus#\n\n试过，可以\n\n\nvant#\n\n\nreact#\n\n试过，暂时不行\n\n\nant-design#\n\n试过可以\n\n\nant-design-mobile#\n\n试过，可以\n\n\nvite#\n\n试过，暂时不行\n\n\nwebpack#\n\n试过，可以","routePath":"/vue-debugger/README.1","lang":"zh","toc":[{"text":"element-plus","id":"element-plus","depth":2,"charIndex":-1},{"text":"vant","id":"vant","depth":2,"charIndex":22},{"text":"react","id":"react","depth":2,"charIndex":30},{"text":"ant-design","id":"ant-design","depth":2,"charIndex":48},{"text":"ant-design-mobile","id":"ant-design-mobile","depth":2,"charIndex":68},{"text":"vite","id":"vite","depth":2,"charIndex":96},{"text":"webpack","id":"webpack","depth":2,"charIndex":113}],"domain":"","frontmatter":{},"version":""},{"id":129,"title":"据说90%的人不知道可以用测试用例(Vitest)调试开源项目(Vue3) 源码","content":"#\n\n\n1. 前言#\n\n大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.7k+人）第一的专栏，写有20余篇源码文章。\n\n\n2. 看开源项目学习是怎样的步骤？#\n\n看一个开源仓库，第一步一般是看 README.md 和 contributing.md 贡献指南文档。\n\n> README.md 中一般有提到贡献指南文档的链接的。贡献指南文档就是为了让别人参与项目贡献。\n\n而贡献指南写了很多关于参与项目开发的信息。比如怎么跑起来，项目目录结构是怎样的。怎么投入开发，需要哪些知识储备等。\n\n第二步的克隆下来。按照贡献指南文档，把项目跑起来。\n\n\n3. 如何调试 vue3 源码#\n\n我们这次来学调试 vue3 源码，看 vue3 源码仓库 contributing.md。\n\ncontributing.md 部分内容\n\n> Development Setup\n\n> You will need Node.js version 16+, and PNPM version 7+.\n\n> We also recommend installing ni to help switching between repos using\n> different package managers. ni also provides the handy nr command which\n> running npm scripts easier.\n\n> After cloning the repo, run:\n\n\n\n关于上方提到的 ni，我曾经写过源码文章，可供参考。\n\n尤雨溪推荐神器 ni ，能替代 npm/yarn/pnpm ？简单好用！源码揭秘！\n\n从贡献指南中，我们可以得知一些信息，那么先来克隆项目安装依赖。\n\n\n\n\n4. 使用 vitest vscode 扩展的调试方式#\n\n安装vitest vscode 扩展链接、vitest vscode 扩展 github\n\n安装vitest-runner vscode 扩展链接、vitest-runner vscode 扩展 github\n\n\n\n\n\n\n\n\n\n如下图 gif 图所示，就是调试 vue 源码了。\n\n\n\n关于 gif 图中顶部各个按钮的作用，我曾经写过一篇文章新手向：前端程序员必学基本技能——调试JS代码\n\n通过开源项目的测试用例调试源码，它的优点在于不用打包、更接近源码，测试覆盖率高的开源项目，可以只针对某项功能做针对性调试，看测试用例的过程中也能直接学会使用。而\n这种调试方式，可能是大部分人从未使用过的调试源码方式，因为大多数人可能没学过测试框架。\n\nVue 源码的测试用例现在改成了 Vitest。\n\n同理可得，如果开源项目是使用 Jest 测试框架，可以安装 Jest、Jest Runner vscode 插件。\n\n\n5. 通过生成 sourcemap 调试#\n\n\n5.1 如何生成 sourcemap#\n\n贡献指南的文档 contributing.md 中有写：\n\n> Build with Source Maps\n\nUse the --sourcemap or -s flag to build with source maps. Note this will make\nthe build much slower.\n\n\n\n执行后，所有的都生成了 sourcemap 文件，如下图所示。\n\n\n\n通过 sourcemap 文件，可以找到原始文件信息。\n\n我们可以在根目录下的 package.json 中，看到有一个启动服务的命令。\n\n\n\n这时再在命令行终端，执行这条命令，启动服务。\n\n\n\n\n\n浏览器打开 http://localhost:5000 可以找到相应路径。\n\n比如我们打开这个源码中有的 todomvc 例子，来调试。\nhttp://localhost:64085/packages/vue/examples/composition/todomvc\n\n","routePath":"/vue-debugger/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 看开源项目学习是怎样的步骤？","id":"2-看开源项目学习是怎样的步骤","depth":2,"charIndex":150},{"text":"3. 如何调试 `vue3` 源码","id":"3-如何调试-vue3-源码","depth":2,"charIndex":-1},{"text":"4. 使用 vitest vscode 扩展的调试方式","id":"4-使用-vitest-vscode-扩展的调试方式","depth":2,"charIndex":846},{"text":"5. 通过生成 sourcemap 调试","id":"5-通过生成-sourcemap-调试","depth":2,"charIndex":1284},{"text":"5.1 如何生成 sourcemap","id":"51-如何生成-sourcemap","depth":3,"charIndex":1308},{"text":"5.2 为何贡献指南中写的方式就能生成 sourcemap ？","id":"52-为何贡献指南中写的方式就能生成-sourcemap-","depth":3,"charIndex":-1},{"text":"6. 总结","id":"6-总结","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":130,"title":"尤雨溪几年前开发的“玩具 vite”，才100多行代码，却十分有助于理解 vite 原理","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动，感兴趣的可以加我微信 ruochuan12\n> 参与，已进行两个多月，大家一起交流学习，共同进步。\n\n想学源码，极力推荐之前我写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue-next-release、vue-this、create-vue等十余篇源码文章。\n\n最近组织了源码共读活动，大家一起学习源码。于是各种搜寻值得我们学习，且代码行数不多的源码。\n\n在 vuejs组织 下，找到了尤雨溪几年前写的“玩具 vite” vue-dev-server，发现100来行代码，很值得学习。于是有了这篇文章。\n\n阅读本文，你将学到：\n\n\n\n\n2. vue-dev-server 它的原理是什么#\n\nvue-dev-server#how-it-works README 文档上有四句英文介绍。\n\n发现谷歌翻译的还比较准确，我就原封不动的搬运过来。\n\n * 浏览器请求导入作为原生 ES 模块导入 - 没有捆绑。\n * 服务器拦截对 *.vue 文件的请求，即时编译它们，然后将它们作为 JavaScript 发回。\n * 对于提供在浏览器中工作的 ES 模块构建的库，只需直接从 CDN 导入它们。\n * 导入到 .js 文件中的 npm 包（仅包名称）会即时重写以指向本地安装的文件。 目前，仅支持 vue 作为特例。\n   其他包可能需要进行转换才能作为本地浏览器目标 ES 模块公开。\n\n也可以看看vitejs 文档，了解下原理，文档中图画得非常好。\n\n\n\n看完本文后，我相信你会有一个比较深刻的理解。\n\n\n3. 准备工作#\n\n\n3.1 克隆项目#\n\n本文仓库 vue-dev-server-analysis，求个star^_^\n\n\n\n一般来说，我们看源码先从package.json文件开始：\n\n\n\n根据 scripts test 命令。我们来看 test 文件夹。\n\n\n3.2 test 文件夹#\n\nvue-dev-server/test 文件夹下有三个文件，代码不长。\n\n * index.html\n * main.js\n * text.vue\n\n如图下图所示。\n\n\n\n接着我们找到 vue-dev-server/bin/vue-dev-server.js 文件，代码也不长。\n\n\n3.3 vue-dev-server.js#\n\n\n\n原来就是express启动了端口3000的服务。重点在 vueMiddleware 中间件。接着我们来调试这个中间件。\n\n鉴于估计很多小伙伴没有用过VSCode调试，这里详细叙述下如何调试源码。学会调试源码后，源码并没有想象中的那么难。\n\n\n3.4 用 VSCode 调试项目#\n\nvue-dev-server/bin/vue-dev-server.js 文件中这行 app.use(vueMiddleware()) 打上断点。\n\n找到 vue-dev-server/package.json 的 scripts，把鼠标移动到 test\n命令上，会出现运行脚本和调试脚本命令。如下图所示，选择调试脚本。\n\n\n\n\n\n点击进入函数（F11）按钮可以进入 vueMiddleware\n函数。如果发现断点走到不是本项目的文件中，不想看，看不懂的情况，可以退出或者重新来过。可以用浏览器无痕（隐私）模式（快捷键Ctrl + Shift +\nN，防止插件干扰）打开 http://localhost:3000，可以继续调试 vueMiddleware 函数返回的函数。\n\n> 如果你的VSCode不是中文（不习惯英文），可以安装简体中文插件。 如果 VSCode 没有这个调试功能。建议更新到最新版的 VSCode（目前最新版本\n> v1.61.2）。\n\n接着我们来跟着调试学习 vueMiddleware 源码。可以先看主线，在你觉得重要的地方继续断点调试。\n\n\n4. vueMiddleware 源码#\n\n\n4.1 有无 vueMiddleware 中间件对比#\n\n不在调试情况状态下，我们可以在 vue-dev-server/bin/vue-dev-server.js 文件中注释\napp.use(vueMiddleware())，执行 npm run test 打开 http://localhost:3000。\n\n\n\n再启用中间件后，如下图。\n\n\n\n看图我们大概知道了有哪些区别。\n\n\n4.2 vueMiddleware 中间件概览#\n\n我们可以找到vue-dev-server/middleware.js，查看这个中间件函数的概览。\n\n\n\nvueMiddleware 最终返回一个函数。这个函数里主要做了四件事：\n\n * 对 .vue 结尾的文件进行处理\n\n * 对 .js 结尾的文件进行处理\n\n * 对 /__modules/ 开头的文件进行处理\n\n * 如果不是以上三种情况，执行 next 方法，把控制权交给下一个中间件\n\n接着我们来看下具体是怎么处理的。\n\n我们也可以断点这些重要的地方来查看实现。比如：\n\n\n\n\n4.3 对 .vue 结尾的文件进行处理#\n\n\n\n4.3.1 bundleSFC 编译单文件组件#\n\n这个函数，根据 @vue/component-compiler 转换单文件组件，最终返回浏览器能够识别的文件。\n\n\n\n接着我们来看 readSource 函数实现。\n\n4.3.2 readSource 读取文件资源#\n\n这个函数主要作用：根据请求获取文件资源。返回文件路径 filepath、资源 source、和更新时间 updateTime。\n\n\n\n接着我们来看对 .js 文件的处理\n\n\n4.4 对 .js 结尾的文件进行处理#\n\n\n\n针对 vue-dev-server/test/main.js 转换\n\n\n\n\n\n4.4.1 transformModuleImports 转换 import 引入#\n\nrecast\n\nvalidate-npm-package-name\n\n\n\n也就是针对 npm 包转换。 这里就是 \"/__modules/vue\"\n\n\n\n\n4.5 对 /__modules/ 开头的文件进行处理#\n\n\n\n这段代码最终返回的是读取路径 vue-dev-server/node_modules/vue/dist/vue.esm.browser.js 下的文件。\n\n\n\n4.5.1 loadPkg 加载包（这里只支持Vue文件）#\n\n目前只支持 Vue 文件，也就是读取路径 vue-dev-server/node_modules/vue/dist/vue.esm.browser.js\n下的文件返回。\n\n\n\n至此，我们就基本分析完毕了主文件和一些引入的文件。对主流程有个了解。\n\n\n5. 总结#\n\n最后我们来看上文中有无 vueMiddleware 中间件的两张图总结一下：\n\n\n\n启用中间件后，如下图。\n\n\n\n浏览器支持原生 type=module 模块请求加载。vue-dev-server 对其拦截处理，返回浏览器支持内容，因为无需打包构建，所以速度很快。\n\n\n\n\n5.1 转换#\n\n\n\nmain.js 中的 import 语句\n\n通过 recast 生成 ast 转换成 `` 而最终返回给浏览器的是\nvue-dev-server/node_modules/vue/dist/vue.esm.browser.js\n\n\n5.2 转换#\n\nmain.js 中的引入 .vue 的文件，`` 则用 @vue/component-compiler 转换成浏览器支持的文件。\n\n\n5.3 后续还能做什么？#\n\n鉴于文章篇幅有限，缓存 tryCache 部分目前没有分析。简单说就是使用了 node-lru-cache 最近最少使用\n来做缓存的（这个算法常考）。后续应该会分析这个仓库的源码，欢迎持续关注我@若川。\n\n非常建议读者朋友按照文中方法使用VSCode调试 vue-dev-server 源码。源码中还有很多细节文中由于篇幅有限，未全面展开讲述。\n\n值得一提的是这个仓库的 master 分支，是尤雨溪两年前写的，相对本文会比较复杂，有余力的读者可以学习。\n\n也可以直接去看 vite 源码。\n\n看完本文，也许你就能发现其实前端能做的事情越来越多，不由感慨：前端水深不可测，唯有持续学习。\n\n最后欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。","routePath":"/vue-dev-server/README.mp","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. vue-dev-server 它的原理是什么","id":"2-vue-dev-server-它的原理是什么","depth":2,"charIndex":397},{"text":"3. 准备工作","id":"3-准备工作","depth":2,"charIndex":782},{"text":"3.1 克隆项目","id":"31-克隆项目","depth":3,"charIndex":793},{"text":"3.2 test 文件夹","id":"32-test-文件夹","depth":3,"charIndex":915},{"text":"3.3 vue-dev-server.js","id":"33-vue-dev-serverjs","depth":3,"charIndex":1072},{"text":"3.4 用 VSCode 调试项目","id":"34-用-vscode-调试项目","depth":3,"charIndex":1219},{"text":"4. vueMiddleware 源码","id":"4-vuemiddleware-源码","depth":2,"charIndex":1725},{"text":"4.1 有无 vueMiddleware 中间件对比","id":"41-有无-vuemiddleware-中间件对比","depth":3,"charIndex":1748},{"text":"4.2 vueMiddleware 中间件概览","id":"42-vuemiddleware-中间件概览","depth":3,"charIndex":1940},{"text":"4.3 对 .vue 结尾的文件进行处理","id":"43-对-vue-结尾的文件进行处理","depth":3,"charIndex":2210},{"text":"4.3.1 bundleSFC 编译单文件组件","id":"431-bundlesfc-编译单文件组件","depth":4,"charIndex":2235},{"text":"4.3.2 readSource 读取文件资源","id":"432-readsource-读取文件资源","depth":4,"charIndex":2345},{"text":"4.4 对 .js 结尾的文件进行处理","id":"44-对-js-结尾的文件进行处理","depth":3,"charIndex":2458},{"text":"4.4.1 transformModuleImports 转换 import 引入","id":"441-transformmoduleimports-转换-import-引入","depth":4,"charIndex":2521},{"text":"4.5 对 /__modules/ 开头的文件进行处理","id":"45-对-__modules-开头的文件进行处理","depth":3,"charIndex":2643},{"text":"4.5.1 loadPkg 加载包（这里只支持Vue文件）","id":"451-loadpkg-加载包这里只支持vue文件","depth":4,"charIndex":2755},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":2912},{"text":"5.1  转换","id":"51--转换","depth":3,"charIndex":-1},{"text":"5.2  转换","id":"52--转换","depth":3,"charIndex":-1},{"text":"5.3 后续还能做什么？","id":"53-后续还能做什么","depth":3,"charIndex":3260}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":131,"title":"","content":"缓存#\n\n\n\n\ntryCache#\n\n\n\n\ncacheData#\n\n","routePath":"/vue-dev-server/README.todos","lang":"zh","toc":[{"text":"缓存","id":"缓存","depth":3,"charIndex":-1},{"text":"tryCache","id":"trycache","depth":3,"charIndex":7},{"text":"cacheData","id":"cachedata","depth":3,"charIndex":21}],"domain":"","frontmatter":{},"version":""},{"id":132,"title":"尤雨溪几年前开发的“玩具 vite”，才100多行代码，却十分有助于理解 vite 原理","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动，感兴趣的可以加我微信 ruochuan12\n> 参与，已进行两个多月，大家一起交流学习，共同进步。\n\n想学源码，极力推荐之前我写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue-next-release、vue-this、create-vue等10余篇源码文章。\n\n最近组织了源码共读活动，大家一起学习源码。于是各种搜寻值得我们学习，且代码行数不多的源码。\n\n在 vuejs组织 下，找到了尤雨溪几年前写的“玩具 vite” vue-dev-server，发现100来行代码，很值得学习。于是有了这篇文章。\n\n阅读本文，你将学到：\n\n\n\n\n2. vue-dev-server 它的原理是什么#\n\nvue-dev-server#how-it-works README 文档上有四句英文介绍。\n\n发现谷歌翻译的还比较准确，我就原封不动的搬运过来。\n\n * 浏览器请求导入作为原生 ES 模块导入 - 没有捆绑。\n * 服务器拦截对 *.vue 文件的请求，即时编译它们，然后将它们作为 JavaScript 发回。\n * 对于提供在浏览器中工作的 ES 模块构建的库，只需直接从 CDN 导入它们。\n * 导入到 .js 文件中的 npm 包（仅包名称）会即时重写以指向本地安装的文件。 目前，仅支持 vue 作为特例。\n   其他包可能需要进行转换才能作为本地浏览器目标 ES 模块公开。\n\n也可以看看vitejs 文档，了解下原理，文档中图画得非常好。\n\n\n\n看完本文后，我相信你会有一个比较深刻的理解。\n\n\n3. 准备工作#\n\n\n3.1 克隆项目#\n\n本文仓库 vue-dev-server-analysis，求个star^_^\n\n\n\n一般来说，我们看源码先从package.json文件开始：\n\n\n\n根据 scripts test 命令。我们来看 test 文件夹。\n\n\n3.2 test 文件夹#\n\nvue-dev-server/test 文件夹下有三个文件，代码不长。\n\n * index.html\n * main.js\n * text.vue\n\n如图下图所示。\n\n\n\n接着我们找到 vue-dev-server/bin/vue-dev-server.js 文件，代码也不长。\n\n\n3.3 vue-dev-server.js#\n\n\n\n原来就是express启动了端口3000的服务。重点在 vueMiddleware 中间件。接着我们来调试这个中间件。\n\n鉴于估计很多小伙伴没有用过VSCode调试，这里详细叙述下如何调试源码。学会调试源码后，源码并没有想象中的那么难。\n\n\n3.4 用 VSCode 调试项目#\n\nvue-dev-server/bin/vue-dev-server.js 文件中这行 app.use(vueMiddleware()) 打上断点。\n\n找到 vue-dev-server/package.json 的 scripts，把鼠标移动到 test\n命令上，会出现运行脚本和调试脚本命令。如下图所示，选择调试脚本。\n\n\n\n\n\n点击进入函数（F11）按钮可以进入 vueMiddleware\n函数。如果发现断点走到不是本项目的文件中，不想看，看不懂的情况，可以退出或者重新来过。可以用浏览器无痕（隐私）模式（快捷键Ctrl + Shift +\nN，防止插件干扰）打开 http://localhost:3000，可以继续调试 vueMiddleware 函数返回的函数。\n\n> 如果你的VSCode不是中文（不习惯英文），可以安装简体中文插件。 如果 VSCode 没有这个调试功能。建议更新到最新版的 VSCode（目前最新版本\n> v1.61.2）。\n\n接着我们来跟着调试学习 vueMiddleware 源码。可以先看主线，在你觉得重要的地方继续断点调试。\n\n\n4. vueMiddleware 源码#\n\n\n4.1 有无 vueMiddleware 中间件对比#\n\n不在调试情况状态下，我们可以在 vue-dev-server/bin/vue-dev-server.js 文件中注释\napp.use(vueMiddleware())，执行 npm run test 打开 http://localhost:3000。\n\n\n\n再启用中间件后，如下图。\n\n\n\n看图我们大概知道了有哪些区别。\n\n\n4.2 vueMiddleware 中间件概览#\n\n我们可以找到vue-dev-server/middleware.js，查看这个中间件函数的概览。\n\n\n\nvueMiddleware 最终返回一个函数。这个函数里主要做了四件事：\n\n * 对 .vue 结尾的文件进行处理\n\n * 对 .js 结尾的文件进行处理\n\n * 对 /__modules/ 开头的文件进行处理\n\n * 如果不是以上三种情况，执行 next 方法，把控制权交给下一个中间件\n\n接着我们来看下具体是怎么处理的。\n\n我们也可以断点这些重要的地方来查看实现。比如：\n\n\n\n\n4.3 对 .vue 结尾的文件进行处理#\n\n\n\n4.3.1 bundleSFC 编译单文件组件#\n\n这个函数，根据 @vue/component-compiler 转换单文件组件，最终返回浏览器能够识别的文件。\n\n\n\n接着我们来看 readSource 函数实现。\n\n4.3.2 readSource 读取文件资源#\n\n这个函数主要作用：根据请求获取文件资源。返回文件路径 filepath、资源 source、和更新时间 updateTime。\n\n\n\n接着我们来看对 .js 文件的处理\n\n\n4.4 对 .js 结尾的文件进行处理#\n\n\n\n针对 vue-dev-server/test/main.js 转换\n\n\n\n\n\n4.4.1 transformModuleImports 转换 import 引入#\n\nrecast\n\nvalidate-npm-package-name\n\n\n\n也就是针对 npm 包转换。 这里就是 \"/__modules/vue\"\n\n\n\n\n4.5 对 /__modules/ 开头的文件进行处理#\n\n\n\n这段代码最终返回的是读取路径 vue-dev-server/node_modules/vue/dist/vue.esm.browser.js 下的文件。\n\n\n\n4.5.1 loadPkg 加载包（这里只支持Vue文件）#\n\n目前只支持 Vue 文件，也就是读取路径 vue-dev-server/node_modules/vue/dist/vue.esm.browser.js\n下的文件返回。\n\n\n\n至此，我们就基本分析完毕了主文件和一些引入的文件。对主流程有个了解。\n\n\n5. 总结#\n\n最后我们来看上文中有无 vueMiddleware 中间件的两张图总结一下：\n\n\n\n启用中间件后，如下图。\n\n\n\n浏览器支持原生 type=module 模块请求加载。vue-dev-server 对其拦截处理，返回浏览器支持内容，因为无需打包构建，所以速度很快。\n\n\n\n\n5.1 转换#\n\n\n\nmain.js 中的 import 语句\n\n通过 recast 生成 ast 转换成 `` 而最终返回给浏览器的是\nvue-dev-server/node_modules/vue/dist/vue.esm.browser.js\n\n\n5.2 转换#\n\nmain.js 中的引入 .vue 的文件，`` 则用 @vue/component-compiler 转换成浏览器支持的文件。\n\n\n5.3 后续还能做什么？#\n\n鉴于文章篇幅有限，缓存 tryCache 部分目前没有分析。简单说就是使用了 node-lru-cache 最近最少使用\n来做缓存的（这个算法常考）。后续应该会分析这个仓库的源码，欢迎持续关注我@若川。\n\n非常建议读者朋友按照文中方法使用VSCode调试 vue-dev-server 源码。源码中还有很多细节文中由于篇幅有限，未全面展开讲述。\n\n值得一提的是这个仓库的 master 分支，是尤雨溪两年前写的，相对本文会比较复杂，有余力的读者可以学习。\n\n也可以直接去看 vite 源码。\n\n看完本文，也许你就能发现其实前端能做的事情越来越多，不由感慨：前端水深不可测，唯有持续学习。\n\n最后欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。","routePath":"/vue-dev-server/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. vue-dev-server 它的原理是什么","id":"2-vue-dev-server-它的原理是什么","depth":2,"charIndex":398},{"text":"3. 准备工作","id":"3-准备工作","depth":2,"charIndex":783},{"text":"3.1 克隆项目","id":"31-克隆项目","depth":3,"charIndex":794},{"text":"3.2 test 文件夹","id":"32-test-文件夹","depth":3,"charIndex":916},{"text":"3.3 vue-dev-server.js","id":"33-vue-dev-serverjs","depth":3,"charIndex":1073},{"text":"3.4 用 VSCode 调试项目","id":"34-用-vscode-调试项目","depth":3,"charIndex":1220},{"text":"4. vueMiddleware 源码","id":"4-vuemiddleware-源码","depth":2,"charIndex":1726},{"text":"4.1 有无 vueMiddleware 中间件对比","id":"41-有无-vuemiddleware-中间件对比","depth":3,"charIndex":1749},{"text":"4.2 vueMiddleware 中间件概览","id":"42-vuemiddleware-中间件概览","depth":3,"charIndex":1941},{"text":"4.3 对 .vue 结尾的文件进行处理","id":"43-对-vue-结尾的文件进行处理","depth":3,"charIndex":2211},{"text":"4.3.1 bundleSFC 编译单文件组件","id":"431-bundlesfc-编译单文件组件","depth":4,"charIndex":2236},{"text":"4.3.2 readSource 读取文件资源","id":"432-readsource-读取文件资源","depth":4,"charIndex":2346},{"text":"4.4 对 .js 结尾的文件进行处理","id":"44-对-js-结尾的文件进行处理","depth":3,"charIndex":2459},{"text":"4.4.1 transformModuleImports 转换 import 引入","id":"441-transformmoduleimports-转换-import-引入","depth":4,"charIndex":2522},{"text":"4.5 对 /__modules/ 开头的文件进行处理","id":"45-对-__modules-开头的文件进行处理","depth":3,"charIndex":2644},{"text":"4.5.1 loadPkg 加载包（这里只支持Vue文件）","id":"451-loadpkg-加载包这里只支持vue文件","depth":4,"charIndex":2756},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":2913},{"text":"5.1  转换","id":"51--转换","depth":3,"charIndex":-1},{"text":"5.2  转换","id":"52--转换","depth":3,"charIndex":-1},{"text":"5.3 后续还能做什么？","id":"53-后续还能做什么","depth":3,"charIndex":3261}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":133,"title":"尤雨溪开发的 vue-devtools 如何安装，为何打开文件的功能鲜有人知？","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。最近组织了一次源码共读活动。每周读200行左右的源码。很多第一次读源码的小伙伴都感觉很有收获，感兴趣可以加我微信\n> ruochuan12，拉你进群学习。\n\n第一周读的是：据说 99% 的人不知道 vue-devtools\n还能直接打开对应组件文件？本文原理揭秘。虽然我写过文章，但我还是相信有部分小伙伴还是不知道这个功能。\n\n\n\n文中项目用的是vue3，所以需要安装 vue3 版本对应的vue-devtools。\n\n但有挺多小伙伴，无法打开谷歌应用市场。有人说不是谷歌应用市场可以下载嘛。但往往是这一步拦住了很多用户，也有了很多商机。比如各种插件网站应运而生。于是我写篇文章，\n我是如何打包安装 devtools 插件的。\n\n> 友情提醒：文章相对比较简单。估计有人会说，这也要写篇文章嘛。事实上，真的有挺多人不知道怎么打包。写文章也是提醒大家多看官方文档和github README。\n\n> 插件我已经打包好，放到百度网盘中，在我的公众号：若川视野，回复关键词【插件】即可获取到两个版本的 devtools 进行安装，两个版本可以共存。\n\n\n2. 打包插件和安装方法#\n\n打开 github vue-devtools 发现名字也更新了，之前是叫vue-devtools，现在是devtools了，竟然还出了devtools 官网。\n\n\n2.1 打包 vue3 版本对应的 vue-devtools#\n\n查看官方README：vue-devtools contributing\n\n\n\n\n\n不出意外，构建成功后，可以得到有 devtools/packages/shell-chrome/ 目录。\n\n\n2.2 打包 vue2 版本对应的 vue-devtools#\n\n查看官方README：vue2 devtools REAMDE.md\n\n\n\n\n\n同样，不出意外，构建成功后，可以得到有 devtools-v2/packages/shell-chrome/ 目录。\n\n\n2.3 安装#\n\n\n\n如上图所示，谷歌浏览器打开 chrome://extensions/，右上角点击开启开发者模式，点击加载已解压的扩展程序，选择打包生成的\ndevtools-v2/packages/shell-chrome/ 文件夹即可安装，或者直接拖入也可以安装，vue2 和 vue3 的插件可以共存。\n\n安装好后，可以开心的调试啦，顺便可以查看下插件的详细信息。目前 vue3 对应版本的是6.0.0-beta-15。vue2 对应的版本是\n5.3.4。其中详细信息中，允许访问文件网址，默认是开启的，建议开启。\n\n\n\n\n3. 总结#\n\n文章相对简短，如果你身边有新人同事，还在为安装 devtools 插件发愁，可以分享这篇给TA。\n\n启发：我们要养成多查阅官方文档或者github README的习惯。好的开源项目，README一般都写得非常好。另外除了什么新功能，一般在官方文档或者\nREADME 会有体现。虽然一般 README 是英文的会阻拦一部分人，但如果真的看不懂还可以通过谷歌翻译等翻译工具。\n\n> 再次友情提醒：插件我已经打包好，放到百度网盘中，在我的公众号：若川视野，回复关键词【插件】即可获取到两个版本的 devtools\n> 进行安装，两个版本可以共存。\n\n最后欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。","routePath":"/vue-devtools-install/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 打包插件和安装方法","id":"2-打包插件和安装方法","depth":2,"charIndex":496},{"text":"2.1 打包 vue3 版本对应的 vue-devtools","id":"21-打包-vue3-版本对应的-vue-devtools","depth":3,"charIndex":593},{"text":"2.2 打包 vue2 版本对应的 vue-devtools","id":"22-打包-vue2-版本对应的-vue-devtools","depth":3,"charIndex":723},{"text":"2.3 安装","id":"23-安装","depth":3,"charIndex":857},{"text":"3. 总结","id":"3-总结","depth":2,"charIndex":1123}],"domain":"","frontmatter":{},"version":""},{"id":134,"title":"尤雨溪开发的 vue-devtools 如何安装，为何打开文件的功能鲜有人知？","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。最近组织了一次源码共读活动。每周读200行左右的源码。很多第一次读源码的小伙伴都感觉很有收获，感兴趣可以加我微信\n> ruochuan12，拉你进群学习。\n\n第一周读的是：据说 99% 的人不知道 vue-devtools\n还能直接打开对应组件文件？本文原理揭秘。虽然我写过文章，但我还是相信有部分小伙伴还是不知道这个功能。\n\n\n\n文中项目用的是vue3，所以需要安装 vue3 版本对应的vue-devtools。\n\n但有挺多小伙伴，无法打开谷歌应用市场。有人说不是谷歌应用市场可以下载嘛。但往往是这一步拦住了很多用户，也有了很多商机。比如各种插件网站应运而生。于是我写篇文章，\n我是如何打包安装 devtools 插件的。\n\n> 友情提醒：文章相对比较简单。估计有人会说，这也要写篇文章嘛。事实上，真的有挺多人不知道怎么打包。写文章也是提醒大家多看官方文档和github README。\n\n> 插件我已经打包好，放到百度网盘中，在我的公众号：若川视野，回复关键词【插件】即可获取到两个版本的 devtools 进行安装，两个版本可以共存。\n\n\n2. 打包插件和安装方法#\n\n打开 github vue-devtools 发现名字也更新了，之前是叫vue-devtools，现在是devtools了，竟然还出了devtools 官网。\n\n\n2.1 打包 vue3 版本对应的 vue-devtools#\n\n查看官方README：vue-devtools contributing\n\n\n\n\n\n不出意外，构建成功后，可以得到有 devtools/packages/shell-chrome/ 目录。\n\n\n2.2 打包 vue2 版本对应的 vue-devtools#\n\n查看官方README：vue2 devtools REAMDE.md\n\n\n\n\n\n同样，不出意外，构建成功后，可以得到有 devtools-v2/packages/shell-chrome/ 目录。\n\n\n2.3 安装#\n\n\n\n如上图所示，谷歌浏览器打开 chrome://extensions/，右上角点击开启开发者模式，点击加载已解压的扩展程序，选择打包生成的\ndevtools-v2/packages/shell-chrome/ 文件夹即可安装，或者直接拖入也可以安装，vue2 和 vue3 的插件可以共存。\n\n安装好后，可以开心的调试啦，顺便可以查看下插件的详细信息。目前 vue3 对应版本的是6.0.0-beta-15。vue2 对应的版本是\n5.3.4。其中详细信息中，允许访问文件网址，默认是开启的，建议开启。\n\n\n\n\n3. 总结#\n\n文章相对简短，如果你身边有新人同事，还在为安装 devtools 插件发愁，可以分享这篇给TA。\n\n启发：我们要养成多查阅官方文档或者github README的习惯。好的开源项目，README一般都写得非常好。另外除了什么新功能，一般在官方文档或者\nREADME 会有体现。虽然一般 README 是英文的会阻拦一部分人，但如果真的看不懂还可以通过谷歌翻译等翻译工具。\n\n> 再次友情提醒：插件我已经打包好，放到百度网盘中，在我的公众号：若川视野，回复关键词【插件】即可获取到两个版本的 devtools\n> 进行安装，两个版本可以共存。","routePath":"/vue-devtools/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 打包插件和安装方法","id":"2-打包插件和安装方法","depth":2,"charIndex":496},{"text":"2.1 打包 vue3 版本对应的 vue-devtools","id":"21-打包-vue3-版本对应的-vue-devtools","depth":3,"charIndex":593},{"text":"2.2 打包 vue2 版本对应的 vue-devtools","id":"22-打包-vue2-版本对应的-vue-devtools","depth":3,"charIndex":723},{"text":"2.3 安装","id":"23-安装","depth":3,"charIndex":857},{"text":"3. 总结","id":"3-总结","depth":2,"charIndex":1123}],"domain":"","frontmatter":{},"version":""},{"id":135,"title":"开发小程序又一新选择 vue-mini，据说性能是 Taro 的 10 倍，遥遥领先","content":"#\n\n\n1. 前言#\n\n大家好，我是若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。\n\n刚刚结束不久的vueconf 2024 深圳，有一个主题《Vue-Mini 不妥协的小程序框架》，仓库、PPT、视频\n\n\n\nPPT 中有这样两页。\n\n\n\n和 taro 性能对比数据的仓库链接，目前作者暂未给出与 uniapp 的性能对比。有小伙伴在 issue 中问到，作者回复后续会补上\n\nvue-mini 官网 与其他的比较。\n\n\n\n\n\n更多兼容性和使用方法等查阅vue-mini 文档。\n\n本文主要来简单体验下 vue-mini，并且学习下基本的打包构建大概是如何实现的。\n\n学完本文，你将学到：\n\n\n\n\n2. 初始化项目#\n\n根据 官网文档快速开始 生成小程序项目，我采用的是 pnpm create vue-mini@latest，我都选择的\"是\"。如下图所示：\n\n\n\n这个命令调用的是 create-vue-mini 这个项目，写文章时的版本是 1.0.4。它由 create-vue 修改而来。我在21年写过它的源码文章Vue\n团队公开快如闪电的全新脚手架工具 create-vue，未来将替代 Vue-CLI，才300余行代码，学它！，(3.9w+阅读量、483赞)可供学习。\n\n也可以直接克隆我的项目。\n\n\n\n执行 pnpm install 之后，再执行 pnpm run dev 或者 pnpm run build 命令。\n\n\n3. 体验 vue-mini#\n\n直接选择项目根目录而非 dist 目录，将此项目导入微信开发者工具。\n\n打开项目如图：\n\n\n\n\n\n\n3.1 对比打包构建的代码#\n\n我们具体来对比执行 pnpm run dev 命令之后生成的代码。\n\n入口 app.ts 文件。\n\n\n\n首页 html 文件\n\n首页 css 文件\n\n首页 ts 文件\n\n首页 json 文件\n\n我们可以看到主要就是处理入口 app.ts 文件（单独追加了 promise-polyfill）、html、css、ts文件编译成了微信小程序支持的\napp.js、wxml、wxss、js。json 文件是直接复制的，没做处理。\n\n换句话说： 模板写法使用的是原生微信小程序的wxml，只是改名了 html 而已，css 部分也是原生微信小程序的 wxss 只是单位 rpx 改成了 px\n而已，未做类似单文件组件的编译。只是在逻辑侧，ts 文件使用了 vue-mini/core，轻运行时，会把 ES Module 编译成 commonjs。\n\n\n3.1 dev 和 build 命令#\n\npnpm run dev 和 pnpm run build 分别对应的是 package.json 中的两个命令。\n\n\n\ncross-env 是用来跨平台设置环境变量的，NODE_ENV=development 代表开发环境，NODE_ENV=production 代表生产环境。\n\n我们可以打开 build.js 文件，查看下它的代码。\n\n\n\n调试可参考我的文章新手向：前端程序员必学基本技能——调试 JS 代码，或者据说 90%的人不知道可以用测试用例(Vitest)调试开源项目(Vue3)\n源码。本文就不做过多赘述。\n\n\n\nbuild.js 目前是比较原始的方式，没有各种封装，相对容易学习。有小伙伴提建议[Feature] 希望可以增强工程化等基建体验 #65。\n\n让我想起很久很久以前（大约是6年前），vue-cli@2.9.3 版本时就是用生成 vue 项目就是直接生成在开发者的项目中。比较难以和官方保持同步升级。后来\nvue-cli@3.0 之后版本就能相对容易升级了。\n\n> 当时写过一篇文章分析vue-cli@2.9.3 搭建的webpack项目工程，webpack\n> 配置相关可能过时了，但其他知识没有过时，感兴趣的小伙伴可以学习。\n\n\n3. build.js 打包构建文件#\n\n\n3.1 引入各种依赖#\n\n\n\n> 引入 node path 模块和 process 模块\n\n\n\n> 引入 fs-extra 模块，用来操作文件和目录 引入 chokidar 模块，用来监听文件变化\n\n\n\n> 引入 @babel/core 模块，用来编译 js 代码 引入 @babel/traverse 模块，用来遍历 js 代码 引入 @babel/types\n> 模块，用来编译 js 代码 引入 terser 模块，用来压缩 js 代码\n\n\n\n> 引入 postcss 模块，用来编译 css 代码 引入 postcss-load-config 模块，用来加载 postcss 配置文件\n\n\n\n> 引入 rollup 模块，用来打包 js 代码 引入 @rollup/plugin-replace 模块，用来替换代码 引入\n> @rollup/plugin-terser 模块，用来压缩 js 代码 引入 @rollup/plugin-node-resolve 模块，用来解析\n> node_modules 中的依赖 引入 @rollup/commonjs 模块，用来解析 commonjs 依赖\n\n\n\n> 引入 kolorist 模块，用来输出彩色文字\n\n\n3.2 定义变量#\n\n\n\n\n3.3 调用 prod 或者 dev#\n\n\n\n我们先来看 prod 函数，再看 dev 函数。\n\n\n3.4 prod 函数#\n\n\n\n这个函数主要做了以下几件事：\n\n 1. 移除 dist 目录\n 2. 监听 src 目录\n 3. 对于监听的文件，调用 cb 函数，把返回的 promise ，存入数组 waitList。\n 4. 最后调用 Promise.all(waitList) 执行所有的 promise。\n 5. 最后打印构建时长。\n\n\n3.5 dev 函数#\n\n\n\n这个函数和 prod 函数类似，主要做了以下几件事：\n\n 1. 移除 dist 目录\n 2. 监听 src 目录\n 3. 对于监听的文件，调用 cb 函数，把返回的 promise ，存入数组 waitList。\n 4. 文件改变时，调用 cb 函数。\n 5. 调用 Promise.all(waitList) 执行所有的 promise。\n 6. 最后打印启动时长，清空 waitList。\n\n我们接着来看，cb 函数，这个函数用来处理文件变化。\n\n\n\ncb 函数主要用来处理 ts、html、css 文件和复制文件到 dist 目录。\n\n分别来看这几个函数的实现，我们先看 processScript 处理 ts 文件\n\n\n3.6 processScript 处理 ts#\n\n\n\n使用 babel.transformFileAsync 异步地将文件内容转换为抽象语法树（AST）和转换后的代码。\n\n\n\n替换代码 '\"use strict\";'，追加 Promise 的 Polyfill，这里使用的是 promise-polyfill。\n\n\n\n遍历 AST，找到 CallExpression 节点，判断是否为 require 函数，并且参数是字符串，且不是相对路径。\n\n\n\n经过以上处理后，src/pages/home/index.ts 变成了 dist/pages/home/index.js，代码如下所示：\n\n\n\n\n\n我们来简单看下 babel 配置。\n\n3.6.1 babel.config.js babel 配置文件#\n\n\n\n我们继续来看 bundleModule 函数的具体实现。\n\n\n3.7 bundleModule 打包模块#\n\n\n\n如果已经有打包好的模块，直接返回。 用 rollup 打包模块，处理成 commonjs，并写入 dist/miniprogram_npm 目录。\n\n如图所示：\n\n我们继续来看 html 文件处理：\n\n\n3.8 processTemplate 处理模板 html#\n\n\n\n这个函数相对简单，就是复制 src html 文件修改后缀名为 .wxml 文件到 dist 目录。\n\n\n3.9 processStyle 处理样式文件#\n\n\n\npostcss-load-config Autoload Config for PostCSS 是自动加载 postcss.config.js\n等配置文件，并解析其中的插件。 然后调用 postcss 解析样式文件，并写入 dist 目录。\n\n3.9.1 postcss.config.js postcss 配置文件#\n\n\n\n引入 postcss-pxtorpx-pro 插件，将 px 转换为 rpx。\n\n处理 px 为 rpx 如下所示：\n\n\n\n\n4. 总结#\n\n我们学习了初始化项目中的 build.js 是如何打包小程序代码的。\n\n学习了使用 cross-env 配置环境变量，使用 chokidar 监听文件变动。html\n文件就是原生微信小程序的wxml，直接复制粘贴修改了后缀名到dist目录。 使用 babel 和 rollup 处理 js 文件，入口文件\napp.config.ts ，还在开头追加了 promise-ployfill ，使用 postcss 处理样式文件，其他文件是直接复制粘贴到 dist\n目录的。\n\n也就是说：只是html(wxml)模板部分还是原生微信小程序写法，ts(js)逻辑部分使用了vue-mini（轻运行时）。\n\n常言道：一图胜千言。我画了一张图表示：\n\n\n\nvue-mini\n比较适合不需要跨端，比如不需要同时支持微信小程序和支付宝小程序。只开发微信小程序是一个新选择，性能基本等于原生微信小程序，逻辑部分开发体验优于原生微信小程序。适\n合本身就是使用的原生微信小程序开发的，可以渐进式升级替换为 vue-mini。\n\n也就是说 vue-mini 是渐进式开发微信小程序。和原生开发不是二选一。性能上，vue-mini 接近原生，开发体验优于原生开发。\n\n不过目前还处于相对初期阶段，生态还不是很完善，比如暂不支持 less、sass 等。\n\nvue-mini 作者在最后也有一页接下来的开发方向的PPT。作者目前时间和精力有限，没有支持多端的打算。长期可能有。\n\n\n\n感兴趣的小伙伴可以点个 star。我们持续关注后续发展，有余力的小伙伴也可以多参与贡献。\n\n--------------------------------------------------------------------------------\n\n如果看完有收获，欢迎点赞、评论、分享、收藏支持。你的支持和肯定，是我写作的动力。\n\n作者：常以若川为名混迹于江湖。所知甚少，唯善学。若川的博客\n\n最后可以持续关注我@若川，欢迎关注我的公众号：若川视野。我倾力持续组织了 3 年多每周大家一起学习 200 行左右的源码共读活动，感兴趣的可以点此扫码加我微信\nruochuan02 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（6k+人）第一的专栏，写有几十篇源码文章。","routePath":"/vue-mini-analysis/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 初始化项目","id":"2-初始化项目","depth":2,"charIndex":422},{"text":"3. 体验 vue-mini","id":"3-体验-vue-mini","depth":2,"charIndex":740},{"text":"3.1 对比打包构建的代码","id":"31-对比打包构建的代码","depth":3,"charIndex":807},{"text":"3.1 dev 和 build 命令","id":"31-dev-和-build-命令","depth":3,"charIndex":1195},{"text":"3. build.js 打包构建文件","id":"3-buildjs-打包构建文件","depth":2,"charIndex":1748},{"text":"3.1 引入各种依赖","id":"31-引入各种依赖","depth":3,"charIndex":1770},{"text":"3.2 定义变量","id":"32-定义变量","depth":3,"charIndex":2303},{"text":"3.3 调用 prod 或者 dev","id":"33-调用-prod-或者-dev","depth":3,"charIndex":2317},{"text":"3.4 prod 函数","id":"34-prod-函数","depth":3,"charIndex":2367},{"text":"3.5 dev 函数","id":"35-dev-函数","depth":3,"charIndex":2540},{"text":"3.6 processScript 处理 ts","id":"36-processscript-处理-ts","depth":3,"charIndex":2869},{"text":"3.6.1 babel.config.js babel 配置文件","id":"361-babelconfigjs-babel-配置文件","depth":4,"charIndex":3188},{"text":"3.7 bundleModule 打包模块","id":"37-bundlemodule-打包模块","depth":3,"charIndex":3256},{"text":"3.8 processTemplate 处理模板 html","id":"38-processtemplate-处理模板-html","depth":3,"charIndex":3384},{"text":"3.9 processStyle 处理样式文件","id":"39-processstyle-处理样式文件","depth":3,"charIndex":3471},{"text":"3.9.1 postcss.config.js postcss 配置文件","id":"391-postcssconfigjs-postcss-配置文件","depth":4,"charIndex":3621},{"text":"4. 总结","id":"4-总结","depth":2,"charIndex":3725}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":136,"title":"","content":"1. 前言#\n\n大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动1个月，200+人，一起读了4周源码，感兴趣的可以加我微信\nruochuan12，长期交流学习。\n\n之前写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4十篇源码文章。\n\n写相对很难的源码，耗费了自己的时间和精力，也没收获多少阅读点赞，其实是一件挺受打击的事情。从阅读量和读者受益方面来看，不能促进作者持续输出文章。\n\n所以转变思路，写一些相对通俗易懂的文章。其实源码也不是想象的那么难，至少有很多看得懂。\n\n最近尤雨溪发布了3.2版本。小版本已经是3.2.4了。本文来学习下尤大是怎么发布vuejs的，学习源码为自己所用。\n\n本文涉及到的 vue-next/scripts/release.js文件，整个文件代码行数虽然只有 200 余行，但非常值得我们学习。\n\n歌德曾说：读一本好书，就是在和高尚的人谈话。 同理可得：读源码，也算是和作者的一种学习交流的方式。\n\n阅读本文，你将学到：\n\n\n\n环境准备之前，我们先预览下vuejs的发布流程。\n\n\n\n\n2. 环境准备#\n\n打开 vue-next， 开源项目一般都能在 README.md 或者 .github/contributing.md 找到贡献指南。\n\n而贡献指南写了很多关于参与项目开发的信息。比如怎么跑起来，项目目录结构是怎样的。怎么投入开发，需要哪些知识储备等。\n\n你需要确保 Node.js 版本是 10+, 而且 yarn 的版本是 1.x Yarn 1.x。\n\n你安装的 Node.js 版本很可能是低于 10。最简单的办法就是去官网重新安装。也可以使用 nvm等管理Node.js版本。\n\n\n\n\n2.1 严格校验使用 yarn 安装依赖#\n\n接着我们来看下 vue-next/package.json 文件。\n\n\n\n如果你尝试使用 npm 安装依赖，应该是会报错的。为啥会报错呢。 因为 package.json 有个前置 preinstall node\n./scripts/checkYarn.js 判断强制要求是使用yarn安装。\n\nscripts/checkYarn.js文件如下，也就是在process.env环境变量中找执行路径npm_execpath，如果不是yarn就输出警告，且进程\n结束。\n\n\n\n如果你想忽略这个前置的钩子判断，可以使用yarn --ignore-scripts 命令。也有后置的钩子post。更多详细的可以查看 npm 文档\n\n\n2.2 调试 vue-next/scripts/release.js 文件#\n\n接着我们来学习如何调试 vue-next/scripts/release.js文件。\n\n这里声明下我的 VSCode 版本 是 1.59.0 应该 1.50.0 起就可以按以下步骤调试了。\n\n\n\n找到 vue-next/package.json 文件打开，然后在 scripts 上方，会有debug（调试）按钮，点击后，选择\nrelease。即可进入调试模式。\n\n\n\n这时终端会如下图所示，有 Debugger attached. 输出。这时放张图。\n\n\n\n更多 nodejs 调试相关 可以查看官方文档\n\n学会调试后，先大致走一遍流程，在关键地方多打上几个断点多走几遍，就能猜测到源码意图了。\n\n\n3 文件开头的一些依赖引入和函数声明#\n\n我们可以跟着断点来，先看文件开头的一些依赖引入和函数声明\n\n\n3.1 第一部分#\n\n\n\n通过依赖，我们可以在 node_modules 找到对应安装的依赖。也可以找到其README和github仓库。\n\n3.1.1 minimist 命令行参数解析#\n\nminimist\n\n简单说，这个库，就是解析命令行参数的。看例子，我们比较容易看懂传参和解析结果。\n\n\n\n\n\n其中process.argv的第一和第二个元素是Node可执行文件和被执行JavaScript文件的完全限定的文件系统路径，无论你是否这样输入他们。\n\n3.1.2 chalk 终端多色彩输出#\n\nchalk\n\n简单说，这个是用于终端显示多色彩输出。\n\n3.1.3 semver 语义化版本#\n\nsemver\n\n语义化版本的nodejs实现，用于版本校验比较等。关于语义化版本可以看这个语义化版本 2.0.0 文档\n\n> 版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改， 次版本号：当你做了向下兼容的功能性新增，\n> 修订号：当你做了向下兼容的问题修正。 先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n\n3.1.4 enquirer 交互式询问 CLI#\n\n简单说就是交互式询问用户输入。\n\nenquirer\n\n3.1.5 execa 执行命令#\n\n简单说就是执行命令的，类似我们自己在终端输入命令，比如 echo 若川。\n\nexeca\n\n\n\n看完了第一部分，接着我们来看第二部分。\n\n\n3.2 第二部分#\n\n\n\n第二部分相对简单，继续看第三部分。\n\n\n3.3 第三部分#\n\n\n\n这一块可能不是很好理解。inc是生成一个版本。更多可以查看semver文档\n\n\n\n\n3.4 第四部分#\n\n第四部分声明了一些执行脚本函数等\n\n\n\n3.4.1 bin 函数#\n\n获取 node_modules/.bin/ 目录下的命令，整个文件就用了一次。\n\n\n\n相当于在命令终端，项目根目录 运行 ./node_modules/.bin/jest 命令。\n\n3.4.2 run、dryRun、runIfNotDry#\n\n\n\nrun 真实在终端跑命令，比如 yarn build --release\n\ndryRun 则是不跑，只是 console.log(); 打印 'yarn build --release'\n\nrunIfNotDry 如果不是空跑就执行命令。isDryRun 参数是通过控制台输入的。yarn run release\n--dry这样就是true。runIfNotDry就是只是打印，不执行命令。这样设计的好处在于，可以有时不想直接提交，要先看看执行命令的结果。不得不说，尤大就是\n会玩。\n\n在 main 函数末尾，也可以看到类似的提示。可以用git diff先看看文件修改。\n\n\n\n看完了文件开头的一些依赖引入和函数声明等，我们接着来看main主入口函数。\n\n\n4 main 主流程#\n\n第4节，主要都是main 函数拆解分析。\n\n\n4.1 流程梳理 main 函数#\n\n\n\n上面的main函数省略了很多具体函数实现。接下来我们拆解 main 函数。\n\n\n4.2 确认要发布的版本#\n\n第一段代码虽然比较长，但是还好理解。 主要就是确认要发布的版本。\n\n调试时，我们看下这段的两张截图，就好理解啦。\n\n\n\n\n\n\n\n\n4.3 执行测试用例#\n\n\n\n\n4.4 更新所有包的版本号和内部 vue 相关依赖版本号#\n\n这一部分，就是更新根目录下package.json 的版本号和所有 packages 的版本号。\n\n\n\n\n\n4.4.1 updatePackage 更新包的版本号#\n\n\n\n主要就是三种修改。\n\n\n\n一图胜千言。我们执行yarn release --dry 后 git diff 查看的 git 修改，部分截图如下。\n\n\n\n4.4.2 updateDeps 更新内部 vue 相关依赖的版本号#\n\n\n\n一图胜千言。我们在终端执行yarn release --dry。会看到这样是输出。\n\n\n\n也就是这句代码输出的。\n\n\n\n\n4.5 打包编译所有包#\n\n\n\n\n4.6 生成 changelog#\n\n\n\nyarn changelog 对应的脚本是conventional-changelog -p angular -i CHANGELOG.md -s。\n\n\n4.7 提交代码#\n\n经过更新版本号后，有文件改动，于是git diff。 是否有文件改动，如果有提交。\n\ngit add -A git commit -m 'release: v${targetVersion}'\n\n\n\n\n4.8 发布包#\n\n\n\n这段函数比较长，可以不用细看，简单说就是 yarn publish 发布包。 我们 yarn release --dry后，这块函数在终端输出的如下：\n\n\n\n值得一提的是，如果是 vue 默认有个 tag 为 next。当 Vue 3.x 是默认时删除。\n\n\n\n也就是为什么我们现在安装 vue3 还是 npm i vue@next命令。\n\n\n\n\n4.9 推送到 github#\n\n\n\n\n\n我们 yarn release --dry后，这块函数在终端输出的如下：\n\n\n\n到这里我们就拆解分析完 main 函数了。\n\n整个流程很清晰。\n\n\n\n用一张图总结则是：\n\n\n\n看完vue-next/scripts/release.js，感兴趣还可以看vue-next/scripts文件夹下其他代码，相对行数不多，但收益较大。\n\n\n5. 总结#\n\n通过本文学习，我们学会了这些。\n\n\n\n同时建议自己动手用 VSCode 多调试，在终端多执行几次，多理解消化。\n\nvuejs发布的文件很多代码我们可以直接复制粘贴修改，优化我们自己发布的流程。比如写小程序，相对可能发布频繁，完全可以使用这套代码，配合miniprogram-\nci，再加上一些自定义，加以优化。\n\n当然也可以用开源的 release-it。\n\n同时，我们可以：\n\n引入 git flow，管理git分支。估计很多人不知道windows git bash已经默认支持 git flow命令。\n\n引入 husky 和 lint-staged 提交commit时用ESLint等校验代码提交是否能够通过检测。\n\n引入 单元测试 jest，测试关键的工具函数等。\n\n引入 conventional-changelog\n\n引入 git-cz 交互式git commit。\n\n等等规范自己项目的流程。如果一个候选人，通过看vuejs发布的源码，积极主动优化自己项目。我觉得面试官会认为这个候选人比较加分。\n\n看开源项目源码的好处在于：一方面可以拓展视野，另外一方面可以为自己所用，收益相对较高。","routePath":"/vue-next-release/README.zhihu","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":-1},{"text":"2. 环境准备","id":"2-环境准备","depth":2,"charIndex":531},{"text":"2.1 严格校验使用 yarn 安装依赖","id":"21-严格校验使用-yarn-安装依赖","depth":3,"charIndex":788},{"text":"2.2 调试  vue-next/scripts/release.js 文件","id":"22-调试--vue-nextscriptsreleasejs-文件","depth":3,"charIndex":-1},{"text":"3 文件开头的一些依赖引入和函数声明","id":"3-文件开头的一些依赖引入和函数声明","depth":2,"charIndex":1464},{"text":"3.1 第一部分","id":"31-第一部分","depth":3,"charIndex":1516},{"text":"3.1.1 minimist  命令行参数解析","id":"311-minimist--命令行参数解析","depth":4,"charIndex":-1},{"text":"3.1.2 chalk 终端多色彩输出","id":"312-chalk-终端多色彩输出","depth":4,"charIndex":1743},{"text":"3.1.3 semver  语义化版本","id":"313-semver--语义化版本","depth":4,"charIndex":-1},{"text":"3.1.4 enquirer 交互式询问 CLI","id":"314-enquirer-交互式询问-cli","depth":4,"charIndex":2013},{"text":"3.1.5 execa 执行命令","id":"315-execa-执行命令","depth":4,"charIndex":2067},{"text":"3.2 第二部分","id":"32-第二部分","depth":3,"charIndex":2155},{"text":"3.3 第三部分","id":"33-第三部分","depth":3,"charIndex":2188},{"text":"3.4 第四部分","id":"34-第四部分","depth":3,"charIndex":2243},{"text":"3.4.1 bin 函数","id":"341-bin-函数","depth":4,"charIndex":2274},{"text":"3.4.2 run、dryRun、runIfNotDry","id":"342-rundryrunrunifnotdry","depth":4,"charIndex":2380},{"text":"4 main 主流程","id":"4-main-主流程","depth":2,"charIndex":2742},{"text":"4.1 流程梳理 main 函数","id":"41-流程梳理-main-函数","depth":3,"charIndex":2778},{"text":"4.2 确认要发布的版本","id":"42-确认要发布的版本","depth":3,"charIndex":2839},{"text":"4.3 执行测试用例","id":"43-执行测试用例","depth":3,"charIndex":2919},{"text":"4.4 更新所有包的版本号和内部 vue 相关依赖版本号","id":"44-更新所有包的版本号和内部-vue-相关依赖版本号","depth":3,"charIndex":2935},{"text":"4.4.1 updatePackage 更新包的版本号","id":"441-updatepackage-更新包的版本号","depth":4,"charIndex":3020},{"text":"4.4.2 updateDeps 更新内部 vue 相关依赖的版本号","id":"442-updatedeps-更新内部-vue-相关依赖的版本号","depth":4,"charIndex":3127},{"text":"4.5 打包编译所有包","id":"45-打包编译所有包","depth":3,"charIndex":3227},{"text":"4.6 生成 changelog","id":"46-生成-changelog","depth":3,"charIndex":3244},{"text":"4.7 提交代码","id":"47-提交代码","depth":3,"charIndex":3342},{"text":"4.8 发布包","id":"48-发布包","depth":3,"charIndex":3454},{"text":"4.9 推送到 github","id":"49-推送到-github","depth":3,"charIndex":3640},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":3827}],"domain":"","frontmatter":{},"version":""},{"id":137,"title":"Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？","content":"#\n\n\n1. 前言#\n\n大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动《1个月，200+人，一起读了4周源码》，感兴趣的可以加我微信 ruochuan12\n加微信群参与，长期交流学习。\n\n之前写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4十篇源码文章。\n\n写相对很难的源码，耗费了自己的时间和精力，也没收获多少阅读点赞，其实是一件挺受打击的事情。从阅读量和读者受益方面来看，不能促进作者持续输出文章。\n\n所以转变思路，写一些相对通俗易懂的文章。其实源码也不是想象的那么难，至少有很多看得懂。\n\n最近尤雨溪发布了3.2版本。小版本已经是3.2.4了。本文来学习下尤大是怎么发布vuejs的，学习源码为自己所用。\n\n本文涉及到的 vue-next/scripts/release.js文件，整个文件代码行数虽然只有 200 余行，但非常值得我们学习。\n\n歌德曾说：读一本好书，就是在和高尚的人谈话。 同理可得：读源码，也算是和作者的一种学习交流的方式。\n\n阅读本文，你将学到：\n\n\n\n环境准备之前，我们先预览下vuejs的发布流程。\n\n\n\n\n2. 环境准备#\n\n打开 vue-next， 开源项目一般都能在 README.md 或者 .github/contributing.md 找到贡献指南。\n\n而贡献指南写了很多关于参与项目开发的信息。比如怎么跑起来，项目目录结构是怎样的。怎么投入开发，需要哪些知识储备等。\n\n你需要确保 Node.js 版本是 10+, 而且 yarn 的版本是 1.x Yarn 1.x。\n\n你安装的 Node.js 版本很可能是低于 10。最简单的办法就是去官网重新安装。也可以使用 nvm等管理Node.js版本。\n\n\n\n\n2.1 严格校验使用 yarn 安装依赖#\n\n接着我们来看下 vue-next/package.json 文件。\n\n\n\n如果你尝试使用 npm 安装依赖，应该是会报错的。为啥会报错呢。 因为 package.json 有个前置 preinstall node\n./scripts/checkYarn.js 判断强制要求是使用yarn安装。\n\nscripts/checkYarn.js文件如下，也就是在process.env环境变量中找执行路径npm_execpath，如果不是yarn就输出警告，且进程\n结束。\n\n\n\n如果你想忽略这个前置的钩子判断，可以使用yarn --ignore-scripts 命令。也有后置的钩子post。更多详细的可以查看 npm 文档\n\n\n2.2 调试 vue-next/scripts/release.js 文件#\n\n接着我们来学习如何调试 vue-next/scripts/release.js文件。\n\n这里声明下我的 VSCode 版本 是 1.59.0 应该 1.50.0 起就可以按以下步骤调试了。\n\n\n\n找到 vue-next/package.json 文件打开，然后在 scripts 上方，会有debug（调试）按钮，点击后，选择\nrelease。即可进入调试模式。\n\n\n\n这时终端会如下图所示，有 Debugger attached. 输出。这时放张图。\n\n\n\n更多 nodejs 调试相关 可以查看官方文档\n\n学会调试后，先大致走一遍流程，在关键地方多打上几个断点多走几遍，就能猜测到源码意图了。\n\n\n3 文件开头的一些依赖引入和函数声明#\n\n我们可以跟着断点来，先看文件开头的一些依赖引入和函数声明\n\n\n3.1 第一部分#\n\n\n\n通过依赖，我们可以在 node_modules 找到对应安装的依赖。也可以找到其README和github仓库。\n\n3.1.1 minimist 命令行参数解析#\n\nminimist\n\n简单说，这个库，就是解析命令行参数的。看例子，我们比较容易看懂传参和解析结果。\n\n\n\n\n\n其中process.argv的第一和第二个元素是Node可执行文件和被执行JavaScript文件的完全限定的文件系统路径，无论你是否这样输入他们。\n\n3.1.2 chalk 终端多色彩输出#\n\nchalk\n\n简单说，这个是用于终端显示多色彩输出。\n\n3.1.3 semver 语义化版本#\n\nsemver\n\n语义化版本的nodejs实现，用于版本校验比较等。关于语义化版本可以看这个语义化版本 2.0.0 文档\n\n> 版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改， 次版本号：当你做了向下兼容的功能性新增，\n> 修订号：当你做了向下兼容的问题修正。 先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n\n3.1.4 enquirer 交互式询问 CLI#\n\n简单说就是交互式询问用户输入。\n\nenquirer\n\n3.1.5 execa 执行命令#\n\n简单说就是执行命令的，类似我们自己在终端输入命令，比如 echo 若川。\n\nexeca\n\n\n\n看完了第一部分，接着我们来看第二部分。\n\n\n3.2 第二部分#\n\n\n\n第二部分相对简单，继续看第三部分。\n\n\n3.3 第三部分#\n\n\n\n这一块可能不是很好理解。inc是生成一个版本。更多可以查看semver文档\n\n\n\n\n3.4 第四部分#\n\n第四部分声明了一些执行脚本函数等\n\n\n\n3.4.1 bin 函数#\n\n获取 node_modules/.bin/ 目录下的命令，整个文件就用了一次。\n\n\n\n相当于在命令终端，项目根目录 运行 ./node_modules/.bin/jest 命令。\n\n3.4.2 run、dryRun、runIfNotDry#\n\n\n\nrun 真实在终端跑命令，比如 yarn build --release\n\ndryRun 则是不跑，只是 console.log(); 打印 'yarn build --release'\n\nrunIfNotDry 如果不是空跑就执行命令。isDryRun 参数是通过控制台输入的。yarn run release\n--dry这样就是true。runIfNotDry就是只是打印，不执行命令。这样设计的好处在于，可以有时不想直接提交，要先看看执行命令的结果。不得不说，尤大就是\n会玩。\n\n在 main 函数末尾，也可以看到类似的提示。可以用git diff先看看文件修改。\n\n\n\n看完了文件开头的一些依赖引入和函数声明等，我们接着来看main主入口函数。\n\n\n4 main 主流程#\n\n第4节，主要都是main 函数拆解分析。\n\n\n4.1 流程梳理 main 函数#\n\n\n\n上面的main函数省略了很多具体函数实现。接下来我们拆解 main 函数。\n\n\n4.2 确认要发布的版本#\n\n第一段代码虽然比较长，但是还好理解。 主要就是确认要发布的版本。\n\n调试时，我们看下这段的两张截图，就好理解啦。\n\n\n\n\n\n\n\n\n4.3 执行测试用例#\n\n\n\n\n4.4 更新所有包的版本号和内部 vue 相关依赖版本号#\n\n这一部分，就是更新根目录下package.json 的版本号和所有 packages 的版本号。\n\n\n\n\n\n4.4.1 updatePackage 更新包的版本号#\n\n\n\n主要就是三种修改。\n\n\n\n一图胜千言。我们执行yarn release --dry 后 git diff 查看的 git 修改，部分截图如下。\n\n\n\n4.4.2 updateDeps 更新内部 vue 相关依赖的版本号#\n\n\n\n一图胜千言。我们在终端执行yarn release --dry。会看到这样是输出。\n\n\n\n也就是这句代码输出的。\n\n\n\n\n4.5 打包编译所有包#\n\n\n\n\n4.6 生成 changelog#\n\n\n\nyarn changelog 对应的脚本是conventional-changelog -p angular -i CHANGELOG.md -s。\n\n\n4.7 提交代码#\n\n经过更新版本号后，有文件改动，于是git diff。 是否有文件改动，如果有提交。\n\ngit add -A git commit -m 'release: v${targetVersion}'\n\n\n\n\n4.8 发布包#\n\n\n\n这段函数比较长，可以不用细看，简单说就是 yarn publish 发布包。 我们 yarn release --dry后，这块函数在终端输出的如下：\n\n\n\n值得一提的是，如果是 vue 默认有个 tag 为 next。当 Vue 3.x 是默认时删除。\n\n\n\n也就是为什么我们现在安装 vue3 还是 npm i vue@next命令。\n\n\n\n\n4.9 推送到 github#\n\n\n\n\n\n我们 yarn release --dry后，这块函数在终端输出的如下：\n\n\n\n到这里我们就拆解分析完 main 函数了。\n\n整个流程很清晰。\n\n\n\n用一张图总结则是：\n\n\n\n看完vue-next/scripts/release.js，感兴趣还可以看vue-next/scripts文件夹下其他代码，相对行数不多，但收益较大。\n\n\n5. 总结#\n\n通过本文学习，我们学会了这些。\n\n\n\n同时建议自己动手用 VSCode 多调试，在终端多执行几次，多理解消化。\n\nvuejs发布的文件很多代码我们可以直接复制粘贴修改，优化我们自己发布的流程。比如写小程序，相对可能发布频繁，完全可以使用这套代码，配合miniprogram-\nci，再加上一些自定义，加以优化。\n\n关于小程序 ci 上传，再分享两篇文章。\n\n基于 CI 实现微信小程序的持续构建\n\n小打卡小程序自动化构建及发布的工程化实践 虽然文章里不是最新的 miniprogram-ci，但这篇场景写得比较全面。\n\n当然版本发布也可以用开源的 release-it。\n\n同时，我们可以：\n\n引入 git flow，管理git分支。估计很多人不知道windows git bash已经默认支持 git flow命令。\n\n引入 husky 和 lint-staged 提交commit时用ESLint等校验代码提交是否能够通过检测。\n\n引入 单元测试 jest，测试关键的工具函数等。\n\n引入 conventional-changelog\n\n引入 git-cz 交互式git commit。\n\n等等规范自己项目的流程。如果一个候选人，通过看vuejs发布的源码，积极主动优化自己项目。我觉得面试官会认为这个候选人比较加分。\n\n看开源项目源码的好处在于：一方面可以拓展视野，另外一方面可以为自己所用，收益相对较高。\n\n最后欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。","routePath":"/vue-next-release/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 环境准备","id":"2-环境准备","depth":2,"charIndex":544},{"text":"2.1 严格校验使用 yarn 安装依赖","id":"21-严格校验使用-yarn-安装依赖","depth":3,"charIndex":801},{"text":"2.2 调试  vue-next/scripts/release.js 文件","id":"22-调试--vue-nextscriptsreleasejs-文件","depth":3,"charIndex":-1},{"text":"3 文件开头的一些依赖引入和函数声明","id":"3-文件开头的一些依赖引入和函数声明","depth":2,"charIndex":1477},{"text":"3.1 第一部分","id":"31-第一部分","depth":3,"charIndex":1529},{"text":"3.1.1 minimist  命令行参数解析","id":"311-minimist--命令行参数解析","depth":4,"charIndex":-1},{"text":"3.1.2 chalk 终端多色彩输出","id":"312-chalk-终端多色彩输出","depth":4,"charIndex":1756},{"text":"3.1.3 semver  语义化版本","id":"313-semver--语义化版本","depth":4,"charIndex":-1},{"text":"3.1.4 enquirer 交互式询问 CLI","id":"314-enquirer-交互式询问-cli","depth":4,"charIndex":2026},{"text":"3.1.5 execa 执行命令","id":"315-execa-执行命令","depth":4,"charIndex":2080},{"text":"3.2 第二部分","id":"32-第二部分","depth":3,"charIndex":2168},{"text":"3.3 第三部分","id":"33-第三部分","depth":3,"charIndex":2201},{"text":"3.4 第四部分","id":"34-第四部分","depth":3,"charIndex":2256},{"text":"3.4.1 bin 函数","id":"341-bin-函数","depth":4,"charIndex":2287},{"text":"3.4.2 run、dryRun、runIfNotDry","id":"342-rundryrunrunifnotdry","depth":4,"charIndex":2393},{"text":"4 main 主流程","id":"4-main-主流程","depth":2,"charIndex":2755},{"text":"4.1 流程梳理 main 函数","id":"41-流程梳理-main-函数","depth":3,"charIndex":2791},{"text":"4.2 确认要发布的版本","id":"42-确认要发布的版本","depth":3,"charIndex":2852},{"text":"4.3 执行测试用例","id":"43-执行测试用例","depth":3,"charIndex":2932},{"text":"4.4 更新所有包的版本号和内部 vue 相关依赖版本号","id":"44-更新所有包的版本号和内部-vue-相关依赖版本号","depth":3,"charIndex":2948},{"text":"4.4.1 updatePackage 更新包的版本号","id":"441-updatepackage-更新包的版本号","depth":4,"charIndex":3033},{"text":"4.4.2 updateDeps 更新内部 vue 相关依赖的版本号","id":"442-updatedeps-更新内部-vue-相关依赖的版本号","depth":4,"charIndex":3140},{"text":"4.5 打包编译所有包","id":"45-打包编译所有包","depth":3,"charIndex":3240},{"text":"4.6 生成 changelog","id":"46-生成-changelog","depth":3,"charIndex":3257},{"text":"4.7 提交代码","id":"47-提交代码","depth":3,"charIndex":3355},{"text":"4.8 发布包","id":"48-发布包","depth":3,"charIndex":3467},{"text":"4.9 推送到 github","id":"49-推送到-github","depth":3,"charIndex":3653},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":3840}],"domain":"","frontmatter":{"highlight":"darcula","theme":"smartblue"},"version":""},{"id":138,"title":"Vue3 中 那些使用的工具函数","content":"#\n\n\nbabelParserDefaultPlugins#\n\n\n\n\nEMPTY_OBJ 空对象#\n\n\n\n\nEMPTY_ARR 空数组#\n\n\n\n\nNOOP 空函数#\n\n\n\n\nNO 永远返回 false 的函数#\n\n\n\n\nisOn 判断字符串是不是 on 开头#\n\n\n\n\nisModelListener#\n\n\n\n\nextend 继承#\n\n\n\n\nremove 移除数组的一项#\n\n\n\n\nhasOwn 是不是自己本身所拥有的属性#\n\n\n\n\nisArray 判断数组#\n\n\n\n\nisMap 判断是不是 Map 对象#\n\n\n\n\nisSet 判断是不是 Set 对象#\n\n\n\n\nisDate 判断是不是 Date 对象#\n\n\n\n\nisFunction 判断是不是函数#\n\n\n\n\nisString 判断是不是字符串#\n\n\n\n\nisSymbol 判断是不是 Symbol#\n\n\n\n\nisObject 判断是不是对象#\n\n\n\n\nisPromise 判断是不是 Promise#\n\n\n\n\nobjectToString 对象转字符串#\n\n\n\n\ntoTypeString 对象转字符串#\n\n\n\n\ntoRawType 对象转字符串 截取后几位#\n\n\n\n\nisPlainObject 判断是不是纯粹的对象#\n\n\n\n\nisIntegerKey 判断是不是#\n\n\n\n\nisReservedProp#\n\n\n\n\ncacheStringFunction 缓存#\n\n\n\n\nhasChanged 判断是不是有变化#\n\n\n\n\ninvokeArrayFns 执行数组里的函数#\n\n\n\n\ndef 定义#\n\n\n\n\ntoNumber 转数字#\n\n\n\n\ngetGlobalThis 全局对象#\n\n","routePath":"/vue-next-utils/README.ts","lang":"zh","toc":[{"text":"babelParserDefaultPlugins","id":"babelparserdefaultplugins","depth":3,"charIndex":3},{"text":"EMPTY_OBJ 空对象","id":"empty_obj-空对象","depth":3,"charIndex":34},{"text":"EMPTY_ARR  空数组","id":"empty_arr--空数组","depth":3,"charIndex":-1},{"text":"NOOP 空函数","id":"noop-空函数","depth":3,"charIndex":72},{"text":"NO 永远返回 false 的函数","id":"no-永远返回-false-的函数","depth":3,"charIndex":86},{"text":"isOn 判断字符串是不是 on 开头","id":"ison-判断字符串是不是-on-开头","depth":3,"charIndex":109},{"text":"isModelListener","id":"ismodellistener","depth":3,"charIndex":134},{"text":"extend 继承","id":"extend-继承","depth":3,"charIndex":155},{"text":"remove 移除数组的一项","id":"remove-移除数组的一项","depth":3,"charIndex":170},{"text":"hasOwn 是不是自己本身所拥有的属性","id":"hasown-是不是自己本身所拥有的属性","depth":3,"charIndex":190},{"text":"isArray 判断数组","id":"isarray-判断数组","depth":3,"charIndex":216},{"text":"isMap 判断是不是 Map 对象","id":"ismap-判断是不是-map-对象","depth":3,"charIndex":234},{"text":"isSet 判断是不是 Set 对象","id":"isset-判断是不是-set-对象","depth":3,"charIndex":258},{"text":"isDate 判断是不是 Date 对象","id":"isdate-判断是不是-date-对象","depth":3,"charIndex":282},{"text":"isFunction 判断是不是函数","id":"isfunction-判断是不是函数","depth":3,"charIndex":308},{"text":"isString 判断是不是字符串","id":"isstring-判断是不是字符串","depth":3,"charIndex":332},{"text":"isSymbol 判断是不是 Symbol","id":"issymbol-判断是不是-symbol","depth":3,"charIndex":355},{"text":"isObject 判断是不是对象","id":"isobject-判断是不是对象","depth":3,"charIndex":382},{"text":"isPromise 判断是不是 Promise","id":"ispromise-判断是不是-promise","depth":3,"charIndex":404},{"text":"objectToString 对象转字符串","id":"objecttostring-对象转字符串","depth":3,"charIndex":433},{"text":"toTypeString  对象转字符串","id":"totypestring--对象转字符串","depth":3,"charIndex":-1},{"text":"toRawType  对象转字符串 截取后几位","id":"torawtype--对象转字符串-截取后几位","depth":3,"charIndex":-1},{"text":"isPlainObject 判断是不是纯粹的对象","id":"isplainobject-判断是不是纯粹的对象","depth":3,"charIndex":513},{"text":"isIntegerKey 判断是不是","id":"isintegerkey-判断是不是","depth":3,"charIndex":543},{"text":"isReservedProp","id":"isreservedprop","depth":3,"charIndex":567},{"text":"cacheStringFunction 缓存","id":"cachestringfunction-缓存","depth":3,"charIndex":587},{"text":"hasChanged 判断是不是有变化","id":"haschanged-判断是不是有变化","depth":3,"charIndex":615},{"text":"invokeArrayFns  执行数组里的函数","id":"invokearrayfns--执行数组里的函数","depth":3,"charIndex":-1},{"text":"def 定义","id":"def-定义","depth":3,"charIndex":669},{"text":"toNumber 转数字","id":"tonumber-转数字","depth":3,"charIndex":681},{"text":"getGlobalThis 全局对象","id":"getglobalthis-全局对象","depth":3,"charIndex":699}],"domain":"","frontmatter":{"theme":"smartblue","highlight":"dracula"},"version":""},{"id":139,"title":"初学者也能看懂的 Vue3 源码中那些实用的基础工具函数","content":"#\n\n\n1. 前言#\n\n大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动《1个月，200+人，一起读了4周源码》，感兴趣的可以加我微信 ruochuan12\n加微信群参与，长期交流学习。\n\n之前写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4十篇源码文章。\n\n写相对很难的源码，耗费了自己的时间和精力，也没收获多少阅读点赞，其实是一件挺受打击的事情。从阅读量和读者受益方面来看，不能促进作者持续输出文章。\n\n所以转变思路，写一些相对通俗易懂的文章。其实源码也不是想象的那么难，至少有很多看得懂。比如工具函数。本文通过学习Vue3源码中的工具函数模块的源码，学习源码为自\n己所用。歌德曾说：读一本好书，就是在和高尚的人谈话。 同理可得：读源码，也算是和作者的一种学习交流的方式。\n\n阅读本文，你将学到：\n\n\n\nshared模块中57个工具函数，本次阅读其中的30余个。\n\n\n2. 环境准备#\n\n\n2.1 读开源项目 贡献指南#\n\n打开 vue-next， 开源项目一般都能在 README.md 或者 .github/contributing.md 找到贡献指南。\n\n而贡献指南写了很多关于参与项目开发的信息。比如怎么跑起来，项目目录结构是怎样的。怎么投入开发，需要哪些知识储备等。\n\n我们可以在 项目目录结构 描述中，找到shared模块。\n\nshared: Internal utilities shared across multiple packages (especially\nenvironment-agnostic utils used by both runtime and compiler packages).\n\nREADME.md 和 contributing.md\n一般都是英文的。可能会难倒一部分人。其实看不懂，完全可以可以借助划词翻译，整页翻译和百度翻译等翻译工具。再把英文加入后续学习计划。\n\n本文就是讲shared模块，对应的文件路径是：vue-next/packages/shared/src/index.ts\n\n也可以用github1s访问，速度更快。github1s packages/shared/src/index.ts\n\n\n2.2 按照项目指南 打包构建代码#\n\n为了降低文章难度，我按照贡献指南中方法打包把ts转成了js。如果你需要打包，也可以参考下文打包构建。\n\n你需要确保 Node.js 版本是 10+, 而且 yarn 的版本是 1.x Yarn 1.x。\n\n你安装的 Node.js 版本很可能是低于 10。最简单的办法就是去官网重新安装。也可以使用 nvm等管理Node.js版本。\n\n\n\n可以得到\nvue-next/packages/shared/dist/shared.esm-bundler.js，文件也就是纯js文件。接下来就是解释其中的一些方法。\n\n> 当然，前面可能比较啰嗦。我可以直接讲 3. 工具函数。但通过我上文的介绍，即使是初学者，都能看懂一些开源项目源码，也许就会有一定的成就感。\n> 另外，面试问到被类似的问题或者笔试题时，你说看Vue3源码学到的，面试官绝对对你刮目相看。\n\n\n2.3 如何生成 sourcemap 调试 vue-next 源码#\n\n熟悉我的读者知道，我是经常强调生成sourcemap调试看源码，所以顺便提一下如何配置生成sourcemap，如何调试。这部分可以简单略过，动手操作时再仔细看。\n\n其实贡献指南里描述了。\n\n> Build with Source Maps Use the --sourcemap or -s flag to build with source\n> maps. Note this will make the build much slower.\n\n所以在 vue-next/package.json 追加 \"dev:sourcemap\": \"node scripts/dev.js\n--sourcemap\"，yarn dev:sourcemap执行，即可生成sourcemap，或者直接 build。\n\n\n\n会在控制台输出类似vue-next/packages/vue/src/index.ts →\npackages/vue/dist/vue.global.js的信息。\n\n其中packages/vue/dist/vue.global.js.map 就是sourcemap文件了。\n\n我们在 Vue3官网找个例子，在\nvue-next/examples/index.html。其内容引入packages/vue/dist/vue.global.js。\n\n\n\n然后我们新建一个终端窗口，yarn\nserve，在浏览器中打开http://localhost:5000/examples/，如下图所示，按F11等进入函数，就可以愉快的调试源码了。\n\n\n\n\n3. 工具函数#\n\n本文主要按照源码 vue-next/packages/shared/src/index.ts 的顺序来写。也省去了一些从外部导入的方法。\n\n我们也可以通过ts文件，查看使用函数的位置。同时在VSCode运行调试JS代码，我们比较推荐韩老师写的code runner插件。\n\n\n3.1 babelParserDefaultPlugins babel 解析默认插件#\n\n\n\n这里就是几个默认插件。感兴趣看英文注释查看。\n\n\n3.2 EMPTY_OBJ 空对象#\n\n\n\nprocess.env.NODE_ENV 是 node 项目中的一个环境变量，一般定义为：development\n和production。根据环境写代码。比如开发环境，有报错等信息，生产环境则不需要这些报错警告。\n\n\n3.3 EMPTY_ARR 空数组#\n\n\n\n\n3.4 NOOP 空函数#\n\n\n\n\n3.5 NO 永远返回 false 的函数#\n\n\n\n\n3.6 isOn 判断字符串是不是 on 开头，并且 on 后首字母不是小写字母#\n\n\n\nonRE 是正则。^符号在开头，则表示是什么开头。而在其他地方是指非。\n\n与之相反的是：$符合在结尾，则表示是以什么结尾。\n\n[^a-z]是指不是a到z的小写字母。\n\n同时推荐一个正则在线工具。\n\nregex101\n\n另外正则看老姚的迷你书就够用了。\n\n老姚：《JavaScript 正则表达式迷你书》问世了！\n\n\n3.7 isModelListener 监听器#\n\n判断字符串是不是以onUpdate:开头\n\n\n\nES6入门教程：字符串的新增方法\n\n很多方法都在《ES6入门教程》中有讲到，就不赘述了。\n\n\n3.8 extend 继承 合并#\n\n说合并可能更准确些。\n\n\n\n\n3.9 remove 移除数组的一项#\n\n\n\nsplice 其实是一个很耗性能的方法。删除数组中的一项，其他元素都要移动位置。\n\n引申：axios InterceptorManager 拦截器源码 中，拦截器用数组存储的。但实际移除拦截器时，只是把拦截器置为 null\n。而不是用splice移除。最后执行时为 null 的不执行，同样效果。axios 拦截器这个场景下，不得不说为性能做到了很好的考虑。\n\n看如下 axios 拦截器代码示例：\n\n\n\n\n3.10 hasOwn 是不是自己本身所拥有的属性#\n\n\n\n对象API可以看我之前写的一篇文章JavaScript 对象所有API解析，写的还算全面。\n\n\n3.11 isArray 判断数组#\n\n\n\n\n3.12 isMap 判断是不是 Map 对象#\n\n\n\n> ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object\n> 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比\n> Object 更合适。\n\n\n3.13 isSet 判断是不是 Set 对象#\n\n\n\n> ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\nSet本身是一个构造函数，用来生成 Set 数据结构。\n\n\n3.14 isDate 判断是不是 Date 对象#\n\n\n\n\n3.15 isFunction 判断是不是函数#\n\n\n\n\n3.16 isString 判断是不是字符串#\n\n\n\n\n3.17 isSymbol 判断是不是 Symbol#\n\n\n\n> ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。\n\n\n3.18 isObject 判断是不是对象#\n\n\n\n\n3.19 isPromise 判断是不是 Promise#\n\n\n\n可以根据文末推荐的书籍看Promise相关章节掌握。同时也推荐这本迷你书JavaScript Promise迷你书（中文版）\n\n\n3.20 objectToString 对象转字符串#\n\n\n\n\n3.21 toTypeString 对象转字符串#\n\n\n\n\n3.22 toRawType 对象转字符串 截取后几位#\n\n\n\n可以 截取到 String Array 等这些类型\n\n是 JS 判断数据类型非常重要的知识点。\n\nJS 判断类型也有 typeof ，但不是很准确，而且能够识别出的不多。\n\n这些算是基础知识\n\nmdn typeof 文档，文档比较详细，也实现了一个很完善的type函数，本文就不赘述了。\n\n\n\n\n3.23 isPlainObject 判断是不是纯粹的对象#\n\n\n\n\n3.24 isIntegerKey 判断是不是数字型的字符串key值#\n\n\n\n\n3.25 makeMap && isReservedProp#\n\n传入一个以逗号分隔的字符串，生成一个 map(键值对)，并且返回一个函数检测 key 值在不在这个 map 中。第二个参数是小写选项。\n\n\n\n\n3.26 cacheStringFunction 缓存#\n\n\n\n这个函数也是和上面 MakeMap 函数类似。只不过接收参数的是函数。 《JavaScript 设计模式与开发实践》书中的第四章 JS单例模式也是类似的实现。\n\n\n\n以下是一些正则，系统学习正则推荐老姚：《JavaScript 正则表达式迷你书》问世了！，看过的都说好。所以本文不会过多描述正则相关知识点。\n\n\n\n\n3.27 hasChanged 判断是不是有变化#\n\nhasChanged 这个方法，值得一提的是：我刚写这篇文章时，还没有用Object.is，后来看 git 记录发现有人 提PR\n修改为Object.is了，尤大合并了。\n\n\n\n以下是原先的源码。\n\n\n\n根据 hasChanged 这个我们继续来看看：Object.is API。\n\nObject.is(value1, value2) (ES6)\n\n该方法用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致。 不同之处只有两个：一是+0不等于-0，二是 NaN 等于自身。\n\n\n\nES5可以通过以下代码部署Object.is。\n\n\n\n根据举例可以说明\n\n\n3.28 invokeArrayFns 执行数组里的函数#\n\n\n\n为什么这样写，我们一般都是一个函数执行就行。\n\n数组中存放函数，函数其实也算是数据。这种写法方便统一执行多个函数。\n\n\n3.29 def 定义对象属性#\n\n\n\nObject.defineProperty 算是一个非常重要的API。还有一个定义多个属性的API：Object.defineProperties(obj,\nprops) (ES5)\n\nObject.defineProperty 涉及到比较重要的知识点。\n在ES3中，除了一些内置属性（如：Math.PI），对象的所有的属性在任何时候都可以被修改、插入、删除。在ES5中，我们可以设置属性是否可以被改变或是被删除——\n在这之前，它是内置属性的特权。ES5中引入了属性描述符的概念，我们可以通过它对所定义的属性有更大的控制权。这些属性描述符（特性）包括：\n\n> value——当试图获取属性时所返回的值。 writable——该属性是否可写。 enumerable——该属性在for in循环中是否会被枚举。\n> configurable——该属性是否可被删除。 set()——该属性的更新操作所调用的函数。 get()——获取属性值时所调用的函数。\n\n另外，数据描述符（其中属性为：enumerable，configurable，value，writable）与存取描述符（其中属性为enumerable，con\nfigurable，set()，get()）之间是有互斥关系的。在定义了set()和get()之后，描述符会认为存取操作已被\n定义了，其中再定义value和writable会引起错误。\n\n以下是ES3风格的属性定义方式：\n\n\n\n以下是等价的ES5通过数据描述符定义属性的方式：\n\n\n\n其中，\n除了value的默认值为undefined以外，其他的默认值都为false。这就意味着，如果想要通过这一方式定义一个可写的属性，必须显示将它们设为true。\n或者，我们也可以通过ES5的存储描述符来定义：\n\n\n\n这样一来，多了许多可以用来描述属性的代码，如果想要防止别人篡改我们的属性，就必须要用到它们。此外，也不要忘了浏览器向后兼容ES3方面所做的考虑。例如，跟添加Ar\nray.prototype属性不一样，我们不能再旧版的浏览器中使用shim这一特性。\n另外，我们还可以（通过定义nonmalleable属性），在具体行为中运用这些描述符：\n\n\n\n其他本文就不过多赘述了。更多对象 API 可以查看这篇文章JavaScript 对象所有API解析。\n\n\n3.30 toNumber 转数字#\n\n\n\n> 其实 isNaN 本意是判断是不是 NaN 值，但是不准确的。 比如：isNaN('a') 为 true。 所以 ES6 有了 Number.isNaN\n> 这个判断方法，为了弥补这一个API。\n\n\n\n\n3.31 getGlobalThis 全局对象#\n\n\n\n获取全局 this 指向。\n\n初次执行肯定是 _globalThis 是 undefined。所以会执行后面的赋值语句。\n\n如果存在 globalThis 就用 globalThis。MDN globalThis\n\n如果存在self，就用self。在 Web Worker 中不能访问到 window 对象，但是我们却能通过 self 访问到 Worker 环境中的全局对象。\n\n如果存在window，就用window。\n\n如果存在global，就用global。Node环境下，使用global。\n\n如果都不存在，使用空对象。可能是微信小程序环境下。\n\n下次执行就直接返回 _globalThis，不需要第二次继续判断了。这种写法值得我们学习。\n\n\n4. 最后推荐一些文章和书籍#\n\n先推荐我认为不错的JavaScript API的几篇文章和几本值得读的书。\n\nJavaScript字符串所有API全解密\n\n【深度长文】JavaScript数组所有API全解密\n\n正则表达式前端使用手册\n\n老姚：《JavaScript 正则表达式迷你书》问世了！\n\n老姚浅谈：怎么学JavaScript？\n\nJavaScript 对象所有API解析 https://ruochuan12.github.io/js-object-api/\n\nMDN JavaScript\n\n《JavaScript高级程序设计》第4版\n\n《JavaScript 权威指南》第7版\n\n《JavaScript面向对象编程2》 面向对象讲的很详细。\n\n阮一峰老师：《ES6 入门教程》\n\n《现代 JavaScript 教程》\n\n《你不知道的JavaScript》上中卷\n\n《JavaScript 设计模式与开发实践》\n\n我也是从小白看不懂书经历过来的。到现在写文章分享。\n\n我看书的方法：多本书同时看，看相同类似的章节，比如函数。看完这本可能没懂，看下一本，几本书看下来基本就懂了，一遍没看懂，再看几遍，可以避免遗忘，巩固相关章节。当\n然，刚开始看书很难受，看不进。这些书大部分在微信读书都有，如果习惯看纸质书，那可以买来看。\n\n这时可以看些视频和动手练习一些简单的项目。\n\n比如：可以自己注册一个github账号，分章节小节，抄写书中的代码，提交到github，练习了才会更有感觉。\n\n再比如 freeCodeCamp 中文在线学习网站 网站。看书是系统学习非常好的方法。后来我就是看源码较多，写文章分享出来给大家。\n\n\n5. 总结#\n\n文中主要通过学习 shared\n模块下的几十个工具函数，比如有：isPromise、makeMap、cacheStringFunction、invokeArrayFns、def、getGlob\nalThis等等。\n\n同时还分享了vue源码的调试技巧，推荐了一些书籍和看书籍的方法。\n\n源码也不是那么可怕。平常我们工作中也是经常能使用到这些工具函数。通过学习一些简单源码，拓展视野的同时，还能落实到自己工作开发中，收益相对比较高。\n\n最后欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。","routePath":"/vue-next-utils/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 环境准备","id":"2-环境准备","depth":2,"charIndex":459},{"text":"2.1 读开源项目 贡献指南","id":"21-读开源项目-贡献指南","depth":3,"charIndex":470},{"text":"2.2 按照项目指南 打包构建代码","id":"22-按照项目指南-打包构建代码","depth":3,"charIndex":1006},{"text":"2.3 如何生成 sourcemap 调试 vue-next 源码","id":"23-如何生成-sourcemap-调试-vue-next-源码","depth":3,"charIndex":1403},{"text":"3. 工具函数","id":"3-工具函数","depth":2,"charIndex":2114},{"text":"3.1 babelParserDefaultPlugins  babel 解析默认插件","id":"31-babelparserdefaultplugins--babel-解析默认插件","depth":3,"charIndex":-1},{"text":"3.2 EMPTY_OBJ 空对象","id":"32-empty_obj-空对象","depth":3,"charIndex":2334},{"text":"3.3 EMPTY_ARR 空数组","id":"33-empty_arr-空数组","depth":3,"charIndex":2465},{"text":"3.4 NOOP 空函数","id":"34-noop-空函数","depth":3,"charIndex":2488},{"text":"3.5 NO 永远返回 false 的函数","id":"35-no-永远返回-false-的函数","depth":3,"charIndex":2506},{"text":"3.6 isOn 判断字符串是不是 on 开头，并且 on 后首字母不是小写字母","id":"36-ison-判断字符串是不是-on-开头并且-on-后首字母不是小写字母","depth":3,"charIndex":2533},{"text":"3.7 isModelListener 监听器","id":"37-ismodellistener-监听器","depth":3,"charIndex":2736},{"text":"3.8 extend 继承 合并","id":"38-extend-继承-合并","depth":3,"charIndex":2833},{"text":"3.9 remove 移除数组的一项","id":"39-remove-移除数组的一项","depth":3,"charIndex":2867},{"text":"3.10 hasOwn 是不是自己本身所拥有的属性","id":"310-hasown-是不是自己本身所拥有的属性","depth":3,"charIndex":3094},{"text":"3.11 isArray 判断数组","id":"311-isarray-判断数组","depth":3,"charIndex":3172},{"text":"3.12 isMap 判断是不是 Map 对象","id":"312-ismap-判断是不是-map-对象","depth":3,"charIndex":3195},{"text":"3.13 isSet 判断是不是 Set 对象","id":"313-isset-判断是不是-set-对象","depth":3,"charIndex":3396},{"text":"3.14 isDate 判断是不是 Date 对象","id":"314-isdate-判断是不是-date-对象","depth":3,"charIndex":3502},{"text":"3.15 isFunction 判断是不是函数","id":"315-isfunction-判断是不是函数","depth":3,"charIndex":3533},{"text":"3.16 isString 判断是不是字符串","id":"316-isstring-判断是不是字符串","depth":3,"charIndex":3562},{"text":"3.17 isSymbol 判断是不是 Symbol","id":"317-issymbol-判断是不是-symbol","depth":3,"charIndex":3590},{"text":"3.18 isObject 判断是不是对象","id":"318-isobject-判断是不是对象","depth":3,"charIndex":3659},{"text":"3.19 isPromise 判断是不是 Promise","id":"319-ispromise-判断是不是-promise","depth":3,"charIndex":3686},{"text":"3.20 objectToString 对象转字符串","id":"320-objecttostring-对象转字符串","depth":3,"charIndex":3784},{"text":"3.21 toTypeString  对象转字符串","id":"321-totypestring--对象转字符串","depth":3,"charIndex":-1},{"text":"3.22 toRawType  对象转字符串 截取后几位","id":"322-torawtype--对象转字符串-截取后几位","depth":3,"charIndex":-1},{"text":"3.23 isPlainObject 判断是不是纯粹的对象","id":"323-isplainobject-判断是不是纯粹的对象","depth":3,"charIndex":4026},{"text":"3.24 isIntegerKey 判断是不是数字型的字符串key值","id":"324-isintegerkey-判断是不是数字型的字符串key值","depth":3,"charIndex":4061},{"text":"3.25 makeMap && isReservedProp","id":"325-makemap--isreservedprop","depth":3,"charIndex":4101},{"text":"3.26 cacheStringFunction 缓存","id":"326-cachestringfunction-缓存","depth":3,"charIndex":4206},{"text":"3.27 hasChanged 判断是不是有变化","id":"327-haschanged-判断是不是有变化","depth":3,"charIndex":4396},{"text":"3.28 invokeArrayFns  执行数组里的函数","id":"328-invokearrayfns--执行数组里的函数","depth":3,"charIndex":-1},{"text":"3.29 def 定义对象属性","id":"329-def-定义对象属性","depth":3,"charIndex":4804},{"text":"3.30 toNumber 转数字","id":"330-tonumber-转数字","depth":3,"charIndex":5807},{"text":"3.31 getGlobalThis 全局对象","id":"331-getglobalthis-全局对象","depth":3,"charIndex":5933},{"text":"4. 最后推荐一些文章和书籍","id":"4-最后推荐一些文章和书籍","depth":2,"charIndex":6287},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":7003}],"domain":"","frontmatter":{"theme":"smartblue","highlight":"dracula"},"version":""},{"id":140,"title":"","content":"","routePath":"/vue-next-utils/regex","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":141,"title":"vue-router","content":"#","routePath":"/vue-router/","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":142,"title":"","content":"","routePath":"/vue-router/vue-router-v3.1.3","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":143,"title":"为什么 Vue2 this 能够直接获取到 data 和 methods","content":"","routePath":"/vue-this/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":-1},{"text":"2. 示例：this 能够直接获取到 data 和 methods","id":"2-示例this-能够直接获取到-data-和-methods","depth":2,"charIndex":-1},{"text":"3. 准备环境调试源码一探究竟","id":"3-准备环境调试源码一探究竟","depth":2,"charIndex":-1},{"text":"3.1 Vue 构造函数","id":"31-vue-构造函数","depth":3,"charIndex":-1},{"text":"3.2 _init 初始化函数","id":"32-_init-初始化函数","depth":3,"charIndex":-1},{"text":"3.3 initState 初始化状态","id":"33-initstate-初始化状态","depth":3,"charIndex":-1},{"text":"3.4 initMethods 初始化方法","id":"34-initmethods-初始化方法","depth":3,"charIndex":-1},{"text":"3.4.1 bind 返回一个函数，修改 this 指向","id":"341-bind-返回一个函数修改-this-指向","depth":4,"charIndex":-1},{"text":"3.5 initData 初始化 data","id":"35-initdata-初始化-data","depth":3,"charIndex":-1},{"text":"3.5.1 getData 获取数据","id":"351-getdata-获取数据","depth":4,"charIndex":-1},{"text":"3.5.2 proxy 代理","id":"352-proxy-代理","depth":4,"charIndex":-1},{"text":"3.5.3 Object.defineProperty 定义对象属性","id":"353-objectdefineproperty-定义对象属性","depth":4,"charIndex":-1},{"text":"3.6 文中出现的一些函数，最后统一解释下","id":"36-文中出现的一些函数最后统一解释下","depth":3,"charIndex":-1},{"text":"3.6.1 hasOwn 是否是对象本身拥有的属性","id":"361-hasown-是否是对象本身拥有的属性","depth":4,"charIndex":-1},{"text":"3.6.2 isReserved 是否是内部私有保留的字符串$  和 _ 开头","id":"362-isreserved-是否是内部私有保留的字符串--和-_-开头","depth":4,"charIndex":-1},{"text":"4. 最后用60余行代码实现简化版","id":"4-最后用60余行代码实现简化版","depth":2,"charIndex":-1},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":144,"title":"初学者也能看懂的 Vue2 源码中那些实用的基础工具函数","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。欢迎关注我的公众号若川视野，最近组织了源码共读活动，感兴趣的可以加我微信 ruochuan12\n> 参与，从8月份开始，如今已进行近三个月，大家一起交流学习，共同进步，很多人都表示收获颇丰。\n\n想学源码，极力推荐之前我写的《学习源码整体架构系列》\n包含jQuery、underscore、lodash、vuex、sentry、axios、redux、koa、vue-devtools、vuex4、koa-co\nmpose、vue 3.2 发布、vue-this、create-vue、玩具vite等10余篇源码文章。\n\n本文仓库 vue-analysis，求个star^_^\n\n最近组织了源码共读活动，大家一起学习源码。于是搜寻各种值得我们学习，且代码行数不多的源码。\n\n之前写了 Vue3 相关的两篇文章。\n\n * 初学者也能看懂的 Vue3 源码中那些实用的基础工具函数\n\n这篇写了如何学习 JavaScript 基础知识，推荐了很多书籍和学习资料，还有我的一些经验分享。\n\n * Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？\n\n参加源码共读的读者反馈，TA 其实还是用着 Vue2。能不能写篇 Vue2\n基础工具函数。作为一名知识博主卑微号主，本着学我所学，为我所用，帮助他人的宗旨，于是写上了这篇文章。算是 Vue3\n工具函数的姐妹篇，本文和这篇文章会有类似的地方。\n\n阅读本文，你将学到：\n\n\n\n\n2. 环境准备#\n\n\n2.1 读开源项目 贡献指南#\n\n打开 vue 仓库， 开源项目一般都能在 README.md 或者 .github/contributing.md 找到贡献指南。\n\n而贡献指南写了很多关于参与项目开发的信息。比如怎么跑起来，项目目录结构是怎样的。怎么投入开发，需要哪些知识储备等。\n\n我们可以在 项目目录结构 描述中，找到shared模块。\n\nshared: contains utilities shared across the entire codebase.\n\nREADME.md 和 contributing.md\n一般都是英文的。可能会难倒一部分人。其实看不懂，完全可以可以借助划词翻译，整页翻译和谷歌翻译等翻译工具。再把英文加入后续学习计划。\n\n本文就是讲 shared 模块，对应的文件路径是：vue/vue/src/shared。\n\n也可以用github1s访问，速度更快。github1s vue/vue/src/shared\n\n\n2.2 为了降低文章难度，直接学习打包后的源码#\n\n源代码的代码vue/vue/src/shared，使用了Flow 类型，可能不太好理解。\n\n为了降低文章难度，我们直接学习源码仓库中的打包后的 dist/vue.js 14行到379行。\n\n> 当然，前面可能比较啰嗦。我可以直接讲 3. 工具函数。但通过我上文的介绍，即使是初学者，都能看懂一些开源项目源码，也许就会有一定的成就感。\n> 另外，面试问到被类似的问题或者笔试题时，你说看Vue2源码学到的，面试官绝对对你刮目相看。\n\n\n3. 工具函数#\n\n打包后的 vue.js 14行到379行，接下来就是解释其中的这些方法。\n\n\n3.1 emptyObject#\n\n\n\n冻结对象。第一层无法修改。对象中也有判断是否冻结的方法。\n\n\n\n关于对象 API 推荐看之前我的文章 JavaScript 对象所有API解析\n\n还可以看阮一峰老师的ES6 入门书籍 reflect\n\n\n3.2 isUndef 是否是未定义#\n\n\n\n\n3.3 isDef 是否是已经定义#\n\nJavaScript中假值有六个。\n\n\n\n为了判断准确，Vue2 源码中封装了isDef、 isTrue、isFalse函数来准确判断。\n\n见名知意。\n\n\n\n\n3.4 isTrue 是否是 true#\n\n见名知意。\n\n\n\n\n3.5 isFalse 是否是 false#\n\n见名知意。\n\n\n\n\n3.6 isPrimitive 判断值是否是原始值#\n\n判断是否是字符串、或者数字、或者 symbol、或者布尔值。\n\n\n\n\n3.7 isObject 判断是对象#\n\n因为 typeof null 是 'object'。数组等用这个函数判断也是 true\n\n\n\n\n3.8 toRawType 转换成原始类型#\n\nObject.prototype.toString() 方法返回一个表示该对象的字符串。\n\nmdn\n\necma 规范，说明了这些类型。\n\n\n\nECMAScript5.1 中文版\n\n\n\n\n3.9 isPlainObject 是否是纯对象#\n\n\n\n\n3.10 isRegExp 是否是正则表达式#\n\n\n\n\n3.11 isValidArrayIndex 是否是可用的数组索引值#\n\n数组可用的索引值是 0 ('0')、1 ('1') 、2 ('2') ...\n\n\n\n该全局 isFinite() 函数用来判断被传入的参数值是否为一个有限数值（finite number）。在必要情况下，参数会首先转为一个数值。\n\nisFinite mdn\n\n\n\n\n3.12 isPromise 判断是否是 promise#\n\n\n\n这里用 isDef 判断其实相对 isObject 来判断 来说有点不严谨。但是够用。\n\n\n3.13 toString 转字符串#\n\n转换成字符串。是数组或者对象并且对象的 toString 方法是 Object.prototype.toString，用 JSON.stringify 转换。\n\n\n\n\n3.14 toNumber 转数字#\n\n转换成数字。如果转换失败依旧返回原始字符串。\n\n\n\n\n3.15 makeMap 生成一个 map （对象）#\n\n传入一个以逗号分隔的字符串，生成一个 map(键值对)，并且返回一个函数检测 key 值在不在这个 map 中。第二个参数是小写选项。\n\n\n\n\n3.16 isBuiltInTag 是否是内置的 tag#\n\n\n\n\n3.17 isReservedAttribute 是否是保留的属性#\n\n\n\n\n3.18 remove 移除数组中的中一项#\n\n\n\nsplice 其实是一个很耗性能的方法。删除数组中的一项，其他元素都要移动位置。\n\n引申：axios InterceptorManager 拦截器源码 中，拦截器用数组存储的。但实际移除拦截器时，只是把拦截器置为 null\n。而不是用splice移除。最后执行时为 null 的不执行，同样效果。axios\n拦截器这个场景下，不得不说为性能做到了很好的考虑。因为拦截器是用户自定义的，理论上可以有无数个，所以做性能考虑是必要的。\n\n看如下 axios 拦截器代码示例：\n\n\n\n\n3.19 hasOwn 检测是否是自己的属性#\n\n\n\n\n3.20 cached 缓存#\n\n利用闭包特性，缓存数据\n\n\n\n系统学习正则推荐老姚：《JavaScript 正则表达式迷你书》问世了！，看过的都说好。所以本文不会很详细的描述正则相关知识点。\n\n\n3.21 camelize 连字符转小驼峰#\n\n连字符 - 转驼峰 on-click => onClick\n\n\n\n\n3.22 capitalize 首字母转大写#\n\n首字母转大写\n\n\n\n\n3.23 hyphenate 小驼峰转连字符#\n\nonClick => on-click\n\n\n\n\n3.24 polyfillBind bind 的垫片#\n\n\n\n简单来说就是兼容了老版本浏览器不支持原生的 bind 函数。同时兼容写法，对参数的多少做出了判断，使用call和apply实现，据说参数多适合用\napply，少用 call 性能更好。\n\n如果对于call、apply、bind的用法和实现不熟悉，可以查看我在面试官问系列中写的面试官问：能否模拟实现JS的call和apply方法\n面试官问：能否模拟实现JS的bind方法\n\n\n3.25 toArray 把类数组转成真正的数组#\n\n把类数组转换成数组，支持从哪个位置开始，默认从 0 开始。\n\n\n\n\n3.26 extend 合并#\n\n\n\n\n3.27 toObject 转对象#\n\n\n\n\n3.28 noop 空函数#\n\n\n\n\n3.29 no 一直返回 false#\n\n\n\n\n3.30 identity 返回参数本身#\n\n\n\n\n3.31 genStaticKeys 生成静态属性#\n\n\n\n\n3.32 looseEqual 宽松相等#\n\n由于数组、对象等是引用类型，所以两个内容看起来相等，严格相等都是不相等。\n\n\n\n所以该函数是对数组、日期、对象进行递归比对。如果内容完全相等则宽松相等。\n\n\n\n\n3.33 looseIndexOf 宽松的 indexOf#\n\n该函数实现的是宽松相等。原生的 indexOf 是严格相等。\n\n\n\n\n3.34 once 确保函数只执行一次#\n\n利用闭包特性，存储状态\n\n\n\n\n3.35 生命周期等#\n\n\n\n\n4. 最后推荐一些文章和书籍#\n\n这部分和Vue3工具函数文章一样，值得推荐，所以复制到这里。\n\n先推荐我认为不错的JavaScript API的几篇文章和几本值得读的书。\n\nJavaScript字符串所有API全解密\n\n【深度长文】JavaScript数组所有API全解密\n\n正则表达式前端使用手册\n\n老姚：《JavaScript 正则表达式迷你书》问世了！\n\n老姚浅谈：怎么学JavaScript？\n\nJavaScript 对象所有API解析 https://ruochuan12.github.io/js-object-api/\n\nMDN JavaScript\n\n《JavaScript高级程序设计》第4版\n\n《JavaScript 权威指南》第7版\n\n《JavaScript面向对象编程2》 面向对象讲的很详细。\n\n阮一峰老师：《ES6 入门教程》\n\n《现代 JavaScript 教程》\n\n《你不知道的JavaScript》上中卷\n\n《JavaScript 设计模式与开发实践》\n\n我也是从小白看不懂书经历过来的。到现在写文章分享。\n\n我看书的方法：多本书同时看，看相同类似的章节，比如函数。看完这本可能没懂，看下一本，几本书看下来基本就懂了，一遍没看懂，再看几遍，可以避免遗忘，巩固相关章节。当\n然，刚开始看书很难受，看不进。这些书大部分在微信读书都有，如果习惯看纸质书，那可以买来看。\n\n这时可以看些视频和动手练习一些简单的项目。\n\n比如：可以自己注册一个github账号，分章节小节，抄写书中的代码，提交到github，练习了才会更有感觉。\n\n再比如 freeCodeCamp 中文在线学习网站 网站。看书是系统学习非常好的方法。后来我就是看源码较多，写文章分享出来给大家。\n\n\n5. 总结#\n\n本文通过查看 Vue2 源码中 shared 模块打包后的 dist/vue.js\n14行到379行。源码也不是那么难，至少很多能看懂，比如工具函数。难可能是难在：不知道应用场景。\n\nVue2 工具函数命名很规范，比如：is 判断，to 转换，has 是否有，让开发者一眼就能看出函数语意。\n\n这些函数也非常单一，基本一个函数只做一件事。\n\n建议读者朋友把不熟悉的函数，动手写写，有助于巩固基础知识，查漏补缺。\n\n最后可以持续关注我@若川。欢迎加我微信 ruochuan12 交流，参与 源码共读 活动，大家一起学习源码，共同进步。","routePath":"/vue-utils/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 环境准备","id":"2-环境准备","depth":2,"charIndex":635},{"text":"2.1 读开源项目 贡献指南","id":"21-读开源项目-贡献指南","depth":3,"charIndex":646},{"text":"2.2 为了降低文章难度，直接学习打包后的源码","id":"22-为了降低文章难度直接学习打包后的源码","depth":3,"charIndex":1073},{"text":"3. 工具函数","id":"3-工具函数","depth":2,"charIndex":1316},{"text":"3.1 emptyObject","id":"31-emptyobject","depth":3,"charIndex":1365},{"text":"3.2 isUndef 是否是未定义","id":"32-isundef-是否是未定义","depth":3,"charIndex":1487},{"text":"3.3 isDef 是否是已经定义","id":"33-isdef-是否是已经定义","depth":3,"charIndex":1511},{"text":"3.4 isTrue 是否是 true","id":"34-istrue-是否是-true","depth":3,"charIndex":1611},{"text":"3.5 isFalse 是否是 false","id":"35-isfalse-是否是-false","depth":3,"charIndex":1643},{"text":"3.6 isPrimitive 判断值是否是原始值","id":"36-isprimitive-判断值是否是原始值","depth":3,"charIndex":1677},{"text":"3.7 isObject 判断是对象","id":"37-isobject-判断是对象","depth":3,"charIndex":1740},{"text":"3.8 toRawType 转换成原始类型","id":"38-torawtype-转换成原始类型","depth":3,"charIndex":1809},{"text":"3.9 isPlainObject 是否是纯对象","id":"39-isplainobject-是否是纯对象","depth":3,"charIndex":1926},{"text":"3.10 isRegExp 是否是正则表达式","id":"310-isregexp-是否是正则表达式","depth":3,"charIndex":1956},{"text":"3.11 isValidArrayIndex 是否是可用的数组索引值","id":"311-isvalidarrayindex-是否是可用的数组索引值","depth":3,"charIndex":1984},{"text":"3.12 isPromise 判断是否是 promise","id":"312-ispromise-判断是否是-promise","depth":3,"charIndex":2154},{"text":"3.13 toString 转字符串","id":"313-tostring-转字符串","depth":3,"charIndex":2233},{"text":"3.14 toNumber 转数字","id":"314-tonumber-转数字","depth":3,"charIndex":2338},{"text":"3.15 makeMap 生成一个 map （对象）","id":"315-makemap-生成一个-map-对象","depth":3,"charIndex":2385},{"text":"3.16 isBuiltInTag 是否是内置的 tag","id":"316-isbuiltintag-是否是内置的-tag","depth":3,"charIndex":2486},{"text":"3.17 isReservedAttribute 是否是保留的属性","id":"317-isreservedattribute-是否是保留的属性","depth":3,"charIndex":2520},{"text":"3.18 remove 移除数组中的中一项","id":"318-remove-移除数组中的中一项","depth":3,"charIndex":2559},{"text":"3.19 hasOwn 检测是否是自己的属性","id":"319-hasown-检测是否是自己的属性","depth":3,"charIndex":2824},{"text":"3.20 cached 缓存","id":"320-cached-缓存","depth":3,"charIndex":2852},{"text":"3.21 camelize 连字符转小驼峰","id":"321-camelize-连字符转小驼峰","depth":3,"charIndex":2951},{"text":"3.22 capitalize 首字母转大写","id":"322-capitalize-首字母转大写","depth":3,"charIndex":3009},{"text":"3.23 hyphenate 小驼峰转连字符","id":"323-hyphenate-小驼峰转连字符","depth":3,"charIndex":3045},{"text":"3.24 polyfillBind bind 的垫片","id":"324-polyfillbind-bind-的垫片","depth":3,"charIndex":3094},{"text":"3.25 toArray 把类数组转成真正的数组","id":"325-toarray-把类数组转成真正的数组","depth":3,"charIndex":3313},{"text":"3.26 extend 合并","id":"326-extend-合并","depth":3,"charIndex":3374},{"text":"3.27 toObject 转对象","id":"327-toobject-转对象","depth":3,"charIndex":3394},{"text":"3.28 noop 空函数","id":"328-noop-空函数","depth":3,"charIndex":3417},{"text":"3.29 no 一直返回 false","id":"329-no-一直返回-false","depth":3,"charIndex":3436},{"text":"3.30 identity 返回参数本身","id":"330-identity-返回参数本身","depth":3,"charIndex":3460},{"text":"3.31 genStaticKeys 生成静态属性","id":"331-genstatickeys-生成静态属性","depth":3,"charIndex":3486},{"text":"3.32 looseEqual 宽松相等","id":"332-looseequal-宽松相等","depth":3,"charIndex":3517},{"text":"3.33 looseIndexOf 宽松的 indexOf","id":"333-looseindexof-宽松的-indexof","depth":3,"charIndex":3621},{"text":"3.34 once 确保函数只执行一次","id":"334-once-确保函数只执行一次","depth":3,"charIndex":3688},{"text":"3.35 生命周期等","id":"335-生命周期等","depth":3,"charIndex":3726},{"text":"4. 最后推荐一些文章和书籍","id":"4-最后推荐一些文章和书籍","depth":2,"charIndex":3742},{"text":"5. 总结","id":"5-总结","depth":2,"charIndex":4490}],"domain":"","frontmatter":{"theme":"smartblue","highlight":"dracula"},"version":""},{"id":145,"title":"Vue 源码","content":"#","routePath":"/vue/","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":146,"title":"","content":"","routePath":"/vue/vue-v0.1","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":147,"title":"","content":"","routePath":"/vue/vue-v2.6.10","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":148,"title":"面对 this 指向丢失，尤雨溪在 Vuex 源码中是怎么处理的","content":"#\n\n\n1. 前言#\n\n大家好，我是若川。好久以前我有写过《面试官问系列》，旨在帮助读者提升JS基础知识，包含new、call、apply、this、继承相关知识。其中写了\n面试官问：this 指向 文章。在掘金等平台收获了还算不错的反馈。\n\n最近有小伙伴看我的 Vuex源码\n文章，提到有一处this指向有点看不懂（好不容易终于有人看我的源码文章了，感动的要流泪了^_^）。于是我写篇文章答疑解惑，简单再说说 this 指向和尤大在\nVuex 源码中是怎么处理 this 指向丢失的。\n\n\n2. 对象中的this指向#\n\n\n\n\n3. 类中的this指向#\n\n\n3.1 ES5#\n\n\n\n\n3.2 ES6#\n\n\n\n\n4. 尤大在Vuex源码中是怎么处理的#\n\n先看代码\n\n\n\n\n\n结论：非常巧妙的用了call把dispatch和commit函数的this指向强制绑定到store实例对象上。如果不这么绑定就报错了。\n\n\n4.1 actions 解构 store#\n\n其实Vuex源码里就有上面解构const { dispatch, commit } =\nstore;的写法。想想我们平时是如何写actions的。actions中自定义函数的第一个参数其实就是 store 实例。\n\n这时我们翻看下actions文档：https://vuex.vuejs.org/zh/guide/actions.html\n\n\n\n也可以用解构赋值的写法。\n\n\n\n有了Vuex源码构造函数里的call绑定，这样this指向就被修正啦~不得不说祖师爷就是厉害。这一招，大家可以免费学走~\n\n接着我们带着问题，为啥上文中的context就是store实例，有dispatch、commit这些方法呢。继续往下看。\n\n\n4.2 为什么 actions 对象里的自定义函数 第一个参数就是 store 实例。#\n\n以下是简单源码，有缩减，感兴趣的可以看我的文章 Vuex 源码文章\n\n\n\n接着我们看installModule函数中的遍历注册 actions 实现\n\n\n\n接着看注册 actions 函数实现 registerAction\n\n\n\n比较容易发现调用顺序是 new Store() => installModule(this) => registerAction(store) => let\nres = handler.call(store)。\n\n其中handler 就是\n用户自定义的函数，也就是对应上文的例子increment函数。store实例对象一路往下传递，到handler执行时，也是用了call函数，强制绑定了第一个参数\n是store实例对象。\n\n\n\n这也就是为什么 actions 对象中的自定义函数的第一个参数是 store 对象实例了。\n\n好啦，文章到这里就基本写完啦~相对简短一些。应该也比较好理解。\n\n\n5. 最后再总结下 this 指向#\n\n摘抄下面试官问：this 指向文章结尾。\n\n如果要判断一个运行中函数的 this 绑定， 就需要找到这个函数的直接调用位置。 找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。\n\n 1. new 调用：绑定到新创建的对象，注意：显示return函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。\n 2. call 或者 apply（ 或者 bind）\n    调用：严格模式下，绑定到指定的第一个参数。非严格模式下，null和undefined，指向全局对象（浏览器中是window），其余值指向被new\n    Object()包装的对象。\n 3. 对象上的函数调用：绑定到那个对象。\n 4. 普通函数调用： 在严格模式下绑定到 undefined，否则绑定到全局对象。\n\nES6 中的箭头函数：不会使用上文的四条标准的绑定规则， 而是根据当前的词法作用域来决定this， 具体来说， 箭头函数会继承外层函数，调用的 this 绑定（\n无论 this 绑定到什么），没有外层函数，则是绑定到全局对象（浏览器中是window）。 这其实和 ES6 之前代码中的 self = this 机制一样。\n\n--------------------------------------------------------------------------------","routePath":"/vuex-this/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. 对象中的this指向","id":"2-对象中的this指向","depth":2,"charIndex":245},{"text":"3. 类中的this指向","id":"3-类中的this指向","depth":2,"charIndex":264},{"text":"3.1 ES5","id":"31-es5","depth":3,"charIndex":280},{"text":"3.2 ES6","id":"32-es6","depth":3,"charIndex":293},{"text":"4. 尤大在Vuex源码中是怎么处理的","id":"4-尤大在vuex源码中是怎么处理的","depth":2,"charIndex":306},{"text":"4.1 actions 解构 store","id":"41-actions-解构-store","depth":3,"charIndex":408},{"text":"4.2 为什么 actions 对象里的自定义函数 第一个参数就是 store 实例。","id":"42-为什么-actions-对象里的自定义函数-第一个参数就是-store-实例","depth":3,"charIndex":745},{"text":"5. 最后再总结下 this 指向","id":"5-最后再总结下-this-指向","depth":2,"charIndex":1203}],"domain":"","frontmatter":{},"version":""},{"id":149,"title":"学习 vuex 源码整体架构，打造属于自己的状态管理库","content":"#\n\n\n1. 前言#\n\n> 大家好，我是若川。我倾力持续组织了一年每周大家一起学习200行左右的源码共读活动，感兴趣的可以点此扫码加我微信 ruochuan02\n> 参与。另外，想学源码，极力推荐关注我写的专栏《学习源码整体架构系列》，目前是掘金关注人数（4.1k+人）第一的专栏，写有20余篇源码文章。\n\n> 这是学习源码整体架构第五篇。整体架构这词语好像有点大，姑且就算是源码整体结构吧，主要就是学习是代码整体结构，不深究其他不是主线的具体函数的实现。本篇文章学习\n> 的是实际仓库的代码。\n\n> 本文仓库地址：git clone https://github.com/ruochuan12/vuex-analysis.git\n\n> 要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是太好了。\n\n学习源码整体架构系列文章如下：\n\n> 1.学习 jQuery 源码整体架构，打造属于自己的 js 类库 2.学习 underscore 源码整体架构，打造属于自己的函数式编程类库 3.学习\n> lodash 源码整体架构，打造属于自己的函数式编程类库 4.学习 sentry 源码整体架构，打造属于自己的前端异常监控SDK 5.学习 vuex\n> 源码整体架构，打造属于自己的状态管理库 6.学习 axios 源码整体架构，打造属于自己的请求库 7.学习 koa\n> 源码的整体架构，浅析koa洋葱模型原理和co原理 8.学习 redux 源码整体架构，深入理解 redux 及其中间件原理\n\n感兴趣的读者可以点击阅读。 其他源码计划中的有：express、vue-rotuer、react-redux\n等源码，不知何时能写完（哭泣），欢迎持续关注我（若川）。\n\n源码类文章，一般阅读量不高。已经有能力看懂的，自己就看了。不想看，不敢看的就不会去看源码。 所以我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。\n\n导读 文章比较详细的介绍了vuex、vue源码调试方法和 Vuex 原理。并且详细介绍了 Vuex.use 安装和 new Vuex.Store\n初始化、Vuex.Store 的全部API（如dispatch、commit等）的实现和辅助函数 mapState、mapGetters、\nmapActions、mapMutations createNamespacedHelpers。\n\n\n2. chrome 浏览器调试 vuex 源码方法#\n\nVue文档：在 VS Code 中调试 Vue 项目 从上文中同理可得调试 vuex 方法，这里详细说下，便于帮助到可能不知道如何调试源码的读者。\n可以把笔者的这个 vuex-analysis 源码分析仓库fork一份或者直接克隆下来， git clone\nhttps://github.com/ruochuan12/vuex-analysis.git\n\n> 其中文件夹vuex，是克隆官方的vuex仓库 dev分支。\n> 截至目前（2019年11月），版本是v3.1.2，最后一次commit是ba2ff3a3，2019-11-11 11:51 Ben Hutton。\n> 包含笔者的注释，便于理解。\n\n克隆完成后， 在vuex/examples/webpack.config.js 中添加devtool配置。\n\n\n\n\n\n> 打开 http://localhost:8080/ 点击你想打开的例子，例如：Shopping Cart =>\n> http://localhost:8080/shopping-cart/ 打开控制面板 source 在左侧找到 webapck// . src 目录\n> store 文件 根据自己需求断点调试即可。\n\n本文主要就是通过Shopping Cart，(路径vuex/examples/shopping-cart)例子调试代码的。\n\n\n2.1 顺便提一下调试 vue 源码（v2.6.10）的方法#\n\n\n\n克隆下来后将package.json 文件中的script dev命令后面添加这个 --sourcemap。\n\n\n\n\n\n本小节大篇幅介绍调试方法。是因为真的很重要。会调试代码，看源码就比较简单了。关注主线调试代码，很容易看懂。\n强烈建议克隆笔者的这个仓库，自己调试代码，对着注释看，不调试代码，只看文章不容易吸收消化。\n笔者也看了文章末尾笔者推荐阅读的文章，但还是需要自己看源代码，才知道这些文章哪里写到了，哪里没有细写。\n\n正文开始～\n\n\n3. vuex 原理#\n\n简单说明下 vuex 原理\n\n\n\n每个组件（也就是Vue实例）在beforeCreate的生命周期中都混入（Vue.mixin）同一个Store实例 作为属性 $store， 也就是为啥可以通过\nthis.$store.dispatch 等调用方法的原因。\n\n最后显示在模板里的 $store.state.count 源码是这样的。\n\n\n\n其实就是： vm.$store._vm._data.$$state.count 其中vm.$store._vm._data.$$state 是 响应式的。\n怎么实现响应式的？其实就是new Vue()\n\n\n\n这里的 state 就是 用户定义的 state。 这里的 computed 就是处理后的用户定义的 getters。 而 class\nStore上的一些函数（API）主要都是围绕修改vm.$store._vm._data.$$state和computed(getter)服务的。\n\n\n3. Vue.use 安装#\n\n笔者画了一张图表示下Vuex对象，是Vue的一个插件。\n\n\n\n> 看到这里，恭喜你已经了解了Vuex原理。文章比较长，如果暂时不想关注源码细节，可以克隆一下本仓库代码git clone\n> https://github.com/ruochuan12/vuex-analysis.git，后续调试代码，点赞收藏到时想看了再看。\n\n文档 Vue.use Vue.use(Vuex)\n\n> 参数： {Object | Function} plugin 用法： 安装 Vue.js 插件。如果插件是一个对象，必须提供 install\n> 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。 该方法需要在调用 new Vue()\n> 之前被调用。 当 install 方法被同一个插件多次调用，插件将只会被安装一次。\n\n根据断点调试，来看下Vue.use的源码。\n\n\n\n\n3.1 install 函数#\n\nvuex/src/store.js\n\n\n\n接下来看 applyMixin 函数\n\n\n3.2 applyMixin 函数#\n\nvuex/src/mixin.js\n\n\n\n最终每个Vue的实例对象，都有一个$store属性。且是同一个Store实例。 用购物车的例子来举例就是：\n\n\n\n\n4. Vuex.Store 构造函数#\n\n先看最终 new Vuex.Store 之后的 Store 实例对象关系图：先大致有个印象。\n\n\n\n\n\n如果是 cdn script 方式引入vuex插件，则自动安装vuex插件，不需要用Vue.use(Vuex)来安装。\n\n\n\n\n\n条件断言：不满足直接抛出错误\n\n> 1.必须使用 Vue.use(Vuex) 创建 store 实例。 2.当前环境不支持Promise，报错：vuex 需要 Promise\n> polyfill。 3.Store 函数必须使用 new 操作符调用。\n\n\n\n从用户定义的new Vuex.Store(options) 取出plugins和strict参数。\n\n\n\n声明Store实例对象一些内部变量。用于存放处理后用户自定义的actions、mutations、getters等变量。\n\n> 提一下 Object.create(null) 和 {} 的区别。前者没有原型链，后者有。 即 Object.create(null).__proto__是\n> undefined ({}).__proto__ 是 Object.prototype\n\n\n\n给自己 绑定 commit 和 dispatch\n\n> 为何要这样绑定 ? 说明调用 commit 和 dispach 的 this 不一定是 store 实例 这是确保这两个函数里的 this 是 store\n> 实例\n\n\n\n上述这段代码 installModule(this, state, [], this._modules.root)\n\n> 初始化 根模块。 并且也递归的注册所有子模块。 并且收集所有模块的 getters 放在 this._wrappedGetters 里面。\n\nresetStoreVM(this, state)\n\n> 初始化 store._vm 响应式的 并且注册 _wrappedGetters 作为 computed 的属性\n\n\n\n插件：把实例对象 store 传给插件函数，执行所有插件。\n\n\n\n初始化 vue-devtool 开发工具。 参数 devtools 传递了取 devtools 否则取Vue.config.devtools 配置。\n\n初读这个构造函数的全部源代码。会发现有三个地方需要重点看。分别是：\n\n\n\n阅读时可以断点调试，赋值语句this._modules = new\nModuleCollection(options)，如果暂时不想看，可以直接看返回结果。installModule，resetStoreVM函数则可以断点调试。\n\n\n4.1 class ModuleCollection#\n\n收集模块，构造模块树结构。\n\n> 注册根模块 参数 rawRootModule 也就是 Vuex.Store 的 options 参数 未加工过的模块（用户自定义的），根模块\n\n\n\n\n\n4.1.1 class Module#\n\n\n\n经过一系列的注册后，最后 this._modules = new ModuleCollection(options) this._modules 的值是这样的。\n笔者画了一张图表示：\n\n\n\n\n4.2 installModule 函数#\n\n\n\n4.2.1 注册 state#\n\n\n\n最后得到的是类似这样的结构且是响应式的数据 实例 Store.state 比如：\n\n\n\n\n\n> module.context 这个赋值主要是给 helpers 中\n> mapState、mapGetters、mapMutations、mapActions四个辅助函数使用的。\n> 生成本地的dispatch、commit、getters和state。 主要作用就是抹平差异化，不需要用户再传模块参数。\n\n4.2.2 遍历注册 mutation#\n\n\n\n\n\n4.2.3 遍历注册 action#\n\n\n\n\n\n4.2.4 遍历注册 getter#\n\n\n\n\n\n4.2.5 遍历注册 子模块#\n\n\n\n\n4.3 resetStoreVM 函数#\n\nresetStoreVM(this, state, hot)\n\n> 初始化 store._vm 响应式的 并且注册 _wrappedGetters 作为 computed 的属性\n\n\n\n到此，构造函数源代码看完了，接下来看 Vuex.Store 的 一些 API 实现。\n\n\n5. Vuex.Store 实例方法#\n\nVuex API 文档\n\n\n5.1 commit#\n\n提交 mutation。\n\n\n\ncommit 支持多种方式。比如：\n\n\n\nunifyObjectStyle函数将参数统一，返回 { type, payload, options }。\n\n\n5.2 dispatch#\n\n分发 action。\n\n\n\n\n5.3 replaceState#\n\n替换 store 的根状态，仅用状态合并或时光旅行调试。\n\n\n\n\n5.4 watch#\n\n响应式地侦听 fn 的返回值，当值改变时调用回调函数。\n\n\n\n\n5.5 subscribe#\n\n订阅 store 的 mutation。\n\n\n\n\n\n\n5.6 subscribeAction#\n\n订阅 store 的 action。\n\n\n\n\n5.7 registerModule#\n\n注册一个动态模块。\n\n\n\n\n5.8 unregisterModule#\n\n卸载一个动态模块。\n\n\n\n\n5.9 hotUpdate#\n\n热替换新的 action 和 mutation。\n\n\n\n\n6. 组件绑定的辅助函数#\n\n文件路径：vuex/src/helpers.js\n\n\n6.1 mapState#\n\n为组件创建计算属性以返回 Vuex store 中的状态。\n\n\n\nnormalizeNamespace 标准化统一命名空间\n\n\n\n\n\n\n\nmodule.context 这个赋值主要是给 helpers 中\nmapState、mapGetters、mapMutations、mapActions四个辅助函数使用的。\n\n\n\n这里就是抹平差异，不用用户传递命名空间，获取到对应的 commit、dispatch、state、和 getters\n\ngetModuleByNamespace\n\n\n\n看完这些，最后举个例子： vuex/examples/shopping-cart/components/ShoppingCart.vue\n\n\n\n没有命名空间的情况下，最终会转换成这样\n\n\n\n假设有命名空间'ruochuan'，\n\n\n\n则会转换成：\n\n\n\n\n6.2 mapGetters#\n\n为组件创建计算属性以返回 getter 的返回值。\n\n\n\n举例：\n\n\n\n最终转换成：\n\n\n\n\n6.3 mapActions#\n\n创建组件方法分发 action。\n\n\n\n\n6.4 mapMutations#\n\n创建组件方法提交 mutation。 mapMutations 和 mapActions 类似，只是 dispatch 换成了 commit。\n\n\n\nvuex/src/helpers\n\nmapMutations、mapActions 举例：\n\n\n\n最终转换成\n\n\n\n由此可见：这些辅助函数极大地方便了开发者。\n\n\n6.5 createNamespacedHelpers#\n\n创建基于命名空间的组件绑定辅助函数。\n\n\n\n就是把这些辅助函数放在一个对象中。\n\n\n7. 插件#\n\n插件部分文件路径是： vuex/src/plugins/devtool vuex/src/plugins/logger\n\n文章比较长了，这部分就不再叙述。具体可以看笔者的仓库 vuex-analysis vuex/src/plugins/ 的源码注释。\n\n\n8. 总结#\n\n文章比较详细的介绍了vuex、vue源码调试方法和 Vuex 原理。并且详细介绍了 Vuex.use 安装和 new Vuex.Store\n初始化、Vuex.Store 的全部API（如dispatch、commit等）的实现和辅助函数 mapState、mapGetters、\nmapActions、mapMutations createNamespacedHelpers。\n\n文章注释，在vuex-analysis源码仓库里基本都有注释分析，求个star。再次强烈建议要克隆代码下来。\n\n\n\n先把 Store 实例打印出来，看具体结构，再结合实例断点调试，事半功倍。\n\nVuex 源码相对不多，打包后一千多行，非常值得学习，也比较容易看完。\n\n如果读者发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出。另外觉得写得不错，对您有些许帮助，可以点赞、评论、转发分享，也是对笔者的一种支持，万分感\n谢。\n\n\n9. 推荐阅读#\n\nvuex 官方文档 vuex github 仓库 美团明裔：Vuex框架原理与源码分析这篇文章强烈推荐，流程图画的很好 知乎黄轶：Vuex 2.0\n源码分析这篇文章也强烈推荐，讲述的比较全面 小虫巨蟹：Vuex 源码解析（如何阅读源代码实践篇）这篇文章也强烈推荐，主要讲如何阅读源代码 染陌：Vuex\n源码解析 网易考拉前端团队：Vuex 源码分析 yck：Vuex 源码深度解析 小生方勤：【前端词典】从源码解读 Vuex 注入 Vue 生命周期的过程\n\n\n笔者另一个系列#\n\n面试官问：JS的继承 面试官问：JS的this指向 面试官问：能否模拟实现JS的call和apply方法 面试官问：能否模拟实现JS的bind方法\n面试官问：能否模拟实现JS的new操作符\n\n\n关于#\n\n作者：常以若川为名混迹于江湖。前端路上 | PPT爱好者 | 所知甚少，唯善学。 个人博客-若川，使用vuepress重构了，阅读体验可能更好些\n掘金专栏，欢迎关注~ segmentfault前端视野专栏，欢迎关注~ 知乎前端视野专栏，欢迎关注~ 语雀前端视野专栏，新增语雀专栏，欢迎关注~ github\nblog，相关源码和资源都放在这里，求个star^_^~\n\n\n欢迎加微信交流 微信公众号#\n\n可能比较有趣的微信公众号，长按扫码关注（回复pdf获取前端优质书籍pdf）。也可以加微信 ruochuan12，注明来源，拉您进【前端视野交流群】。\n\n","routePath":"/vuex/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"2. chrome 浏览器调试 vuex 源码方法","id":"2-chrome-浏览器调试-vuex-源码方法","depth":2,"charIndex":1012},{"text":"2.1 顺便提一下调试 vue 源码（v2.6.10）的方法","id":"21-顺便提一下调试-vue-源码v2610的方法","depth":3,"charIndex":1628},{"text":"3. vuex 原理","id":"3-vuex-原理","depth":2,"charIndex":1884},{"text":"3. Vue.use 安装","id":"3-vueuse-安装","depth":2,"charIndex":2314},{"text":"3.1 install 函数","id":"31-install-函数","depth":3,"charIndex":2744},{"text":"3.2 applyMixin 函数","id":"32-applymixin-函数","depth":3,"charIndex":2803},{"text":"4. Vuex.Store 构造函数","id":"4-vuexstore-构造函数","depth":2,"charIndex":2902},{"text":"4.1 class ModuleCollection","id":"41-class-modulecollection","depth":3,"charIndex":4011},{"text":"4.1.1 class Module","id":"411-class-module","depth":4,"charIndex":4133},{"text":"4.2 installModule 函数","id":"42-installmodule-函数","depth":3,"charIndex":4252},{"text":"4.2.1 注册 state","id":"421-注册-state","depth":4,"charIndex":4277},{"text":"4.2.2 遍历注册 mutation","id":"422-遍历注册-mutation","depth":4,"charIndex":4498},{"text":"4.2.3 遍历注册 action","id":"423-遍历注册-action","depth":4,"charIndex":4524},{"text":"4.2.4 遍历注册 getter","id":"424-遍历注册-getter","depth":4,"charIndex":4548},{"text":"4.2.5 遍历注册 子模块","id":"425-遍历注册-子模块","depth":4,"charIndex":4572},{"text":"4.3 resetStoreVM 函数","id":"43-resetstorevm-函数","depth":3,"charIndex":4592},{"text":"5. Vuex.Store 实例方法","id":"5-vuexstore-实例方法","depth":2,"charIndex":4752},{"text":"5.1 commit","id":"51-commit","depth":3,"charIndex":4787},{"text":"5.2 dispatch","id":"52-dispatch","depth":3,"charIndex":4894},{"text":"5.3 replaceState","id":"53-replacestate","depth":3,"charIndex":4924},{"text":"5.4 watch","id":"54-watch","depth":3,"charIndex":4976},{"text":"5.5 subscribe","id":"55-subscribe","depth":3,"charIndex":5020},{"text":"5.6 subscribeAction","id":"56-subscribeaction","depth":3,"charIndex":5063},{"text":"5.7 registerModule","id":"57-registermodule","depth":3,"charIndex":5108},{"text":"5.8 unregisterModule","id":"58-unregistermodule","depth":3,"charIndex":5143},{"text":"5.9 hotUpdate","id":"59-hotupdate","depth":3,"charIndex":5180},{"text":"6. 组件绑定的辅助函数","id":"6-组件绑定的辅助函数","depth":2,"charIndex":5225},{"text":"6.1 mapState","id":"61-mapstate","depth":3,"charIndex":5267},{"text":"6.2 mapGetters","id":"62-mapgetters","depth":3,"charIndex":5654},{"text":"6.3 mapActions","id":"63-mapactions","depth":3,"charIndex":5718},{"text":"6.4 mapMutations","id":"64-mapmutations","depth":3,"charIndex":5756},{"text":"6.5 createNamespacedHelpers","id":"65-createnamespacedhelpers","depth":3,"charIndex":5932},{"text":"7. 插件","id":"7-插件","depth":2,"charIndex":6004},{"text":"8. 总结","id":"8-总结","depth":2,"charIndex":6141},{"text":"9. 推荐阅读","id":"9-推荐阅读","depth":2,"charIndex":6559},{"text":"笔者另一个系列","id":"笔者另一个系列","depth":2,"charIndex":6799},{"text":"关于","id":"关于","depth":2,"charIndex":6906},{"text":"欢迎加微信交流 微信公众号","id":"欢迎加微信交流-微信公众号","depth":2,"charIndex":7095}],"domain":"","frontmatter":{},"version":""},{"id":150,"title":"一文读懂vuex4源码，原来provide/inject就是妙用了原型链？","content":"#\n\n\n1. 前言#\n\n> 你好，我是若川，微信搜索「若川视野」关注我，专注前端技术分享，一个愿景是帮助5年内前端开阔视野走向前列的公众号。欢迎加我微信ruochuan12，长期交流学\n> 习。\n\n> 这是学习源码整体架构系列 之 vuex4\n> 源码（第十篇）。学习源码整体架构系列文章(有哪些必看的JS库)：jQuery、underscore、lodash、sentry、vuex、axios、koa\n> 、redux、vue-devtools 直接打开文件功能揭秘。\n\n> 10篇源码系列文章小成就达成，从19年7月开始写，19年写了6篇，20年写了2篇，今年写了2篇。算是一个完结吧。短时间内应该暂时不更新这个系列了。主要是投入\n> 的时间和精力比较多，看的人很少，得到的反馈也比较少。之后先写其他文章吧。欢迎持续关注我（若川）。\n\n> 本文仓库地址：git clone\n> https://github.com/ruochuan12/vuex4-analysis.git，本文最佳阅读方式，克隆仓库自己动手调试，容易吸收消化。\n\n> 要是有人说到怎么读源码，正在读文章的你能推荐我的源码系列文章，那真是无以为报啊。\n\n我的文章，尽量写得让想看源码又不知道怎么看的读者能看懂。我都是推荐使用搭建环境断点调试源码学习，哪里不会点哪里，边调试边看，而不是硬看。正所谓：授人与鱼不如授人\n予渔。\n\n阅读本文后你将学到：\n\n * 1. git subtree 管理子仓库\n * 2. 如何学习Vuex 4源码、理解Vuex原理\n * 3. Vuex 4 和 Vuex 3 的异同\n * 4. Vuex 4 composition API 如何使用\n * 5. Vue.provide / Vue.inject API 使用和原理\n * 6. 如何写一个 Vue3 插件\n * 等等\n\n如果对于谷歌浏览器调试还不是很熟悉的读者，可以看这篇文章chrome devtools\nsource面板，写的很详细。顺带提一下，我打开的设置，source面板中支持展开搜索代码块（默认不支持），一图胜千言。谷歌浏览器是我们前端常用的工具，所以建议\n大家深入学习，毕竟工欲善其事，必先利其器。\n\n之前写过Vuex 3的源码文章学习 vuex\n源码整体架构，打造属于自己的状态管理库、若川的博客Vuex源码，仓库有很详细的注释和看源码方法，所以本文不会过多赘述与Vuex 3源码相同的地方。\n\n\n1.1 本文阅读最佳方式#\n\n把我的vuex4源码仓库 git clone\nhttps://github.com/ruochuan12/vuex4-analysis.git克隆下来，顺便star一下我的vuex4源码学习仓库^_^。跟着\n文章节奏调试和示例代码调试，用chrome动手调试印象更加深刻。文章长段代码不用细看，可以调试时再细看。看这类源码文章百遍，可能不如自己多调试几遍，大胆猜测，小\n心求证。也欢迎加我微信交流ruochuan12。\n\n\n2. Vuex 原理简述#\n\n结论先行：Vuex原理可以拆解为三个关键点。 第一点、其实就是每个组件实例里都注入了Store实例。\n第二点、Store实例中的各种方法都是为Store中的属性服务的。 第三点、Store中的属性变更触发视图更新。\n\n本文主要讲解第一点。第二点在我的上一篇文章学习 vuex 源码整体架构，打造属于自己的状态管理库详细讲了，本文就不赘述了。第三点两篇文章都没有详细讲述。\n\n以下是一段简短的代码说明Vuex原理的。\n\n\n\n\n\n看了上面的官方文档中的图，大概知道是用provide父级组件中提供Store实例，用inject来获取到Store实例。\n\n那么接下来，带着问题：\n\n1、为什么修改了实例store里的属性，变更后会触发视图更新。\n\n2、Vuex4作为Vue的插件如何实现和Vue结合的。\n\n3、provide、inject的如何实现的，每个组件如何获取到组件实例中的Store的。\n\n4、为什么每个组件对象里都有Store实例对象了(渲染组件对象过程)。\n\n5、为什么在组件中写的provide提供的数据，能被子级组件获取到。\n\n\n3. Vuex 4 重大改变#\n\n在看源码之前，先来看下Vuex 4发布的release和官方文档迁移提到的重大改变，Vuex 4 release。\n\n从 3.x 迁移到 4.0\n\nVuex 4的重点是兼容性。Vuex 4支持使用Vue 3开发，并且直接提供了和Vuex 3完全相同的API，因此用户可以在Vue\n3项目中复用现有的Vuex代码。\n\n相比Vuex 3版本。主要有如下重大改变（其他的在上方链接中）：\n\n\n3.1 安装过程#\n\nVuex 3是Vue.use(Vuex)\n\nVuex 4则是app.use(store)\n\n\n\n\n\n\n3.2 核心模块导出了 createLogger 函数#\n\n\n\n接下来我们从源码的角度来看这些重大改变。\n\n\n4. 从源码角度看 Vuex 4 重大变化#\n\n\n4.1 chrome 调试 Vuex 4 源码准备工作#\n\n\n\n这种方式保留了vuex4仓库的git记录信息。更多git subtree使用方式可以查看这篇文章用 Git Subtree 在多个 Git\n项目间双向同步子项目，附简明使用手册。\n\n作为读者朋友的你，只需克隆我的Vuex 4源码仓库 https://github.com/ruochuan12/vuex4-analysis.git\n即可，也欢迎star一下。\n\n把vuex/examples/webpack.config.js，加个devtool: 'source-map'，这样就能开启sourcemap调试源码了。\n\n我们使用项目中的购物车的例子调试，贯穿全文。\n\n\n\n据说一图胜千言，这时简单截个调试的图。\n\n\n\n找到 createStore函数打上断点。\n\n\n\n找到app.js入口，在app.use(store)、app.mount('#app')等打上断点。\n\n\n\n接下来，我们从createApp({})、app.use(Store)两个方面发散开来讲解。\n\n\n4.2 Vuex.createStore 函数#\n\n相比 Vuex 3 中，new Vuex.Store，其实是一样的。只不过为了和Vue 3 统一，Vuex 4 额外多了一个 createStore 函数。\n\n\n\n监测数据\n\n和Vuex 3不同的是，监听数据不再是用new Vue()，而是Vue 3提供的reactive方法。\n\nVue.reactive 函数方法，本文就不展开讲解了。因为展开来讲，又可以写篇新的文章了。只需要知道主要功能是监测数据改变，变更视图即可。\n\n这也就算解答了开头提出的第一个问题。\n\n跟着断点我们继续看app.use()方法，Vue提供的插件机制。\n\n\n4.3 app.use() 方法#\n\nuse做的事情说起来也算简单，把传递过来的插件添加插件集合中，到防止重复。\n\n执行插件，如果是对象，install是函数，则把参数app和其他参数传递给install函数执行。如果是函数直接执行。\n\n\n\n上面代码中，断点这行plugin.install(app, ...options);\n\n跟着断点走到下一步，install函数。\n\n\n4.4 install 函数#\n\n\n\nVuex4中的install函数相对比Vuex3中简单了许多。 第一句是给Composition API提供的。注入到根实例对象中。 第二句则是为option\nAPI提供的。\n\n接着断点这两句，按F11来看app.provide实现。\n\n4.4.1 app.provide#\n\n简单来说就是给context的provides属性中加了store = Store实例对象。\n\n\n\n接着从上方代码中搜索context，可以发现这一句代码：\n\n\n\n接着我们来看函数 createAppContext。 context 为上下文\n\n\n\nVue3 文档应用配置(app.config)\n\n4.4.2 app.config.globalProperties#\n\napp.config.globalProperties 官方文档\n\n用法：\n\n\n\n也就能解释为什么每个组件都可以使用 this.$store.xxx 访问 vuex中的方法和属性了。\n\n也就是说在appContext.provides中注入了一个Store实例对象。这时也就是相当于根组件实例和config全局配置globalProperties\n中有了Store实例对象。\n\n至此我们就看完，createStore(store)，app.use(store)两个API。\n\napp.provide 其实是用于composition API使用的。\n\n但这只是文档中这样说的，为什么就每个组件实例都能访问的呢，我们继续深入探究下原理。\n\n接下来，我们看下源码具体实现，为什么每个组件实例中都能获取到的。\n\n这之前先来看下组合式API中，我们如何使用Vuex4，这是线索。\n\n\n4.5 composition API 中如何使用Vuex 4#\n\n接着我们找到如下文件，useStore是我们断点的对象。\n\n\n\n接着断点按F11，单步调试，会发现最终是使用了Vue.inject方法。\n\n4.5.1 Vuex.useStore 源码实现#\n\n\n\n4.5.2 Vue.inject 源码实现#\n\n接着看inject函数，看着代码很多，其实原理很简单，就是要找到我们用provide提供的值。\n\n如果没有父级，也就是根实例，就取实例对象中的vnode.appContext.provides。\n否则就取父级中的instance.parent.provides的值。\n\n在Vuex4源码里则是：Store实例对象。\n\n\n\n接着我们继续来看inject的相对应的provide。\n\n4.5.3 Vue.provide 源码实现#\n\nprovide函数作用其实也算简单，1、也就是给当前组件实例上的provides对象属性，添加键值对key/value。\n\n2、还有一个作用是当当前组件和父级组件的provides相同时，在当前组件实例中的provides对象和父级，则建立链接，也就是原型[[prototype]]，\n(__proto__)。\n\n\n\nprovide函数中的这段，可能不是那么好理解。\n\n\n\n我们来举个例子消化一下。\n\n\n\n经过一次执行这个后，currentInstance 就变成了这样。\n\n\n\n执行第二次时，currentInstance 则是：\n\n\n\n以此类推，多执行provide几次，原型链就越长。\n\n上文inject、provide函数中都有个变量currentInstance当前实例，那么当前实例对象是怎么来的呢。\n\n为什么每个组件就能访问到，依赖注入的思想。\n有一个讨巧的方法，就是在文件runtime-core.esm-bundler.js中搜索provides，则能搜索到createComponentInstanc\ne函数\n\n接下来我们createComponentInstance函数如何创建组件实例。\n\n\n4.6 createComponentInstance 创建组件实例#\n\n可以禁用其他断点，单独断点这里， 比如：const appContext = (parent ? parent.appContext :\nvnode.appContext) || emptyAppContext; 来看具体实现。\n\n\n\n断点时会发现，根组件实例时vnode已经生成，至于是什么时候生成的，我整理了下简化版。\n\n\n\n其中 Object.create 其实就是建立原型关系。这时放一张图，一图胜千言。\n\n，出自黄轶老师拉勾专栏，本想自己画一张图，但觉得这张挺好的。\n\n4.6.1 组件实例生成了，那怎么把它们结合呢#\n\n这时，也有一个讨巧的方法，在runtime-core.esm-bundler.js文件中，搜索 provide(可以搜到如下代码：\n\n这段代码其实看起来很复杂的样子，实际上主要就是把用户在组件中写的provides对象或者函数返回值遍历, 生成类似这样的实例对象：\n\n\n\n\n\n这样一来就从上到下app.provide提供的对象，被注入到每一个组件实例中了。同时组件本身提供的provides也被注入到实例中了。\n\n接着我们跟着项目来验证下，上文中的表述。翻看Vue3文档可以发现有一个API可以获取当前组件实例。\n\n\n4.7 getCurrentInstance 获取当前实例对象#\n\ngetCurrentInstance 支持访问内部组件实例，用于高阶用法或库的开发。\n\n\n\n知道这个API后，我们可以在购物车例子的代码中添加一些代码。便于我们理解。\n\n\n\n\n\n\n\n在控制台输出这些值\n\n\n\n\n\n看控制台截图输出的例子，其实跟上文写的类似。这时如果写了顺手自己注入了一个provide('store':\n'空字符串')，那么顺着原型链，肯定是先找到用户写的store，这时Vuex无法正常使用，就报错了。\n\n当然vuex4提供了注入的key可以不是store的写法，这时就不和用户的冲突了。\n\n\n\n\n\n\n5. 解答下开头提出的5个问题#\n\n统一解答下开头提出的5个问题：\n\n1、为什么修改了实例store里的属性，变更后会触发视图更新。\n\n答：使用Vue 中的 reactive 方法监测数据变化的。\n\n\n\n2、Vuex4作为Vue的插件如何实现和Vue结合的。\n\n答：app.use(store) 时会执行Store中的install方法，一句是为 composition API\n中使用，提供Store实例对象到根实例中。一句则是注入到根实例的全局属性中，为 option API 中使用。它们都会在组件生成时，注入到每个组件实例中。\n\n\n\n3、provide、inject的如何实现的，每个组件如何获取到组件实例中的Store的。\n\n5、为什么在组件中写的provide提供的数据，能被子级组件获取到。\n\n答：provide函数建立原型链区分出组件实例用户自己写的属性和系统注入的属性。inject函数则是通过原型链找父级实例中的provides对象中的属性。\n\n\n\n\n\n也就是类似这样的实例：\n\n\n\n4、为什么每个组件对象里都有Store实例对象了(渲染组件对象过程)。\n\n答：渲染生成组件实例时，调用createComponentInstance，注入到组件实例的provides中。\n\n\n\n 6. 你怎么知道那么多的\n\n答：因为社区有人写了Vue4源码文章。\n\n\n6. 总结#\n\n本文主要讲述了Vuex4把Store实例注入到各个组件中的原理，展开讲述了Vuex4相对与Vuex3安装方式的改变Vuex.createStore、app.us\ne(store) ，深入源码分析Vue.inject、Vue.provide实现原理。\n\nVuex4 除了安装方式和监测数据变化方式使用了Vue.reactive，其他基本和Vuex3.x版本没什么区别。\n\n最后回顾下文章开头的图，可以说就是原型链的妙用。\n\n\n\n是不是觉得豁然开朗。\n\nVuex其实也是Vue的一个插件，知晓了Vuex原理，对于自己给Vue写插件也是会游刃有余。\n\n> 如果读者朋友发现有不妥或可改善之处，再或者哪里没写明白的地方，欢迎评论指出，也欢迎加我微信 ruochuan12\n> 交流。另外觉得写得不错，对您有些许帮助，可以点赞、评论、转发分享，也是对我的一种支持，万分感谢。如果能关注我的前端公众号：「若川视野」，就更好啦。\n\n\n关于#\n\n> 你好，我是若川，微信搜索「若川视野」关注我，专注前端技术分享，一个愿景是帮助5年内前端开阔视野走向前列的公众号。欢迎加我微信ruochuan12，长期交流学\n> 习。 主要有以下系列文章：学习源码整体架构系列、年度总结、JS基础系列\n\n\n参考链接#\n\n官网文档 Provide / Inject github 仓库 provide/inject 源码 github 仓库 provide/inject 测试\nVuex 4 官方中文文档","routePath":"/vuex4/","lang":"zh","toc":[{"text":"1. 前言","id":"1-前言","depth":2,"charIndex":3},{"text":"1.1 本文阅读最佳方式","id":"11-本文阅读最佳方式","depth":3,"charIndex":1038},{"text":"2. Vuex 原理简述","id":"2-vuex-原理简述","depth":2,"charIndex":1265},{"text":"3. Vuex 4 重大改变","id":"3-vuex-4-重大改变","depth":2,"charIndex":1751},{"text":"3.1 安装过程","id":"31-安装过程","depth":3,"charIndex":1961},{"text":"3.2 核心模块导出了 `createLogger` 函数","id":"32-核心模块导出了-createlogger-函数","depth":3,"charIndex":-1},{"text":"4. 从源码角度看 Vuex 4 重大变化","id":"4-从源码角度看-vuex-4-重大变化","depth":2,"charIndex":2078},{"text":"4.1 chrome 调试 Vuex 4 源码准备工作","id":"41-chrome-调试-vuex-4-源码准备工作","depth":3,"charIndex":2103},{"text":"4.2 Vuex.createStore 函数","id":"42-vuexcreatestore-函数","depth":3,"charIndex":2573},{"text":"4.3 app.use() 方法","id":"43-appuse-方法","depth":3,"charIndex":2867},{"text":"4.4 install 函数","id":"44-install-函数","depth":3,"charIndex":3055},{"text":"4.4.1 app.provide","id":"441-appprovide","depth":4,"charIndex":3193},{"text":"4.4.2 app.config.globalProperties","id":"442-appconfigglobalproperties","depth":4,"charIndex":3363},{"text":"4.5 composition API 中如何使用Vuex 4","id":"45-composition-api-中如何使用vuex-4","depth":3,"charIndex":3787},{"text":"4.5.1 Vuex.useStore 源码实现","id":"451-vuexusestore-源码实现","depth":4,"charIndex":3891},{"text":"4.5.2 Vue.inject 源码实现","id":"452-vueinject-源码实现","depth":4,"charIndex":3920},{"text":"4.5.3  Vue.provide 源码实现","id":"453--vueprovide-源码实现","depth":4,"charIndex":-1},{"text":"4.6 createComponentInstance 创建组件实例","id":"46-createcomponentinstance-创建组件实例","depth":3,"charIndex":4667},{"text":"4.6.1 组件实例生成了，那怎么把它们结合呢","id":"461-组件实例生成了那怎么把它们结合呢","depth":4,"charIndex":4944},{"text":"4.7 getCurrentInstance 获取当前实例对象","id":"47-getcurrentinstance-获取当前实例对象","depth":3,"charIndex":5229},{"text":"5. 解答下开头提出的5个问题","id":"5-解答下开头提出的5个问题","depth":2,"charIndex":5523},{"text":"6. 总结","id":"6-总结","depth":2,"charIndex":6109},{"text":"关于","id":"关于","depth":2,"charIndex":6527},{"text":"参考链接","id":"参考链接","depth":2,"charIndex":6653}],"domain":"","frontmatter":{"theme":"smartblue","highlight":"dracula"},"version":""},{"id":151,"title":"webpack","content":"#","routePath":"/webpack/","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""}]